// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "IntermediatesPMI.hxx"

namespace xsd
{
  namespace qif2
  {
    // FormalStandardEnumType
    // 

    FormalStandardEnumType::
    FormalStandardEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_FormalStandardEnumType_literals_[v])
    {
    }

    FormalStandardEnumType::
    FormalStandardEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    FormalStandardEnumType::
    FormalStandardEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    FormalStandardEnumType::
    FormalStandardEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    FormalStandardEnumType::
    FormalStandardEnumType (const FormalStandardEnumType& v,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    FormalStandardEnumType& FormalStandardEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_FormalStandardEnumType_literals_[v]);

      return *this;
    }


    // FormalStandardType
    // 

    const FormalStandardType::FormalStandardEnum_optional& FormalStandardType::
    FormalStandardEnum () const
    {
      return this->FormalStandardEnum_;
    }

    FormalStandardType::FormalStandardEnum_optional& FormalStandardType::
    FormalStandardEnum ()
    {
      return this->FormalStandardEnum_;
    }

    void FormalStandardType::
    FormalStandardEnum (const FormalStandardEnum_type& x)
    {
      this->FormalStandardEnum_.set (x);
    }

    void FormalStandardType::
    FormalStandardEnum (const FormalStandardEnum_optional& x)
    {
      this->FormalStandardEnum_ = x;
    }

    void FormalStandardType::
    FormalStandardEnum (::std::auto_ptr< FormalStandardEnum_type > x)
    {
      this->FormalStandardEnum_.set (x);
    }

    const FormalStandardType::OtherFormalStandard_optional& FormalStandardType::
    OtherFormalStandard () const
    {
      return this->OtherFormalStandard_;
    }

    FormalStandardType::OtherFormalStandard_optional& FormalStandardType::
    OtherFormalStandard ()
    {
      return this->OtherFormalStandard_;
    }

    void FormalStandardType::
    OtherFormalStandard (const OtherFormalStandard_type& x)
    {
      this->OtherFormalStandard_.set (x);
    }

    void FormalStandardType::
    OtherFormalStandard (const OtherFormalStandard_optional& x)
    {
      this->OtherFormalStandard_ = x;
    }

    void FormalStandardType::
    OtherFormalStandard (::std::auto_ptr< OtherFormalStandard_type > x)
    {
      this->OtherFormalStandard_.set (x);
    }


    // SequencedDatumType
    // 

    const SequencedDatumType::SimpleDatum_optional& SequencedDatumType::
    SimpleDatum () const
    {
      return this->SimpleDatum_;
    }

    SequencedDatumType::SimpleDatum_optional& SequencedDatumType::
    SimpleDatum ()
    {
      return this->SimpleDatum_;
    }

    void SequencedDatumType::
    SimpleDatum (const SimpleDatum_type& x)
    {
      this->SimpleDatum_.set (x);
    }

    void SequencedDatumType::
    SimpleDatum (const SimpleDatum_optional& x)
    {
      this->SimpleDatum_ = x;
    }

    void SequencedDatumType::
    SimpleDatum (::std::auto_ptr< SimpleDatum_type > x)
    {
      this->SimpleDatum_.set (x);
    }

    const SequencedDatumType::CompoundDatum_optional& SequencedDatumType::
    CompoundDatum () const
    {
      return this->CompoundDatum_;
    }

    SequencedDatumType::CompoundDatum_optional& SequencedDatumType::
    CompoundDatum ()
    {
      return this->CompoundDatum_;
    }

    void SequencedDatumType::
    CompoundDatum (const CompoundDatum_type& x)
    {
      this->CompoundDatum_.set (x);
    }

    void SequencedDatumType::
    CompoundDatum (const CompoundDatum_optional& x)
    {
      this->CompoundDatum_ = x;
    }

    void SequencedDatumType::
    CompoundDatum (::std::auto_ptr< CompoundDatum_type > x)
    {
      this->CompoundDatum_.set (x);
    }

    const SequencedDatumType::SequenceNumber_type& SequencedDatumType::
    SequenceNumber () const
    {
      return this->SequenceNumber_.get ();
    }

    SequencedDatumType::SequenceNumber_type& SequencedDatumType::
    SequenceNumber ()
    {
      return this->SequenceNumber_.get ();
    }

    void SequencedDatumType::
    SequenceNumber (const SequenceNumber_type& x)
    {
      this->SequenceNumber_.set (x);
    }


    // CompoundDatumType
    // 

    const CompoundDatumType::Datum_sequence& CompoundDatumType::
    Datum () const
    {
      return this->Datum_;
    }

    CompoundDatumType::Datum_sequence& CompoundDatumType::
    Datum ()
    {
      return this->Datum_;
    }

    void CompoundDatumType::
    Datum (const Datum_sequence& s)
    {
      this->Datum_ = s;
    }

    const CompoundDatumType::ReducedDatum_optional& CompoundDatumType::
    ReducedDatum () const
    {
      return this->ReducedDatum_;
    }

    CompoundDatumType::ReducedDatum_optional& CompoundDatumType::
    ReducedDatum ()
    {
      return this->ReducedDatum_;
    }

    void CompoundDatumType::
    ReducedDatum (const ReducedDatum_type& x)
    {
      this->ReducedDatum_.set (x);
    }

    void CompoundDatumType::
    ReducedDatum (const ReducedDatum_optional& x)
    {
      this->ReducedDatum_ = x;
    }

    void CompoundDatumType::
    ReducedDatum (::std::auto_ptr< ReducedDatum_type > x)
    {
      this->ReducedDatum_.set (x);
    }


    // DatumWithPrecedenceType
    // 

    const DatumWithPrecedenceType::SimpleDatum_optional& DatumWithPrecedenceType::
    SimpleDatum () const
    {
      return this->SimpleDatum_;
    }

    DatumWithPrecedenceType::SimpleDatum_optional& DatumWithPrecedenceType::
    SimpleDatum ()
    {
      return this->SimpleDatum_;
    }

    void DatumWithPrecedenceType::
    SimpleDatum (const SimpleDatum_type& x)
    {
      this->SimpleDatum_.set (x);
    }

    void DatumWithPrecedenceType::
    SimpleDatum (const SimpleDatum_optional& x)
    {
      this->SimpleDatum_ = x;
    }

    void DatumWithPrecedenceType::
    SimpleDatum (::std::auto_ptr< SimpleDatum_type > x)
    {
      this->SimpleDatum_.set (x);
    }

    const DatumWithPrecedenceType::NominalDatumFeature_optional& DatumWithPrecedenceType::
    NominalDatumFeature () const
    {
      return this->NominalDatumFeature_;
    }

    DatumWithPrecedenceType::NominalDatumFeature_optional& DatumWithPrecedenceType::
    NominalDatumFeature ()
    {
      return this->NominalDatumFeature_;
    }

    void DatumWithPrecedenceType::
    NominalDatumFeature (const NominalDatumFeature_type& x)
    {
      this->NominalDatumFeature_.set (x);
    }

    void DatumWithPrecedenceType::
    NominalDatumFeature (const NominalDatumFeature_optional& x)
    {
      this->NominalDatumFeature_ = x;
    }

    void DatumWithPrecedenceType::
    NominalDatumFeature (::std::auto_ptr< NominalDatumFeature_type > x)
    {
      this->NominalDatumFeature_.set (x);
    }

    const DatumWithPrecedenceType::ActualDatumFeature_optional& DatumWithPrecedenceType::
    ActualDatumFeature () const
    {
      return this->ActualDatumFeature_;
    }

    DatumWithPrecedenceType::ActualDatumFeature_optional& DatumWithPrecedenceType::
    ActualDatumFeature ()
    {
      return this->ActualDatumFeature_;
    }

    void DatumWithPrecedenceType::
    ActualDatumFeature (const ActualDatumFeature_type& x)
    {
      this->ActualDatumFeature_.set (x);
    }

    void DatumWithPrecedenceType::
    ActualDatumFeature (const ActualDatumFeature_optional& x)
    {
      this->ActualDatumFeature_ = x;
    }

    void DatumWithPrecedenceType::
    ActualDatumFeature (::std::auto_ptr< ActualDatumFeature_type > x)
    {
      this->ActualDatumFeature_.set (x);
    }

    const DatumWithPrecedenceType::CompoundDatum_optional& DatumWithPrecedenceType::
    CompoundDatum () const
    {
      return this->CompoundDatum_;
    }

    DatumWithPrecedenceType::CompoundDatum_optional& DatumWithPrecedenceType::
    CompoundDatum ()
    {
      return this->CompoundDatum_;
    }

    void DatumWithPrecedenceType::
    CompoundDatum (const CompoundDatum_type& x)
    {
      this->CompoundDatum_.set (x);
    }

    void DatumWithPrecedenceType::
    CompoundDatum (const CompoundDatum_optional& x)
    {
      this->CompoundDatum_ = x;
    }

    void DatumWithPrecedenceType::
    CompoundDatum (::std::auto_ptr< CompoundDatum_type > x)
    {
      this->CompoundDatum_.set (x);
    }

    const DatumWithPrecedenceType::Precedence_type& DatumWithPrecedenceType::
    Precedence () const
    {
      return this->Precedence_.get ();
    }

    DatumWithPrecedenceType::Precedence_type& DatumWithPrecedenceType::
    Precedence ()
    {
      return this->Precedence_.get ();
    }

    void DatumWithPrecedenceType::
    Precedence (const Precedence_type& x)
    {
      this->Precedence_.set (x);
    }

    void DatumWithPrecedenceType::
    Precedence (::std::auto_ptr< Precedence_type > x)
    {
      this->Precedence_.set (x);
    }


    // DatumType
    // 

    const DatumType::DatumDefinitionId_type& DatumType::
    DatumDefinitionId () const
    {
      return this->DatumDefinitionId_.get ();
    }

    DatumType::DatumDefinitionId_type& DatumType::
    DatumDefinitionId ()
    {
      return this->DatumDefinitionId_.get ();
    }

    void DatumType::
    DatumDefinitionId (const DatumDefinitionId_type& x)
    {
      this->DatumDefinitionId_.set (x);
    }

    void DatumType::
    DatumDefinitionId (::std::auto_ptr< DatumDefinitionId_type > x)
    {
      this->DatumDefinitionId_.set (x);
    }

    const DatumType::MaterialModifier_type& DatumType::
    MaterialModifier () const
    {
      return this->MaterialModifier_.get ();
    }

    DatumType::MaterialModifier_type& DatumType::
    MaterialModifier ()
    {
      return this->MaterialModifier_.get ();
    }

    void DatumType::
    MaterialModifier (const MaterialModifier_type& x)
    {
      this->MaterialModifier_.set (x);
    }

    void DatumType::
    MaterialModifier (::std::auto_ptr< MaterialModifier_type > x)
    {
      this->MaterialModifier_.set (x);
    }

    const DatumType::ReferencedComponent_type& DatumType::
    ReferencedComponent () const
    {
      return this->ReferencedComponent_.get ();
    }

    DatumType::ReferencedComponent_type& DatumType::
    ReferencedComponent ()
    {
      return this->ReferencedComponent_.get ();
    }

    void DatumType::
    ReferencedComponent (const ReferencedComponent_type& x)
    {
      this->ReferencedComponent_.set (x);
    }

    void DatumType::
    ReferencedComponent (::std::auto_ptr< ReferencedComponent_type > x)
    {
      this->ReferencedComponent_.set (x);
    }

    const DatumType::DatumFeatureSimulatorModifier_optional& DatumType::
    DatumFeatureSimulatorModifier () const
    {
      return this->DatumFeatureSimulatorModifier_;
    }

    DatumType::DatumFeatureSimulatorModifier_optional& DatumType::
    DatumFeatureSimulatorModifier ()
    {
      return this->DatumFeatureSimulatorModifier_;
    }

    void DatumType::
    DatumFeatureSimulatorModifier (const DatumFeatureSimulatorModifier_type& x)
    {
      this->DatumFeatureSimulatorModifier_.set (x);
    }

    void DatumType::
    DatumFeatureSimulatorModifier (const DatumFeatureSimulatorModifier_optional& x)
    {
      this->DatumFeatureSimulatorModifier_ = x;
    }

    void DatumType::
    DatumFeatureSimulatorModifier (::std::auto_ptr< DatumFeatureSimulatorModifier_type > x)
    {
      this->DatumFeatureSimulatorModifier_.set (x);
    }

    const DatumType::DatumTranslation_optional& DatumType::
    DatumTranslation () const
    {
      return this->DatumTranslation_;
    }

    DatumType::DatumTranslation_optional& DatumType::
    DatumTranslation ()
    {
      return this->DatumTranslation_;
    }

    void DatumType::
    DatumTranslation (const DatumTranslation_type& x)
    {
      this->DatumTranslation_.set (x);
    }

    void DatumType::
    DatumTranslation (const DatumTranslation_optional& x)
    {
      this->DatumTranslation_ = x;
    }

    void DatumType::
    DatumTranslation (::std::auto_ptr< DatumTranslation_type > x)
    {
      this->DatumTranslation_.set (x);
    }

    const DatumType::DegreesOfFreedom_optional& DatumType::
    DegreesOfFreedom () const
    {
      return this->DegreesOfFreedom_;
    }

    DatumType::DegreesOfFreedom_optional& DatumType::
    DegreesOfFreedom ()
    {
      return this->DegreesOfFreedom_;
    }

    void DatumType::
    DegreesOfFreedom (const DegreesOfFreedom_type& x)
    {
      this->DegreesOfFreedom_.set (x);
    }

    void DatumType::
    DegreesOfFreedom (const DegreesOfFreedom_optional& x)
    {
      this->DegreesOfFreedom_ = x;
    }

    void DatumType::
    DegreesOfFreedom (::std::auto_ptr< DegreesOfFreedom_type > x)
    {
      this->DegreesOfFreedom_.set (x);
    }

    const DatumType::ProjectedDatum_optional& DatumType::
    ProjectedDatum () const
    {
      return this->ProjectedDatum_;
    }

    DatumType::ProjectedDatum_optional& DatumType::
    ProjectedDatum ()
    {
      return this->ProjectedDatum_;
    }

    void DatumType::
    ProjectedDatum (const ProjectedDatum_type& x)
    {
      this->ProjectedDatum_.set (x);
    }

    void DatumType::
    ProjectedDatum (const ProjectedDatum_optional& x)
    {
      this->ProjectedDatum_ = x;
    }

    void DatumType::
    ProjectedDatum (::std::auto_ptr< ProjectedDatum_type > x)
    {
      this->ProjectedDatum_.set (x);
    }

    const DatumType::DiameterModifier_optional& DatumType::
    DiameterModifier () const
    {
      return this->DiameterModifier_;
    }

    DatumType::DiameterModifier_optional& DatumType::
    DiameterModifier ()
    {
      return this->DiameterModifier_;
    }

    void DatumType::
    DiameterModifier (const DiameterModifier_type& x)
    {
      this->DiameterModifier_.set (x);
    }

    void DatumType::
    DiameterModifier (const DiameterModifier_optional& x)
    {
      this->DiameterModifier_ = x;
    }

    void DatumType::
    DiameterModifier (::std::auto_ptr< DiameterModifier_type > x)
    {
      this->DiameterModifier_.set (x);
    }

    const DatumType::SectionModifier_optional& DatumType::
    SectionModifier () const
    {
      return this->SectionModifier_;
    }

    DatumType::SectionModifier_optional& DatumType::
    SectionModifier ()
    {
      return this->SectionModifier_;
    }

    void DatumType::
    SectionModifier (const SectionModifier_type& x)
    {
      this->SectionModifier_.set (x);
    }

    void DatumType::
    SectionModifier (const SectionModifier_optional& x)
    {
      this->SectionModifier_ = x;
    }

    void DatumType::
    SectionModifier (::std::auto_ptr< SectionModifier_type > x)
    {
      this->SectionModifier_.set (x);
    }

    const DatumType::ContactingFeature_optional& DatumType::
    ContactingFeature () const
    {
      return this->ContactingFeature_;
    }

    DatumType::ContactingFeature_optional& DatumType::
    ContactingFeature ()
    {
      return this->ContactingFeature_;
    }

    void DatumType::
    ContactingFeature (const ContactingFeature_type& x)
    {
      this->ContactingFeature_.set (x);
    }

    void DatumType::
    ContactingFeature (const ContactingFeature_optional& x)
    {
      this->ContactingFeature_ = x;
    }

    const DatumType::DistanceVariable_optional& DatumType::
    DistanceVariable () const
    {
      return this->DistanceVariable_;
    }

    DatumType::DistanceVariable_optional& DatumType::
    DistanceVariable ()
    {
      return this->DistanceVariable_;
    }

    void DatumType::
    DistanceVariable (const DistanceVariable_type& x)
    {
      this->DistanceVariable_.set (x);
    }

    void DatumType::
    DistanceVariable (const DistanceVariable_optional& x)
    {
      this->DistanceVariable_ = x;
    }

    const DatumType::DatumFixed_optional& DatumType::
    DatumFixed () const
    {
      return this->DatumFixed_;
    }

    DatumType::DatumFixed_optional& DatumType::
    DatumFixed ()
    {
      return this->DatumFixed_;
    }

    void DatumType::
    DatumFixed (const DatumFixed_type& x)
    {
      this->DatumFixed_.set (x);
    }

    void DatumType::
    DatumFixed (const DatumFixed_optional& x)
    {
      this->DatumFixed_ = x;
    }

    const DatumType::ReducedDatum_optional& DatumType::
    ReducedDatum () const
    {
      return this->ReducedDatum_;
    }

    DatumType::ReducedDatum_optional& DatumType::
    ReducedDatum ()
    {
      return this->ReducedDatum_;
    }

    void DatumType::
    ReducedDatum (const ReducedDatum_type& x)
    {
      this->ReducedDatum_.set (x);
    }

    void DatumType::
    ReducedDatum (const ReducedDatum_optional& x)
    {
      this->ReducedDatum_ = x;
    }

    void DatumType::
    ReducedDatum (::std::auto_ptr< ReducedDatum_type > x)
    {
      this->ReducedDatum_.set (x);
    }

    const DatumType::ConstrainOrientation_optional& DatumType::
    ConstrainOrientation () const
    {
      return this->ConstrainOrientation_;
    }

    DatumType::ConstrainOrientation_optional& DatumType::
    ConstrainOrientation ()
    {
      return this->ConstrainOrientation_;
    }

    void DatumType::
    ConstrainOrientation (const ConstrainOrientation_type& x)
    {
      this->ConstrainOrientation_.set (x);
    }

    void DatumType::
    ConstrainOrientation (const ConstrainOrientation_optional& x)
    {
      this->ConstrainOrientation_ = x;
    }

    const DatumType::ConstrainSubsequent_optional& DatumType::
    ConstrainSubsequent () const
    {
      return this->ConstrainSubsequent_;
    }

    DatumType::ConstrainSubsequent_optional& DatumType::
    ConstrainSubsequent ()
    {
      return this->ConstrainSubsequent_;
    }

    void DatumType::
    ConstrainSubsequent (const ConstrainSubsequent_type& x)
    {
      this->ConstrainSubsequent_.set (x);
    }

    void DatumType::
    ConstrainSubsequent (const ConstrainSubsequent_optional& x)
    {
      this->ConstrainSubsequent_ = x;
    }


    // DatumTranslationType
    // 

    const DatumTranslationType::DatumTranslationAllowed_type& DatumTranslationType::
    DatumTranslationAllowed () const
    {
      return this->DatumTranslationAllowed_.get ();
    }

    DatumTranslationType::DatumTranslationAllowed_type& DatumTranslationType::
    DatumTranslationAllowed ()
    {
      return this->DatumTranslationAllowed_.get ();
    }

    void DatumTranslationType::
    DatumTranslationAllowed (const DatumTranslationAllowed_type& x)
    {
      this->DatumTranslationAllowed_.set (x);
    }


    // DatumFeatureBaseType
    // 

    const DatumFeatureBaseType::FeatureItemId_type& DatumFeatureBaseType::
    FeatureItemId () const
    {
      return this->FeatureItemId_.get ();
    }

    DatumFeatureBaseType::FeatureItemId_type& DatumFeatureBaseType::
    FeatureItemId ()
    {
      return this->FeatureItemId_.get ();
    }

    void DatumFeatureBaseType::
    FeatureItemId (const FeatureItemId_type& x)
    {
      this->FeatureItemId_.set (x);
    }

    void DatumFeatureBaseType::
    FeatureItemId (::std::auto_ptr< FeatureItemId_type > x)
    {
      this->FeatureItemId_.set (x);
    }


    // ActualDatumFeatureType
    // 

    const ActualDatumFeatureType::MaterialModifier_type& ActualDatumFeatureType::
    MaterialModifier () const
    {
      return this->MaterialModifier_.get ();
    }

    ActualDatumFeatureType::MaterialModifier_type& ActualDatumFeatureType::
    MaterialModifier ()
    {
      return this->MaterialModifier_.get ();
    }

    void ActualDatumFeatureType::
    MaterialModifier (const MaterialModifier_type& x)
    {
      this->MaterialModifier_.set (x);
    }

    void ActualDatumFeatureType::
    MaterialModifier (::std::auto_ptr< MaterialModifier_type > x)
    {
      this->MaterialModifier_.set (x);
    }


    // NominalDatumFeatureType
    // 


    // DatumFeatureSimulatorModifierType
    // 

    const DatumFeatureSimulatorModifierType::LinearSize_optional& DatumFeatureSimulatorModifierType::
    LinearSize () const
    {
      return this->LinearSize_;
    }

    DatumFeatureSimulatorModifierType::LinearSize_optional& DatumFeatureSimulatorModifierType::
    LinearSize ()
    {
      return this->LinearSize_;
    }

    void DatumFeatureSimulatorModifierType::
    LinearSize (const LinearSize_type& x)
    {
      this->LinearSize_.set (x);
    }

    void DatumFeatureSimulatorModifierType::
    LinearSize (const LinearSize_optional& x)
    {
      this->LinearSize_ = x;
    }

    void DatumFeatureSimulatorModifierType::
    LinearSize (::std::auto_ptr< LinearSize_type > x)
    {
      this->LinearSize_.set (x);
    }

    const DatumFeatureSimulatorModifierType::DiametricalSize_optional& DatumFeatureSimulatorModifierType::
    DiametricalSize () const
    {
      return this->DiametricalSize_;
    }

    DatumFeatureSimulatorModifierType::DiametricalSize_optional& DatumFeatureSimulatorModifierType::
    DiametricalSize ()
    {
      return this->DiametricalSize_;
    }

    void DatumFeatureSimulatorModifierType::
    DiametricalSize (const DiametricalSize_type& x)
    {
      this->DiametricalSize_.set (x);
    }

    void DatumFeatureSimulatorModifierType::
    DiametricalSize (const DiametricalSize_optional& x)
    {
      this->DiametricalSize_ = x;
    }

    void DatumFeatureSimulatorModifierType::
    DiametricalSize (::std::auto_ptr< DiametricalSize_type > x)
    {
      this->DiametricalSize_.set (x);
    }

    const DatumFeatureSimulatorModifierType::BasicSize_optional& DatumFeatureSimulatorModifierType::
    BasicSize () const
    {
      return this->BasicSize_;
    }

    DatumFeatureSimulatorModifierType::BasicSize_optional& DatumFeatureSimulatorModifierType::
    BasicSize ()
    {
      return this->BasicSize_;
    }

    void DatumFeatureSimulatorModifierType::
    BasicSize (const BasicSize_type& x)
    {
      this->BasicSize_.set (x);
    }

    void DatumFeatureSimulatorModifierType::
    BasicSize (const BasicSize_optional& x)
    {
      this->BasicSize_ = x;
    }

    void DatumFeatureSimulatorModifierType::
    BasicSize (::std::auto_ptr< BasicSize_type > x)
    {
      this->BasicSize_.set (x);
    }

    const DatumFeatureSimulatorModifierType::BasicSize_type& DatumFeatureSimulatorModifierType::
    BasicSize_default_value ()
    {
      return BasicSize_default_value_;
    }


    // DatumReferenceFrameType
    // 

    const DatumReferenceFrameType::Attributes_optional& DatumReferenceFrameType::
    Attributes () const
    {
      return this->Attributes_;
    }

    DatumReferenceFrameType::Attributes_optional& DatumReferenceFrameType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void DatumReferenceFrameType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void DatumReferenceFrameType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void DatumReferenceFrameType::
    Attributes (::std::auto_ptr< Attributes_type > x)
    {
      this->Attributes_.set (x);
    }

    const DatumReferenceFrameType::Datum_sequence& DatumReferenceFrameType::
    Datum () const
    {
      return this->Datum_;
    }

    DatumReferenceFrameType::Datum_sequence& DatumReferenceFrameType::
    Datum ()
    {
      return this->Datum_;
    }

    void DatumReferenceFrameType::
    Datum (const Datum_sequence& s)
    {
      this->Datum_ = s;
    }

    const DatumReferenceFrameType::Name_optional& DatumReferenceFrameType::
    Name () const
    {
      return this->Name_;
    }

    DatumReferenceFrameType::Name_optional& DatumReferenceFrameType::
    Name ()
    {
      return this->Name_;
    }

    void DatumReferenceFrameType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void DatumReferenceFrameType::
    Name (const Name_optional& x)
    {
      this->Name_ = x;
    }

    void DatumReferenceFrameType::
    Name (::std::auto_ptr< Name_type > x)
    {
      this->Name_.set (x);
    }

    const DatumReferenceFrameType::Description_optional& DatumReferenceFrameType::
    Description () const
    {
      return this->Description_;
    }

    DatumReferenceFrameType::Description_optional& DatumReferenceFrameType::
    Description ()
    {
      return this->Description_;
    }

    void DatumReferenceFrameType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void DatumReferenceFrameType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void DatumReferenceFrameType::
    Description (::std::auto_ptr< Description_type > x)
    {
      this->Description_.set (x);
    }

    const DatumReferenceFrameType::CoordinateSystemId_optional& DatumReferenceFrameType::
    CoordinateSystemId () const
    {
      return this->CoordinateSystemId_;
    }

    DatumReferenceFrameType::CoordinateSystemId_optional& DatumReferenceFrameType::
    CoordinateSystemId ()
    {
      return this->CoordinateSystemId_;
    }

    void DatumReferenceFrameType::
    CoordinateSystemId (const CoordinateSystemId_type& x)
    {
      this->CoordinateSystemId_.set (x);
    }

    void DatumReferenceFrameType::
    CoordinateSystemId (const CoordinateSystemId_optional& x)
    {
      this->CoordinateSystemId_ = x;
    }

    void DatumReferenceFrameType::
    CoordinateSystemId (::std::auto_ptr< CoordinateSystemId_type > x)
    {
      this->CoordinateSystemId_.set (x);
    }

    const DatumReferenceFrameType::id_type& DatumReferenceFrameType::
    id () const
    {
      return this->id_.get ();
    }

    DatumReferenceFrameType::id_type& DatumReferenceFrameType::
    id ()
    {
      return this->id_.get ();
    }

    void DatumReferenceFrameType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void DatumReferenceFrameType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // DegreeOfFreedomEnumType
    // 

    DegreeOfFreedomEnumType::
    DegreeOfFreedomEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_DegreeOfFreedomEnumType_literals_[v])
    {
    }

    DegreeOfFreedomEnumType::
    DegreeOfFreedomEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DegreeOfFreedomEnumType::
    DegreeOfFreedomEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DegreeOfFreedomEnumType::
    DegreeOfFreedomEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DegreeOfFreedomEnumType::
    DegreeOfFreedomEnumType (const DegreeOfFreedomEnumType& v,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    DegreeOfFreedomEnumType& DegreeOfFreedomEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_DegreeOfFreedomEnumType_literals_[v]);

      return *this;
    }


    // ISODegreeOfFreedomEnumType
    // 

    ISODegreeOfFreedomEnumType::
    ISODegreeOfFreedomEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ISODegreeOfFreedomEnumType_literals_[v])
    {
    }

    ISODegreeOfFreedomEnumType::
    ISODegreeOfFreedomEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ISODegreeOfFreedomEnumType::
    ISODegreeOfFreedomEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ISODegreeOfFreedomEnumType::
    ISODegreeOfFreedomEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ISODegreeOfFreedomEnumType::
    ISODegreeOfFreedomEnumType (const ISODegreeOfFreedomEnumType& v,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ISODegreeOfFreedomEnumType& ISODegreeOfFreedomEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ISODegreeOfFreedomEnumType_literals_[v]);

      return *this;
    }


    // IntersectionPlaneEnumType
    // 

    IntersectionPlaneEnumType::
    IntersectionPlaneEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_IntersectionPlaneEnumType_literals_[v])
    {
    }

    IntersectionPlaneEnumType::
    IntersectionPlaneEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    IntersectionPlaneEnumType::
    IntersectionPlaneEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    IntersectionPlaneEnumType::
    IntersectionPlaneEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    IntersectionPlaneEnumType::
    IntersectionPlaneEnumType (const IntersectionPlaneEnumType& v,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    IntersectionPlaneEnumType& IntersectionPlaneEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_IntersectionPlaneEnumType_literals_[v]);

      return *this;
    }


    // IntersectionPlaneType
    // 

    const IntersectionPlaneType::IntersectionPlaneEnum_type& IntersectionPlaneType::
    IntersectionPlaneEnum () const
    {
      return this->IntersectionPlaneEnum_.get ();
    }

    IntersectionPlaneType::IntersectionPlaneEnum_type& IntersectionPlaneType::
    IntersectionPlaneEnum ()
    {
      return this->IntersectionPlaneEnum_.get ();
    }

    void IntersectionPlaneType::
    IntersectionPlaneEnum (const IntersectionPlaneEnum_type& x)
    {
      this->IntersectionPlaneEnum_.set (x);
    }

    void IntersectionPlaneType::
    IntersectionPlaneEnum (::std::auto_ptr< IntersectionPlaneEnum_type > x)
    {
      this->IntersectionPlaneEnum_.set (x);
    }

    const IntersectionPlaneType::DatumDefinitionId_type& IntersectionPlaneType::
    DatumDefinitionId () const
    {
      return this->DatumDefinitionId_.get ();
    }

    IntersectionPlaneType::DatumDefinitionId_type& IntersectionPlaneType::
    DatumDefinitionId ()
    {
      return this->DatumDefinitionId_.get ();
    }

    void IntersectionPlaneType::
    DatumDefinitionId (const DatumDefinitionId_type& x)
    {
      this->DatumDefinitionId_.set (x);
    }

    void IntersectionPlaneType::
    DatumDefinitionId (::std::auto_ptr< DatumDefinitionId_type > x)
    {
      this->DatumDefinitionId_.set (x);
    }


    // ModifyingPlaneEnumType
    // 

    ModifyingPlaneEnumType::
    ModifyingPlaneEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ModifyingPlaneEnumType_literals_[v])
    {
    }

    ModifyingPlaneEnumType::
    ModifyingPlaneEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ModifyingPlaneEnumType::
    ModifyingPlaneEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ModifyingPlaneEnumType::
    ModifyingPlaneEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ModifyingPlaneEnumType::
    ModifyingPlaneEnumType (const ModifyingPlaneEnumType& v,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ModifyingPlaneEnumType& ModifyingPlaneEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ModifyingPlaneEnumType_literals_[v]);

      return *this;
    }


    // DirectionFeatureType
    // 

    const DirectionFeatureType::DirectionFeatureEnum_type& DirectionFeatureType::
    DirectionFeatureEnum () const
    {
      return this->DirectionFeatureEnum_.get ();
    }

    DirectionFeatureType::DirectionFeatureEnum_type& DirectionFeatureType::
    DirectionFeatureEnum ()
    {
      return this->DirectionFeatureEnum_.get ();
    }

    void DirectionFeatureType::
    DirectionFeatureEnum (const DirectionFeatureEnum_type& x)
    {
      this->DirectionFeatureEnum_.set (x);
    }

    void DirectionFeatureType::
    DirectionFeatureEnum (::std::auto_ptr< DirectionFeatureEnum_type > x)
    {
      this->DirectionFeatureEnum_.set (x);
    }

    const DirectionFeatureType::DatumDefinitionId_type& DirectionFeatureType::
    DatumDefinitionId () const
    {
      return this->DatumDefinitionId_.get ();
    }

    DirectionFeatureType::DatumDefinitionId_type& DirectionFeatureType::
    DatumDefinitionId ()
    {
      return this->DatumDefinitionId_.get ();
    }

    void DirectionFeatureType::
    DatumDefinitionId (const DatumDefinitionId_type& x)
    {
      this->DatumDefinitionId_.set (x);
    }

    void DirectionFeatureType::
    DatumDefinitionId (::std::auto_ptr< DatumDefinitionId_type > x)
    {
      this->DatumDefinitionId_.set (x);
    }


    // CollectionPlaneType
    // 

    const CollectionPlaneType::CollectionPlaneEnum_type& CollectionPlaneType::
    CollectionPlaneEnum () const
    {
      return this->CollectionPlaneEnum_.get ();
    }

    CollectionPlaneType::CollectionPlaneEnum_type& CollectionPlaneType::
    CollectionPlaneEnum ()
    {
      return this->CollectionPlaneEnum_.get ();
    }

    void CollectionPlaneType::
    CollectionPlaneEnum (const CollectionPlaneEnum_type& x)
    {
      this->CollectionPlaneEnum_.set (x);
    }

    void CollectionPlaneType::
    CollectionPlaneEnum (::std::auto_ptr< CollectionPlaneEnum_type > x)
    {
      this->CollectionPlaneEnum_.set (x);
    }

    const CollectionPlaneType::DatumDefinitionId_type& CollectionPlaneType::
    DatumDefinitionId () const
    {
      return this->DatumDefinitionId_.get ();
    }

    CollectionPlaneType::DatumDefinitionId_type& CollectionPlaneType::
    DatumDefinitionId ()
    {
      return this->DatumDefinitionId_.get ();
    }

    void CollectionPlaneType::
    DatumDefinitionId (const DatumDefinitionId_type& x)
    {
      this->DatumDefinitionId_.set (x);
    }

    void CollectionPlaneType::
    DatumDefinitionId (::std::auto_ptr< DatumDefinitionId_type > x)
    {
      this->DatumDefinitionId_.set (x);
    }


    // OrientationPlaneType
    // 

    const OrientationPlaneType::OrientationPlaneEnum_type& OrientationPlaneType::
    OrientationPlaneEnum () const
    {
      return this->OrientationPlaneEnum_.get ();
    }

    OrientationPlaneType::OrientationPlaneEnum_type& OrientationPlaneType::
    OrientationPlaneEnum ()
    {
      return this->OrientationPlaneEnum_.get ();
    }

    void OrientationPlaneType::
    OrientationPlaneEnum (const OrientationPlaneEnum_type& x)
    {
      this->OrientationPlaneEnum_.set (x);
    }

    void OrientationPlaneType::
    OrientationPlaneEnum (::std::auto_ptr< OrientationPlaneEnum_type > x)
    {
      this->OrientationPlaneEnum_.set (x);
    }

    const OrientationPlaneType::DatumDefinitionId_type& OrientationPlaneType::
    DatumDefinitionId () const
    {
      return this->DatumDefinitionId_.get ();
    }

    OrientationPlaneType::DatumDefinitionId_type& OrientationPlaneType::
    DatumDefinitionId ()
    {
      return this->DatumDefinitionId_.get ();
    }

    void OrientationPlaneType::
    DatumDefinitionId (const DatumDefinitionId_type& x)
    {
      this->DatumDefinitionId_.set (x);
    }

    void OrientationPlaneType::
    DatumDefinitionId (::std::auto_ptr< DatumDefinitionId_type > x)
    {
      this->DatumDefinitionId_.set (x);
    }


    // ReducedDatumEnumType
    // 

    ReducedDatumEnumType::
    ReducedDatumEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ReducedDatumEnumType_literals_[v])
    {
    }

    ReducedDatumEnumType::
    ReducedDatumEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ReducedDatumEnumType::
    ReducedDatumEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ReducedDatumEnumType::
    ReducedDatumEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ReducedDatumEnumType::
    ReducedDatumEnumType (const ReducedDatumEnumType& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ReducedDatumEnumType& ReducedDatumEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ReducedDatumEnumType_literals_[v]);

      return *this;
    }


    // DegreesOfFreedomType
    // 

    const DegreesOfFreedomType::DegreeOfFreedom_sequence& DegreesOfFreedomType::
    DegreeOfFreedom () const
    {
      return this->DegreeOfFreedom_;
    }

    DegreesOfFreedomType::DegreeOfFreedom_sequence& DegreesOfFreedomType::
    DegreeOfFreedom ()
    {
      return this->DegreeOfFreedom_;
    }

    void DegreesOfFreedomType::
    DegreeOfFreedom (const DegreeOfFreedom_sequence& s)
    {
      this->DegreeOfFreedom_ = s;
    }

    const DegreesOfFreedomType::ISODegreeOfFreedom_sequence& DegreesOfFreedomType::
    ISODegreeOfFreedom () const
    {
      return this->ISODegreeOfFreedom_;
    }

    DegreesOfFreedomType::ISODegreeOfFreedom_sequence& DegreesOfFreedomType::
    ISODegreeOfFreedom ()
    {
      return this->ISODegreeOfFreedom_;
    }

    void DegreesOfFreedomType::
    ISODegreeOfFreedom (const ISODegreeOfFreedom_sequence& s)
    {
      this->ISODegreeOfFreedom_ = s;
    }


    // DiameterModifierEnumType
    // 

    DiameterModifierEnumType::
    DiameterModifierEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_DiameterModifierEnumType_literals_[v])
    {
    }

    DiameterModifierEnumType::
    DiameterModifierEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DiameterModifierEnumType::
    DiameterModifierEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DiameterModifierEnumType::
    DiameterModifierEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DiameterModifierEnumType::
    DiameterModifierEnumType (const DiameterModifierEnumType& v,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    DiameterModifierEnumType& DiameterModifierEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_DiameterModifierEnumType_literals_[v]);

      return *this;
    }


    // SectionModifierEnumType
    // 

    SectionModifierEnumType::
    SectionModifierEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_SectionModifierEnumType_literals_[v])
    {
    }

    SectionModifierEnumType::
    SectionModifierEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SectionModifierEnumType::
    SectionModifierEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SectionModifierEnumType::
    SectionModifierEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SectionModifierEnumType::
    SectionModifierEnumType (const SectionModifierEnumType& v,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    SectionModifierEnumType& SectionModifierEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_SectionModifierEnumType_literals_[v]);

      return *this;
    }


    // PointWithNormalBaseType
    // 

    const PointWithNormalBaseType::Point_type& PointWithNormalBaseType::
    Point () const
    {
      return this->Point_.get ();
    }

    PointWithNormalBaseType::Point_type& PointWithNormalBaseType::
    Point ()
    {
      return this->Point_.get ();
    }

    void PointWithNormalBaseType::
    Point (const Point_type& x)
    {
      this->Point_.set (x);
    }

    void PointWithNormalBaseType::
    Point (::std::auto_ptr< Point_type > x)
    {
      this->Point_.set (x);
    }

    const PointWithNormalBaseType::Normal_optional& PointWithNormalBaseType::
    Normal () const
    {
      return this->Normal_;
    }

    PointWithNormalBaseType::Normal_optional& PointWithNormalBaseType::
    Normal ()
    {
      return this->Normal_;
    }

    void PointWithNormalBaseType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void PointWithNormalBaseType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void PointWithNormalBaseType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }

    const PointWithNormalBaseType::id_type& PointWithNormalBaseType::
    id () const
    {
      return this->id_.get ();
    }

    PointWithNormalBaseType::id_type& PointWithNormalBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void PointWithNormalBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void PointWithNormalBaseType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // ActualPointWithNormalBaseType
    // 

    const ActualPointWithNormalBaseType::Point_type& ActualPointWithNormalBaseType::
    Point () const
    {
      return this->Point_.get ();
    }

    ActualPointWithNormalBaseType::Point_type& ActualPointWithNormalBaseType::
    Point ()
    {
      return this->Point_.get ();
    }

    void ActualPointWithNormalBaseType::
    Point (const Point_type& x)
    {
      this->Point_.set (x);
    }

    void ActualPointWithNormalBaseType::
    Point (::std::auto_ptr< Point_type > x)
    {
      this->Point_.set (x);
    }

    const ActualPointWithNormalBaseType::Normal_optional& ActualPointWithNormalBaseType::
    Normal () const
    {
      return this->Normal_;
    }

    ActualPointWithNormalBaseType::Normal_optional& ActualPointWithNormalBaseType::
    Normal ()
    {
      return this->Normal_;
    }

    void ActualPointWithNormalBaseType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void ActualPointWithNormalBaseType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void ActualPointWithNormalBaseType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }

    const ActualPointWithNormalBaseType::id_type& ActualPointWithNormalBaseType::
    id () const
    {
      return this->id_.get ();
    }

    ActualPointWithNormalBaseType::id_type& ActualPointWithNormalBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void ActualPointWithNormalBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void ActualPointWithNormalBaseType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // MeasurePointNominalType
    // 

    const MeasurePointNominalType::MeasurementDeviceId_optional& MeasurePointNominalType::
    MeasurementDeviceId () const
    {
      return this->MeasurementDeviceId_;
    }

    MeasurePointNominalType::MeasurementDeviceId_optional& MeasurePointNominalType::
    MeasurementDeviceId ()
    {
      return this->MeasurementDeviceId_;
    }

    void MeasurePointNominalType::
    MeasurementDeviceId (const MeasurementDeviceId_type& x)
    {
      this->MeasurementDeviceId_.set (x);
    }

    void MeasurePointNominalType::
    MeasurementDeviceId (const MeasurementDeviceId_optional& x)
    {
      this->MeasurementDeviceId_ = x;
    }

    void MeasurePointNominalType::
    MeasurementDeviceId (::std::auto_ptr< MeasurementDeviceId_type > x)
    {
      this->MeasurementDeviceId_.set (x);
    }

    const MeasurePointNominalType::SensorId_optional& MeasurePointNominalType::
    SensorId () const
    {
      return this->SensorId_;
    }

    MeasurePointNominalType::SensorId_optional& MeasurePointNominalType::
    SensorId ()
    {
      return this->SensorId_;
    }

    void MeasurePointNominalType::
    SensorId (const SensorId_type& x)
    {
      this->SensorId_.set (x);
    }

    void MeasurePointNominalType::
    SensorId (const SensorId_optional& x)
    {
      this->SensorId_ = x;
    }

    void MeasurePointNominalType::
    SensorId (::std::auto_ptr< SensorId_type > x)
    {
      this->SensorId_.set (x);
    }


    // MeasurePointActualType
    // 

    const MeasurePointActualType::Compensated_type& MeasurePointActualType::
    Compensated () const
    {
      return this->Compensated_.get ();
    }

    MeasurePointActualType::Compensated_type& MeasurePointActualType::
    Compensated ()
    {
      return this->Compensated_.get ();
    }

    void MeasurePointActualType::
    Compensated (const Compensated_type& x)
    {
      this->Compensated_.set (x);
    }

    const MeasurePointActualType::ProbeRadius_optional& MeasurePointActualType::
    ProbeRadius () const
    {
      return this->ProbeRadius_;
    }

    MeasurePointActualType::ProbeRadius_optional& MeasurePointActualType::
    ProbeRadius ()
    {
      return this->ProbeRadius_;
    }

    void MeasurePointActualType::
    ProbeRadius (const ProbeRadius_type& x)
    {
      this->ProbeRadius_.set (x);
    }

    void MeasurePointActualType::
    ProbeRadius (const ProbeRadius_optional& x)
    {
      this->ProbeRadius_ = x;
    }

    void MeasurePointActualType::
    ProbeRadius (::std::auto_ptr< ProbeRadius_type > x)
    {
      this->ProbeRadius_.set (x);
    }

    const MeasurePointActualType::MeasurementDeviceId_optional& MeasurePointActualType::
    MeasurementDeviceId () const
    {
      return this->MeasurementDeviceId_;
    }

    MeasurePointActualType::MeasurementDeviceId_optional& MeasurePointActualType::
    MeasurementDeviceId ()
    {
      return this->MeasurementDeviceId_;
    }

    void MeasurePointActualType::
    MeasurementDeviceId (const MeasurementDeviceId_type& x)
    {
      this->MeasurementDeviceId_.set (x);
    }

    void MeasurePointActualType::
    MeasurementDeviceId (const MeasurementDeviceId_optional& x)
    {
      this->MeasurementDeviceId_ = x;
    }

    void MeasurePointActualType::
    MeasurementDeviceId (::std::auto_ptr< MeasurementDeviceId_type > x)
    {
      this->MeasurementDeviceId_.set (x);
    }

    const MeasurePointActualType::SensorId_optional& MeasurePointActualType::
    SensorId () const
    {
      return this->SensorId_;
    }

    MeasurePointActualType::SensorId_optional& MeasurePointActualType::
    SensorId ()
    {
      return this->SensorId_;
    }

    void MeasurePointActualType::
    SensorId (const SensorId_type& x)
    {
      this->SensorId_.set (x);
    }

    void MeasurePointActualType::
    SensorId (const SensorId_optional& x)
    {
      this->SensorId_ = x;
    }

    void MeasurePointActualType::
    SensorId (::std::auto_ptr< SensorId_type > x)
    {
      this->SensorId_.set (x);
    }

    const MeasurePointActualType::MeasurePointNominalId_optional& MeasurePointActualType::
    MeasurePointNominalId () const
    {
      return this->MeasurePointNominalId_;
    }

    MeasurePointActualType::MeasurePointNominalId_optional& MeasurePointActualType::
    MeasurePointNominalId ()
    {
      return this->MeasurePointNominalId_;
    }

    void MeasurePointActualType::
    MeasurePointNominalId (const MeasurePointNominalId_type& x)
    {
      this->MeasurePointNominalId_.set (x);
    }

    void MeasurePointActualType::
    MeasurePointNominalId (const MeasurePointNominalId_optional& x)
    {
      this->MeasurePointNominalId_ = x;
    }

    void MeasurePointActualType::
    MeasurePointNominalId (::std::auto_ptr< MeasurePointNominalId_type > x)
    {
      this->MeasurePointNominalId_.set (x);
    }


    // MovableDatumTargetDirectionType
    // 

    const MovableDatumTargetDirectionType::DatumTargetTranslationDirection_type& MovableDatumTargetDirectionType::
    DatumTargetTranslationDirection () const
    {
      return this->DatumTargetTranslationDirection_.get ();
    }

    MovableDatumTargetDirectionType::DatumTargetTranslationDirection_type& MovableDatumTargetDirectionType::
    DatumTargetTranslationDirection ()
    {
      return this->DatumTargetTranslationDirection_.get ();
    }

    void MovableDatumTargetDirectionType::
    DatumTargetTranslationDirection (const DatumTargetTranslationDirection_type& x)
    {
      this->DatumTargetTranslationDirection_.set (x);
    }

    void MovableDatumTargetDirectionType::
    DatumTargetTranslationDirection (::std::auto_ptr< DatumTargetTranslationDirection_type > x)
    {
      this->DatumTargetTranslationDirection_.set (x);
    }


    // TargetPointActualType
    // 


    // TargetPointNominalType
    // 


    // TransformListType
    // 

    const TransformListType::Transform_sequence& TransformListType::
    Transform () const
    {
      return this->Transform_;
    }

    TransformListType::Transform_sequence& TransformListType::
    Transform ()
    {
      return this->Transform_;
    }

    void TransformListType::
    Transform (const Transform_sequence& s)
    {
      this->Transform_ = s;
    }

    const TransformListType::N_type& TransformListType::
    N () const
    {
      return this->N_.get ();
    }

    TransformListType::N_type& TransformListType::
    N ()
    {
      return this->N_.get ();
    }

    void TransformListType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void TransformListType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // TransformInstanceType
    // 

    const TransformInstanceType::Attributes_optional& TransformInstanceType::
    Attributes () const
    {
      return this->Attributes_;
    }

    TransformInstanceType::Attributes_optional& TransformInstanceType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void TransformInstanceType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void TransformInstanceType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void TransformInstanceType::
    Attributes (::std::auto_ptr< Attributes_type > x)
    {
      this->Attributes_.set (x);
    }

    const TransformInstanceType::Name_optional& TransformInstanceType::
    Name () const
    {
      return this->Name_;
    }

    TransformInstanceType::Name_optional& TransformInstanceType::
    Name ()
    {
      return this->Name_;
    }

    void TransformInstanceType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void TransformInstanceType::
    Name (const Name_optional& x)
    {
      this->Name_ = x;
    }

    void TransformInstanceType::
    Name (::std::auto_ptr< Name_type > x)
    {
      this->Name_.set (x);
    }

    const TransformInstanceType::id_type& TransformInstanceType::
    id () const
    {
      return this->id_.get ();
    }

    TransformInstanceType::id_type& TransformInstanceType::
    id ()
    {
      return this->id_.get ();
    }

    void TransformInstanceType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void TransformInstanceType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // LinearCoordinateDirectionEnumType
    // 

    LinearCoordinateDirectionEnumType::
    LinearCoordinateDirectionEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_LinearCoordinateDirectionEnumType_literals_[v])
    {
    }

    LinearCoordinateDirectionEnumType::
    LinearCoordinateDirectionEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    LinearCoordinateDirectionEnumType::
    LinearCoordinateDirectionEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    LinearCoordinateDirectionEnumType::
    LinearCoordinateDirectionEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    LinearCoordinateDirectionEnumType::
    LinearCoordinateDirectionEnumType (const LinearCoordinateDirectionEnumType& v,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    LinearCoordinateDirectionEnumType& LinearCoordinateDirectionEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_LinearCoordinateDirectionEnumType_literals_[v]);

      return *this;
    }


    // AngularCoordinateDirectionEnumType
    // 

    AngularCoordinateDirectionEnumType::
    AngularCoordinateDirectionEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_AngularCoordinateDirectionEnumType_literals_[v])
    {
    }

    AngularCoordinateDirectionEnumType::
    AngularCoordinateDirectionEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AngularCoordinateDirectionEnumType::
    AngularCoordinateDirectionEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AngularCoordinateDirectionEnumType::
    AngularCoordinateDirectionEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AngularCoordinateDirectionEnumType::
    AngularCoordinateDirectionEnumType (const AngularCoordinateDirectionEnumType& v,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    AngularCoordinateDirectionEnumType& AngularCoordinateDirectionEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_AngularCoordinateDirectionEnumType_literals_[v]);

      return *this;
    }


    // SubstituteFeatureAlgorithmBaseType
    // 


    // FeatureOfSizeSubstituteFeatureAlgorithmEnumType
    // 

    FeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    FeatureOfSizeSubstituteFeatureAlgorithmEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_FeatureOfSizeSubstituteFeatureAlgorithmEnumType_literals_[v])
    {
    }

    FeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    FeatureOfSizeSubstituteFeatureAlgorithmEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    FeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    FeatureOfSizeSubstituteFeatureAlgorithmEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    FeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    FeatureOfSizeSubstituteFeatureAlgorithmEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    FeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    FeatureOfSizeSubstituteFeatureAlgorithmEnumType (const FeatureOfSizeSubstituteFeatureAlgorithmEnumType& v,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    FeatureOfSizeSubstituteFeatureAlgorithmEnumType& FeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_FeatureOfSizeSubstituteFeatureAlgorithmEnumType_literals_[v]);

      return *this;
    }


    // FeatureOfSizeSubstituteFeatureAlgorithmType
    // 

    const FeatureOfSizeSubstituteFeatureAlgorithmType::FeatureOfSizeSubstituteFeatureAlgorithmEnum_optional& FeatureOfSizeSubstituteFeatureAlgorithmType::
    FeatureOfSizeSubstituteFeatureAlgorithmEnum () const
    {
      return this->FeatureOfSizeSubstituteFeatureAlgorithmEnum_;
    }

    FeatureOfSizeSubstituteFeatureAlgorithmType::FeatureOfSizeSubstituteFeatureAlgorithmEnum_optional& FeatureOfSizeSubstituteFeatureAlgorithmType::
    FeatureOfSizeSubstituteFeatureAlgorithmEnum ()
    {
      return this->FeatureOfSizeSubstituteFeatureAlgorithmEnum_;
    }

    void FeatureOfSizeSubstituteFeatureAlgorithmType::
    FeatureOfSizeSubstituteFeatureAlgorithmEnum (const FeatureOfSizeSubstituteFeatureAlgorithmEnum_type& x)
    {
      this->FeatureOfSizeSubstituteFeatureAlgorithmEnum_.set (x);
    }

    void FeatureOfSizeSubstituteFeatureAlgorithmType::
    FeatureOfSizeSubstituteFeatureAlgorithmEnum (const FeatureOfSizeSubstituteFeatureAlgorithmEnum_optional& x)
    {
      this->FeatureOfSizeSubstituteFeatureAlgorithmEnum_ = x;
    }

    void FeatureOfSizeSubstituteFeatureAlgorithmType::
    FeatureOfSizeSubstituteFeatureAlgorithmEnum (::std::auto_ptr< FeatureOfSizeSubstituteFeatureAlgorithmEnum_type > x)
    {
      this->FeatureOfSizeSubstituteFeatureAlgorithmEnum_.set (x);
    }

    const FeatureOfSizeSubstituteFeatureAlgorithmType::OtherFeatureOfSizeSubstituteFeatureAlgorithm_optional& FeatureOfSizeSubstituteFeatureAlgorithmType::
    OtherFeatureOfSizeSubstituteFeatureAlgorithm () const
    {
      return this->OtherFeatureOfSizeSubstituteFeatureAlgorithm_;
    }

    FeatureOfSizeSubstituteFeatureAlgorithmType::OtherFeatureOfSizeSubstituteFeatureAlgorithm_optional& FeatureOfSizeSubstituteFeatureAlgorithmType::
    OtherFeatureOfSizeSubstituteFeatureAlgorithm ()
    {
      return this->OtherFeatureOfSizeSubstituteFeatureAlgorithm_;
    }

    void FeatureOfSizeSubstituteFeatureAlgorithmType::
    OtherFeatureOfSizeSubstituteFeatureAlgorithm (const OtherFeatureOfSizeSubstituteFeatureAlgorithm_type& x)
    {
      this->OtherFeatureOfSizeSubstituteFeatureAlgorithm_.set (x);
    }

    void FeatureOfSizeSubstituteFeatureAlgorithmType::
    OtherFeatureOfSizeSubstituteFeatureAlgorithm (const OtherFeatureOfSizeSubstituteFeatureAlgorithm_optional& x)
    {
      this->OtherFeatureOfSizeSubstituteFeatureAlgorithm_ = x;
    }

    void FeatureOfSizeSubstituteFeatureAlgorithmType::
    OtherFeatureOfSizeSubstituteFeatureAlgorithm (::std::auto_ptr< OtherFeatureOfSizeSubstituteFeatureAlgorithm_type > x)
    {
      this->OtherFeatureOfSizeSubstituteFeatureAlgorithm_.set (x);
    }


    // NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType
    // 

    NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType_literals_[v])
    {
    }

    NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType (const NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType& v,
                                                        ::xml_schema::flags f,
                                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType& NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType_literals_[v]);

      return *this;
    }


    // NonFeatureOfSizeSubstituteFeatureAlgorithmType
    // 

    const NonFeatureOfSizeSubstituteFeatureAlgorithmType::NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_optional& NonFeatureOfSizeSubstituteFeatureAlgorithmType::
    NonFeatureOfSizeSubstituteFeatureAlgorithmEnum () const
    {
      return this->NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_;
    }

    NonFeatureOfSizeSubstituteFeatureAlgorithmType::NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_optional& NonFeatureOfSizeSubstituteFeatureAlgorithmType::
    NonFeatureOfSizeSubstituteFeatureAlgorithmEnum ()
    {
      return this->NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_;
    }

    void NonFeatureOfSizeSubstituteFeatureAlgorithmType::
    NonFeatureOfSizeSubstituteFeatureAlgorithmEnum (const NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_type& x)
    {
      this->NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_.set (x);
    }

    void NonFeatureOfSizeSubstituteFeatureAlgorithmType::
    NonFeatureOfSizeSubstituteFeatureAlgorithmEnum (const NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_optional& x)
    {
      this->NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_ = x;
    }

    void NonFeatureOfSizeSubstituteFeatureAlgorithmType::
    NonFeatureOfSizeSubstituteFeatureAlgorithmEnum (::std::auto_ptr< NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_type > x)
    {
      this->NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_.set (x);
    }

    const NonFeatureOfSizeSubstituteFeatureAlgorithmType::OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_optional& NonFeatureOfSizeSubstituteFeatureAlgorithmType::
    OtherNonFeatureOfSizeSubstituteFeatureAlgorithm () const
    {
      return this->OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_;
    }

    NonFeatureOfSizeSubstituteFeatureAlgorithmType::OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_optional& NonFeatureOfSizeSubstituteFeatureAlgorithmType::
    OtherNonFeatureOfSizeSubstituteFeatureAlgorithm ()
    {
      return this->OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_;
    }

    void NonFeatureOfSizeSubstituteFeatureAlgorithmType::
    OtherNonFeatureOfSizeSubstituteFeatureAlgorithm (const OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_type& x)
    {
      this->OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_.set (x);
    }

    void NonFeatureOfSizeSubstituteFeatureAlgorithmType::
    OtherNonFeatureOfSizeSubstituteFeatureAlgorithm (const OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_optional& x)
    {
      this->OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_ = x;
    }

    void NonFeatureOfSizeSubstituteFeatureAlgorithmType::
    OtherNonFeatureOfSizeSubstituteFeatureAlgorithm (::std::auto_ptr< OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_type > x)
    {
      this->OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_.set (x);
    }


    // CurveSubstituteFeatureAlgorithmEnumType
    // 

    CurveSubstituteFeatureAlgorithmEnumType::
    CurveSubstituteFeatureAlgorithmEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_CurveSubstituteFeatureAlgorithmEnumType_literals_[v])
    {
    }

    CurveSubstituteFeatureAlgorithmEnumType::
    CurveSubstituteFeatureAlgorithmEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CurveSubstituteFeatureAlgorithmEnumType::
    CurveSubstituteFeatureAlgorithmEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CurveSubstituteFeatureAlgorithmEnumType::
    CurveSubstituteFeatureAlgorithmEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CurveSubstituteFeatureAlgorithmEnumType::
    CurveSubstituteFeatureAlgorithmEnumType (const CurveSubstituteFeatureAlgorithmEnumType& v,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    CurveSubstituteFeatureAlgorithmEnumType& CurveSubstituteFeatureAlgorithmEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_CurveSubstituteFeatureAlgorithmEnumType_literals_[v]);

      return *this;
    }


    // CurveSubstituteFeatureAlgorithmType
    // 

    const CurveSubstituteFeatureAlgorithmType::CurveSubstituteFeatureAlgorithmEnum_optional& CurveSubstituteFeatureAlgorithmType::
    CurveSubstituteFeatureAlgorithmEnum () const
    {
      return this->CurveSubstituteFeatureAlgorithmEnum_;
    }

    CurveSubstituteFeatureAlgorithmType::CurveSubstituteFeatureAlgorithmEnum_optional& CurveSubstituteFeatureAlgorithmType::
    CurveSubstituteFeatureAlgorithmEnum ()
    {
      return this->CurveSubstituteFeatureAlgorithmEnum_;
    }

    void CurveSubstituteFeatureAlgorithmType::
    CurveSubstituteFeatureAlgorithmEnum (const CurveSubstituteFeatureAlgorithmEnum_type& x)
    {
      this->CurveSubstituteFeatureAlgorithmEnum_.set (x);
    }

    void CurveSubstituteFeatureAlgorithmType::
    CurveSubstituteFeatureAlgorithmEnum (const CurveSubstituteFeatureAlgorithmEnum_optional& x)
    {
      this->CurveSubstituteFeatureAlgorithmEnum_ = x;
    }

    void CurveSubstituteFeatureAlgorithmType::
    CurveSubstituteFeatureAlgorithmEnum (::std::auto_ptr< CurveSubstituteFeatureAlgorithmEnum_type > x)
    {
      this->CurveSubstituteFeatureAlgorithmEnum_.set (x);
    }

    const CurveSubstituteFeatureAlgorithmType::OtherCurveSubstituteFeatureAlgorithm_optional& CurveSubstituteFeatureAlgorithmType::
    OtherCurveSubstituteFeatureAlgorithm () const
    {
      return this->OtherCurveSubstituteFeatureAlgorithm_;
    }

    CurveSubstituteFeatureAlgorithmType::OtherCurveSubstituteFeatureAlgorithm_optional& CurveSubstituteFeatureAlgorithmType::
    OtherCurveSubstituteFeatureAlgorithm ()
    {
      return this->OtherCurveSubstituteFeatureAlgorithm_;
    }

    void CurveSubstituteFeatureAlgorithmType::
    OtherCurveSubstituteFeatureAlgorithm (const OtherCurveSubstituteFeatureAlgorithm_type& x)
    {
      this->OtherCurveSubstituteFeatureAlgorithm_.set (x);
    }

    void CurveSubstituteFeatureAlgorithmType::
    OtherCurveSubstituteFeatureAlgorithm (const OtherCurveSubstituteFeatureAlgorithm_optional& x)
    {
      this->OtherCurveSubstituteFeatureAlgorithm_ = x;
    }

    void CurveSubstituteFeatureAlgorithmType::
    OtherCurveSubstituteFeatureAlgorithm (::std::auto_ptr< OtherCurveSubstituteFeatureAlgorithm_type > x)
    {
      this->OtherCurveSubstituteFeatureAlgorithm_.set (x);
    }


    // SurfaceSubstituteFeatureAlgorithmEnumType
    // 

    SurfaceSubstituteFeatureAlgorithmEnumType::
    SurfaceSubstituteFeatureAlgorithmEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_SurfaceSubstituteFeatureAlgorithmEnumType_literals_[v])
    {
    }

    SurfaceSubstituteFeatureAlgorithmEnumType::
    SurfaceSubstituteFeatureAlgorithmEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SurfaceSubstituteFeatureAlgorithmEnumType::
    SurfaceSubstituteFeatureAlgorithmEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SurfaceSubstituteFeatureAlgorithmEnumType::
    SurfaceSubstituteFeatureAlgorithmEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    SurfaceSubstituteFeatureAlgorithmEnumType::
    SurfaceSubstituteFeatureAlgorithmEnumType (const SurfaceSubstituteFeatureAlgorithmEnumType& v,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    SurfaceSubstituteFeatureAlgorithmEnumType& SurfaceSubstituteFeatureAlgorithmEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_SurfaceSubstituteFeatureAlgorithmEnumType_literals_[v]);

      return *this;
    }


    // SurfaceSubstituteFeatureAlgorithmType
    // 

    const SurfaceSubstituteFeatureAlgorithmType::SurfaceSubstituteFeatureAlgorithmEnum_optional& SurfaceSubstituteFeatureAlgorithmType::
    SurfaceSubstituteFeatureAlgorithmEnum () const
    {
      return this->SurfaceSubstituteFeatureAlgorithmEnum_;
    }

    SurfaceSubstituteFeatureAlgorithmType::SurfaceSubstituteFeatureAlgorithmEnum_optional& SurfaceSubstituteFeatureAlgorithmType::
    SurfaceSubstituteFeatureAlgorithmEnum ()
    {
      return this->SurfaceSubstituteFeatureAlgorithmEnum_;
    }

    void SurfaceSubstituteFeatureAlgorithmType::
    SurfaceSubstituteFeatureAlgorithmEnum (const SurfaceSubstituteFeatureAlgorithmEnum_type& x)
    {
      this->SurfaceSubstituteFeatureAlgorithmEnum_.set (x);
    }

    void SurfaceSubstituteFeatureAlgorithmType::
    SurfaceSubstituteFeatureAlgorithmEnum (const SurfaceSubstituteFeatureAlgorithmEnum_optional& x)
    {
      this->SurfaceSubstituteFeatureAlgorithmEnum_ = x;
    }

    void SurfaceSubstituteFeatureAlgorithmType::
    SurfaceSubstituteFeatureAlgorithmEnum (::std::auto_ptr< SurfaceSubstituteFeatureAlgorithmEnum_type > x)
    {
      this->SurfaceSubstituteFeatureAlgorithmEnum_.set (x);
    }

    const SurfaceSubstituteFeatureAlgorithmType::OtherSurfaceSubstituteFeatureAlgorithm_optional& SurfaceSubstituteFeatureAlgorithmType::
    OtherSurfaceSubstituteFeatureAlgorithm () const
    {
      return this->OtherSurfaceSubstituteFeatureAlgorithm_;
    }

    SurfaceSubstituteFeatureAlgorithmType::OtherSurfaceSubstituteFeatureAlgorithm_optional& SurfaceSubstituteFeatureAlgorithmType::
    OtherSurfaceSubstituteFeatureAlgorithm ()
    {
      return this->OtherSurfaceSubstituteFeatureAlgorithm_;
    }

    void SurfaceSubstituteFeatureAlgorithmType::
    OtherSurfaceSubstituteFeatureAlgorithm (const OtherSurfaceSubstituteFeatureAlgorithm_type& x)
    {
      this->OtherSurfaceSubstituteFeatureAlgorithm_.set (x);
    }

    void SurfaceSubstituteFeatureAlgorithmType::
    OtherSurfaceSubstituteFeatureAlgorithm (const OtherSurfaceSubstituteFeatureAlgorithm_optional& x)
    {
      this->OtherSurfaceSubstituteFeatureAlgorithm_ = x;
    }

    void SurfaceSubstituteFeatureAlgorithmType::
    OtherSurfaceSubstituteFeatureAlgorithm (::std::auto_ptr< OtherSurfaceSubstituteFeatureAlgorithm_type > x)
    {
      this->OtherSurfaceSubstituteFeatureAlgorithm_.set (x);
    }


    // MaterialModifierEnumType
    // 

    MaterialModifierEnumType::
    MaterialModifierEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_MaterialModifierEnumType_literals_[v])
    {
    }

    MaterialModifierEnumType::
    MaterialModifierEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MaterialModifierEnumType::
    MaterialModifierEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MaterialModifierEnumType::
    MaterialModifierEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MaterialModifierEnumType::
    MaterialModifierEnumType (const MaterialModifierEnumType& v,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    MaterialModifierEnumType& MaterialModifierEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_MaterialModifierEnumType_literals_[v]);

      return *this;
    }


    // PrecedenceEnumType
    // 

    PrecedenceEnumType::
    PrecedenceEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_PrecedenceEnumType_literals_[v])
    {
    }

    PrecedenceEnumType::
    PrecedenceEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    PrecedenceEnumType::
    PrecedenceEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    PrecedenceEnumType::
    PrecedenceEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    PrecedenceEnumType::
    PrecedenceEnumType (const PrecedenceEnumType& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    PrecedenceEnumType& PrecedenceEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_PrecedenceEnumType_literals_[v]);

      return *this;
    }


    // PrecedenceType
    // 

    const PrecedenceType::PrecedenceEnum_optional& PrecedenceType::
    PrecedenceEnum () const
    {
      return this->PrecedenceEnum_;
    }

    PrecedenceType::PrecedenceEnum_optional& PrecedenceType::
    PrecedenceEnum ()
    {
      return this->PrecedenceEnum_;
    }

    void PrecedenceType::
    PrecedenceEnum (const PrecedenceEnum_type& x)
    {
      this->PrecedenceEnum_.set (x);
    }

    void PrecedenceType::
    PrecedenceEnum (const PrecedenceEnum_optional& x)
    {
      this->PrecedenceEnum_ = x;
    }

    void PrecedenceType::
    PrecedenceEnum (::std::auto_ptr< PrecedenceEnum_type > x)
    {
      this->PrecedenceEnum_.set (x);
    }

    const PrecedenceType::OtherPrecedence_optional& PrecedenceType::
    OtherPrecedence () const
    {
      return this->OtherPrecedence_;
    }

    PrecedenceType::OtherPrecedence_optional& PrecedenceType::
    OtherPrecedence ()
    {
      return this->OtherPrecedence_;
    }

    void PrecedenceType::
    OtherPrecedence (const OtherPrecedence_type& x)
    {
      this->OtherPrecedence_.set (x);
    }

    void PrecedenceType::
    OtherPrecedence (const OtherPrecedence_optional& x)
    {
      this->OtherPrecedence_ = x;
    }

    void PrecedenceType::
    OtherPrecedence (::std::auto_ptr< OtherPrecedence_type > x)
    {
      this->OtherPrecedence_.set (x);
    }


    // ReferencedComponentEnumType
    // 

    ReferencedComponentEnumType::
    ReferencedComponentEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ReferencedComponentEnumType_literals_[v])
    {
    }

    ReferencedComponentEnumType::
    ReferencedComponentEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ReferencedComponentEnumType::
    ReferencedComponentEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ReferencedComponentEnumType::
    ReferencedComponentEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ReferencedComponentEnumType::
    ReferencedComponentEnumType (const ReferencedComponentEnumType& v,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ReferencedComponentEnumType& ReferencedComponentEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ReferencedComponentEnumType_literals_[v]);

      return *this;
    }


    // RetrievalMethodEnumType
    // 

    RetrievalMethodEnumType::
    RetrievalMethodEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_RetrievalMethodEnumType_literals_[v])
    {
    }

    RetrievalMethodEnumType::
    RetrievalMethodEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    RetrievalMethodEnumType::
    RetrievalMethodEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    RetrievalMethodEnumType::
    RetrievalMethodEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    RetrievalMethodEnumType::
    RetrievalMethodEnumType (const RetrievalMethodEnumType& v,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    RetrievalMethodEnumType& RetrievalMethodEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_RetrievalMethodEnumType_literals_[v]);

      return *this;
    }


    // MeasurementDirectiveEnumType
    // 

    MeasurementDirectiveEnumType::
    MeasurementDirectiveEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_MeasurementDirectiveEnumType_literals_[v])
    {
    }

    MeasurementDirectiveEnumType::
    MeasurementDirectiveEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MeasurementDirectiveEnumType::
    MeasurementDirectiveEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MeasurementDirectiveEnumType::
    MeasurementDirectiveEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MeasurementDirectiveEnumType::
    MeasurementDirectiveEnumType (const MeasurementDirectiveEnumType& v,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    MeasurementDirectiveEnumType& MeasurementDirectiveEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_MeasurementDirectiveEnumType_literals_[v]);

      return *this;
    }


    // MeasurementDirectiveType
    // 

    const MeasurementDirectiveType::MeasurementDirectiveEnum_optional& MeasurementDirectiveType::
    MeasurementDirectiveEnum () const
    {
      return this->MeasurementDirectiveEnum_;
    }

    MeasurementDirectiveType::MeasurementDirectiveEnum_optional& MeasurementDirectiveType::
    MeasurementDirectiveEnum ()
    {
      return this->MeasurementDirectiveEnum_;
    }

    void MeasurementDirectiveType::
    MeasurementDirectiveEnum (const MeasurementDirectiveEnum_type& x)
    {
      this->MeasurementDirectiveEnum_.set (x);
    }

    void MeasurementDirectiveType::
    MeasurementDirectiveEnum (const MeasurementDirectiveEnum_optional& x)
    {
      this->MeasurementDirectiveEnum_ = x;
    }

    void MeasurementDirectiveType::
    MeasurementDirectiveEnum (::std::auto_ptr< MeasurementDirectiveEnum_type > x)
    {
      this->MeasurementDirectiveEnum_.set (x);
    }

    const MeasurementDirectiveType::OtherMeasurementDirective_optional& MeasurementDirectiveType::
    OtherMeasurementDirective () const
    {
      return this->OtherMeasurementDirective_;
    }

    MeasurementDirectiveType::OtherMeasurementDirective_optional& MeasurementDirectiveType::
    OtherMeasurementDirective ()
    {
      return this->OtherMeasurementDirective_;
    }

    void MeasurementDirectiveType::
    OtherMeasurementDirective (const OtherMeasurementDirective_type& x)
    {
      this->OtherMeasurementDirective_.set (x);
    }

    void MeasurementDirectiveType::
    OtherMeasurementDirective (const OtherMeasurementDirective_optional& x)
    {
      this->OtherMeasurementDirective_ = x;
    }

    void MeasurementDirectiveType::
    OtherMeasurementDirective (::std::auto_ptr< OtherMeasurementDirective_type > x)
    {
      this->OtherMeasurementDirective_.set (x);
    }


    // DistanceBetweenAnalysisModeEnumType
    // 

    DistanceBetweenAnalysisModeEnumType::
    DistanceBetweenAnalysisModeEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_DistanceBetweenAnalysisModeEnumType_literals_[v])
    {
    }

    DistanceBetweenAnalysisModeEnumType::
    DistanceBetweenAnalysisModeEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DistanceBetweenAnalysisModeEnumType::
    DistanceBetweenAnalysisModeEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DistanceBetweenAnalysisModeEnumType::
    DistanceBetweenAnalysisModeEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DistanceBetweenAnalysisModeEnumType::
    DistanceBetweenAnalysisModeEnumType (const DistanceBetweenAnalysisModeEnumType& v,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    DistanceBetweenAnalysisModeEnumType& DistanceBetweenAnalysisModeEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_DistanceBetweenAnalysisModeEnumType_literals_[v]);

      return *this;
    }


    // AngleBetweenAnalysisModeEnumType
    // 

    AngleBetweenAnalysisModeEnumType::
    AngleBetweenAnalysisModeEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_AngleBetweenAnalysisModeEnumType_literals_[v])
    {
    }

    AngleBetweenAnalysisModeEnumType::
    AngleBetweenAnalysisModeEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AngleBetweenAnalysisModeEnumType::
    AngleBetweenAnalysisModeEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AngleBetweenAnalysisModeEnumType::
    AngleBetweenAnalysisModeEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AngleBetweenAnalysisModeEnumType::
    AngleBetweenAnalysisModeEnumType (const AngleBetweenAnalysisModeEnumType& v,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    AngleBetweenAnalysisModeEnumType& AngleBetweenAnalysisModeEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_AngleBetweenAnalysisModeEnumType_literals_[v]);

      return *this;
    }


    // BaseFeatureType
    // 

    const BaseFeatureType::ReferencedComponent_type& BaseFeatureType::
    ReferencedComponent () const
    {
      return this->ReferencedComponent_.get ();
    }

    BaseFeatureType::ReferencedComponent_type& BaseFeatureType::
    ReferencedComponent ()
    {
      return this->ReferencedComponent_.get ();
    }

    void BaseFeatureType::
    ReferencedComponent (const ReferencedComponent_type& x)
    {
      this->ReferencedComponent_.set (x);
    }

    void BaseFeatureType::
    ReferencedComponent (::std::auto_ptr< ReferencedComponent_type > x)
    {
      this->ReferencedComponent_.set (x);
    }

    const BaseFeatureType::FeatureItemId_type& BaseFeatureType::
    FeatureItemId () const
    {
      return this->FeatureItemId_.get ();
    }

    BaseFeatureType::FeatureItemId_type& BaseFeatureType::
    FeatureItemId ()
    {
      return this->FeatureItemId_.get ();
    }

    void BaseFeatureType::
    FeatureItemId (const FeatureItemId_type& x)
    {
      this->FeatureItemId_.set (x);
    }

    void BaseFeatureType::
    FeatureItemId (::std::auto_ptr< FeatureItemId_type > x)
    {
      this->FeatureItemId_.set (x);
    }


    // SequencedBaseFeatureType
    // 

    const SequencedBaseFeatureType::SequenceNumber_type& SequencedBaseFeatureType::
    SequenceNumber () const
    {
      return this->SequenceNumber_.get ();
    }

    SequencedBaseFeatureType::SequenceNumber_type& SequencedBaseFeatureType::
    SequenceNumber ()
    {
      return this->SequenceNumber_.get ();
    }

    void SequencedBaseFeatureType::
    SequenceNumber (const SequenceNumber_type& x)
    {
      this->SequenceNumber_.set (x);
    }


    // DirectionalOffsetType
    // 

    const DirectionalOffsetType::Offset_type& DirectionalOffsetType::
    Offset () const
    {
      return this->Offset_.get ();
    }

    DirectionalOffsetType::Offset_type& DirectionalOffsetType::
    Offset ()
    {
      return this->Offset_.get ();
    }

    void DirectionalOffsetType::
    Offset (const Offset_type& x)
    {
      this->Offset_.set (x);
    }

    void DirectionalOffsetType::
    Offset (::std::auto_ptr< Offset_type > x)
    {
      this->Offset_.set (x);
    }

    const DirectionalOffsetType::NominalDirection_optional& DirectionalOffsetType::
    NominalDirection () const
    {
      return this->NominalDirection_;
    }

    DirectionalOffsetType::NominalDirection_optional& DirectionalOffsetType::
    NominalDirection ()
    {
      return this->NominalDirection_;
    }

    void DirectionalOffsetType::
    NominalDirection (const NominalDirection_type& x)
    {
      this->NominalDirection_.set (x);
    }

    void DirectionalOffsetType::
    NominalDirection (const NominalDirection_optional& x)
    {
      this->NominalDirection_ = x;
    }

    void DirectionalOffsetType::
    NominalDirection (::std::auto_ptr< NominalDirection_type > x)
    {
      this->NominalDirection_.set (x);
    }

    const DirectionalOffsetType::FeatureDirection_optional& DirectionalOffsetType::
    FeatureDirection () const
    {
      return this->FeatureDirection_;
    }

    DirectionalOffsetType::FeatureDirection_optional& DirectionalOffsetType::
    FeatureDirection ()
    {
      return this->FeatureDirection_;
    }

    void DirectionalOffsetType::
    FeatureDirection (const FeatureDirection_type& x)
    {
      this->FeatureDirection_.set (x);
    }

    void DirectionalOffsetType::
    FeatureDirection (const FeatureDirection_optional& x)
    {
      this->FeatureDirection_ = x;
    }

    void DirectionalOffsetType::
    FeatureDirection (::std::auto_ptr< FeatureDirection_type > x)
    {
      this->FeatureDirection_.set (x);
    }


    // AlignmentFeatureType
    // 

    const AlignmentFeatureType::DatumDefinitionId_optional& AlignmentFeatureType::
    DatumDefinitionId () const
    {
      return this->DatumDefinitionId_;
    }

    AlignmentFeatureType::DatumDefinitionId_optional& AlignmentFeatureType::
    DatumDefinitionId ()
    {
      return this->DatumDefinitionId_;
    }

    void AlignmentFeatureType::
    DatumDefinitionId (const DatumDefinitionId_type& x)
    {
      this->DatumDefinitionId_.set (x);
    }

    void AlignmentFeatureType::
    DatumDefinitionId (const DatumDefinitionId_optional& x)
    {
      this->DatumDefinitionId_ = x;
    }

    void AlignmentFeatureType::
    DatumDefinitionId (::std::auto_ptr< DatumDefinitionId_type > x)
    {
      this->DatumDefinitionId_.set (x);
    }

    const AlignmentFeatureType::BaseFeature_optional& AlignmentFeatureType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    AlignmentFeatureType::BaseFeature_optional& AlignmentFeatureType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void AlignmentFeatureType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void AlignmentFeatureType::
    BaseFeature (const BaseFeature_optional& x)
    {
      this->BaseFeature_ = x;
    }

    void AlignmentFeatureType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // AlignmentOperationBaseType
    // 

    const AlignmentOperationBaseType::SequenceNumber_type& AlignmentOperationBaseType::
    SequenceNumber () const
    {
      return this->SequenceNumber_.get ();
    }

    AlignmentOperationBaseType::SequenceNumber_type& AlignmentOperationBaseType::
    SequenceNumber ()
    {
      return this->SequenceNumber_.get ();
    }

    void AlignmentOperationBaseType::
    SequenceNumber (const SequenceNumber_type& x)
    {
      this->SequenceNumber_.set (x);
    }


    // PrimaryAlignmentOperationType
    // 

    const PrimaryAlignmentOperationType::PrimaryEntity_type& PrimaryAlignmentOperationType::
    PrimaryEntity () const
    {
      return this->PrimaryEntity_.get ();
    }

    PrimaryAlignmentOperationType::PrimaryEntity_type& PrimaryAlignmentOperationType::
    PrimaryEntity ()
    {
      return this->PrimaryEntity_.get ();
    }

    void PrimaryAlignmentOperationType::
    PrimaryEntity (const PrimaryEntity_type& x)
    {
      this->PrimaryEntity_.set (x);
    }

    void PrimaryAlignmentOperationType::
    PrimaryEntity (::std::auto_ptr< PrimaryEntity_type > x)
    {
      this->PrimaryEntity_.set (x);
    }

    const PrimaryAlignmentOperationType::PrimaryAxis_type& PrimaryAlignmentOperationType::
    PrimaryAxis () const
    {
      return this->PrimaryAxis_.get ();
    }

    PrimaryAlignmentOperationType::PrimaryAxis_type& PrimaryAlignmentOperationType::
    PrimaryAxis ()
    {
      return this->PrimaryAxis_.get ();
    }

    void PrimaryAlignmentOperationType::
    PrimaryAxis (const PrimaryAxis_type& x)
    {
      this->PrimaryAxis_.set (x);
    }

    void PrimaryAlignmentOperationType::
    PrimaryAxis (::std::auto_ptr< PrimaryAxis_type > x)
    {
      this->PrimaryAxis_.set (x);
    }


    // SecondaryAlignmentOperationType
    // 

    const SecondaryAlignmentOperationType::SecondaryEntity_type& SecondaryAlignmentOperationType::
    SecondaryEntity () const
    {
      return this->SecondaryEntity_.get ();
    }

    SecondaryAlignmentOperationType::SecondaryEntity_type& SecondaryAlignmentOperationType::
    SecondaryEntity ()
    {
      return this->SecondaryEntity_.get ();
    }

    void SecondaryAlignmentOperationType::
    SecondaryEntity (const SecondaryEntity_type& x)
    {
      this->SecondaryEntity_.set (x);
    }

    void SecondaryAlignmentOperationType::
    SecondaryEntity (::std::auto_ptr< SecondaryEntity_type > x)
    {
      this->SecondaryEntity_.set (x);
    }

    const SecondaryAlignmentOperationType::SecondaryAxis_type& SecondaryAlignmentOperationType::
    SecondaryAxis () const
    {
      return this->SecondaryAxis_.get ();
    }

    SecondaryAlignmentOperationType::SecondaryAxis_type& SecondaryAlignmentOperationType::
    SecondaryAxis ()
    {
      return this->SecondaryAxis_.get ();
    }

    void SecondaryAlignmentOperationType::
    SecondaryAxis (const SecondaryAxis_type& x)
    {
      this->SecondaryAxis_.set (x);
    }

    void SecondaryAlignmentOperationType::
    SecondaryAxis (::std::auto_ptr< SecondaryAxis_type > x)
    {
      this->SecondaryAxis_.set (x);
    }

    const SecondaryAlignmentOperationType::RotationAxis_optional& SecondaryAlignmentOperationType::
    RotationAxis () const
    {
      return this->RotationAxis_;
    }

    SecondaryAlignmentOperationType::RotationAxis_optional& SecondaryAlignmentOperationType::
    RotationAxis ()
    {
      return this->RotationAxis_;
    }

    void SecondaryAlignmentOperationType::
    RotationAxis (const RotationAxis_type& x)
    {
      this->RotationAxis_.set (x);
    }

    void SecondaryAlignmentOperationType::
    RotationAxis (const RotationAxis_optional& x)
    {
      this->RotationAxis_ = x;
    }

    void SecondaryAlignmentOperationType::
    RotationAxis (::std::auto_ptr< RotationAxis_type > x)
    {
      this->RotationAxis_.set (x);
    }


    // ActualOriginOffsetType
    // 

    const ActualOriginOffsetType::OriginEntity_type& ActualOriginOffsetType::
    OriginEntity () const
    {
      return this->OriginEntity_.get ();
    }

    ActualOriginOffsetType::OriginEntity_type& ActualOriginOffsetType::
    OriginEntity ()
    {
      return this->OriginEntity_.get ();
    }

    void ActualOriginOffsetType::
    OriginEntity (const OriginEntity_type& x)
    {
      this->OriginEntity_.set (x);
    }

    void ActualOriginOffsetType::
    OriginEntity (::std::auto_ptr< OriginEntity_type > x)
    {
      this->OriginEntity_.set (x);
    }

    const ActualOriginOffsetType::OriginDirection_type& ActualOriginOffsetType::
    OriginDirection () const
    {
      return this->OriginDirection_.get ();
    }

    ActualOriginOffsetType::OriginDirection_type& ActualOriginOffsetType::
    OriginDirection ()
    {
      return this->OriginDirection_.get ();
    }

    void ActualOriginOffsetType::
    OriginDirection (const OriginDirection_type& x)
    {
      this->OriginDirection_.set (x);
    }

    void ActualOriginOffsetType::
    OriginDirection (::std::auto_ptr< OriginDirection_type > x)
    {
      this->OriginDirection_.set (x);
    }


    // ActualOffsetAlignmentOperationType
    // 

    const ActualOffsetAlignmentOperationType::Origin_sequence& ActualOffsetAlignmentOperationType::
    Origin () const
    {
      return this->Origin_;
    }

    ActualOffsetAlignmentOperationType::Origin_sequence& ActualOffsetAlignmentOperationType::
    Origin ()
    {
      return this->Origin_;
    }

    void ActualOffsetAlignmentOperationType::
    Origin (const Origin_sequence& s)
    {
      this->Origin_ = s;
    }


    // NominalOffsetAlignmentOperationType
    // 

    const NominalOffsetAlignmentOperationType::Offset_type& NominalOffsetAlignmentOperationType::
    Offset () const
    {
      return this->Offset_.get ();
    }

    NominalOffsetAlignmentOperationType::Offset_type& NominalOffsetAlignmentOperationType::
    Offset ()
    {
      return this->Offset_.get ();
    }

    void NominalOffsetAlignmentOperationType::
    Offset (const Offset_type& x)
    {
      this->Offset_.set (x);
    }

    void NominalOffsetAlignmentOperationType::
    Offset (::std::auto_ptr< Offset_type > x)
    {
      this->Offset_.set (x);
    }


    // NominalRotationAlignmentOperationType
    // 

    const NominalRotationAlignmentOperationType::RotationAxis_type& NominalRotationAlignmentOperationType::
    RotationAxis () const
    {
      return this->RotationAxis_.get ();
    }

    NominalRotationAlignmentOperationType::RotationAxis_type& NominalRotationAlignmentOperationType::
    RotationAxis ()
    {
      return this->RotationAxis_.get ();
    }

    void NominalRotationAlignmentOperationType::
    RotationAxis (const RotationAxis_type& x)
    {
      this->RotationAxis_.set (x);
    }

    void NominalRotationAlignmentOperationType::
    RotationAxis (::std::auto_ptr< RotationAxis_type > x)
    {
      this->RotationAxis_.set (x);
    }

    const NominalRotationAlignmentOperationType::Angle_type& NominalRotationAlignmentOperationType::
    Angle () const
    {
      return this->Angle_.get ();
    }

    NominalRotationAlignmentOperationType::Angle_type& NominalRotationAlignmentOperationType::
    Angle ()
    {
      return this->Angle_.get ();
    }

    void NominalRotationAlignmentOperationType::
    Angle (const Angle_type& x)
    {
      this->Angle_.set (x);
    }

    void NominalRotationAlignmentOperationType::
    Angle (::std::auto_ptr< Angle_type > x)
    {
      this->Angle_.set (x);
    }


    // DatumPrecedenceAlignmentOperationType
    // 

    const DatumPrecedenceAlignmentOperationType::DatumReferenceFrameId_type& DatumPrecedenceAlignmentOperationType::
    DatumReferenceFrameId () const
    {
      return this->DatumReferenceFrameId_.get ();
    }

    DatumPrecedenceAlignmentOperationType::DatumReferenceFrameId_type& DatumPrecedenceAlignmentOperationType::
    DatumReferenceFrameId ()
    {
      return this->DatumReferenceFrameId_.get ();
    }

    void DatumPrecedenceAlignmentOperationType::
    DatumReferenceFrameId (const DatumReferenceFrameId_type& x)
    {
      this->DatumReferenceFrameId_.set (x);
    }

    void DatumPrecedenceAlignmentOperationType::
    DatumReferenceFrameId (::std::auto_ptr< DatumReferenceFrameId_type > x)
    {
      this->DatumReferenceFrameId_.set (x);
    }

    const DatumPrecedenceAlignmentOperationType::PrimaryAxis_type& DatumPrecedenceAlignmentOperationType::
    PrimaryAxis () const
    {
      return this->PrimaryAxis_.get ();
    }

    DatumPrecedenceAlignmentOperationType::PrimaryAxis_type& DatumPrecedenceAlignmentOperationType::
    PrimaryAxis ()
    {
      return this->PrimaryAxis_.get ();
    }

    void DatumPrecedenceAlignmentOperationType::
    PrimaryAxis (const PrimaryAxis_type& x)
    {
      this->PrimaryAxis_.set (x);
    }

    void DatumPrecedenceAlignmentOperationType::
    PrimaryAxis (::std::auto_ptr< PrimaryAxis_type > x)
    {
      this->PrimaryAxis_.set (x);
    }

    const DatumPrecedenceAlignmentOperationType::SecondaryAxis_optional& DatumPrecedenceAlignmentOperationType::
    SecondaryAxis () const
    {
      return this->SecondaryAxis_;
    }

    DatumPrecedenceAlignmentOperationType::SecondaryAxis_optional& DatumPrecedenceAlignmentOperationType::
    SecondaryAxis ()
    {
      return this->SecondaryAxis_;
    }

    void DatumPrecedenceAlignmentOperationType::
    SecondaryAxis (const SecondaryAxis_type& x)
    {
      this->SecondaryAxis_.set (x);
    }

    void DatumPrecedenceAlignmentOperationType::
    SecondaryAxis (const SecondaryAxis_optional& x)
    {
      this->SecondaryAxis_ = x;
    }

    void DatumPrecedenceAlignmentOperationType::
    SecondaryAxis (::std::auto_ptr< SecondaryAxis_type > x)
    {
      this->SecondaryAxis_.set (x);
    }


    // BestFitAlignmentOperationType
    // 

    const BestFitAlignmentOperationType::DegreesOfFreedom_type& BestFitAlignmentOperationType::
    DegreesOfFreedom () const
    {
      return this->DegreesOfFreedom_.get ();
    }

    BestFitAlignmentOperationType::DegreesOfFreedom_type& BestFitAlignmentOperationType::
    DegreesOfFreedom ()
    {
      return this->DegreesOfFreedom_.get ();
    }

    void BestFitAlignmentOperationType::
    DegreesOfFreedom (const DegreesOfFreedom_type& x)
    {
      this->DegreesOfFreedom_.set (x);
    }

    void BestFitAlignmentOperationType::
    DegreesOfFreedom (::std::auto_ptr< DegreesOfFreedom_type > x)
    {
      this->DegreesOfFreedom_.set (x);
    }

    const BestFitAlignmentOperationType::BaseFeature_sequence& BestFitAlignmentOperationType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    BestFitAlignmentOperationType::BaseFeature_sequence& BestFitAlignmentOperationType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void BestFitAlignmentOperationType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // MachineCoordinateSystemOperationType
    // 


    // AlignmentOperationsType
    // 

    const AlignmentOperationsType::AlignmentOperation_sequence& AlignmentOperationsType::
    AlignmentOperation () const
    {
      return this->AlignmentOperation_;
    }

    AlignmentOperationsType::AlignmentOperation_sequence& AlignmentOperationsType::
    AlignmentOperation ()
    {
      return this->AlignmentOperation_;
    }

    void AlignmentOperationsType::
    AlignmentOperation (const AlignmentOperation_sequence& s)
    {
      this->AlignmentOperation_ = s;
    }

    const AlignmentOperationsType::BaseCoordinateSystemId_optional& AlignmentOperationsType::
    BaseCoordinateSystemId () const
    {
      return this->BaseCoordinateSystemId_;
    }

    AlignmentOperationsType::BaseCoordinateSystemId_optional& AlignmentOperationsType::
    BaseCoordinateSystemId ()
    {
      return this->BaseCoordinateSystemId_;
    }

    void AlignmentOperationsType::
    BaseCoordinateSystemId (const BaseCoordinateSystemId_type& x)
    {
      this->BaseCoordinateSystemId_.set (x);
    }

    void AlignmentOperationsType::
    BaseCoordinateSystemId (const BaseCoordinateSystemId_optional& x)
    {
      this->BaseCoordinateSystemId_ = x;
    }

    void AlignmentOperationsType::
    BaseCoordinateSystemId (::std::auto_ptr< BaseCoordinateSystemId_type > x)
    {
      this->BaseCoordinateSystemId_.set (x);
    }


    // CoordinateSystemListType
    // 

    const CoordinateSystemListType::CoordinateSystem_sequence& CoordinateSystemListType::
    CoordinateSystem () const
    {
      return this->CoordinateSystem_;
    }

    CoordinateSystemListType::CoordinateSystem_sequence& CoordinateSystemListType::
    CoordinateSystem ()
    {
      return this->CoordinateSystem_;
    }

    void CoordinateSystemListType::
    CoordinateSystem (const CoordinateSystem_sequence& s)
    {
      this->CoordinateSystem_ = s;
    }

    const CoordinateSystemListType::CommonCoordinateSystemId_optional& CoordinateSystemListType::
    CommonCoordinateSystemId () const
    {
      return this->CommonCoordinateSystemId_;
    }

    CoordinateSystemListType::CommonCoordinateSystemId_optional& CoordinateSystemListType::
    CommonCoordinateSystemId ()
    {
      return this->CommonCoordinateSystemId_;
    }

    void CoordinateSystemListType::
    CommonCoordinateSystemId (const CommonCoordinateSystemId_type& x)
    {
      this->CommonCoordinateSystemId_.set (x);
    }

    void CoordinateSystemListType::
    CommonCoordinateSystemId (const CommonCoordinateSystemId_optional& x)
    {
      this->CommonCoordinateSystemId_ = x;
    }

    void CoordinateSystemListType::
    CommonCoordinateSystemId (::std::auto_ptr< CommonCoordinateSystemId_type > x)
    {
      this->CommonCoordinateSystemId_.set (x);
    }

    const CoordinateSystemListType::MachineCoordinateSystemId_optional& CoordinateSystemListType::
    MachineCoordinateSystemId () const
    {
      return this->MachineCoordinateSystemId_;
    }

    CoordinateSystemListType::MachineCoordinateSystemId_optional& CoordinateSystemListType::
    MachineCoordinateSystemId ()
    {
      return this->MachineCoordinateSystemId_;
    }

    void CoordinateSystemListType::
    MachineCoordinateSystemId (const MachineCoordinateSystemId_type& x)
    {
      this->MachineCoordinateSystemId_.set (x);
    }

    void CoordinateSystemListType::
    MachineCoordinateSystemId (const MachineCoordinateSystemId_optional& x)
    {
      this->MachineCoordinateSystemId_ = x;
    }

    void CoordinateSystemListType::
    MachineCoordinateSystemId (::std::auto_ptr< MachineCoordinateSystemId_type > x)
    {
      this->MachineCoordinateSystemId_.set (x);
    }


    // CoordinateSystemType
    // 

    const CoordinateSystemType::Attributes_optional& CoordinateSystemType::
    Attributes () const
    {
      return this->Attributes_;
    }

    CoordinateSystemType::Attributes_optional& CoordinateSystemType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void CoordinateSystemType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void CoordinateSystemType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void CoordinateSystemType::
    Attributes (::std::auto_ptr< Attributes_type > x)
    {
      this->Attributes_.set (x);
    }

    const CoordinateSystemType::Name_optional& CoordinateSystemType::
    Name () const
    {
      return this->Name_;
    }

    CoordinateSystemType::Name_optional& CoordinateSystemType::
    Name ()
    {
      return this->Name_;
    }

    void CoordinateSystemType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void CoordinateSystemType::
    Name (const Name_optional& x)
    {
      this->Name_ = x;
    }

    void CoordinateSystemType::
    Name (::std::auto_ptr< Name_type > x)
    {
      this->Name_.set (x);
    }

    const CoordinateSystemType::NominalTransform_optional& CoordinateSystemType::
    NominalTransform () const
    {
      return this->NominalTransform_;
    }

    CoordinateSystemType::NominalTransform_optional& CoordinateSystemType::
    NominalTransform ()
    {
      return this->NominalTransform_;
    }

    void CoordinateSystemType::
    NominalTransform (const NominalTransform_type& x)
    {
      this->NominalTransform_.set (x);
    }

    void CoordinateSystemType::
    NominalTransform (const NominalTransform_optional& x)
    {
      this->NominalTransform_ = x;
    }

    void CoordinateSystemType::
    NominalTransform (::std::auto_ptr< NominalTransform_type > x)
    {
      this->NominalTransform_.set (x);
    }

    const CoordinateSystemType::InternalCADCoordinateSystemId_optional& CoordinateSystemType::
    InternalCADCoordinateSystemId () const
    {
      return this->InternalCADCoordinateSystemId_;
    }

    CoordinateSystemType::InternalCADCoordinateSystemId_optional& CoordinateSystemType::
    InternalCADCoordinateSystemId ()
    {
      return this->InternalCADCoordinateSystemId_;
    }

    void CoordinateSystemType::
    InternalCADCoordinateSystemId (const InternalCADCoordinateSystemId_type& x)
    {
      this->InternalCADCoordinateSystemId_.set (x);
    }

    void CoordinateSystemType::
    InternalCADCoordinateSystemId (const InternalCADCoordinateSystemId_optional& x)
    {
      this->InternalCADCoordinateSystemId_ = x;
    }

    void CoordinateSystemType::
    InternalCADCoordinateSystemId (::std::auto_ptr< InternalCADCoordinateSystemId_type > x)
    {
      this->InternalCADCoordinateSystemId_.set (x);
    }

    const CoordinateSystemType::ExternalCADCoordinateSystemId_optional& CoordinateSystemType::
    ExternalCADCoordinateSystemId () const
    {
      return this->ExternalCADCoordinateSystemId_;
    }

    CoordinateSystemType::ExternalCADCoordinateSystemId_optional& CoordinateSystemType::
    ExternalCADCoordinateSystemId ()
    {
      return this->ExternalCADCoordinateSystemId_;
    }

    void CoordinateSystemType::
    ExternalCADCoordinateSystemId (const ExternalCADCoordinateSystemId_type& x)
    {
      this->ExternalCADCoordinateSystemId_.set (x);
    }

    void CoordinateSystemType::
    ExternalCADCoordinateSystemId (const ExternalCADCoordinateSystemId_optional& x)
    {
      this->ExternalCADCoordinateSystemId_ = x;
    }

    void CoordinateSystemType::
    ExternalCADCoordinateSystemId (::std::auto_ptr< ExternalCADCoordinateSystemId_type > x)
    {
      this->ExternalCADCoordinateSystemId_.set (x);
    }

    const CoordinateSystemType::AlignmentOperations_optional& CoordinateSystemType::
    AlignmentOperations () const
    {
      return this->AlignmentOperations_;
    }

    CoordinateSystemType::AlignmentOperations_optional& CoordinateSystemType::
    AlignmentOperations ()
    {
      return this->AlignmentOperations_;
    }

    void CoordinateSystemType::
    AlignmentOperations (const AlignmentOperations_type& x)
    {
      this->AlignmentOperations_.set (x);
    }

    void CoordinateSystemType::
    AlignmentOperations (const AlignmentOperations_optional& x)
    {
      this->AlignmentOperations_ = x;
    }

    void CoordinateSystemType::
    AlignmentOperations (::std::auto_ptr< AlignmentOperations_type > x)
    {
      this->AlignmentOperations_.set (x);
    }

    const CoordinateSystemType::SequenceNumber_optional& CoordinateSystemType::
    SequenceNumber () const
    {
      return this->SequenceNumber_;
    }

    CoordinateSystemType::SequenceNumber_optional& CoordinateSystemType::
    SequenceNumber ()
    {
      return this->SequenceNumber_;
    }

    void CoordinateSystemType::
    SequenceNumber (const SequenceNumber_type& x)
    {
      this->SequenceNumber_.set (x);
    }

    void CoordinateSystemType::
    SequenceNumber (const SequenceNumber_optional& x)
    {
      this->SequenceNumber_ = x;
    }

    const CoordinateSystemType::id_type& CoordinateSystemType::
    id () const
    {
      return this->id_.get ();
    }

    CoordinateSystemType::id_type& CoordinateSystemType::
    id ()
    {
      return this->id_.get ();
    }

    void CoordinateSystemType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void CoordinateSystemType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // CoordinateSystemActualTransformType
    // 

    const CoordinateSystemActualTransformType::ActualTransform_type& CoordinateSystemActualTransformType::
    ActualTransform () const
    {
      return this->ActualTransform_.get ();
    }

    CoordinateSystemActualTransformType::ActualTransform_type& CoordinateSystemActualTransformType::
    ActualTransform ()
    {
      return this->ActualTransform_.get ();
    }

    void CoordinateSystemActualTransformType::
    ActualTransform (const ActualTransform_type& x)
    {
      this->ActualTransform_.set (x);
    }

    void CoordinateSystemActualTransformType::
    ActualTransform (::std::auto_ptr< ActualTransform_type > x)
    {
      this->ActualTransform_.set (x);
    }

    const CoordinateSystemActualTransformType::CoordinateSystemId_type& CoordinateSystemActualTransformType::
    CoordinateSystemId () const
    {
      return this->CoordinateSystemId_.get ();
    }

    CoordinateSystemActualTransformType::CoordinateSystemId_type& CoordinateSystemActualTransformType::
    CoordinateSystemId ()
    {
      return this->CoordinateSystemId_.get ();
    }

    void CoordinateSystemActualTransformType::
    CoordinateSystemId (const CoordinateSystemId_type& x)
    {
      this->CoordinateSystemId_.set (x);
    }

    void CoordinateSystemActualTransformType::
    CoordinateSystemId (::std::auto_ptr< CoordinateSystemId_type > x)
    {
      this->CoordinateSystemId_.set (x);
    }


    // CoordinateSystemActualTransformsType
    // 

    const CoordinateSystemActualTransformsType::Transform_sequence& CoordinateSystemActualTransformsType::
    Transform () const
    {
      return this->Transform_;
    }

    CoordinateSystemActualTransformsType::Transform_sequence& CoordinateSystemActualTransformsType::
    Transform ()
    {
      return this->Transform_;
    }

    void CoordinateSystemActualTransformsType::
    Transform (const Transform_sequence& s)
    {
      this->Transform_ = s;
    }


    // ThreadSpecificationDetailedBaseType
    // 

    const ThreadSpecificationDetailedBaseType::Diameter_type& ThreadSpecificationDetailedBaseType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    ThreadSpecificationDetailedBaseType::Diameter_type& ThreadSpecificationDetailedBaseType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void ThreadSpecificationDetailedBaseType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void ThreadSpecificationDetailedBaseType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const ThreadSpecificationDetailedBaseType::ThreadSeries_type& ThreadSpecificationDetailedBaseType::
    ThreadSeries () const
    {
      return this->ThreadSeries_.get ();
    }

    ThreadSpecificationDetailedBaseType::ThreadSeries_type& ThreadSpecificationDetailedBaseType::
    ThreadSeries ()
    {
      return this->ThreadSeries_.get ();
    }

    void ThreadSpecificationDetailedBaseType::
    ThreadSeries (const ThreadSeries_type& x)
    {
      this->ThreadSeries_.set (x);
    }

    void ThreadSpecificationDetailedBaseType::
    ThreadSeries (::std::auto_ptr< ThreadSeries_type > x)
    {
      this->ThreadSeries_.set (x);
    }

    const ThreadSpecificationDetailedBaseType::ThreadToleranceClass_type& ThreadSpecificationDetailedBaseType::
    ThreadToleranceClass () const
    {
      return this->ThreadToleranceClass_.get ();
    }

    ThreadSpecificationDetailedBaseType::ThreadToleranceClass_type& ThreadSpecificationDetailedBaseType::
    ThreadToleranceClass ()
    {
      return this->ThreadToleranceClass_.get ();
    }

    void ThreadSpecificationDetailedBaseType::
    ThreadToleranceClass (const ThreadToleranceClass_type& x)
    {
      this->ThreadToleranceClass_.set (x);
    }

    void ThreadSpecificationDetailedBaseType::
    ThreadToleranceClass (::std::auto_ptr< ThreadToleranceClass_type > x)
    {
      this->ThreadToleranceClass_.set (x);
    }

    const ThreadSpecificationDetailedBaseType::CrestDiameterToleranceClass_optional& ThreadSpecificationDetailedBaseType::
    CrestDiameterToleranceClass () const
    {
      return this->CrestDiameterToleranceClass_;
    }

    ThreadSpecificationDetailedBaseType::CrestDiameterToleranceClass_optional& ThreadSpecificationDetailedBaseType::
    CrestDiameterToleranceClass ()
    {
      return this->CrestDiameterToleranceClass_;
    }

    void ThreadSpecificationDetailedBaseType::
    CrestDiameterToleranceClass (const CrestDiameterToleranceClass_type& x)
    {
      this->CrestDiameterToleranceClass_.set (x);
    }

    void ThreadSpecificationDetailedBaseType::
    CrestDiameterToleranceClass (const CrestDiameterToleranceClass_optional& x)
    {
      this->CrestDiameterToleranceClass_ = x;
    }

    void ThreadSpecificationDetailedBaseType::
    CrestDiameterToleranceClass (::std::auto_ptr< CrestDiameterToleranceClass_type > x)
    {
      this->CrestDiameterToleranceClass_.set (x);
    }

    const ThreadSpecificationDetailedBaseType::LeftHanded_optional& ThreadSpecificationDetailedBaseType::
    LeftHanded () const
    {
      return this->LeftHanded_;
    }

    ThreadSpecificationDetailedBaseType::LeftHanded_optional& ThreadSpecificationDetailedBaseType::
    LeftHanded ()
    {
      return this->LeftHanded_;
    }

    void ThreadSpecificationDetailedBaseType::
    LeftHanded (const LeftHanded_type& x)
    {
      this->LeftHanded_.set (x);
    }

    void ThreadSpecificationDetailedBaseType::
    LeftHanded (const LeftHanded_optional& x)
    {
      this->LeftHanded_ = x;
    }

    const ThreadSpecificationDetailedBaseType::ModifiedThread_optional& ThreadSpecificationDetailedBaseType::
    ModifiedThread () const
    {
      return this->ModifiedThread_;
    }

    ThreadSpecificationDetailedBaseType::ModifiedThread_optional& ThreadSpecificationDetailedBaseType::
    ModifiedThread ()
    {
      return this->ModifiedThread_;
    }

    void ThreadSpecificationDetailedBaseType::
    ModifiedThread (const ModifiedThread_type& x)
    {
      this->ModifiedThread_.set (x);
    }

    void ThreadSpecificationDetailedBaseType::
    ModifiedThread (const ModifiedThread_optional& x)
    {
      this->ModifiedThread_ = x;
    }

    const ThreadSpecificationDetailedBaseType::ThreadLengthEngagement_optional& ThreadSpecificationDetailedBaseType::
    ThreadLengthEngagement () const
    {
      return this->ThreadLengthEngagement_;
    }

    ThreadSpecificationDetailedBaseType::ThreadLengthEngagement_optional& ThreadSpecificationDetailedBaseType::
    ThreadLengthEngagement ()
    {
      return this->ThreadLengthEngagement_;
    }

    void ThreadSpecificationDetailedBaseType::
    ThreadLengthEngagement (const ThreadLengthEngagement_type& x)
    {
      this->ThreadLengthEngagement_.set (x);
    }

    void ThreadSpecificationDetailedBaseType::
    ThreadLengthEngagement (const ThreadLengthEngagement_optional& x)
    {
      this->ThreadLengthEngagement_ = x;
    }

    void ThreadSpecificationDetailedBaseType::
    ThreadLengthEngagement (::std::auto_ptr< ThreadLengthEngagement_type > x)
    {
      this->ThreadLengthEngagement_.set (x);
    }

    const ThreadSpecificationDetailedBaseType::id_type& ThreadSpecificationDetailedBaseType::
    id () const
    {
      return this->id_.get ();
    }

    ThreadSpecificationDetailedBaseType::id_type& ThreadSpecificationDetailedBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void ThreadSpecificationDetailedBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void ThreadSpecificationDetailedBaseType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // SingleLeadThreadSpecificationType
    // 

    const SingleLeadThreadSpecificationType::ThreadDensity_type& SingleLeadThreadSpecificationType::
    ThreadDensity () const
    {
      return this->ThreadDensity_.get ();
    }

    SingleLeadThreadSpecificationType::ThreadDensity_type& SingleLeadThreadSpecificationType::
    ThreadDensity ()
    {
      return this->ThreadDensity_.get ();
    }

    void SingleLeadThreadSpecificationType::
    ThreadDensity (const ThreadDensity_type& x)
    {
      this->ThreadDensity_.set (x);
    }

    void SingleLeadThreadSpecificationType::
    ThreadDensity (::std::auto_ptr< ThreadDensity_type > x)
    {
      this->ThreadDensity_.set (x);
    }


    // MultiLeadThreadSpecificationType
    // 

    const MultiLeadThreadSpecificationType::ThreadPitch_type& MultiLeadThreadSpecificationType::
    ThreadPitch () const
    {
      return this->ThreadPitch_.get ();
    }

    MultiLeadThreadSpecificationType::ThreadPitch_type& MultiLeadThreadSpecificationType::
    ThreadPitch ()
    {
      return this->ThreadPitch_.get ();
    }

    void MultiLeadThreadSpecificationType::
    ThreadPitch (const ThreadPitch_type& x)
    {
      this->ThreadPitch_.set (x);
    }

    void MultiLeadThreadSpecificationType::
    ThreadPitch (::std::auto_ptr< ThreadPitch_type > x)
    {
      this->ThreadPitch_.set (x);
    }

    const MultiLeadThreadSpecificationType::ThreadLeadDistance_type& MultiLeadThreadSpecificationType::
    ThreadLeadDistance () const
    {
      return this->ThreadLeadDistance_.get ();
    }

    MultiLeadThreadSpecificationType::ThreadLeadDistance_type& MultiLeadThreadSpecificationType::
    ThreadLeadDistance ()
    {
      return this->ThreadLeadDistance_.get ();
    }

    void MultiLeadThreadSpecificationType::
    ThreadLeadDistance (const ThreadLeadDistance_type& x)
    {
      this->ThreadLeadDistance_.set (x);
    }

    void MultiLeadThreadSpecificationType::
    ThreadLeadDistance (::std::auto_ptr< ThreadLeadDistance_type > x)
    {
      this->ThreadLeadDistance_.set (x);
    }

    const MultiLeadThreadSpecificationType::ThreadLeadStarts_type& MultiLeadThreadSpecificationType::
    ThreadLeadStarts () const
    {
      return this->ThreadLeadStarts_.get ();
    }

    MultiLeadThreadSpecificationType::ThreadLeadStarts_type& MultiLeadThreadSpecificationType::
    ThreadLeadStarts ()
    {
      return this->ThreadLeadStarts_.get ();
    }

    void MultiLeadThreadSpecificationType::
    ThreadLeadStarts (const ThreadLeadStarts_type& x)
    {
      this->ThreadLeadStarts_.set (x);
    }


    // ThreadSpecificationType
    // 

    const ThreadSpecificationType::SingleLeadSpecification_optional& ThreadSpecificationType::
    SingleLeadSpecification () const
    {
      return this->SingleLeadSpecification_;
    }

    ThreadSpecificationType::SingleLeadSpecification_optional& ThreadSpecificationType::
    SingleLeadSpecification ()
    {
      return this->SingleLeadSpecification_;
    }

    void ThreadSpecificationType::
    SingleLeadSpecification (const SingleLeadSpecification_type& x)
    {
      this->SingleLeadSpecification_.set (x);
    }

    void ThreadSpecificationType::
    SingleLeadSpecification (const SingleLeadSpecification_optional& x)
    {
      this->SingleLeadSpecification_ = x;
    }

    void ThreadSpecificationType::
    SingleLeadSpecification (::std::auto_ptr< SingleLeadSpecification_type > x)
    {
      this->SingleLeadSpecification_.set (x);
    }

    const ThreadSpecificationType::MultiLeadSpecification_optional& ThreadSpecificationType::
    MultiLeadSpecification () const
    {
      return this->MultiLeadSpecification_;
    }

    ThreadSpecificationType::MultiLeadSpecification_optional& ThreadSpecificationType::
    MultiLeadSpecification ()
    {
      return this->MultiLeadSpecification_;
    }

    void ThreadSpecificationType::
    MultiLeadSpecification (const MultiLeadSpecification_type& x)
    {
      this->MultiLeadSpecification_.set (x);
    }

    void ThreadSpecificationType::
    MultiLeadSpecification (const MultiLeadSpecification_optional& x)
    {
      this->MultiLeadSpecification_ = x;
    }

    void ThreadSpecificationType::
    MultiLeadSpecification (::std::auto_ptr< MultiLeadSpecification_type > x)
    {
      this->MultiLeadSpecification_.set (x);
    }

    const ThreadSpecificationType::TextThreadSpecification_optional& ThreadSpecificationType::
    TextThreadSpecification () const
    {
      return this->TextThreadSpecification_;
    }

    ThreadSpecificationType::TextThreadSpecification_optional& ThreadSpecificationType::
    TextThreadSpecification ()
    {
      return this->TextThreadSpecification_;
    }

    void ThreadSpecificationType::
    TextThreadSpecification (const TextThreadSpecification_type& x)
    {
      this->TextThreadSpecification_.set (x);
    }

    void ThreadSpecificationType::
    TextThreadSpecification (const TextThreadSpecification_optional& x)
    {
      this->TextThreadSpecification_ = x;
    }

    void ThreadSpecificationType::
    TextThreadSpecification (::std::auto_ptr< TextThreadSpecification_type > x)
    {
      this->TextThreadSpecification_.set (x);
    }


    // TextThreadSpecificationType
    // 

    const TextThreadSpecificationType::TextSpecification_type& TextThreadSpecificationType::
    TextSpecification () const
    {
      return this->TextSpecification_.get ();
    }

    TextThreadSpecificationType::TextSpecification_type& TextThreadSpecificationType::
    TextSpecification ()
    {
      return this->TextSpecification_.get ();
    }

    void TextThreadSpecificationType::
    TextSpecification (const TextSpecification_type& x)
    {
      this->TextSpecification_.set (x);
    }

    void TextThreadSpecificationType::
    TextSpecification (::std::auto_ptr< TextSpecification_type > x)
    {
      this->TextSpecification_.set (x);
    }

    const TextThreadSpecificationType::id_type& TextThreadSpecificationType::
    id () const
    {
      return this->id_.get ();
    }

    TextThreadSpecificationType::id_type& TextThreadSpecificationType::
    id ()
    {
      return this->id_.get ();
    }

    void TextThreadSpecificationType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void TextThreadSpecificationType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // ThreadSpecificationsType
    // 

    const ThreadSpecificationsType::ThreadSpecification_sequence& ThreadSpecificationsType::
    ThreadSpecification () const
    {
      return this->ThreadSpecification_;
    }

    ThreadSpecificationsType::ThreadSpecification_sequence& ThreadSpecificationsType::
    ThreadSpecification ()
    {
      return this->ThreadSpecification_;
    }

    void ThreadSpecificationsType::
    ThreadSpecification (const ThreadSpecification_sequence& s)
    {
      this->ThreadSpecification_ = s;
    }


    // ToleranceZonePerUnitAreaType
    // 

    const ToleranceZonePerUnitAreaType::ToleranceValuePerUnit_type& ToleranceZonePerUnitAreaType::
    ToleranceValuePerUnit () const
    {
      return this->ToleranceValuePerUnit_.get ();
    }

    ToleranceZonePerUnitAreaType::ToleranceValuePerUnit_type& ToleranceZonePerUnitAreaType::
    ToleranceValuePerUnit ()
    {
      return this->ToleranceValuePerUnit_.get ();
    }

    void ToleranceZonePerUnitAreaType::
    ToleranceValuePerUnit (const ToleranceValuePerUnit_type& x)
    {
      this->ToleranceValuePerUnit_.set (x);
    }

    void ToleranceZonePerUnitAreaType::
    ToleranceValuePerUnit (::std::auto_ptr< ToleranceValuePerUnit_type > x)
    {
      this->ToleranceValuePerUnit_.set (x);
    }

    const ToleranceZonePerUnitAreaType::RectangularUnitArea_optional& ToleranceZonePerUnitAreaType::
    RectangularUnitArea () const
    {
      return this->RectangularUnitArea_;
    }

    ToleranceZonePerUnitAreaType::RectangularUnitArea_optional& ToleranceZonePerUnitAreaType::
    RectangularUnitArea ()
    {
      return this->RectangularUnitArea_;
    }

    void ToleranceZonePerUnitAreaType::
    RectangularUnitArea (const RectangularUnitArea_type& x)
    {
      this->RectangularUnitArea_.set (x);
    }

    void ToleranceZonePerUnitAreaType::
    RectangularUnitArea (const RectangularUnitArea_optional& x)
    {
      this->RectangularUnitArea_ = x;
    }

    void ToleranceZonePerUnitAreaType::
    RectangularUnitArea (::std::auto_ptr< RectangularUnitArea_type > x)
    {
      this->RectangularUnitArea_.set (x);
    }

    const ToleranceZonePerUnitAreaType::CircularUnitArea_optional& ToleranceZonePerUnitAreaType::
    CircularUnitArea () const
    {
      return this->CircularUnitArea_;
    }

    ToleranceZonePerUnitAreaType::CircularUnitArea_optional& ToleranceZonePerUnitAreaType::
    CircularUnitArea ()
    {
      return this->CircularUnitArea_;
    }

    void ToleranceZonePerUnitAreaType::
    CircularUnitArea (const CircularUnitArea_type& x)
    {
      this->CircularUnitArea_.set (x);
    }

    void ToleranceZonePerUnitAreaType::
    CircularUnitArea (const CircularUnitArea_optional& x)
    {
      this->CircularUnitArea_ = x;
    }

    void ToleranceZonePerUnitAreaType::
    CircularUnitArea (::std::auto_ptr< CircularUnitArea_type > x)
    {
      this->CircularUnitArea_.set (x);
    }


    // ToleranceZonePerUnitLengthType
    // 

    const ToleranceZonePerUnitLengthType::ToleranceValuePerUnit_type& ToleranceZonePerUnitLengthType::
    ToleranceValuePerUnit () const
    {
      return this->ToleranceValuePerUnit_.get ();
    }

    ToleranceZonePerUnitLengthType::ToleranceValuePerUnit_type& ToleranceZonePerUnitLengthType::
    ToleranceValuePerUnit ()
    {
      return this->ToleranceValuePerUnit_.get ();
    }

    void ToleranceZonePerUnitLengthType::
    ToleranceValuePerUnit (const ToleranceValuePerUnit_type& x)
    {
      this->ToleranceValuePerUnit_.set (x);
    }

    void ToleranceZonePerUnitLengthType::
    ToleranceValuePerUnit (::std::auto_ptr< ToleranceValuePerUnit_type > x)
    {
      this->ToleranceValuePerUnit_.set (x);
    }

    const ToleranceZonePerUnitLengthType::UnitLength_type& ToleranceZonePerUnitLengthType::
    UnitLength () const
    {
      return this->UnitLength_.get ();
    }

    ToleranceZonePerUnitLengthType::UnitLength_type& ToleranceZonePerUnitLengthType::
    UnitLength ()
    {
      return this->UnitLength_.get ();
    }

    void ToleranceZonePerUnitLengthType::
    UnitLength (const UnitLength_type& x)
    {
      this->UnitLength_.set (x);
    }

    void ToleranceZonePerUnitLengthType::
    UnitLength (::std::auto_ptr< UnitLength_type > x)
    {
      this->UnitLength_.set (x);
    }


    // ToleranceZonePerUnitAngleType
    // 

    const ToleranceZonePerUnitAngleType::ToleranceValuePerUnit_type& ToleranceZonePerUnitAngleType::
    ToleranceValuePerUnit () const
    {
      return this->ToleranceValuePerUnit_.get ();
    }

    ToleranceZonePerUnitAngleType::ToleranceValuePerUnit_type& ToleranceZonePerUnitAngleType::
    ToleranceValuePerUnit ()
    {
      return this->ToleranceValuePerUnit_.get ();
    }

    void ToleranceZonePerUnitAngleType::
    ToleranceValuePerUnit (const ToleranceValuePerUnit_type& x)
    {
      this->ToleranceValuePerUnit_.set (x);
    }

    void ToleranceZonePerUnitAngleType::
    ToleranceValuePerUnit (::std::auto_ptr< ToleranceValuePerUnit_type > x)
    {
      this->ToleranceValuePerUnit_.set (x);
    }

    const ToleranceZonePerUnitAngleType::UnitAngle_type& ToleranceZonePerUnitAngleType::
    UnitAngle () const
    {
      return this->UnitAngle_.get ();
    }

    ToleranceZonePerUnitAngleType::UnitAngle_type& ToleranceZonePerUnitAngleType::
    UnitAngle ()
    {
      return this->UnitAngle_.get ();
    }

    void ToleranceZonePerUnitAngleType::
    UnitAngle (const UnitAngle_type& x)
    {
      this->UnitAngle_.set (x);
    }

    void ToleranceZonePerUnitAngleType::
    UnitAngle (::std::auto_ptr< UnitAngle_type > x)
    {
      this->UnitAngle_.set (x);
    }


    // ToleranceZonePerUnitPolarAreaType
    // 

    const ToleranceZonePerUnitPolarAreaType::ToleranceValuePerUnit_type& ToleranceZonePerUnitPolarAreaType::
    ToleranceValuePerUnit () const
    {
      return this->ToleranceValuePerUnit_.get ();
    }

    ToleranceZonePerUnitPolarAreaType::ToleranceValuePerUnit_type& ToleranceZonePerUnitPolarAreaType::
    ToleranceValuePerUnit ()
    {
      return this->ToleranceValuePerUnit_.get ();
    }

    void ToleranceZonePerUnitPolarAreaType::
    ToleranceValuePerUnit (const ToleranceValuePerUnit_type& x)
    {
      this->ToleranceValuePerUnit_.set (x);
    }

    void ToleranceZonePerUnitPolarAreaType::
    ToleranceValuePerUnit (::std::auto_ptr< ToleranceValuePerUnit_type > x)
    {
      this->ToleranceValuePerUnit_.set (x);
    }

    const ToleranceZonePerUnitPolarAreaType::UnitAngle_type& ToleranceZonePerUnitPolarAreaType::
    UnitAngle () const
    {
      return this->UnitAngle_.get ();
    }

    ToleranceZonePerUnitPolarAreaType::UnitAngle_type& ToleranceZonePerUnitPolarAreaType::
    UnitAngle ()
    {
      return this->UnitAngle_.get ();
    }

    void ToleranceZonePerUnitPolarAreaType::
    UnitAngle (const UnitAngle_type& x)
    {
      this->UnitAngle_.set (x);
    }

    void ToleranceZonePerUnitPolarAreaType::
    UnitAngle (::std::auto_ptr< UnitAngle_type > x)
    {
      this->UnitAngle_.set (x);
    }

    const ToleranceZonePerUnitPolarAreaType::UnitLength_type& ToleranceZonePerUnitPolarAreaType::
    UnitLength () const
    {
      return this->UnitLength_.get ();
    }

    ToleranceZonePerUnitPolarAreaType::UnitLength_type& ToleranceZonePerUnitPolarAreaType::
    UnitLength ()
    {
      return this->UnitLength_.get ();
    }

    void ToleranceZonePerUnitPolarAreaType::
    UnitLength (const UnitLength_type& x)
    {
      this->UnitLength_.set (x);
    }

    void ToleranceZonePerUnitPolarAreaType::
    UnitLength (::std::auto_ptr< UnitLength_type > x)
    {
      this->UnitLength_.set (x);
    }


    // CompoundFeatureGeometryEnumType
    // 

    CompoundFeatureGeometryEnumType::
    CompoundFeatureGeometryEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_CompoundFeatureGeometryEnumType_literals_[v])
    {
    }

    CompoundFeatureGeometryEnumType::
    CompoundFeatureGeometryEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CompoundFeatureGeometryEnumType::
    CompoundFeatureGeometryEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CompoundFeatureGeometryEnumType::
    CompoundFeatureGeometryEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CompoundFeatureGeometryEnumType::
    CompoundFeatureGeometryEnumType (const CompoundFeatureGeometryEnumType& v,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    CompoundFeatureGeometryEnumType& CompoundFeatureGeometryEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_CompoundFeatureGeometryEnumType_literals_[v]);

      return *this;
    }


    // DatumReferenceFramesType
    // 

    const DatumReferenceFramesType::DatumReferenceFrame_sequence& DatumReferenceFramesType::
    DatumReferenceFrame () const
    {
      return this->DatumReferenceFrame_;
    }

    DatumReferenceFramesType::DatumReferenceFrame_sequence& DatumReferenceFramesType::
    DatumReferenceFrame ()
    {
      return this->DatumReferenceFrame_;
    }

    void DatumReferenceFramesType::
    DatumReferenceFrame (const DatumReferenceFrame_sequence& s)
    {
      this->DatumReferenceFrame_ = s;
    }


    // EventBaseType
    // 

    const EventBaseType::Description_type& EventBaseType::
    Description () const
    {
      return this->Description_.get ();
    }

    EventBaseType::Description_type& EventBaseType::
    Description ()
    {
      return this->Description_.get ();
    }

    void EventBaseType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void EventBaseType::
    Description (::std::auto_ptr< Description_type > x)
    {
      this->Description_.set (x);
    }

    const EventBaseType::id_type& EventBaseType::
    id () const
    {
      return this->id_.get ();
    }

    EventBaseType::id_type& EventBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void EventBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void EventBaseType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // NotableEventType
    // 

    const NotableEventType::Active_type& NotableEventType::
    Active () const
    {
      return this->Active_.get ();
    }

    NotableEventType::Active_type& NotableEventType::
    Active ()
    {
      return this->Active_.get ();
    }

    void NotableEventType::
    Active (const Active_type& x)
    {
      this->Active_.set (x);
    }


    // NotableEventsType
    // 

    const NotableEventsType::NotableEvent_sequence& NotableEventsType::
    NotableEvent () const
    {
      return this->NotableEvent_;
    }

    NotableEventsType::NotableEvent_sequence& NotableEventsType::
    NotableEvent ()
    {
      return this->NotableEvent_;
    }

    void NotableEventsType::
    NotableEvent (const NotableEvent_sequence& s)
    {
      this->NotableEvent_ = s;
    }


    // NotedEventType
    // 

    const NotedEventType::SequenceNumber_type& NotedEventType::
    SequenceNumber () const
    {
      return this->SequenceNumber_.get ();
    }

    NotedEventType::SequenceNumber_type& NotedEventType::
    SequenceNumber ()
    {
      return this->SequenceNumber_.get ();
    }

    void NotedEventType::
    SequenceNumber (const SequenceNumber_type& x)
    {
      this->SequenceNumber_.set (x);
    }

    const NotedEventType::TimeOccurred_optional& NotedEventType::
    TimeOccurred () const
    {
      return this->TimeOccurred_;
    }

    NotedEventType::TimeOccurred_optional& NotedEventType::
    TimeOccurred ()
    {
      return this->TimeOccurred_;
    }

    void NotedEventType::
    TimeOccurred (const TimeOccurred_type& x)
    {
      this->TimeOccurred_.set (x);
    }

    void NotedEventType::
    TimeOccurred (const TimeOccurred_optional& x)
    {
      this->TimeOccurred_ = x;
    }

    void NotedEventType::
    TimeOccurred (::std::auto_ptr< TimeOccurred_type > x)
    {
      this->TimeOccurred_.set (x);
    }

    const NotedEventType::NotableEventId_optional& NotedEventType::
    NotableEventId () const
    {
      return this->NotableEventId_;
    }

    NotedEventType::NotableEventId_optional& NotedEventType::
    NotableEventId ()
    {
      return this->NotableEventId_;
    }

    void NotedEventType::
    NotableEventId (const NotableEventId_type& x)
    {
      this->NotableEventId_.set (x);
    }

    void NotedEventType::
    NotableEventId (const NotableEventId_optional& x)
    {
      this->NotableEventId_ = x;
    }

    void NotedEventType::
    NotableEventId (::std::auto_ptr< NotableEventId_type > x)
    {
      this->NotableEventId_.set (x);
    }


    // NotedEventsType
    // 

    const NotedEventsType::NotedEvent_sequence& NotedEventsType::
    NotedEvent () const
    {
      return this->NotedEvent_;
    }

    NotedEventsType::NotedEvent_sequence& NotedEventsType::
    NotedEvent ()
    {
      return this->NotedEvent_;
    }

    void NotedEventsType::
    NotedEvent (const NotedEvent_sequence& s)
    {
      this->NotedEvent_ = s;
    }


    // InspectionStatusEnumType
    // 

    InspectionStatusEnumType::
    InspectionStatusEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_InspectionStatusEnumType_literals_[v])
    {
    }

    InspectionStatusEnumType::
    InspectionStatusEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    InspectionStatusEnumType::
    InspectionStatusEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    InspectionStatusEnumType::
    InspectionStatusEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    InspectionStatusEnumType::
    InspectionStatusEnumType (const InspectionStatusEnumType& v,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    InspectionStatusEnumType& InspectionStatusEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_InspectionStatusEnumType_literals_[v]);

      return *this;
    }


    // InspectionStatusType
    // 

    const InspectionStatusType::InspectionStatusEnum_optional& InspectionStatusType::
    InspectionStatusEnum () const
    {
      return this->InspectionStatusEnum_;
    }

    InspectionStatusType::InspectionStatusEnum_optional& InspectionStatusType::
    InspectionStatusEnum ()
    {
      return this->InspectionStatusEnum_;
    }

    void InspectionStatusType::
    InspectionStatusEnum (const InspectionStatusEnum_type& x)
    {
      this->InspectionStatusEnum_.set (x);
    }

    void InspectionStatusType::
    InspectionStatusEnum (const InspectionStatusEnum_optional& x)
    {
      this->InspectionStatusEnum_ = x;
    }

    void InspectionStatusType::
    InspectionStatusEnum (::std::auto_ptr< InspectionStatusEnum_type > x)
    {
      this->InspectionStatusEnum_.set (x);
    }

    const InspectionStatusType::OtherInspectionStatus_optional& InspectionStatusType::
    OtherInspectionStatus () const
    {
      return this->OtherInspectionStatus_;
    }

    InspectionStatusType::OtherInspectionStatus_optional& InspectionStatusType::
    OtherInspectionStatus ()
    {
      return this->OtherInspectionStatus_;
    }

    void InspectionStatusType::
    OtherInspectionStatus (const OtherInspectionStatus_type& x)
    {
      this->OtherInspectionStatus_.set (x);
    }

    void InspectionStatusType::
    OtherInspectionStatus (const OtherInspectionStatus_optional& x)
    {
      this->OtherInspectionStatus_ = x;
    }

    void InspectionStatusType::
    OtherInspectionStatus (::std::auto_ptr< OtherInspectionStatus_type > x)
    {
      this->OtherInspectionStatus_.set (x);
    }


    // EntityExternalType
    // 

    const EntityExternalType::EntityId_type& EntityExternalType::
    EntityId () const
    {
      return this->EntityId_.get ();
    }

    EntityExternalType::EntityId_type& EntityExternalType::
    EntityId ()
    {
      return this->EntityId_.get ();
    }

    void EntityExternalType::
    EntityId (const EntityId_type& x)
    {
      this->EntityId_.set (x);
    }

    void EntityExternalType::
    EntityId (::std::auto_ptr< EntityId_type > x)
    {
      this->EntityId_.set (x);
    }

    const EntityExternalType::Name_optional& EntityExternalType::
    Name () const
    {
      return this->Name_;
    }

    EntityExternalType::Name_optional& EntityExternalType::
    Name ()
    {
      return this->Name_;
    }

    void EntityExternalType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void EntityExternalType::
    Name (const Name_optional& x)
    {
      this->Name_ = x;
    }

    void EntityExternalType::
    Name (::std::auto_ptr< Name_type > x)
    {
      this->Name_.set (x);
    }

    const EntityExternalType::Description_optional& EntityExternalType::
    Description () const
    {
      return this->Description_;
    }

    EntityExternalType::Description_optional& EntityExternalType::
    Description ()
    {
      return this->Description_;
    }

    void EntityExternalType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void EntityExternalType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void EntityExternalType::
    Description (::std::auto_ptr< Description_type > x)
    {
      this->Description_.set (x);
    }

    const EntityExternalType::id_type& EntityExternalType::
    id () const
    {
      return this->id_.get ();
    }

    EntityExternalType::id_type& EntityExternalType::
    id ()
    {
      return this->id_.get ();
    }

    void EntityExternalType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void EntityExternalType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // EntitiesExternalType
    // 

    const EntitiesExternalType::Entity_sequence& EntitiesExternalType::
    Entity () const
    {
      return this->Entity_;
    }

    EntitiesExternalType::Entity_sequence& EntitiesExternalType::
    Entity ()
    {
      return this->Entity_;
    }

    void EntitiesExternalType::
    Entity (const Entity_sequence& s)
    {
      this->Entity_ = s;
    }


    // ZoneDataType
    // 

    const ZoneDataType::FeatureItemId_type& ZoneDataType::
    FeatureItemId () const
    {
      return this->FeatureItemId_.get ();
    }

    ZoneDataType::FeatureItemId_type& ZoneDataType::
    FeatureItemId ()
    {
      return this->FeatureItemId_.get ();
    }

    void ZoneDataType::
    FeatureItemId (const FeatureItemId_type& x)
    {
      this->FeatureItemId_.set (x);
    }

    void ZoneDataType::
    FeatureItemId (::std::auto_ptr< FeatureItemId_type > x)
    {
      this->FeatureItemId_.set (x);
    }

    const ZoneDataType::Bonus_type& ZoneDataType::
    Bonus () const
    {
      return this->Bonus_.get ();
    }

    ZoneDataType::Bonus_type& ZoneDataType::
    Bonus ()
    {
      return this->Bonus_.get ();
    }

    void ZoneDataType::
    Bonus (const Bonus_type& x)
    {
      this->Bonus_.set (x);
    }

    void ZoneDataType::
    Bonus (::std::auto_ptr< Bonus_type > x)
    {
      this->Bonus_.set (x);
    }

    const ZoneDataType::ReferenceLength_type& ZoneDataType::
    ReferenceLength () const
    {
      return this->ReferenceLength_.get ();
    }

    ZoneDataType::ReferenceLength_type& ZoneDataType::
    ReferenceLength ()
    {
      return this->ReferenceLength_.get ();
    }

    void ZoneDataType::
    ReferenceLength (const ReferenceLength_type& x)
    {
      this->ReferenceLength_.set (x);
    }

    void ZoneDataType::
    ReferenceLength (::std::auto_ptr< ReferenceLength_type > x)
    {
      this->ReferenceLength_.set (x);
    }


    // LinearToleranceType
    // 

    const LinearToleranceType::MaxValue_optional& LinearToleranceType::
    MaxValue () const
    {
      return this->MaxValue_;
    }

    LinearToleranceType::MaxValue_optional& LinearToleranceType::
    MaxValue ()
    {
      return this->MaxValue_;
    }

    void LinearToleranceType::
    MaxValue (const MaxValue_type& x)
    {
      this->MaxValue_.set (x);
    }

    void LinearToleranceType::
    MaxValue (const MaxValue_optional& x)
    {
      this->MaxValue_ = x;
    }

    void LinearToleranceType::
    MaxValue (::std::auto_ptr< MaxValue_type > x)
    {
      this->MaxValue_.set (x);
    }

    const LinearToleranceType::MinValue_optional& LinearToleranceType::
    MinValue () const
    {
      return this->MinValue_;
    }

    LinearToleranceType::MinValue_optional& LinearToleranceType::
    MinValue ()
    {
      return this->MinValue_;
    }

    void LinearToleranceType::
    MinValue (const MinValue_type& x)
    {
      this->MinValue_.set (x);
    }

    void LinearToleranceType::
    MinValue (const MinValue_optional& x)
    {
      this->MinValue_ = x;
    }

    void LinearToleranceType::
    MinValue (::std::auto_ptr< MinValue_type > x)
    {
      this->MinValue_.set (x);
    }

    const LinearToleranceType::DefinitionId_optional& LinearToleranceType::
    DefinitionId () const
    {
      return this->DefinitionId_;
    }

    LinearToleranceType::DefinitionId_optional& LinearToleranceType::
    DefinitionId ()
    {
      return this->DefinitionId_;
    }

    void LinearToleranceType::
    DefinitionId (const DefinitionId_type& x)
    {
      this->DefinitionId_.set (x);
    }

    void LinearToleranceType::
    DefinitionId (const DefinitionId_optional& x)
    {
      this->DefinitionId_ = x;
    }

    void LinearToleranceType::
    DefinitionId (::std::auto_ptr< DefinitionId_type > x)
    {
      this->DefinitionId_.set (x);
    }

    const LinearToleranceType::DefinedAsLimit_type& LinearToleranceType::
    DefinedAsLimit () const
    {
      return this->DefinedAsLimit_.get ();
    }

    LinearToleranceType::DefinedAsLimit_type& LinearToleranceType::
    DefinedAsLimit ()
    {
      return this->DefinedAsLimit_.get ();
    }

    void LinearToleranceType::
    DefinedAsLimit (const DefinedAsLimit_type& x)
    {
      this->DefinedAsLimit_.set (x);
    }


    // LinearToleranceDefinitionType
    // 

    const LinearToleranceDefinitionType::Attributes_optional& LinearToleranceDefinitionType::
    Attributes () const
    {
      return this->Attributes_;
    }

    LinearToleranceDefinitionType::Attributes_optional& LinearToleranceDefinitionType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void LinearToleranceDefinitionType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void LinearToleranceDefinitionType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void LinearToleranceDefinitionType::
    Attributes (::std::auto_ptr< Attributes_type > x)
    {
      this->Attributes_.set (x);
    }

    const LinearToleranceDefinitionType::MaxValue_optional& LinearToleranceDefinitionType::
    MaxValue () const
    {
      return this->MaxValue_;
    }

    LinearToleranceDefinitionType::MaxValue_optional& LinearToleranceDefinitionType::
    MaxValue ()
    {
      return this->MaxValue_;
    }

    void LinearToleranceDefinitionType::
    MaxValue (const MaxValue_type& x)
    {
      this->MaxValue_.set (x);
    }

    void LinearToleranceDefinitionType::
    MaxValue (const MaxValue_optional& x)
    {
      this->MaxValue_ = x;
    }

    void LinearToleranceDefinitionType::
    MaxValue (::std::auto_ptr< MaxValue_type > x)
    {
      this->MaxValue_.set (x);
    }

    const LinearToleranceDefinitionType::MinValue_optional& LinearToleranceDefinitionType::
    MinValue () const
    {
      return this->MinValue_;
    }

    LinearToleranceDefinitionType::MinValue_optional& LinearToleranceDefinitionType::
    MinValue ()
    {
      return this->MinValue_;
    }

    void LinearToleranceDefinitionType::
    MinValue (const MinValue_type& x)
    {
      this->MinValue_.set (x);
    }

    void LinearToleranceDefinitionType::
    MinValue (const MinValue_optional& x)
    {
      this->MinValue_ = x;
    }

    void LinearToleranceDefinitionType::
    MinValue (::std::auto_ptr< MinValue_type > x)
    {
      this->MinValue_.set (x);
    }

    const LinearToleranceDefinitionType::id_type& LinearToleranceDefinitionType::
    id () const
    {
      return this->id_.get ();
    }

    LinearToleranceDefinitionType::id_type& LinearToleranceDefinitionType::
    id ()
    {
      return this->id_.get ();
    }

    void LinearToleranceDefinitionType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void LinearToleranceDefinitionType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // AngularToleranceType
    // 

    const AngularToleranceType::MaxValue_optional& AngularToleranceType::
    MaxValue () const
    {
      return this->MaxValue_;
    }

    AngularToleranceType::MaxValue_optional& AngularToleranceType::
    MaxValue ()
    {
      return this->MaxValue_;
    }

    void AngularToleranceType::
    MaxValue (const MaxValue_type& x)
    {
      this->MaxValue_.set (x);
    }

    void AngularToleranceType::
    MaxValue (const MaxValue_optional& x)
    {
      this->MaxValue_ = x;
    }

    void AngularToleranceType::
    MaxValue (::std::auto_ptr< MaxValue_type > x)
    {
      this->MaxValue_.set (x);
    }

    const AngularToleranceType::MinValue_optional& AngularToleranceType::
    MinValue () const
    {
      return this->MinValue_;
    }

    AngularToleranceType::MinValue_optional& AngularToleranceType::
    MinValue ()
    {
      return this->MinValue_;
    }

    void AngularToleranceType::
    MinValue (const MinValue_type& x)
    {
      this->MinValue_.set (x);
    }

    void AngularToleranceType::
    MinValue (const MinValue_optional& x)
    {
      this->MinValue_ = x;
    }

    void AngularToleranceType::
    MinValue (::std::auto_ptr< MinValue_type > x)
    {
      this->MinValue_.set (x);
    }

    const AngularToleranceType::DefinitionId_optional& AngularToleranceType::
    DefinitionId () const
    {
      return this->DefinitionId_;
    }

    AngularToleranceType::DefinitionId_optional& AngularToleranceType::
    DefinitionId ()
    {
      return this->DefinitionId_;
    }

    void AngularToleranceType::
    DefinitionId (const DefinitionId_type& x)
    {
      this->DefinitionId_.set (x);
    }

    void AngularToleranceType::
    DefinitionId (const DefinitionId_optional& x)
    {
      this->DefinitionId_ = x;
    }

    void AngularToleranceType::
    DefinitionId (::std::auto_ptr< DefinitionId_type > x)
    {
      this->DefinitionId_.set (x);
    }

    const AngularToleranceType::DefinedAsLimit_type& AngularToleranceType::
    DefinedAsLimit () const
    {
      return this->DefinedAsLimit_.get ();
    }

    AngularToleranceType::DefinedAsLimit_type& AngularToleranceType::
    DefinedAsLimit ()
    {
      return this->DefinedAsLimit_.get ();
    }

    void AngularToleranceType::
    DefinedAsLimit (const DefinedAsLimit_type& x)
    {
      this->DefinedAsLimit_.set (x);
    }


    // AngularToleranceDefinitionType
    // 

    const AngularToleranceDefinitionType::Attributes_optional& AngularToleranceDefinitionType::
    Attributes () const
    {
      return this->Attributes_;
    }

    AngularToleranceDefinitionType::Attributes_optional& AngularToleranceDefinitionType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void AngularToleranceDefinitionType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void AngularToleranceDefinitionType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void AngularToleranceDefinitionType::
    Attributes (::std::auto_ptr< Attributes_type > x)
    {
      this->Attributes_.set (x);
    }

    const AngularToleranceDefinitionType::MaxValue_optional& AngularToleranceDefinitionType::
    MaxValue () const
    {
      return this->MaxValue_;
    }

    AngularToleranceDefinitionType::MaxValue_optional& AngularToleranceDefinitionType::
    MaxValue ()
    {
      return this->MaxValue_;
    }

    void AngularToleranceDefinitionType::
    MaxValue (const MaxValue_type& x)
    {
      this->MaxValue_.set (x);
    }

    void AngularToleranceDefinitionType::
    MaxValue (const MaxValue_optional& x)
    {
      this->MaxValue_ = x;
    }

    void AngularToleranceDefinitionType::
    MaxValue (::std::auto_ptr< MaxValue_type > x)
    {
      this->MaxValue_.set (x);
    }

    const AngularToleranceDefinitionType::MinValue_optional& AngularToleranceDefinitionType::
    MinValue () const
    {
      return this->MinValue_;
    }

    AngularToleranceDefinitionType::MinValue_optional& AngularToleranceDefinitionType::
    MinValue ()
    {
      return this->MinValue_;
    }

    void AngularToleranceDefinitionType::
    MinValue (const MinValue_type& x)
    {
      this->MinValue_.set (x);
    }

    void AngularToleranceDefinitionType::
    MinValue (const MinValue_optional& x)
    {
      this->MinValue_ = x;
    }

    void AngularToleranceDefinitionType::
    MinValue (::std::auto_ptr< MinValue_type > x)
    {
      this->MinValue_.set (x);
    }

    const AngularToleranceDefinitionType::id_type& AngularToleranceDefinitionType::
    id () const
    {
      return this->id_.get ();
    }

    AngularToleranceDefinitionType::id_type& AngularToleranceDefinitionType::
    id ()
    {
      return this->id_.get ();
    }

    void AngularToleranceDefinitionType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void AngularToleranceDefinitionType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // TemperatureToleranceType
    // 

    const TemperatureToleranceType::MaxValue_optional& TemperatureToleranceType::
    MaxValue () const
    {
      return this->MaxValue_;
    }

    TemperatureToleranceType::MaxValue_optional& TemperatureToleranceType::
    MaxValue ()
    {
      return this->MaxValue_;
    }

    void TemperatureToleranceType::
    MaxValue (const MaxValue_type& x)
    {
      this->MaxValue_.set (x);
    }

    void TemperatureToleranceType::
    MaxValue (const MaxValue_optional& x)
    {
      this->MaxValue_ = x;
    }

    void TemperatureToleranceType::
    MaxValue (::std::auto_ptr< MaxValue_type > x)
    {
      this->MaxValue_.set (x);
    }

    const TemperatureToleranceType::MinValue_optional& TemperatureToleranceType::
    MinValue () const
    {
      return this->MinValue_;
    }

    TemperatureToleranceType::MinValue_optional& TemperatureToleranceType::
    MinValue ()
    {
      return this->MinValue_;
    }

    void TemperatureToleranceType::
    MinValue (const MinValue_type& x)
    {
      this->MinValue_.set (x);
    }

    void TemperatureToleranceType::
    MinValue (const MinValue_optional& x)
    {
      this->MinValue_ = x;
    }

    void TemperatureToleranceType::
    MinValue (::std::auto_ptr< MinValue_type > x)
    {
      this->MinValue_.set (x);
    }

    const TemperatureToleranceType::DefinedAsLimit_type& TemperatureToleranceType::
    DefinedAsLimit () const
    {
      return this->DefinedAsLimit_.get ();
    }

    TemperatureToleranceType::DefinedAsLimit_type& TemperatureToleranceType::
    DefinedAsLimit ()
    {
      return this->DefinedAsLimit_.get ();
    }

    void TemperatureToleranceType::
    DefinedAsLimit (const DefinedAsLimit_type& x)
    {
      this->DefinedAsLimit_.set (x);
    }


    // AreaToleranceType
    // 

    const AreaToleranceType::MaxValue_optional& AreaToleranceType::
    MaxValue () const
    {
      return this->MaxValue_;
    }

    AreaToleranceType::MaxValue_optional& AreaToleranceType::
    MaxValue ()
    {
      return this->MaxValue_;
    }

    void AreaToleranceType::
    MaxValue (const MaxValue_type& x)
    {
      this->MaxValue_.set (x);
    }

    void AreaToleranceType::
    MaxValue (const MaxValue_optional& x)
    {
      this->MaxValue_ = x;
    }

    void AreaToleranceType::
    MaxValue (::std::auto_ptr< MaxValue_type > x)
    {
      this->MaxValue_.set (x);
    }

    const AreaToleranceType::MinValue_optional& AreaToleranceType::
    MinValue () const
    {
      return this->MinValue_;
    }

    AreaToleranceType::MinValue_optional& AreaToleranceType::
    MinValue ()
    {
      return this->MinValue_;
    }

    void AreaToleranceType::
    MinValue (const MinValue_type& x)
    {
      this->MinValue_.set (x);
    }

    void AreaToleranceType::
    MinValue (const MinValue_optional& x)
    {
      this->MinValue_ = x;
    }

    void AreaToleranceType::
    MinValue (::std::auto_ptr< MinValue_type > x)
    {
      this->MinValue_.set (x);
    }

    const AreaToleranceType::DefinedAsLimit_type& AreaToleranceType::
    DefinedAsLimit () const
    {
      return this->DefinedAsLimit_.get ();
    }

    AreaToleranceType::DefinedAsLimit_type& AreaToleranceType::
    DefinedAsLimit ()
    {
      return this->DefinedAsLimit_.get ();
    }

    void AreaToleranceType::
    DefinedAsLimit (const DefinedAsLimit_type& x)
    {
      this->DefinedAsLimit_.set (x);
    }


    // ForceToleranceType
    // 

    const ForceToleranceType::MaxValue_optional& ForceToleranceType::
    MaxValue () const
    {
      return this->MaxValue_;
    }

    ForceToleranceType::MaxValue_optional& ForceToleranceType::
    MaxValue ()
    {
      return this->MaxValue_;
    }

    void ForceToleranceType::
    MaxValue (const MaxValue_type& x)
    {
      this->MaxValue_.set (x);
    }

    void ForceToleranceType::
    MaxValue (const MaxValue_optional& x)
    {
      this->MaxValue_ = x;
    }

    void ForceToleranceType::
    MaxValue (::std::auto_ptr< MaxValue_type > x)
    {
      this->MaxValue_.set (x);
    }

    const ForceToleranceType::MinValue_optional& ForceToleranceType::
    MinValue () const
    {
      return this->MinValue_;
    }

    ForceToleranceType::MinValue_optional& ForceToleranceType::
    MinValue ()
    {
      return this->MinValue_;
    }

    void ForceToleranceType::
    MinValue (const MinValue_type& x)
    {
      this->MinValue_.set (x);
    }

    void ForceToleranceType::
    MinValue (const MinValue_optional& x)
    {
      this->MinValue_ = x;
    }

    void ForceToleranceType::
    MinValue (::std::auto_ptr< MinValue_type > x)
    {
      this->MinValue_.set (x);
    }

    const ForceToleranceType::DefinedAsLimit_type& ForceToleranceType::
    DefinedAsLimit () const
    {
      return this->DefinedAsLimit_.get ();
    }

    ForceToleranceType::DefinedAsLimit_type& ForceToleranceType::
    DefinedAsLimit ()
    {
      return this->DefinedAsLimit_.get ();
    }

    void ForceToleranceType::
    DefinedAsLimit (const DefinedAsLimit_type& x)
    {
      this->DefinedAsLimit_.set (x);
    }


    // MassToleranceType
    // 

    const MassToleranceType::MaxValue_optional& MassToleranceType::
    MaxValue () const
    {
      return this->MaxValue_;
    }

    MassToleranceType::MaxValue_optional& MassToleranceType::
    MaxValue ()
    {
      return this->MaxValue_;
    }

    void MassToleranceType::
    MaxValue (const MaxValue_type& x)
    {
      this->MaxValue_.set (x);
    }

    void MassToleranceType::
    MaxValue (const MaxValue_optional& x)
    {
      this->MaxValue_ = x;
    }

    void MassToleranceType::
    MaxValue (::std::auto_ptr< MaxValue_type > x)
    {
      this->MaxValue_.set (x);
    }

    const MassToleranceType::MinValue_optional& MassToleranceType::
    MinValue () const
    {
      return this->MinValue_;
    }

    MassToleranceType::MinValue_optional& MassToleranceType::
    MinValue ()
    {
      return this->MinValue_;
    }

    void MassToleranceType::
    MinValue (const MinValue_type& x)
    {
      this->MinValue_.set (x);
    }

    void MassToleranceType::
    MinValue (const MinValue_optional& x)
    {
      this->MinValue_ = x;
    }

    void MassToleranceType::
    MinValue (::std::auto_ptr< MinValue_type > x)
    {
      this->MinValue_.set (x);
    }

    const MassToleranceType::DefinedAsLimit_type& MassToleranceType::
    DefinedAsLimit () const
    {
      return this->DefinedAsLimit_.get ();
    }

    MassToleranceType::DefinedAsLimit_type& MassToleranceType::
    DefinedAsLimit ()
    {
      return this->DefinedAsLimit_.get ();
    }

    void MassToleranceType::
    DefinedAsLimit (const DefinedAsLimit_type& x)
    {
      this->DefinedAsLimit_.set (x);
    }


    // PressureToleranceType
    // 

    const PressureToleranceType::MaxValue_optional& PressureToleranceType::
    MaxValue () const
    {
      return this->MaxValue_;
    }

    PressureToleranceType::MaxValue_optional& PressureToleranceType::
    MaxValue ()
    {
      return this->MaxValue_;
    }

    void PressureToleranceType::
    MaxValue (const MaxValue_type& x)
    {
      this->MaxValue_.set (x);
    }

    void PressureToleranceType::
    MaxValue (const MaxValue_optional& x)
    {
      this->MaxValue_ = x;
    }

    void PressureToleranceType::
    MaxValue (::std::auto_ptr< MaxValue_type > x)
    {
      this->MaxValue_.set (x);
    }

    const PressureToleranceType::MinValue_optional& PressureToleranceType::
    MinValue () const
    {
      return this->MinValue_;
    }

    PressureToleranceType::MinValue_optional& PressureToleranceType::
    MinValue ()
    {
      return this->MinValue_;
    }

    void PressureToleranceType::
    MinValue (const MinValue_type& x)
    {
      this->MinValue_.set (x);
    }

    void PressureToleranceType::
    MinValue (const MinValue_optional& x)
    {
      this->MinValue_ = x;
    }

    void PressureToleranceType::
    MinValue (::std::auto_ptr< MinValue_type > x)
    {
      this->MinValue_.set (x);
    }

    const PressureToleranceType::DefinedAsLimit_type& PressureToleranceType::
    DefinedAsLimit () const
    {
      return this->DefinedAsLimit_.get ();
    }

    PressureToleranceType::DefinedAsLimit_type& PressureToleranceType::
    DefinedAsLimit ()
    {
      return this->DefinedAsLimit_.get ();
    }

    void PressureToleranceType::
    DefinedAsLimit (const DefinedAsLimit_type& x)
    {
      this->DefinedAsLimit_.set (x);
    }


    // SpeedToleranceType
    // 

    const SpeedToleranceType::MaxValue_optional& SpeedToleranceType::
    MaxValue () const
    {
      return this->MaxValue_;
    }

    SpeedToleranceType::MaxValue_optional& SpeedToleranceType::
    MaxValue ()
    {
      return this->MaxValue_;
    }

    void SpeedToleranceType::
    MaxValue (const MaxValue_type& x)
    {
      this->MaxValue_.set (x);
    }

    void SpeedToleranceType::
    MaxValue (const MaxValue_optional& x)
    {
      this->MaxValue_ = x;
    }

    void SpeedToleranceType::
    MaxValue (::std::auto_ptr< MaxValue_type > x)
    {
      this->MaxValue_.set (x);
    }

    const SpeedToleranceType::MinValue_optional& SpeedToleranceType::
    MinValue () const
    {
      return this->MinValue_;
    }

    SpeedToleranceType::MinValue_optional& SpeedToleranceType::
    MinValue ()
    {
      return this->MinValue_;
    }

    void SpeedToleranceType::
    MinValue (const MinValue_type& x)
    {
      this->MinValue_.set (x);
    }

    void SpeedToleranceType::
    MinValue (const MinValue_optional& x)
    {
      this->MinValue_ = x;
    }

    void SpeedToleranceType::
    MinValue (::std::auto_ptr< MinValue_type > x)
    {
      this->MinValue_.set (x);
    }

    const SpeedToleranceType::DefinedAsLimit_type& SpeedToleranceType::
    DefinedAsLimit () const
    {
      return this->DefinedAsLimit_.get ();
    }

    SpeedToleranceType::DefinedAsLimit_type& SpeedToleranceType::
    DefinedAsLimit ()
    {
      return this->DefinedAsLimit_.get ();
    }

    void SpeedToleranceType::
    DefinedAsLimit (const DefinedAsLimit_type& x)
    {
      this->DefinedAsLimit_.set (x);
    }


    // TimeToleranceType
    // 

    const TimeToleranceType::MaxValue_optional& TimeToleranceType::
    MaxValue () const
    {
      return this->MaxValue_;
    }

    TimeToleranceType::MaxValue_optional& TimeToleranceType::
    MaxValue ()
    {
      return this->MaxValue_;
    }

    void TimeToleranceType::
    MaxValue (const MaxValue_type& x)
    {
      this->MaxValue_.set (x);
    }

    void TimeToleranceType::
    MaxValue (const MaxValue_optional& x)
    {
      this->MaxValue_ = x;
    }

    void TimeToleranceType::
    MaxValue (::std::auto_ptr< MaxValue_type > x)
    {
      this->MaxValue_.set (x);
    }

    const TimeToleranceType::MinValue_optional& TimeToleranceType::
    MinValue () const
    {
      return this->MinValue_;
    }

    TimeToleranceType::MinValue_optional& TimeToleranceType::
    MinValue ()
    {
      return this->MinValue_;
    }

    void TimeToleranceType::
    MinValue (const MinValue_type& x)
    {
      this->MinValue_.set (x);
    }

    void TimeToleranceType::
    MinValue (const MinValue_optional& x)
    {
      this->MinValue_ = x;
    }

    void TimeToleranceType::
    MinValue (::std::auto_ptr< MinValue_type > x)
    {
      this->MinValue_.set (x);
    }

    const TimeToleranceType::DefinedAsLimit_type& TimeToleranceType::
    DefinedAsLimit () const
    {
      return this->DefinedAsLimit_.get ();
    }

    TimeToleranceType::DefinedAsLimit_type& TimeToleranceType::
    DefinedAsLimit ()
    {
      return this->DefinedAsLimit_.get ();
    }

    void TimeToleranceType::
    DefinedAsLimit (const DefinedAsLimit_type& x)
    {
      this->DefinedAsLimit_.set (x);
    }


    // DimensionModifierEnumType
    // 

    DimensionModifierEnumType::
    DimensionModifierEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_DimensionModifierEnumType_literals_[v])
    {
    }

    DimensionModifierEnumType::
    DimensionModifierEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DimensionModifierEnumType::
    DimensionModifierEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DimensionModifierEnumType::
    DimensionModifierEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    DimensionModifierEnumType::
    DimensionModifierEnumType (const DimensionModifierEnumType& v,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    DimensionModifierEnumType& DimensionModifierEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_DimensionModifierEnumType_literals_[v]);

      return *this;
    }


    // NonToleranceEnumType
    // 

    NonToleranceEnumType::
    NonToleranceEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_NonToleranceEnumType_literals_[v])
    {
    }

    NonToleranceEnumType::
    NonToleranceEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    NonToleranceEnumType::
    NonToleranceEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    NonToleranceEnumType::
    NonToleranceEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    NonToleranceEnumType::
    NonToleranceEnumType (const NonToleranceEnumType& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    NonToleranceEnumType& NonToleranceEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_NonToleranceEnumType_literals_[v]);

      return *this;
    }


    // CommonFileSpecEnumType
    // 

    CommonFileSpecEnumType::
    CommonFileSpecEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_CommonFileSpecEnumType_literals_[v])
    {
    }

    CommonFileSpecEnumType::
    CommonFileSpecEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CommonFileSpecEnumType::
    CommonFileSpecEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CommonFileSpecEnumType::
    CommonFileSpecEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CommonFileSpecEnumType::
    CommonFileSpecEnumType (const CommonFileSpecEnumType& v,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    CommonFileSpecEnumType& CommonFileSpecEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_CommonFileSpecEnumType_literals_[v]);

      return *this;
    }


    // FileSpecType
    // 

    const FileSpecType::CommonFileSpecEnum_optional& FileSpecType::
    CommonFileSpecEnum () const
    {
      return this->CommonFileSpecEnum_;
    }

    FileSpecType::CommonFileSpecEnum_optional& FileSpecType::
    CommonFileSpecEnum ()
    {
      return this->CommonFileSpecEnum_;
    }

    void FileSpecType::
    CommonFileSpecEnum (const CommonFileSpecEnum_type& x)
    {
      this->CommonFileSpecEnum_.set (x);
    }

    void FileSpecType::
    CommonFileSpecEnum (const CommonFileSpecEnum_optional& x)
    {
      this->CommonFileSpecEnum_ = x;
    }

    void FileSpecType::
    CommonFileSpecEnum (::std::auto_ptr< CommonFileSpecEnum_type > x)
    {
      this->CommonFileSpecEnum_.set (x);
    }

    const FileSpecType::OtherFileSpec_optional& FileSpecType::
    OtherFileSpec () const
    {
      return this->OtherFileSpec_;
    }

    FileSpecType::OtherFileSpec_optional& FileSpecType::
    OtherFileSpec ()
    {
      return this->OtherFileSpec_;
    }

    void FileSpecType::
    OtherFileSpec (const OtherFileSpec_type& x)
    {
      this->OtherFileSpec_.set (x);
    }

    void FileSpecType::
    OtherFileSpec (const OtherFileSpec_optional& x)
    {
      this->OtherFileSpec_ = x;
    }

    void FileSpecType::
    OtherFileSpec (::std::auto_ptr< OtherFileSpec_type > x)
    {
      this->OtherFileSpec_.set (x);
    }


    // ExternalFileReferenceType
    // 

    const ExternalFileReferenceType::URI_type& ExternalFileReferenceType::
    URI () const
    {
      return this->URI_.get ();
    }

    ExternalFileReferenceType::URI_type& ExternalFileReferenceType::
    URI ()
    {
      return this->URI_.get ();
    }

    void ExternalFileReferenceType::
    URI (const URI_type& x)
    {
      this->URI_.set (x);
    }

    void ExternalFileReferenceType::
    URI (::std::auto_ptr< URI_type > x)
    {
      this->URI_.set (x);
    }

    const ExternalFileReferenceType::FileSpec_type& ExternalFileReferenceType::
    FileSpec () const
    {
      return this->FileSpec_.get ();
    }

    ExternalFileReferenceType::FileSpec_type& ExternalFileReferenceType::
    FileSpec ()
    {
      return this->FileSpec_.get ();
    }

    void ExternalFileReferenceType::
    FileSpec (const FileSpec_type& x)
    {
      this->FileSpec_.set (x);
    }

    void ExternalFileReferenceType::
    FileSpec (::std::auto_ptr< FileSpec_type > x)
    {
      this->FileSpec_.set (x);
    }

    const ExternalFileReferenceType::Description_type& ExternalFileReferenceType::
    Description () const
    {
      return this->Description_.get ();
    }

    ExternalFileReferenceType::Description_type& ExternalFileReferenceType::
    Description ()
    {
      return this->Description_.get ();
    }

    void ExternalFileReferenceType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void ExternalFileReferenceType::
    Description (::std::auto_ptr< Description_type > x)
    {
      this->Description_.set (x);
    }


    // DatumTargetDefinitionsType
    // 

    const DatumTargetDefinitionsType::DatumTarget_sequence& DatumTargetDefinitionsType::
    DatumTarget () const
    {
      return this->DatumTarget_;
    }

    DatumTargetDefinitionsType::DatumTarget_sequence& DatumTargetDefinitionsType::
    DatumTarget ()
    {
      return this->DatumTarget_;
    }

    void DatumTargetDefinitionsType::
    DatumTarget (const DatumTarget_sequence& s)
    {
      this->DatumTarget_ = s;
    }

    const DatumTargetDefinitionsType::N_type& DatumTargetDefinitionsType::
    N () const
    {
      return this->N_.get ();
    }

    DatumTargetDefinitionsType::N_type& DatumTargetDefinitionsType::
    N ()
    {
      return this->N_.get ();
    }

    void DatumTargetDefinitionsType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void DatumTargetDefinitionsType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // DatumDefinitionType
    // 

    const DatumDefinitionType::Attributes_optional& DatumDefinitionType::
    Attributes () const
    {
      return this->Attributes_;
    }

    DatumDefinitionType::Attributes_optional& DatumDefinitionType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void DatumDefinitionType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void DatumDefinitionType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void DatumDefinitionType::
    Attributes (::std::auto_ptr< Attributes_type > x)
    {
      this->Attributes_.set (x);
    }

    const DatumDefinitionType::DatumLabel_type& DatumDefinitionType::
    DatumLabel () const
    {
      return this->DatumLabel_.get ();
    }

    DatumDefinitionType::DatumLabel_type& DatumDefinitionType::
    DatumLabel ()
    {
      return this->DatumLabel_.get ();
    }

    void DatumDefinitionType::
    DatumLabel (const DatumLabel_type& x)
    {
      this->DatumLabel_.set (x);
    }

    void DatumDefinitionType::
    DatumLabel (::std::auto_ptr< DatumLabel_type > x)
    {
      this->DatumLabel_.set (x);
    }

    const DatumDefinitionType::DatumTargetIds_optional& DatumDefinitionType::
    DatumTargetIds () const
    {
      return this->DatumTargetIds_;
    }

    DatumDefinitionType::DatumTargetIds_optional& DatumDefinitionType::
    DatumTargetIds ()
    {
      return this->DatumTargetIds_;
    }

    void DatumDefinitionType::
    DatumTargetIds (const DatumTargetIds_type& x)
    {
      this->DatumTargetIds_.set (x);
    }

    void DatumDefinitionType::
    DatumTargetIds (const DatumTargetIds_optional& x)
    {
      this->DatumTargetIds_ = x;
    }

    void DatumDefinitionType::
    DatumTargetIds (::std::auto_ptr< DatumTargetIds_type > x)
    {
      this->DatumTargetIds_.set (x);
    }

    const DatumDefinitionType::FeatureNominalIds_optional& DatumDefinitionType::
    FeatureNominalIds () const
    {
      return this->FeatureNominalIds_;
    }

    DatumDefinitionType::FeatureNominalIds_optional& DatumDefinitionType::
    FeatureNominalIds ()
    {
      return this->FeatureNominalIds_;
    }

    void DatumDefinitionType::
    FeatureNominalIds (const FeatureNominalIds_type& x)
    {
      this->FeatureNominalIds_.set (x);
    }

    void DatumDefinitionType::
    FeatureNominalIds (const FeatureNominalIds_optional& x)
    {
      this->FeatureNominalIds_ = x;
    }

    void DatumDefinitionType::
    FeatureNominalIds (::std::auto_ptr< FeatureNominalIds_type > x)
    {
      this->FeatureNominalIds_.set (x);
    }

    const DatumDefinitionType::id_type& DatumDefinitionType::
    id () const
    {
      return this->id_.get ();
    }

    DatumDefinitionType::id_type& DatumDefinitionType::
    id ()
    {
      return this->id_.get ();
    }

    void DatumDefinitionType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void DatumDefinitionType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // DatumDefinitionsType
    // 

    const DatumDefinitionsType::DatumDefinition_sequence& DatumDefinitionsType::
    DatumDefinition () const
    {
      return this->DatumDefinition_;
    }

    DatumDefinitionsType::DatumDefinition_sequence& DatumDefinitionsType::
    DatumDefinition ()
    {
      return this->DatumDefinition_;
    }

    void DatumDefinitionsType::
    DatumDefinition (const DatumDefinition_sequence& s)
    {
      this->DatumDefinition_ = s;
    }


    // DatumTargetDefinitionBaseType
    // 

    const DatumTargetDefinitionBaseType::Attributes_optional& DatumTargetDefinitionBaseType::
    Attributes () const
    {
      return this->Attributes_;
    }

    DatumTargetDefinitionBaseType::Attributes_optional& DatumTargetDefinitionBaseType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void DatumTargetDefinitionBaseType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void DatumTargetDefinitionBaseType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void DatumTargetDefinitionBaseType::
    Attributes (::std::auto_ptr< Attributes_type > x)
    {
      this->Attributes_.set (x);
    }

    const DatumTargetDefinitionBaseType::DatumTargetLabel_type& DatumTargetDefinitionBaseType::
    DatumTargetLabel () const
    {
      return this->DatumTargetLabel_.get ();
    }

    DatumTargetDefinitionBaseType::DatumTargetLabel_type& DatumTargetDefinitionBaseType::
    DatumTargetLabel ()
    {
      return this->DatumTargetLabel_.get ();
    }

    void DatumTargetDefinitionBaseType::
    DatumTargetLabel (const DatumTargetLabel_type& x)
    {
      this->DatumTargetLabel_.set (x);
    }

    void DatumTargetDefinitionBaseType::
    DatumTargetLabel (::std::auto_ptr< DatumTargetLabel_type > x)
    {
      this->DatumTargetLabel_.set (x);
    }

    const DatumTargetDefinitionBaseType::FeatureNominalId_optional& DatumTargetDefinitionBaseType::
    FeatureNominalId () const
    {
      return this->FeatureNominalId_;
    }

    DatumTargetDefinitionBaseType::FeatureNominalId_optional& DatumTargetDefinitionBaseType::
    FeatureNominalId ()
    {
      return this->FeatureNominalId_;
    }

    void DatumTargetDefinitionBaseType::
    FeatureNominalId (const FeatureNominalId_type& x)
    {
      this->FeatureNominalId_.set (x);
    }

    void DatumTargetDefinitionBaseType::
    FeatureNominalId (const FeatureNominalId_optional& x)
    {
      this->FeatureNominalId_ = x;
    }

    void DatumTargetDefinitionBaseType::
    FeatureNominalId (::std::auto_ptr< FeatureNominalId_type > x)
    {
      this->FeatureNominalId_.set (x);
    }

    const DatumTargetDefinitionBaseType::MovableDatumTarget_optional& DatumTargetDefinitionBaseType::
    MovableDatumTarget () const
    {
      return this->MovableDatumTarget_;
    }

    DatumTargetDefinitionBaseType::MovableDatumTarget_optional& DatumTargetDefinitionBaseType::
    MovableDatumTarget ()
    {
      return this->MovableDatumTarget_;
    }

    void DatumTargetDefinitionBaseType::
    MovableDatumTarget (const MovableDatumTarget_type& x)
    {
      this->MovableDatumTarget_.set (x);
    }

    void DatumTargetDefinitionBaseType::
    MovableDatumTarget (const MovableDatumTarget_optional& x)
    {
      this->MovableDatumTarget_ = x;
    }

    void DatumTargetDefinitionBaseType::
    MovableDatumTarget (::std::auto_ptr< MovableDatumTarget_type > x)
    {
      this->MovableDatumTarget_.set (x);
    }

    const DatumTargetDefinitionBaseType::id_type& DatumTargetDefinitionBaseType::
    id () const
    {
      return this->id_.get ();
    }

    DatumTargetDefinitionBaseType::id_type& DatumTargetDefinitionBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void DatumTargetDefinitionBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void DatumTargetDefinitionBaseType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // DatumTargetPointDefinitionType
    // 

    const DatumTargetPointDefinitionType::Point_type& DatumTargetPointDefinitionType::
    Point () const
    {
      return this->Point_.get ();
    }

    DatumTargetPointDefinitionType::Point_type& DatumTargetPointDefinitionType::
    Point ()
    {
      return this->Point_.get ();
    }

    void DatumTargetPointDefinitionType::
    Point (const Point_type& x)
    {
      this->Point_.set (x);
    }

    void DatumTargetPointDefinitionType::
    Point (::std::auto_ptr< Point_type > x)
    {
      this->Point_.set (x);
    }


    // DatumTargetLineDefinitionType
    // 

    const DatumTargetLineDefinitionType::Line_type& DatumTargetLineDefinitionType::
    Line () const
    {
      return this->Line_.get ();
    }

    DatumTargetLineDefinitionType::Line_type& DatumTargetLineDefinitionType::
    Line ()
    {
      return this->Line_.get ();
    }

    void DatumTargetLineDefinitionType::
    Line (const Line_type& x)
    {
      this->Line_.set (x);
    }

    void DatumTargetLineDefinitionType::
    Line (::std::auto_ptr< Line_type > x)
    {
      this->Line_.set (x);
    }


    // DatumTargetCircularAreaDefinitionType
    // 

    const DatumTargetCircularAreaDefinitionType::Circle_type& DatumTargetCircularAreaDefinitionType::
    Circle () const
    {
      return this->Circle_.get ();
    }

    DatumTargetCircularAreaDefinitionType::Circle_type& DatumTargetCircularAreaDefinitionType::
    Circle ()
    {
      return this->Circle_.get ();
    }

    void DatumTargetCircularAreaDefinitionType::
    Circle (const Circle_type& x)
    {
      this->Circle_.set (x);
    }

    void DatumTargetCircularAreaDefinitionType::
    Circle (::std::auto_ptr< Circle_type > x)
    {
      this->Circle_.set (x);
    }


    // DatumTargetCircularLineDefinitionType
    // 

    const DatumTargetCircularLineDefinitionType::Circle_type& DatumTargetCircularLineDefinitionType::
    Circle () const
    {
      return this->Circle_.get ();
    }

    DatumTargetCircularLineDefinitionType::Circle_type& DatumTargetCircularLineDefinitionType::
    Circle ()
    {
      return this->Circle_.get ();
    }

    void DatumTargetCircularLineDefinitionType::
    Circle (const Circle_type& x)
    {
      this->Circle_.set (x);
    }

    void DatumTargetCircularLineDefinitionType::
    Circle (::std::auto_ptr< Circle_type > x)
    {
      this->Circle_.set (x);
    }


    // DatumTargetCylindricalAreaDefinitionType
    // 

    const DatumTargetCylindricalAreaDefinitionType::Cylinder_type& DatumTargetCylindricalAreaDefinitionType::
    Cylinder () const
    {
      return this->Cylinder_.get ();
    }

    DatumTargetCylindricalAreaDefinitionType::Cylinder_type& DatumTargetCylindricalAreaDefinitionType::
    Cylinder ()
    {
      return this->Cylinder_.get ();
    }

    void DatumTargetCylindricalAreaDefinitionType::
    Cylinder (const Cylinder_type& x)
    {
      this->Cylinder_.set (x);
    }

    void DatumTargetCylindricalAreaDefinitionType::
    Cylinder (::std::auto_ptr< Cylinder_type > x)
    {
      this->Cylinder_.set (x);
    }


    // DatumTargetRectangularAreaDefinitionType
    // 

    const DatumTargetRectangularAreaDefinitionType::Rectangle_type& DatumTargetRectangularAreaDefinitionType::
    Rectangle () const
    {
      return this->Rectangle_.get ();
    }

    DatumTargetRectangularAreaDefinitionType::Rectangle_type& DatumTargetRectangularAreaDefinitionType::
    Rectangle ()
    {
      return this->Rectangle_.get ();
    }

    void DatumTargetRectangularAreaDefinitionType::
    Rectangle (const Rectangle_type& x)
    {
      this->Rectangle_.set (x);
    }

    void DatumTargetRectangularAreaDefinitionType::
    Rectangle (::std::auto_ptr< Rectangle_type > x)
    {
      this->Rectangle_.set (x);
    }


    // DatumTargetSphereDefinitionType
    // 

    const DatumTargetSphereDefinitionType::Sphere_type& DatumTargetSphereDefinitionType::
    Sphere () const
    {
      return this->Sphere_.get ();
    }

    DatumTargetSphereDefinitionType::Sphere_type& DatumTargetSphereDefinitionType::
    Sphere ()
    {
      return this->Sphere_.get ();
    }

    void DatumTargetSphereDefinitionType::
    Sphere (const Sphere_type& x)
    {
      this->Sphere_.set (x);
    }

    void DatumTargetSphereDefinitionType::
    Sphere (::std::auto_ptr< Sphere_type > x)
    {
      this->Sphere_.set (x);
    }


    // DatumTargetIrregularAreaDefinitionType
    // 

    const DatumTargetIrregularAreaDefinitionType::Boundary_type& DatumTargetIrregularAreaDefinitionType::
    Boundary () const
    {
      return this->Boundary_.get ();
    }

    DatumTargetIrregularAreaDefinitionType::Boundary_type& DatumTargetIrregularAreaDefinitionType::
    Boundary ()
    {
      return this->Boundary_.get ();
    }

    void DatumTargetIrregularAreaDefinitionType::
    Boundary (const Boundary_type& x)
    {
      this->Boundary_.set (x);
    }

    void DatumTargetIrregularAreaDefinitionType::
    Boundary (::std::auto_ptr< Boundary_type > x)
    {
      this->Boundary_.set (x);
    }


    // EmployeeType
    // 

    const EmployeeType::Name_type& EmployeeType::
    Name () const
    {
      return this->Name_.get ();
    }

    EmployeeType::Name_type& EmployeeType::
    Name ()
    {
      return this->Name_.get ();
    }

    void EmployeeType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void EmployeeType::
    Name (::std::auto_ptr< Name_type > x)
    {
      this->Name_.set (x);
    }

    const EmployeeType::EmployeeId_optional& EmployeeType::
    EmployeeId () const
    {
      return this->EmployeeId_;
    }

    EmployeeType::EmployeeId_optional& EmployeeType::
    EmployeeId ()
    {
      return this->EmployeeId_;
    }

    void EmployeeType::
    EmployeeId (const EmployeeId_type& x)
    {
      this->EmployeeId_.set (x);
    }

    void EmployeeType::
    EmployeeId (const EmployeeId_optional& x)
    {
      this->EmployeeId_ = x;
    }

    void EmployeeType::
    EmployeeId (::std::auto_ptr< EmployeeId_type > x)
    {
      this->EmployeeId_.set (x);
    }

    const EmployeeType::Shift_optional& EmployeeType::
    Shift () const
    {
      return this->Shift_;
    }

    EmployeeType::Shift_optional& EmployeeType::
    Shift ()
    {
      return this->Shift_;
    }

    void EmployeeType::
    Shift (const Shift_type& x)
    {
      this->Shift_.set (x);
    }

    void EmployeeType::
    Shift (const Shift_optional& x)
    {
      this->Shift_ = x;
    }

    void EmployeeType::
    Shift (::std::auto_ptr< Shift_type > x)
    {
      this->Shift_.set (x);
    }


    // FileType
    // 

    const FileType::Name_type& FileType::
    Name () const
    {
      return this->Name_.get ();
    }

    FileType::Name_type& FileType::
    Name ()
    {
      return this->Name_.get ();
    }

    void FileType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void FileType::
    Name (::std::auto_ptr< Name_type > x)
    {
      this->Name_.set (x);
    }

    const FileType::Version_optional& FileType::
    Version () const
    {
      return this->Version_;
    }

    FileType::Version_optional& FileType::
    Version ()
    {
      return this->Version_;
    }

    void FileType::
    Version (const Version_type& x)
    {
      this->Version_.set (x);
    }

    void FileType::
    Version (const Version_optional& x)
    {
      this->Version_ = x;
    }

    void FileType::
    Version (::std::auto_ptr< Version_type > x)
    {
      this->Version_.set (x);
    }

    const FileType::Format_optional& FileType::
    Format () const
    {
      return this->Format_;
    }

    FileType::Format_optional& FileType::
    Format ()
    {
      return this->Format_;
    }

    void FileType::
    Format (const Format_type& x)
    {
      this->Format_.set (x);
    }

    void FileType::
    Format (const Format_optional& x)
    {
      this->Format_ = x;
    }

    void FileType::
    Format (::std::auto_ptr< Format_type > x)
    {
      this->Format_.set (x);
    }


    // SoftwareType
    // 

    const SoftwareType::VendorName_type& SoftwareType::
    VendorName () const
    {
      return this->VendorName_.get ();
    }

    SoftwareType::VendorName_type& SoftwareType::
    VendorName ()
    {
      return this->VendorName_.get ();
    }

    void SoftwareType::
    VendorName (const VendorName_type& x)
    {
      this->VendorName_.set (x);
    }

    void SoftwareType::
    VendorName (::std::auto_ptr< VendorName_type > x)
    {
      this->VendorName_.set (x);
    }

    const SoftwareType::ApplicationName_type& SoftwareType::
    ApplicationName () const
    {
      return this->ApplicationName_.get ();
    }

    SoftwareType::ApplicationName_type& SoftwareType::
    ApplicationName ()
    {
      return this->ApplicationName_.get ();
    }

    void SoftwareType::
    ApplicationName (const ApplicationName_type& x)
    {
      this->ApplicationName_.set (x);
    }

    void SoftwareType::
    ApplicationName (::std::auto_ptr< ApplicationName_type > x)
    {
      this->ApplicationName_.set (x);
    }

    const SoftwareType::Version_optional& SoftwareType::
    Version () const
    {
      return this->Version_;
    }

    SoftwareType::Version_optional& SoftwareType::
    Version ()
    {
      return this->Version_;
    }

    void SoftwareType::
    Version (const Version_type& x)
    {
      this->Version_.set (x);
    }

    void SoftwareType::
    Version (const Version_optional& x)
    {
      this->Version_ = x;
    }

    void SoftwareType::
    Version (::std::auto_ptr< Version_type > x)
    {
      this->Version_.set (x);
    }

    const SoftwareType::Description_optional& SoftwareType::
    Description () const
    {
      return this->Description_;
    }

    SoftwareType::Description_optional& SoftwareType::
    Description ()
    {
      return this->Description_;
    }

    void SoftwareType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void SoftwareType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void SoftwareType::
    Description (::std::auto_ptr< Description_type > x)
    {
      this->Description_.set (x);
    }


    // OrganizationType
    // 

    const OrganizationType::Name_type& OrganizationType::
    Name () const
    {
      return this->Name_.get ();
    }

    OrganizationType::Name_type& OrganizationType::
    Name ()
    {
      return this->Name_.get ();
    }

    void OrganizationType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void OrganizationType::
    Name (::std::auto_ptr< Name_type > x)
    {
      this->Name_.set (x);
    }

    const OrganizationType::Address_optional& OrganizationType::
    Address () const
    {
      return this->Address_;
    }

    OrganizationType::Address_optional& OrganizationType::
    Address ()
    {
      return this->Address_;
    }

    void OrganizationType::
    Address (const Address_type& x)
    {
      this->Address_.set (x);
    }

    void OrganizationType::
    Address (const Address_optional& x)
    {
      this->Address_ = x;
    }

    void OrganizationType::
    Address (::std::auto_ptr< Address_type > x)
    {
      this->Address_.set (x);
    }


    // PhysicalAddressType
    // 

    const PhysicalAddressType::Description_optional& PhysicalAddressType::
    Description () const
    {
      return this->Description_;
    }

    PhysicalAddressType::Description_optional& PhysicalAddressType::
    Description ()
    {
      return this->Description_;
    }

    void PhysicalAddressType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void PhysicalAddressType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void PhysicalAddressType::
    Description (::std::auto_ptr< Description_type > x)
    {
      this->Description_.set (x);
    }

    const PhysicalAddressType::InternalLocation_optional& PhysicalAddressType::
    InternalLocation () const
    {
      return this->InternalLocation_;
    }

    PhysicalAddressType::InternalLocation_optional& PhysicalAddressType::
    InternalLocation ()
    {
      return this->InternalLocation_;
    }

    void PhysicalAddressType::
    InternalLocation (const InternalLocation_type& x)
    {
      this->InternalLocation_.set (x);
    }

    void PhysicalAddressType::
    InternalLocation (const InternalLocation_optional& x)
    {
      this->InternalLocation_ = x;
    }

    void PhysicalAddressType::
    InternalLocation (::std::auto_ptr< InternalLocation_type > x)
    {
      this->InternalLocation_.set (x);
    }

    const PhysicalAddressType::StreetNumber_optional& PhysicalAddressType::
    StreetNumber () const
    {
      return this->StreetNumber_;
    }

    PhysicalAddressType::StreetNumber_optional& PhysicalAddressType::
    StreetNumber ()
    {
      return this->StreetNumber_;
    }

    void PhysicalAddressType::
    StreetNumber (const StreetNumber_type& x)
    {
      this->StreetNumber_.set (x);
    }

    void PhysicalAddressType::
    StreetNumber (const StreetNumber_optional& x)
    {
      this->StreetNumber_ = x;
    }

    void PhysicalAddressType::
    StreetNumber (::std::auto_ptr< StreetNumber_type > x)
    {
      this->StreetNumber_.set (x);
    }

    const PhysicalAddressType::Street_optional& PhysicalAddressType::
    Street () const
    {
      return this->Street_;
    }

    PhysicalAddressType::Street_optional& PhysicalAddressType::
    Street ()
    {
      return this->Street_;
    }

    void PhysicalAddressType::
    Street (const Street_type& x)
    {
      this->Street_.set (x);
    }

    void PhysicalAddressType::
    Street (const Street_optional& x)
    {
      this->Street_ = x;
    }

    void PhysicalAddressType::
    Street (::std::auto_ptr< Street_type > x)
    {
      this->Street_.set (x);
    }

    const PhysicalAddressType::PostalBox_optional& PhysicalAddressType::
    PostalBox () const
    {
      return this->PostalBox_;
    }

    PhysicalAddressType::PostalBox_optional& PhysicalAddressType::
    PostalBox ()
    {
      return this->PostalBox_;
    }

    void PhysicalAddressType::
    PostalBox (const PostalBox_type& x)
    {
      this->PostalBox_.set (x);
    }

    void PhysicalAddressType::
    PostalBox (const PostalBox_optional& x)
    {
      this->PostalBox_ = x;
    }

    void PhysicalAddressType::
    PostalBox (::std::auto_ptr< PostalBox_type > x)
    {
      this->PostalBox_.set (x);
    }

    const PhysicalAddressType::Town_optional& PhysicalAddressType::
    Town () const
    {
      return this->Town_;
    }

    PhysicalAddressType::Town_optional& PhysicalAddressType::
    Town ()
    {
      return this->Town_;
    }

    void PhysicalAddressType::
    Town (const Town_type& x)
    {
      this->Town_.set (x);
    }

    void PhysicalAddressType::
    Town (const Town_optional& x)
    {
      this->Town_ = x;
    }

    void PhysicalAddressType::
    Town (::std::auto_ptr< Town_type > x)
    {
      this->Town_.set (x);
    }

    const PhysicalAddressType::Region_optional& PhysicalAddressType::
    Region () const
    {
      return this->Region_;
    }

    PhysicalAddressType::Region_optional& PhysicalAddressType::
    Region ()
    {
      return this->Region_;
    }

    void PhysicalAddressType::
    Region (const Region_type& x)
    {
      this->Region_.set (x);
    }

    void PhysicalAddressType::
    Region (const Region_optional& x)
    {
      this->Region_ = x;
    }

    void PhysicalAddressType::
    Region (::std::auto_ptr< Region_type > x)
    {
      this->Region_.set (x);
    }

    const PhysicalAddressType::PostalCode_optional& PhysicalAddressType::
    PostalCode () const
    {
      return this->PostalCode_;
    }

    PhysicalAddressType::PostalCode_optional& PhysicalAddressType::
    PostalCode ()
    {
      return this->PostalCode_;
    }

    void PhysicalAddressType::
    PostalCode (const PostalCode_type& x)
    {
      this->PostalCode_.set (x);
    }

    void PhysicalAddressType::
    PostalCode (const PostalCode_optional& x)
    {
      this->PostalCode_ = x;
    }

    void PhysicalAddressType::
    PostalCode (::std::auto_ptr< PostalCode_type > x)
    {
      this->PostalCode_.set (x);
    }

    const PhysicalAddressType::Country_optional& PhysicalAddressType::
    Country () const
    {
      return this->Country_;
    }

    PhysicalAddressType::Country_optional& PhysicalAddressType::
    Country ()
    {
      return this->Country_;
    }

    void PhysicalAddressType::
    Country (const Country_type& x)
    {
      this->Country_.set (x);
    }

    void PhysicalAddressType::
    Country (const Country_optional& x)
    {
      this->Country_ = x;
    }

    void PhysicalAddressType::
    Country (::std::auto_ptr< Country_type > x)
    {
      this->Country_.set (x);
    }

    const PhysicalAddressType::FacsimileNumber_optional& PhysicalAddressType::
    FacsimileNumber () const
    {
      return this->FacsimileNumber_;
    }

    PhysicalAddressType::FacsimileNumber_optional& PhysicalAddressType::
    FacsimileNumber ()
    {
      return this->FacsimileNumber_;
    }

    void PhysicalAddressType::
    FacsimileNumber (const FacsimileNumber_type& x)
    {
      this->FacsimileNumber_.set (x);
    }

    void PhysicalAddressType::
    FacsimileNumber (const FacsimileNumber_optional& x)
    {
      this->FacsimileNumber_ = x;
    }

    void PhysicalAddressType::
    FacsimileNumber (::std::auto_ptr< FacsimileNumber_type > x)
    {
      this->FacsimileNumber_.set (x);
    }

    const PhysicalAddressType::TelephoneNumber_optional& PhysicalAddressType::
    TelephoneNumber () const
    {
      return this->TelephoneNumber_;
    }

    PhysicalAddressType::TelephoneNumber_optional& PhysicalAddressType::
    TelephoneNumber ()
    {
      return this->TelephoneNumber_;
    }

    void PhysicalAddressType::
    TelephoneNumber (const TelephoneNumber_type& x)
    {
      this->TelephoneNumber_.set (x);
    }

    void PhysicalAddressType::
    TelephoneNumber (const TelephoneNumber_optional& x)
    {
      this->TelephoneNumber_ = x;
    }

    void PhysicalAddressType::
    TelephoneNumber (::std::auto_ptr< TelephoneNumber_type > x)
    {
      this->TelephoneNumber_.set (x);
    }

    const PhysicalAddressType::ElectronicMailAddress_optional& PhysicalAddressType::
    ElectronicMailAddress () const
    {
      return this->ElectronicMailAddress_;
    }

    PhysicalAddressType::ElectronicMailAddress_optional& PhysicalAddressType::
    ElectronicMailAddress ()
    {
      return this->ElectronicMailAddress_;
    }

    void PhysicalAddressType::
    ElectronicMailAddress (const ElectronicMailAddress_type& x)
    {
      this->ElectronicMailAddress_.set (x);
    }

    void PhysicalAddressType::
    ElectronicMailAddress (const ElectronicMailAddress_optional& x)
    {
      this->ElectronicMailAddress_ = x;
    }

    void PhysicalAddressType::
    ElectronicMailAddress (::std::auto_ptr< ElectronicMailAddress_type > x)
    {
      this->ElectronicMailAddress_.set (x);
    }

    const PhysicalAddressType::TelexNumber_optional& PhysicalAddressType::
    TelexNumber () const
    {
      return this->TelexNumber_;
    }

    PhysicalAddressType::TelexNumber_optional& PhysicalAddressType::
    TelexNumber ()
    {
      return this->TelexNumber_;
    }

    void PhysicalAddressType::
    TelexNumber (const TelexNumber_type& x)
    {
      this->TelexNumber_.set (x);
    }

    void PhysicalAddressType::
    TelexNumber (const TelexNumber_optional& x)
    {
      this->TelexNumber_ = x;
    }

    void PhysicalAddressType::
    TelexNumber (::std::auto_ptr< TelexNumber_type > x)
    {
      this->TelexNumber_.set (x);
    }


    // AddressDescriptionEnumType
    // 

    AddressDescriptionEnumType::
    AddressDescriptionEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_AddressDescriptionEnumType_literals_[v])
    {
    }

    AddressDescriptionEnumType::
    AddressDescriptionEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AddressDescriptionEnumType::
    AddressDescriptionEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AddressDescriptionEnumType::
    AddressDescriptionEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    AddressDescriptionEnumType::
    AddressDescriptionEnumType (const AddressDescriptionEnumType& v,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    AddressDescriptionEnumType& AddressDescriptionEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_AddressDescriptionEnumType_literals_[v]);

      return *this;
    }


    // AddressDescriptionType
    // 

    const AddressDescriptionType::AddressDescriptionEnum_optional& AddressDescriptionType::
    AddressDescriptionEnum () const
    {
      return this->AddressDescriptionEnum_;
    }

    AddressDescriptionType::AddressDescriptionEnum_optional& AddressDescriptionType::
    AddressDescriptionEnum ()
    {
      return this->AddressDescriptionEnum_;
    }

    void AddressDescriptionType::
    AddressDescriptionEnum (const AddressDescriptionEnum_type& x)
    {
      this->AddressDescriptionEnum_.set (x);
    }

    void AddressDescriptionType::
    AddressDescriptionEnum (const AddressDescriptionEnum_optional& x)
    {
      this->AddressDescriptionEnum_ = x;
    }

    void AddressDescriptionType::
    AddressDescriptionEnum (::std::auto_ptr< AddressDescriptionEnum_type > x)
    {
      this->AddressDescriptionEnum_.set (x);
    }

    const AddressDescriptionType::OtherAddressDescription_optional& AddressDescriptionType::
    OtherAddressDescription () const
    {
      return this->OtherAddressDescription_;
    }

    AddressDescriptionType::OtherAddressDescription_optional& AddressDescriptionType::
    OtherAddressDescription ()
    {
      return this->OtherAddressDescription_;
    }

    void AddressDescriptionType::
    OtherAddressDescription (const OtherAddressDescription_type& x)
    {
      this->OtherAddressDescription_.set (x);
    }

    void AddressDescriptionType::
    OtherAddressDescription (const OtherAddressDescription_optional& x)
    {
      this->OtherAddressDescription_ = x;
    }

    void AddressDescriptionType::
    OtherAddressDescription (::std::auto_ptr< OtherAddressDescription_type > x)
    {
      this->OtherAddressDescription_.set (x);
    }


    // LocationType
    // 

    const LocationType::LocationDescription_type& LocationType::
    LocationDescription () const
    {
      return this->LocationDescription_.get ();
    }

    LocationType::LocationDescription_type& LocationType::
    LocationDescription ()
    {
      return this->LocationDescription_.get ();
    }

    void LocationType::
    LocationDescription (const LocationDescription_type& x)
    {
      this->LocationDescription_.set (x);
    }

    void LocationType::
    LocationDescription (::std::auto_ptr< LocationDescription_type > x)
    {
      this->LocationDescription_.set (x);
    }

    const LocationType::Address_optional& LocationType::
    Address () const
    {
      return this->Address_;
    }

    LocationType::Address_optional& LocationType::
    Address ()
    {
      return this->Address_;
    }

    void LocationType::
    Address (const Address_type& x)
    {
      this->Address_.set (x);
    }

    void LocationType::
    Address (const Address_optional& x)
    {
      this->Address_ = x;
    }

    void LocationType::
    Address (::std::auto_ptr< Address_type > x)
    {
      this->Address_.set (x);
    }

    const LocationType::id_type& LocationType::
    id () const
    {
      return this->id_.get ();
    }

    LocationType::id_type& LocationType::
    id ()
    {
      return this->id_.get ();
    }

    void LocationType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void LocationType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // CustomerOrganizationType
    // 

    const CustomerOrganizationType::CustomerNumber_type& CustomerOrganizationType::
    CustomerNumber () const
    {
      return this->CustomerNumber_.get ();
    }

    CustomerOrganizationType::CustomerNumber_type& CustomerOrganizationType::
    CustomerNumber ()
    {
      return this->CustomerNumber_.get ();
    }

    void CustomerOrganizationType::
    CustomerNumber (const CustomerNumber_type& x)
    {
      this->CustomerNumber_.set (x);
    }

    void CustomerOrganizationType::
    CustomerNumber (::std::auto_ptr< CustomerNumber_type > x)
    {
      this->CustomerNumber_.set (x);
    }


    // VersionHistoryType
    // 

    const VersionHistoryType::EarlierVersion_sequence& VersionHistoryType::
    EarlierVersion () const
    {
      return this->EarlierVersion_;
    }

    VersionHistoryType::EarlierVersion_sequence& VersionHistoryType::
    EarlierVersion ()
    {
      return this->EarlierVersion_;
    }

    void VersionHistoryType::
    EarlierVersion (const EarlierVersion_sequence& s)
    {
      this->EarlierVersion_ = s;
    }


    // VersionBaseType
    // 

    const VersionBaseType::TimeCreated_optional& VersionBaseType::
    TimeCreated () const
    {
      return this->TimeCreated_;
    }

    VersionBaseType::TimeCreated_optional& VersionBaseType::
    TimeCreated ()
    {
      return this->TimeCreated_;
    }

    void VersionBaseType::
    TimeCreated (const TimeCreated_type& x)
    {
      this->TimeCreated_.set (x);
    }

    void VersionBaseType::
    TimeCreated (const TimeCreated_optional& x)
    {
      this->TimeCreated_ = x;
    }

    void VersionBaseType::
    TimeCreated (::std::auto_ptr< TimeCreated_type > x)
    {
      this->TimeCreated_.set (x);
    }

    const VersionBaseType::SignOffs_optional& VersionBaseType::
    SignOffs () const
    {
      return this->SignOffs_;
    }

    VersionBaseType::SignOffs_optional& VersionBaseType::
    SignOffs ()
    {
      return this->SignOffs_;
    }

    void VersionBaseType::
    SignOffs (const SignOffs_type& x)
    {
      this->SignOffs_.set (x);
    }

    void VersionBaseType::
    SignOffs (const SignOffs_optional& x)
    {
      this->SignOffs_ = x;
    }

    void VersionBaseType::
    SignOffs (::std::auto_ptr< SignOffs_type > x)
    {
      this->SignOffs_.set (x);
    }


    // VersionType
    // 

    const VersionType::ThisInstanceQPId_optional& VersionType::
    ThisInstanceQPId () const
    {
      return this->ThisInstanceQPId_;
    }

    VersionType::ThisInstanceQPId_optional& VersionType::
    ThisInstanceQPId ()
    {
      return this->ThisInstanceQPId_;
    }

    void VersionType::
    ThisInstanceQPId (const ThisInstanceQPId_type& x)
    {
      this->ThisInstanceQPId_.set (x);
    }

    void VersionType::
    ThisInstanceQPId (const ThisInstanceQPId_optional& x)
    {
      this->ThisInstanceQPId_ = x;
    }

    void VersionType::
    ThisInstanceQPId (::std::auto_ptr< ThisInstanceQPId_type > x)
    {
      this->ThisInstanceQPId_.set (x);
    }


    // VersionReferenceType
    // 

    const VersionReferenceType::QPIdReference_optional& VersionReferenceType::
    QPIdReference () const
    {
      return this->QPIdReference_;
    }

    VersionReferenceType::QPIdReference_optional& VersionReferenceType::
    QPIdReference ()
    {
      return this->QPIdReference_;
    }

    void VersionReferenceType::
    QPIdReference (const QPIdReference_type& x)
    {
      this->QPIdReference_.set (x);
    }

    void VersionReferenceType::
    QPIdReference (const QPIdReference_optional& x)
    {
      this->QPIdReference_ = x;
    }

    void VersionReferenceType::
    QPIdReference (::std::auto_ptr< QPIdReference_type > x)
    {
      this->QPIdReference_.set (x);
    }


    // SignOffsType
    // 

    const SignOffsType::Employee_sequence& SignOffsType::
    Employee () const
    {
      return this->Employee_;
    }

    SignOffsType::Employee_sequence& SignOffsType::
    Employee ()
    {
      return this->Employee_;
    }

    void SignOffsType::
    Employee (const Employee_sequence& s)
    {
      this->Employee_ = s;
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif2
  {
    // FormalStandardEnumType
    //

    FormalStandardEnumType::
    FormalStandardEnumType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_FormalStandardEnumType_convert ();
    }

    FormalStandardEnumType::
    FormalStandardEnumType (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_FormalStandardEnumType_convert ();
    }

    FormalStandardEnumType::
    FormalStandardEnumType (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_FormalStandardEnumType_convert ();
    }

    FormalStandardEnumType* FormalStandardEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FormalStandardEnumType (*this, f, c);
    }

    FormalStandardEnumType::value FormalStandardEnumType::
    _xsd_FormalStandardEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_FormalStandardEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_FormalStandardEnumType_indexes_,
                        _xsd_FormalStandardEnumType_indexes_ + 11,
                        *this,
                        c));

      if (i == _xsd_FormalStandardEnumType_indexes_ + 11 || _xsd_FormalStandardEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const FormalStandardEnumType::
    _xsd_FormalStandardEnumType_literals_[11] =
    {
      "ANSI",
      "ASME-Y14.5-1982",
      "ASME-Y14.5-1994",
      "ASME-Y14.5-2009",
      "ISO1101:1983",
      "ISO1101:2004",
      "ISO1101:2012",
      "BS_8888_2004",
      "JIS",
      "DIN",
      "COMPANY"
    };

    const FormalStandardEnumType::value FormalStandardEnumType::
    _xsd_FormalStandardEnumType_indexes_[11] =
    {
      ::xsd::qif2::FormalStandardEnumType::ANSI,
      ::xsd::qif2::FormalStandardEnumType::ASME_Y14_5_1982,
      ::xsd::qif2::FormalStandardEnumType::ASME_Y14_5_1994,
      ::xsd::qif2::FormalStandardEnumType::ASME_Y14_5_2009,
      ::xsd::qif2::FormalStandardEnumType::BS_8888_2004,
      ::xsd::qif2::FormalStandardEnumType::COMPANY,
      ::xsd::qif2::FormalStandardEnumType::DIN,
      ::xsd::qif2::FormalStandardEnumType::ISO1101_1983,
      ::xsd::qif2::FormalStandardEnumType::ISO1101_2004,
      ::xsd::qif2::FormalStandardEnumType::ISO1101_2012,
      ::xsd::qif2::FormalStandardEnumType::JIS
    };

    // FormalStandardType
    //

    FormalStandardType::
    FormalStandardType ()
    : ::xml_schema::type (),
      FormalStandardEnum_ (this),
      OtherFormalStandard_ (this)
    {
    }

    FormalStandardType::
    FormalStandardType (const FormalStandardType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FormalStandardEnum_ (x.FormalStandardEnum_, f, this),
      OtherFormalStandard_ (x.OtherFormalStandard_, f, this)
    {
    }

    FormalStandardType::
    FormalStandardType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FormalStandardEnum_ (this),
      OtherFormalStandard_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FormalStandardType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FormalStandardEnum
        //
        if (n.name () == "FormalStandardEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FormalStandardEnum_type > r (
            FormalStandardEnum_traits::create (i, f, this));

          if (!this->FormalStandardEnum_)
          {
            this->FormalStandardEnum_.set (r);
            continue;
          }
        }

        // OtherFormalStandard
        //
        if (n.name () == "OtherFormalStandard" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherFormalStandard_type > r (
            OtherFormalStandard_traits::create (i, f, this));

          if (!this->OtherFormalStandard_)
          {
            this->OtherFormalStandard_.set (r);
            continue;
          }
        }

        break;
      }
    }

    FormalStandardType* FormalStandardType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FormalStandardType (*this, f, c);
    }

    FormalStandardType& FormalStandardType::
    operator= (const FormalStandardType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FormalStandardEnum_ = x.FormalStandardEnum_;
        this->OtherFormalStandard_ = x.OtherFormalStandard_;
      }

      return *this;
    }

    FormalStandardType::
    ~FormalStandardType ()
    {
    }

    // SequencedDatumType
    //

    SequencedDatumType::
    SequencedDatumType (const SequenceNumber_type& SequenceNumber)
    : ::xml_schema::type (),
      SimpleDatum_ (this),
      CompoundDatum_ (this),
      SequenceNumber_ (SequenceNumber, this)
    {
    }

    SequencedDatumType::
    SequencedDatumType (const SequencedDatumType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SimpleDatum_ (x.SimpleDatum_, f, this),
      CompoundDatum_ (x.CompoundDatum_, f, this),
      SequenceNumber_ (x.SequenceNumber_, f, this)
    {
    }

    SequencedDatumType::
    SequencedDatumType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SimpleDatum_ (this),
      CompoundDatum_ (this),
      SequenceNumber_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SequencedDatumType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SimpleDatum
        //
        if (n.name () == "SimpleDatum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SimpleDatum_type > r (
            SimpleDatum_traits::create (i, f, this));

          if (!this->SimpleDatum_)
          {
            this->SimpleDatum_.set (r);
            continue;
          }
        }

        // CompoundDatum
        //
        if (n.name () == "CompoundDatum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CompoundDatum_type > r (
            CompoundDatum_traits::create (i, f, this));

          if (!this->CompoundDatum_)
          {
            this->CompoundDatum_.set (r);
            continue;
          }
        }

        // SequenceNumber
        //
        if (n.name () == "SequenceNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!SequenceNumber_.present ())
          {
            this->SequenceNumber_.set (SequenceNumber_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!SequenceNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SequenceNumber",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SequencedDatumType* SequencedDatumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SequencedDatumType (*this, f, c);
    }

    SequencedDatumType& SequencedDatumType::
    operator= (const SequencedDatumType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SimpleDatum_ = x.SimpleDatum_;
        this->CompoundDatum_ = x.CompoundDatum_;
        this->SequenceNumber_ = x.SequenceNumber_;
      }

      return *this;
    }

    SequencedDatumType::
    ~SequencedDatumType ()
    {
    }

    // CompoundDatumType
    //

    CompoundDatumType::
    CompoundDatumType ()
    : ::xml_schema::type (),
      Datum_ (this),
      ReducedDatum_ (this)
    {
    }

    CompoundDatumType::
    CompoundDatumType (const CompoundDatumType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Datum_ (x.Datum_, f, this),
      ReducedDatum_ (x.ReducedDatum_, f, this)
    {
    }

    CompoundDatumType::
    CompoundDatumType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Datum_ (this),
      ReducedDatum_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CompoundDatumType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Datum
        //
        if (n.name () == "Datum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Datum_type > r (
            Datum_traits::create (i, f, this));

          this->Datum_.push_back (r);
          continue;
        }

        // ReducedDatum
        //
        if (n.name () == "ReducedDatum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ReducedDatum_type > r (
            ReducedDatum_traits::create (i, f, this));

          if (!this->ReducedDatum_)
          {
            this->ReducedDatum_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CompoundDatumType* CompoundDatumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompoundDatumType (*this, f, c);
    }

    CompoundDatumType& CompoundDatumType::
    operator= (const CompoundDatumType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Datum_ = x.Datum_;
        this->ReducedDatum_ = x.ReducedDatum_;
      }

      return *this;
    }

    CompoundDatumType::
    ~CompoundDatumType ()
    {
    }

    // DatumWithPrecedenceType
    //

    DatumWithPrecedenceType::
    DatumWithPrecedenceType (const Precedence_type& Precedence)
    : ::xml_schema::type (),
      SimpleDatum_ (this),
      NominalDatumFeature_ (this),
      ActualDatumFeature_ (this),
      CompoundDatum_ (this),
      Precedence_ (Precedence, this)
    {
    }

    DatumWithPrecedenceType::
    DatumWithPrecedenceType (::std::auto_ptr< Precedence_type > Precedence)
    : ::xml_schema::type (),
      SimpleDatum_ (this),
      NominalDatumFeature_ (this),
      ActualDatumFeature_ (this),
      CompoundDatum_ (this),
      Precedence_ (Precedence, this)
    {
    }

    DatumWithPrecedenceType::
    DatumWithPrecedenceType (const DatumWithPrecedenceType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SimpleDatum_ (x.SimpleDatum_, f, this),
      NominalDatumFeature_ (x.NominalDatumFeature_, f, this),
      ActualDatumFeature_ (x.ActualDatumFeature_, f, this),
      CompoundDatum_ (x.CompoundDatum_, f, this),
      Precedence_ (x.Precedence_, f, this)
    {
    }

    DatumWithPrecedenceType::
    DatumWithPrecedenceType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SimpleDatum_ (this),
      NominalDatumFeature_ (this),
      ActualDatumFeature_ (this),
      CompoundDatum_ (this),
      Precedence_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DatumWithPrecedenceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SimpleDatum
        //
        if (n.name () == "SimpleDatum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SimpleDatum_type > r (
            SimpleDatum_traits::create (i, f, this));

          if (!this->SimpleDatum_)
          {
            this->SimpleDatum_.set (r);
            continue;
          }
        }

        // NominalDatumFeature
        //
        if (n.name () == "NominalDatumFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< NominalDatumFeature_type > r (
            NominalDatumFeature_traits::create (i, f, this));

          if (!this->NominalDatumFeature_)
          {
            this->NominalDatumFeature_.set (r);
            continue;
          }
        }

        // ActualDatumFeature
        //
        if (n.name () == "ActualDatumFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ActualDatumFeature_type > r (
            ActualDatumFeature_traits::create (i, f, this));

          if (!this->ActualDatumFeature_)
          {
            this->ActualDatumFeature_.set (r);
            continue;
          }
        }

        // CompoundDatum
        //
        if (n.name () == "CompoundDatum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CompoundDatum_type > r (
            CompoundDatum_traits::create (i, f, this));

          if (!this->CompoundDatum_)
          {
            this->CompoundDatum_.set (r);
            continue;
          }
        }

        // Precedence
        //
        if (n.name () == "Precedence" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Precedence_type > r (
            Precedence_traits::create (i, f, this));

          if (!Precedence_.present ())
          {
            this->Precedence_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Precedence_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Precedence",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    DatumWithPrecedenceType* DatumWithPrecedenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumWithPrecedenceType (*this, f, c);
    }

    DatumWithPrecedenceType& DatumWithPrecedenceType::
    operator= (const DatumWithPrecedenceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SimpleDatum_ = x.SimpleDatum_;
        this->NominalDatumFeature_ = x.NominalDatumFeature_;
        this->ActualDatumFeature_ = x.ActualDatumFeature_;
        this->CompoundDatum_ = x.CompoundDatum_;
        this->Precedence_ = x.Precedence_;
      }

      return *this;
    }

    DatumWithPrecedenceType::
    ~DatumWithPrecedenceType ()
    {
    }

    // DatumType
    //

    DatumType::
    DatumType (const DatumDefinitionId_type& DatumDefinitionId,
               const MaterialModifier_type& MaterialModifier,
               const ReferencedComponent_type& ReferencedComponent)
    : ::xml_schema::type (),
      DatumDefinitionId_ (DatumDefinitionId, this),
      MaterialModifier_ (MaterialModifier, this),
      ReferencedComponent_ (ReferencedComponent, this),
      DatumFeatureSimulatorModifier_ (this),
      DatumTranslation_ (this),
      DegreesOfFreedom_ (this),
      ProjectedDatum_ (this),
      DiameterModifier_ (this),
      SectionModifier_ (this),
      ContactingFeature_ (this),
      DistanceVariable_ (this),
      DatumFixed_ (this),
      ReducedDatum_ (this),
      ConstrainOrientation_ (this),
      ConstrainSubsequent_ (this)
    {
    }

    DatumType::
    DatumType (::std::auto_ptr< DatumDefinitionId_type > DatumDefinitionId,
               const MaterialModifier_type& MaterialModifier,
               const ReferencedComponent_type& ReferencedComponent)
    : ::xml_schema::type (),
      DatumDefinitionId_ (DatumDefinitionId, this),
      MaterialModifier_ (MaterialModifier, this),
      ReferencedComponent_ (ReferencedComponent, this),
      DatumFeatureSimulatorModifier_ (this),
      DatumTranslation_ (this),
      DegreesOfFreedom_ (this),
      ProjectedDatum_ (this),
      DiameterModifier_ (this),
      SectionModifier_ (this),
      ContactingFeature_ (this),
      DistanceVariable_ (this),
      DatumFixed_ (this),
      ReducedDatum_ (this),
      ConstrainOrientation_ (this),
      ConstrainSubsequent_ (this)
    {
    }

    DatumType::
    DatumType (const DatumType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DatumDefinitionId_ (x.DatumDefinitionId_, f, this),
      MaterialModifier_ (x.MaterialModifier_, f, this),
      ReferencedComponent_ (x.ReferencedComponent_, f, this),
      DatumFeatureSimulatorModifier_ (x.DatumFeatureSimulatorModifier_, f, this),
      DatumTranslation_ (x.DatumTranslation_, f, this),
      DegreesOfFreedom_ (x.DegreesOfFreedom_, f, this),
      ProjectedDatum_ (x.ProjectedDatum_, f, this),
      DiameterModifier_ (x.DiameterModifier_, f, this),
      SectionModifier_ (x.SectionModifier_, f, this),
      ContactingFeature_ (x.ContactingFeature_, f, this),
      DistanceVariable_ (x.DistanceVariable_, f, this),
      DatumFixed_ (x.DatumFixed_, f, this),
      ReducedDatum_ (x.ReducedDatum_, f, this),
      ConstrainOrientation_ (x.ConstrainOrientation_, f, this),
      ConstrainSubsequent_ (x.ConstrainSubsequent_, f, this)
    {
    }

    DatumType::
    DatumType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DatumDefinitionId_ (this),
      MaterialModifier_ (this),
      ReferencedComponent_ (this),
      DatumFeatureSimulatorModifier_ (this),
      DatumTranslation_ (this),
      DegreesOfFreedom_ (this),
      ProjectedDatum_ (this),
      DiameterModifier_ (this),
      SectionModifier_ (this),
      ContactingFeature_ (this),
      DistanceVariable_ (this),
      DatumFixed_ (this),
      ReducedDatum_ (this),
      ConstrainOrientation_ (this),
      ConstrainSubsequent_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DatumType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DatumDefinitionId
        //
        if (n.name () == "DatumDefinitionId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DatumDefinitionId_type > r (
            DatumDefinitionId_traits::create (i, f, this));

          if (!DatumDefinitionId_.present ())
          {
            this->DatumDefinitionId_.set (r);
            continue;
          }
        }

        // MaterialModifier
        //
        if (n.name () == "MaterialModifier" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaterialModifier_type > r (
            MaterialModifier_traits::create (i, f, this));

          if (!MaterialModifier_.present ())
          {
            this->MaterialModifier_.set (r);
            continue;
          }
        }

        // ReferencedComponent
        //
        if (n.name () == "ReferencedComponent" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ReferencedComponent_type > r (
            ReferencedComponent_traits::create (i, f, this));

          if (!ReferencedComponent_.present ())
          {
            this->ReferencedComponent_.set (r);
            continue;
          }
        }

        // DatumFeatureSimulatorModifier
        //
        if (n.name () == "DatumFeatureSimulatorModifier" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DatumFeatureSimulatorModifier_type > r (
            DatumFeatureSimulatorModifier_traits::create (i, f, this));

          if (!this->DatumFeatureSimulatorModifier_)
          {
            this->DatumFeatureSimulatorModifier_.set (r);
            continue;
          }
        }

        // DatumTranslation
        //
        if (n.name () == "DatumTranslation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DatumTranslation_type > r (
            DatumTranslation_traits::create (i, f, this));

          if (!this->DatumTranslation_)
          {
            this->DatumTranslation_.set (r);
            continue;
          }
        }

        // DegreesOfFreedom
        //
        if (n.name () == "DegreesOfFreedom" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DegreesOfFreedom_type > r (
            DegreesOfFreedom_traits::create (i, f, this));

          if (!this->DegreesOfFreedom_)
          {
            this->DegreesOfFreedom_.set (r);
            continue;
          }
        }

        // ProjectedDatum
        //
        if (n.name () == "ProjectedDatum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectedDatum_type > r (
            ProjectedDatum_traits::create (i, f, this));

          if (!this->ProjectedDatum_)
          {
            this->ProjectedDatum_.set (r);
            continue;
          }
        }

        // DiameterModifier
        //
        if (n.name () == "DiameterModifier" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterModifier_type > r (
            DiameterModifier_traits::create (i, f, this));

          if (!this->DiameterModifier_)
          {
            this->DiameterModifier_.set (r);
            continue;
          }
        }

        // SectionModifier
        //
        if (n.name () == "SectionModifier" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SectionModifier_type > r (
            SectionModifier_traits::create (i, f, this));

          if (!this->SectionModifier_)
          {
            this->SectionModifier_.set (r);
            continue;
          }
        }

        // ContactingFeature
        //
        if (n.name () == "ContactingFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->ContactingFeature_)
          {
            this->ContactingFeature_.set (ContactingFeature_traits::create (i, f, this));
            continue;
          }
        }

        // DistanceVariable
        //
        if (n.name () == "DistanceVariable" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->DistanceVariable_)
          {
            this->DistanceVariable_.set (DistanceVariable_traits::create (i, f, this));
            continue;
          }
        }

        // DatumFixed
        //
        if (n.name () == "DatumFixed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->DatumFixed_)
          {
            this->DatumFixed_.set (DatumFixed_traits::create (i, f, this));
            continue;
          }
        }

        // ReducedDatum
        //
        if (n.name () == "ReducedDatum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ReducedDatum_type > r (
            ReducedDatum_traits::create (i, f, this));

          if (!this->ReducedDatum_)
          {
            this->ReducedDatum_.set (r);
            continue;
          }
        }

        // ConstrainOrientation
        //
        if (n.name () == "ConstrainOrientation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->ConstrainOrientation_)
          {
            this->ConstrainOrientation_.set (ConstrainOrientation_traits::create (i, f, this));
            continue;
          }
        }

        // ConstrainSubsequent
        //
        if (n.name () == "ConstrainSubsequent" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->ConstrainSubsequent_)
          {
            this->ConstrainSubsequent_.set (ConstrainSubsequent_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!DatumDefinitionId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DatumDefinitionId",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MaterialModifier_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MaterialModifier",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ReferencedComponent_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ReferencedComponent",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    DatumType* DatumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumType (*this, f, c);
    }

    DatumType& DatumType::
    operator= (const DatumType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DatumDefinitionId_ = x.DatumDefinitionId_;
        this->MaterialModifier_ = x.MaterialModifier_;
        this->ReferencedComponent_ = x.ReferencedComponent_;
        this->DatumFeatureSimulatorModifier_ = x.DatumFeatureSimulatorModifier_;
        this->DatumTranslation_ = x.DatumTranslation_;
        this->DegreesOfFreedom_ = x.DegreesOfFreedom_;
        this->ProjectedDatum_ = x.ProjectedDatum_;
        this->DiameterModifier_ = x.DiameterModifier_;
        this->SectionModifier_ = x.SectionModifier_;
        this->ContactingFeature_ = x.ContactingFeature_;
        this->DistanceVariable_ = x.DistanceVariable_;
        this->DatumFixed_ = x.DatumFixed_;
        this->ReducedDatum_ = x.ReducedDatum_;
        this->ConstrainOrientation_ = x.ConstrainOrientation_;
        this->ConstrainSubsequent_ = x.ConstrainSubsequent_;
      }

      return *this;
    }

    DatumType::
    ~DatumType ()
    {
    }

    // DatumTranslationType
    //

    DatumTranslationType::
    DatumTranslationType (const DatumTranslationAllowed_type& DatumTranslationAllowed)
    : ::xml_schema::type (),
      DatumTranslationAllowed_ (DatumTranslationAllowed, this)
    {
    }

    DatumTranslationType::
    DatumTranslationType (const DatumTranslationType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DatumTranslationAllowed_ (x.DatumTranslationAllowed_, f, this)
    {
    }

    DatumTranslationType::
    DatumTranslationType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DatumTranslationAllowed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DatumTranslationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DatumTranslationAllowed
        //
        if (n.name () == "DatumTranslationAllowed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!DatumTranslationAllowed_.present ())
          {
            this->DatumTranslationAllowed_.set (DatumTranslationAllowed_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!DatumTranslationAllowed_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DatumTranslationAllowed",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    DatumTranslationType* DatumTranslationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumTranslationType (*this, f, c);
    }

    DatumTranslationType& DatumTranslationType::
    operator= (const DatumTranslationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DatumTranslationAllowed_ = x.DatumTranslationAllowed_;
      }

      return *this;
    }

    DatumTranslationType::
    ~DatumTranslationType ()
    {
    }

    // DatumFeatureBaseType
    //

    DatumFeatureBaseType::
    DatumFeatureBaseType (const FeatureItemId_type& FeatureItemId)
    : ::xml_schema::type (),
      FeatureItemId_ (FeatureItemId, this)
    {
    }

    DatumFeatureBaseType::
    DatumFeatureBaseType (::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xml_schema::type (),
      FeatureItemId_ (FeatureItemId, this)
    {
    }

    DatumFeatureBaseType::
    DatumFeatureBaseType (const DatumFeatureBaseType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureItemId_ (x.FeatureItemId_, f, this)
    {
    }

    DatumFeatureBaseType::
    DatumFeatureBaseType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureItemId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DatumFeatureBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FeatureItemId
        //
        if (n.name () == "FeatureItemId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureItemId_type > r (
            FeatureItemId_traits::create (i, f, this));

          if (!FeatureItemId_.present ())
          {
            this->FeatureItemId_.set (r);
            continue;
          }
        }

        break;
      }

      if (!FeatureItemId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "FeatureItemId",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    DatumFeatureBaseType* DatumFeatureBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumFeatureBaseType (*this, f, c);
    }

    DatumFeatureBaseType& DatumFeatureBaseType::
    operator= (const DatumFeatureBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FeatureItemId_ = x.FeatureItemId_;
      }

      return *this;
    }

    DatumFeatureBaseType::
    ~DatumFeatureBaseType ()
    {
    }

    // ActualDatumFeatureType
    //

    ActualDatumFeatureType::
    ActualDatumFeatureType (const FeatureItemId_type& FeatureItemId,
                            const MaterialModifier_type& MaterialModifier)
    : ::xsd::qif2::DatumFeatureBaseType (FeatureItemId),
      MaterialModifier_ (MaterialModifier, this)
    {
    }

    ActualDatumFeatureType::
    ActualDatumFeatureType (::std::auto_ptr< FeatureItemId_type > FeatureItemId,
                            const MaterialModifier_type& MaterialModifier)
    : ::xsd::qif2::DatumFeatureBaseType (FeatureItemId),
      MaterialModifier_ (MaterialModifier, this)
    {
    }

    ActualDatumFeatureType::
    ActualDatumFeatureType (const ActualDatumFeatureType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::DatumFeatureBaseType (x, f, c),
      MaterialModifier_ (x.MaterialModifier_, f, this)
    {
    }

    ActualDatumFeatureType::
    ActualDatumFeatureType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::DatumFeatureBaseType (e, f | ::xml_schema::flags::base, c),
      MaterialModifier_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ActualDatumFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::DatumFeatureBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MaterialModifier
        //
        if (n.name () == "MaterialModifier" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaterialModifier_type > r (
            MaterialModifier_traits::create (i, f, this));

          if (!MaterialModifier_.present ())
          {
            this->MaterialModifier_.set (r);
            continue;
          }
        }

        break;
      }

      if (!MaterialModifier_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MaterialModifier",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ActualDatumFeatureType* ActualDatumFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualDatumFeatureType (*this, f, c);
    }

    ActualDatumFeatureType& ActualDatumFeatureType::
    operator= (const ActualDatumFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::DatumFeatureBaseType& > (*this) = x;
        this->MaterialModifier_ = x.MaterialModifier_;
      }

      return *this;
    }

    ActualDatumFeatureType::
    ~ActualDatumFeatureType ()
    {
    }

    // NominalDatumFeatureType
    //

    NominalDatumFeatureType::
    NominalDatumFeatureType (const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::DatumFeatureBaseType (FeatureItemId)
    {
    }

    NominalDatumFeatureType::
    NominalDatumFeatureType (::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::DatumFeatureBaseType (FeatureItemId)
    {
    }

    NominalDatumFeatureType::
    NominalDatumFeatureType (const NominalDatumFeatureType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::DatumFeatureBaseType (x, f, c)
    {
    }

    NominalDatumFeatureType::
    NominalDatumFeatureType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::DatumFeatureBaseType (e, f, c)
    {
    }

    NominalDatumFeatureType* NominalDatumFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NominalDatumFeatureType (*this, f, c);
    }

    NominalDatumFeatureType::
    ~NominalDatumFeatureType ()
    {
    }

    // DatumFeatureSimulatorModifierType
    //

    const DatumFeatureSimulatorModifierType::BasicSize_type DatumFeatureSimulatorModifierType::BasicSize_default_value_ (
      "BASIC");

    DatumFeatureSimulatorModifierType::
    DatumFeatureSimulatorModifierType ()
    : ::xml_schema::type (),
      LinearSize_ (this),
      DiametricalSize_ (this),
      BasicSize_ (this)
    {
    }

    DatumFeatureSimulatorModifierType::
    DatumFeatureSimulatorModifierType (const DatumFeatureSimulatorModifierType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      LinearSize_ (x.LinearSize_, f, this),
      DiametricalSize_ (x.DiametricalSize_, f, this),
      BasicSize_ (x.BasicSize_, f, this)
    {
    }

    DatumFeatureSimulatorModifierType::
    DatumFeatureSimulatorModifierType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      LinearSize_ (this),
      DiametricalSize_ (this),
      BasicSize_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DatumFeatureSimulatorModifierType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // LinearSize
        //
        if (n.name () == "LinearSize" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LinearSize_type > r (
            LinearSize_traits::create (i, f, this));

          if (!this->LinearSize_)
          {
            this->LinearSize_.set (r);
            continue;
          }
        }

        // DiametricalSize
        //
        if (n.name () == "DiametricalSize" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiametricalSize_type > r (
            DiametricalSize_traits::create (i, f, this));

          if (!this->DiametricalSize_)
          {
            this->DiametricalSize_.set (r);
            continue;
          }
        }

        // BasicSize
        //
        if (n.name () == "BasicSize" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BasicSize_type > r (
            BasicSize_traits::create (i, f, this));

          if (!this->BasicSize_)
          {
            this->BasicSize_.set (r);
            continue;
          }
        }

        break;
      }
    }

    DatumFeatureSimulatorModifierType* DatumFeatureSimulatorModifierType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumFeatureSimulatorModifierType (*this, f, c);
    }

    DatumFeatureSimulatorModifierType& DatumFeatureSimulatorModifierType::
    operator= (const DatumFeatureSimulatorModifierType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->LinearSize_ = x.LinearSize_;
        this->DiametricalSize_ = x.DiametricalSize_;
        this->BasicSize_ = x.BasicSize_;
      }

      return *this;
    }

    DatumFeatureSimulatorModifierType::
    ~DatumFeatureSimulatorModifierType ()
    {
    }

    // DatumReferenceFrameType
    //

    DatumReferenceFrameType::
    DatumReferenceFrameType (const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      Datum_ (this),
      Name_ (this),
      Description_ (this),
      CoordinateSystemId_ (this),
      id_ (id, this)
    {
    }

    DatumReferenceFrameType::
    DatumReferenceFrameType (const DatumReferenceFrameType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      Datum_ (x.Datum_, f, this),
      Name_ (x.Name_, f, this),
      Description_ (x.Description_, f, this),
      CoordinateSystemId_ (x.CoordinateSystemId_, f, this),
      id_ (x.id_, f, this)
    {
    }

    DatumReferenceFrameType::
    DatumReferenceFrameType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      Datum_ (this),
      Name_ (this),
      Description_ (this),
      CoordinateSystemId_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DatumReferenceFrameType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Attributes
        //
        if (n.name () == "Attributes" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (r);
            continue;
          }
        }

        // Datum
        //
        if (n.name () == "Datum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Datum_type > r (
            Datum_traits::create (i, f, this));

          this->Datum_.push_back (r);
          continue;
        }

        // Name
        //
        if (n.name () == "Name" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!this->Name_)
          {
            this->Name_.set (r);
            continue;
          }
        }

        // Description
        //
        if (n.name () == "Description" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (r);
            continue;
          }
        }

        // CoordinateSystemId
        //
        if (n.name () == "CoordinateSystemId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CoordinateSystemId_type > r (
            CoordinateSystemId_traits::create (i, f, this));

          if (!this->CoordinateSystemId_)
          {
            this->CoordinateSystemId_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    DatumReferenceFrameType* DatumReferenceFrameType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumReferenceFrameType (*this, f, c);
    }

    DatumReferenceFrameType& DatumReferenceFrameType::
    operator= (const DatumReferenceFrameType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->Datum_ = x.Datum_;
        this->Name_ = x.Name_;
        this->Description_ = x.Description_;
        this->CoordinateSystemId_ = x.CoordinateSystemId_;
        this->id_ = x.id_;
      }

      return *this;
    }

    DatumReferenceFrameType::
    ~DatumReferenceFrameType ()
    {
    }

    // DegreeOfFreedomEnumType
    //

    DegreeOfFreedomEnumType::
    DegreeOfFreedomEnumType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_DegreeOfFreedomEnumType_convert ();
    }

    DegreeOfFreedomEnumType::
    DegreeOfFreedomEnumType (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_DegreeOfFreedomEnumType_convert ();
    }

    DegreeOfFreedomEnumType::
    DegreeOfFreedomEnumType (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_DegreeOfFreedomEnumType_convert ();
    }

    DegreeOfFreedomEnumType* DegreeOfFreedomEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DegreeOfFreedomEnumType (*this, f, c);
    }

    DegreeOfFreedomEnumType::value DegreeOfFreedomEnumType::
    _xsd_DegreeOfFreedomEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_DegreeOfFreedomEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_DegreeOfFreedomEnumType_indexes_,
                        _xsd_DegreeOfFreedomEnumType_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_DegreeOfFreedomEnumType_indexes_ + 6 || _xsd_DegreeOfFreedomEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const DegreeOfFreedomEnumType::
    _xsd_DegreeOfFreedomEnumType_literals_[6] =
    {
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z"
    };

    const DegreeOfFreedomEnumType::value DegreeOfFreedomEnumType::
    _xsd_DegreeOfFreedomEnumType_indexes_[6] =
    {
      ::xsd::qif2::DegreeOfFreedomEnumType::U,
      ::xsd::qif2::DegreeOfFreedomEnumType::V,
      ::xsd::qif2::DegreeOfFreedomEnumType::W,
      ::xsd::qif2::DegreeOfFreedomEnumType::X,
      ::xsd::qif2::DegreeOfFreedomEnumType::Y,
      ::xsd::qif2::DegreeOfFreedomEnumType::Z
    };

    // ISODegreeOfFreedomEnumType
    //

    ISODegreeOfFreedomEnumType::
    ISODegreeOfFreedomEnumType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ISODegreeOfFreedomEnumType_convert ();
    }

    ISODegreeOfFreedomEnumType::
    ISODegreeOfFreedomEnumType (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ISODegreeOfFreedomEnumType_convert ();
    }

    ISODegreeOfFreedomEnumType::
    ISODegreeOfFreedomEnumType (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ISODegreeOfFreedomEnumType_convert ();
    }

    ISODegreeOfFreedomEnumType* ISODegreeOfFreedomEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ISODegreeOfFreedomEnumType (*this, f, c);
    }

    ISODegreeOfFreedomEnumType::value ISODegreeOfFreedomEnumType::
    _xsd_ISODegreeOfFreedomEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ISODegreeOfFreedomEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ISODegreeOfFreedomEnumType_indexes_,
                        _xsd_ISODegreeOfFreedomEnumType_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_ISODegreeOfFreedomEnumType_indexes_ + 6 || _xsd_ISODegreeOfFreedomEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const ISODegreeOfFreedomEnumType::
    _xsd_ISODegreeOfFreedomEnumType_literals_[6] =
    {
      "Rx",
      "Ry",
      "Rz",
      "Tx",
      "Ty",
      "Tz"
    };

    const ISODegreeOfFreedomEnumType::value ISODegreeOfFreedomEnumType::
    _xsd_ISODegreeOfFreedomEnumType_indexes_[6] =
    {
      ::xsd::qif2::ISODegreeOfFreedomEnumType::Rx,
      ::xsd::qif2::ISODegreeOfFreedomEnumType::Ry,
      ::xsd::qif2::ISODegreeOfFreedomEnumType::Rz,
      ::xsd::qif2::ISODegreeOfFreedomEnumType::Tx,
      ::xsd::qif2::ISODegreeOfFreedomEnumType::Ty,
      ::xsd::qif2::ISODegreeOfFreedomEnumType::Tz
    };

    // IntersectionPlaneEnumType
    //

    IntersectionPlaneEnumType::
    IntersectionPlaneEnumType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_IntersectionPlaneEnumType_convert ();
    }

    IntersectionPlaneEnumType::
    IntersectionPlaneEnumType (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_IntersectionPlaneEnumType_convert ();
    }

    IntersectionPlaneEnumType::
    IntersectionPlaneEnumType (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_IntersectionPlaneEnumType_convert ();
    }

    IntersectionPlaneEnumType* IntersectionPlaneEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IntersectionPlaneEnumType (*this, f, c);
    }

    IntersectionPlaneEnumType::value IntersectionPlaneEnumType::
    _xsd_IntersectionPlaneEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_IntersectionPlaneEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_IntersectionPlaneEnumType_indexes_,
                        _xsd_IntersectionPlaneEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_IntersectionPlaneEnumType_indexes_ + 3 || _xsd_IntersectionPlaneEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const IntersectionPlaneEnumType::
    _xsd_IntersectionPlaneEnumType_literals_[3] =
    {
      "PARALLEL",
      "PERPENDICULAR",
      "INCLUDING"
    };

    const IntersectionPlaneEnumType::value IntersectionPlaneEnumType::
    _xsd_IntersectionPlaneEnumType_indexes_[3] =
    {
      ::xsd::qif2::IntersectionPlaneEnumType::INCLUDING,
      ::xsd::qif2::IntersectionPlaneEnumType::PARALLEL,
      ::xsd::qif2::IntersectionPlaneEnumType::PERPENDICULAR
    };

    // IntersectionPlaneType
    //

    IntersectionPlaneType::
    IntersectionPlaneType (const IntersectionPlaneEnum_type& IntersectionPlaneEnum,
                           const DatumDefinitionId_type& DatumDefinitionId)
    : ::xml_schema::type (),
      IntersectionPlaneEnum_ (IntersectionPlaneEnum, this),
      DatumDefinitionId_ (DatumDefinitionId, this)
    {
    }

    IntersectionPlaneType::
    IntersectionPlaneType (const IntersectionPlaneEnum_type& IntersectionPlaneEnum,
                           ::std::auto_ptr< DatumDefinitionId_type > DatumDefinitionId)
    : ::xml_schema::type (),
      IntersectionPlaneEnum_ (IntersectionPlaneEnum, this),
      DatumDefinitionId_ (DatumDefinitionId, this)
    {
    }

    IntersectionPlaneType::
    IntersectionPlaneType (const IntersectionPlaneType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      IntersectionPlaneEnum_ (x.IntersectionPlaneEnum_, f, this),
      DatumDefinitionId_ (x.DatumDefinitionId_, f, this)
    {
    }

    IntersectionPlaneType::
    IntersectionPlaneType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      IntersectionPlaneEnum_ (this),
      DatumDefinitionId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void IntersectionPlaneType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // IntersectionPlaneEnum
        //
        if (n.name () == "IntersectionPlaneEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< IntersectionPlaneEnum_type > r (
            IntersectionPlaneEnum_traits::create (i, f, this));

          if (!IntersectionPlaneEnum_.present ())
          {
            this->IntersectionPlaneEnum_.set (r);
            continue;
          }
        }

        // DatumDefinitionId
        //
        if (n.name () == "DatumDefinitionId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DatumDefinitionId_type > r (
            DatumDefinitionId_traits::create (i, f, this));

          if (!DatumDefinitionId_.present ())
          {
            this->DatumDefinitionId_.set (r);
            continue;
          }
        }

        break;
      }

      if (!IntersectionPlaneEnum_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "IntersectionPlaneEnum",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!DatumDefinitionId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DatumDefinitionId",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    IntersectionPlaneType* IntersectionPlaneType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IntersectionPlaneType (*this, f, c);
    }

    IntersectionPlaneType& IntersectionPlaneType::
    operator= (const IntersectionPlaneType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->IntersectionPlaneEnum_ = x.IntersectionPlaneEnum_;
        this->DatumDefinitionId_ = x.DatumDefinitionId_;
      }

      return *this;
    }

    IntersectionPlaneType::
    ~IntersectionPlaneType ()
    {
    }

    // ModifyingPlaneEnumType
    //

    ModifyingPlaneEnumType::
    ModifyingPlaneEnumType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ModifyingPlaneEnumType_convert ();
    }

    ModifyingPlaneEnumType::
    ModifyingPlaneEnumType (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ModifyingPlaneEnumType_convert ();
    }

    ModifyingPlaneEnumType::
    ModifyingPlaneEnumType (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ModifyingPlaneEnumType_convert ();
    }

    ModifyingPlaneEnumType* ModifyingPlaneEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ModifyingPlaneEnumType (*this, f, c);
    }

    ModifyingPlaneEnumType::value ModifyingPlaneEnumType::
    _xsd_ModifyingPlaneEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ModifyingPlaneEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ModifyingPlaneEnumType_indexes_,
                        _xsd_ModifyingPlaneEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_ModifyingPlaneEnumType_indexes_ + 3 || _xsd_ModifyingPlaneEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const ModifyingPlaneEnumType::
    _xsd_ModifyingPlaneEnumType_literals_[3] =
    {
      "PARALLEL",
      "PERPENDICULAR",
      "INCLINED"
    };

    const ModifyingPlaneEnumType::value ModifyingPlaneEnumType::
    _xsd_ModifyingPlaneEnumType_indexes_[3] =
    {
      ::xsd::qif2::ModifyingPlaneEnumType::INCLINED,
      ::xsd::qif2::ModifyingPlaneEnumType::PARALLEL,
      ::xsd::qif2::ModifyingPlaneEnumType::PERPENDICULAR
    };

    // DirectionFeatureType
    //

    DirectionFeatureType::
    DirectionFeatureType (const DirectionFeatureEnum_type& DirectionFeatureEnum,
                          const DatumDefinitionId_type& DatumDefinitionId)
    : ::xml_schema::type (),
      DirectionFeatureEnum_ (DirectionFeatureEnum, this),
      DatumDefinitionId_ (DatumDefinitionId, this)
    {
    }

    DirectionFeatureType::
    DirectionFeatureType (const DirectionFeatureEnum_type& DirectionFeatureEnum,
                          ::std::auto_ptr< DatumDefinitionId_type > DatumDefinitionId)
    : ::xml_schema::type (),
      DirectionFeatureEnum_ (DirectionFeatureEnum, this),
      DatumDefinitionId_ (DatumDefinitionId, this)
    {
    }

    DirectionFeatureType::
    DirectionFeatureType (const DirectionFeatureType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DirectionFeatureEnum_ (x.DirectionFeatureEnum_, f, this),
      DatumDefinitionId_ (x.DatumDefinitionId_, f, this)
    {
    }

    DirectionFeatureType::
    DirectionFeatureType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DirectionFeatureEnum_ (this),
      DatumDefinitionId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DirectionFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DirectionFeatureEnum
        //
        if (n.name () == "DirectionFeatureEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DirectionFeatureEnum_type > r (
            DirectionFeatureEnum_traits::create (i, f, this));

          if (!DirectionFeatureEnum_.present ())
          {
            this->DirectionFeatureEnum_.set (r);
            continue;
          }
        }

        // DatumDefinitionId
        //
        if (n.name () == "DatumDefinitionId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DatumDefinitionId_type > r (
            DatumDefinitionId_traits::create (i, f, this));

          if (!DatumDefinitionId_.present ())
          {
            this->DatumDefinitionId_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DirectionFeatureEnum_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DirectionFeatureEnum",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!DatumDefinitionId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DatumDefinitionId",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    DirectionFeatureType* DirectionFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DirectionFeatureType (*this, f, c);
    }

    DirectionFeatureType& DirectionFeatureType::
    operator= (const DirectionFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DirectionFeatureEnum_ = x.DirectionFeatureEnum_;
        this->DatumDefinitionId_ = x.DatumDefinitionId_;
      }

      return *this;
    }

    DirectionFeatureType::
    ~DirectionFeatureType ()
    {
    }

    // CollectionPlaneType
    //

    CollectionPlaneType::
    CollectionPlaneType (const CollectionPlaneEnum_type& CollectionPlaneEnum,
                         const DatumDefinitionId_type& DatumDefinitionId)
    : ::xml_schema::type (),
      CollectionPlaneEnum_ (CollectionPlaneEnum, this),
      DatumDefinitionId_ (DatumDefinitionId, this)
    {
    }

    CollectionPlaneType::
    CollectionPlaneType (const CollectionPlaneEnum_type& CollectionPlaneEnum,
                         ::std::auto_ptr< DatumDefinitionId_type > DatumDefinitionId)
    : ::xml_schema::type (),
      CollectionPlaneEnum_ (CollectionPlaneEnum, this),
      DatumDefinitionId_ (DatumDefinitionId, this)
    {
    }

    CollectionPlaneType::
    CollectionPlaneType (const CollectionPlaneType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CollectionPlaneEnum_ (x.CollectionPlaneEnum_, f, this),
      DatumDefinitionId_ (x.DatumDefinitionId_, f, this)
    {
    }

    CollectionPlaneType::
    CollectionPlaneType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CollectionPlaneEnum_ (this),
      DatumDefinitionId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CollectionPlaneType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CollectionPlaneEnum
        //
        if (n.name () == "CollectionPlaneEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CollectionPlaneEnum_type > r (
            CollectionPlaneEnum_traits::create (i, f, this));

          if (!CollectionPlaneEnum_.present ())
          {
            this->CollectionPlaneEnum_.set (r);
            continue;
          }
        }

        // DatumDefinitionId
        //
        if (n.name () == "DatumDefinitionId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DatumDefinitionId_type > r (
            DatumDefinitionId_traits::create (i, f, this));

          if (!DatumDefinitionId_.present ())
          {
            this->DatumDefinitionId_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CollectionPlaneEnum_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CollectionPlaneEnum",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!DatumDefinitionId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DatumDefinitionId",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CollectionPlaneType* CollectionPlaneType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CollectionPlaneType (*this, f, c);
    }

    CollectionPlaneType& CollectionPlaneType::
    operator= (const CollectionPlaneType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CollectionPlaneEnum_ = x.CollectionPlaneEnum_;
        this->DatumDefinitionId_ = x.DatumDefinitionId_;
      }

      return *this;
    }

    CollectionPlaneType::
    ~CollectionPlaneType ()
    {
    }

    // OrientationPlaneType
    //

    OrientationPlaneType::
    OrientationPlaneType (const OrientationPlaneEnum_type& OrientationPlaneEnum,
                          const DatumDefinitionId_type& DatumDefinitionId)
    : ::xml_schema::type (),
      OrientationPlaneEnum_ (OrientationPlaneEnum, this),
      DatumDefinitionId_ (DatumDefinitionId, this)
    {
    }

    OrientationPlaneType::
    OrientationPlaneType (const OrientationPlaneEnum_type& OrientationPlaneEnum,
                          ::std::auto_ptr< DatumDefinitionId_type > DatumDefinitionId)
    : ::xml_schema::type (),
      OrientationPlaneEnum_ (OrientationPlaneEnum, this),
      DatumDefinitionId_ (DatumDefinitionId, this)
    {
    }

    OrientationPlaneType::
    OrientationPlaneType (const OrientationPlaneType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      OrientationPlaneEnum_ (x.OrientationPlaneEnum_, f, this),
      DatumDefinitionId_ (x.DatumDefinitionId_, f, this)
    {
    }

    OrientationPlaneType::
    OrientationPlaneType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      OrientationPlaneEnum_ (this),
      DatumDefinitionId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OrientationPlaneType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // OrientationPlaneEnum
        //
        if (n.name () == "OrientationPlaneEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OrientationPlaneEnum_type > r (
            OrientationPlaneEnum_traits::create (i, f, this));

          if (!OrientationPlaneEnum_.present ())
          {
            this->OrientationPlaneEnum_.set (r);
            continue;
          }
        }

        // DatumDefinitionId
        //
        if (n.name () == "DatumDefinitionId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DatumDefinitionId_type > r (
            DatumDefinitionId_traits::create (i, f, this));

          if (!DatumDefinitionId_.present ())
          {
            this->DatumDefinitionId_.set (r);
            continue;
          }
        }

        break;
      }

      if (!OrientationPlaneEnum_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "OrientationPlaneEnum",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!DatumDefinitionId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DatumDefinitionId",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OrientationPlaneType* OrientationPlaneType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OrientationPlaneType (*this, f, c);
    }

    OrientationPlaneType& OrientationPlaneType::
    operator= (const OrientationPlaneType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->OrientationPlaneEnum_ = x.OrientationPlaneEnum_;
        this->DatumDefinitionId_ = x.DatumDefinitionId_;
      }

      return *this;
    }

    OrientationPlaneType::
    ~OrientationPlaneType ()
    {
    }

    // ReducedDatumEnumType
    //

    ReducedDatumEnumType::
    ReducedDatumEnumType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ReducedDatumEnumType_convert ();
    }

    ReducedDatumEnumType::
    ReducedDatumEnumType (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ReducedDatumEnumType_convert ();
    }

    ReducedDatumEnumType::
    ReducedDatumEnumType (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ReducedDatumEnumType_convert ();
    }

    ReducedDatumEnumType* ReducedDatumEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ReducedDatumEnumType (*this, f, c);
    }

    ReducedDatumEnumType::value ReducedDatumEnumType::
    _xsd_ReducedDatumEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ReducedDatumEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ReducedDatumEnumType_indexes_,
                        _xsd_ReducedDatumEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_ReducedDatumEnumType_indexes_ + 3 || _xsd_ReducedDatumEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const ReducedDatumEnumType::
    _xsd_ReducedDatumEnumType_literals_[3] =
    {
      "PT",
      "SL",
      "PL"
    };

    const ReducedDatumEnumType::value ReducedDatumEnumType::
    _xsd_ReducedDatumEnumType_indexes_[3] =
    {
      ::xsd::qif2::ReducedDatumEnumType::PL,
      ::xsd::qif2::ReducedDatumEnumType::PT,
      ::xsd::qif2::ReducedDatumEnumType::SL
    };

    // DegreesOfFreedomType
    //

    DegreesOfFreedomType::
    DegreesOfFreedomType ()
    : ::xml_schema::type (),
      DegreeOfFreedom_ (this),
      ISODegreeOfFreedom_ (this)
    {
    }

    DegreesOfFreedomType::
    DegreesOfFreedomType (const DegreesOfFreedomType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DegreeOfFreedom_ (x.DegreeOfFreedom_, f, this),
      ISODegreeOfFreedom_ (x.ISODegreeOfFreedom_, f, this)
    {
    }

    DegreesOfFreedomType::
    DegreesOfFreedomType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DegreeOfFreedom_ (this),
      ISODegreeOfFreedom_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DegreesOfFreedomType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DegreeOfFreedom
        //
        if (n.name () == "DegreeOfFreedom" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DegreeOfFreedom_type > r (
            DegreeOfFreedom_traits::create (i, f, this));

          this->DegreeOfFreedom_.push_back (r);
          continue;
        }

        // ISODegreeOfFreedom
        //
        if (n.name () == "ISODegreeOfFreedom" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ISODegreeOfFreedom_type > r (
            ISODegreeOfFreedom_traits::create (i, f, this));

          this->ISODegreeOfFreedom_.push_back (r);
          continue;
        }

        break;
      }
    }

    DegreesOfFreedomType* DegreesOfFreedomType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DegreesOfFreedomType (*this, f, c);
    }

    DegreesOfFreedomType& DegreesOfFreedomType::
    operator= (const DegreesOfFreedomType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DegreeOfFreedom_ = x.DegreeOfFreedom_;
        this->ISODegreeOfFreedom_ = x.ISODegreeOfFreedom_;
      }

      return *this;
    }

    DegreesOfFreedomType::
    ~DegreesOfFreedomType ()
    {
    }

    // DiameterModifierEnumType
    //

    DiameterModifierEnumType::
    DiameterModifierEnumType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_DiameterModifierEnumType_convert ();
    }

    DiameterModifierEnumType::
    DiameterModifierEnumType (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_DiameterModifierEnumType_convert ();
    }

    DiameterModifierEnumType::
    DiameterModifierEnumType (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_DiameterModifierEnumType_convert ();
    }

    DiameterModifierEnumType* DiameterModifierEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DiameterModifierEnumType (*this, f, c);
    }

    DiameterModifierEnumType::value DiameterModifierEnumType::
    _xsd_DiameterModifierEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_DiameterModifierEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_DiameterModifierEnumType_indexes_,
                        _xsd_DiameterModifierEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_DiameterModifierEnumType_indexes_ + 3 || _xsd_DiameterModifierEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const DiameterModifierEnumType::
    _xsd_DiameterModifierEnumType_literals_[3] =
    {
      "PD",
      "MD",
      "LD"
    };

    const DiameterModifierEnumType::value DiameterModifierEnumType::
    _xsd_DiameterModifierEnumType_indexes_[3] =
    {
      ::xsd::qif2::DiameterModifierEnumType::LD,
      ::xsd::qif2::DiameterModifierEnumType::MD,
      ::xsd::qif2::DiameterModifierEnumType::PD
    };

    // SectionModifierEnumType
    //

    SectionModifierEnumType::
    SectionModifierEnumType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_SectionModifierEnumType_convert ();
    }

    SectionModifierEnumType::
    SectionModifierEnumType (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_SectionModifierEnumType_convert ();
    }

    SectionModifierEnumType::
    SectionModifierEnumType (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_SectionModifierEnumType_convert ();
    }

    SectionModifierEnumType* SectionModifierEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SectionModifierEnumType (*this, f, c);
    }

    SectionModifierEnumType::value SectionModifierEnumType::
    _xsd_SectionModifierEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_SectionModifierEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_SectionModifierEnumType_indexes_,
                        _xsd_SectionModifierEnumType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_SectionModifierEnumType_indexes_ + 2 || _xsd_SectionModifierEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const SectionModifierEnumType::
    _xsd_SectionModifierEnumType_literals_[2] =
    {
      "ACS",
      "ALS"
    };

    const SectionModifierEnumType::value SectionModifierEnumType::
    _xsd_SectionModifierEnumType_indexes_[2] =
    {
      ::xsd::qif2::SectionModifierEnumType::ACS,
      ::xsd::qif2::SectionModifierEnumType::ALS
    };

    // PointWithNormalBaseType
    //

    PointWithNormalBaseType::
    PointWithNormalBaseType (const Point_type& Point,
                             const id_type& id)
    : ::xml_schema::type (),
      Point_ (Point, this),
      Normal_ (this),
      id_ (id, this)
    {
    }

    PointWithNormalBaseType::
    PointWithNormalBaseType (::std::auto_ptr< Point_type > Point,
                             const id_type& id)
    : ::xml_schema::type (),
      Point_ (Point, this),
      Normal_ (this),
      id_ (id, this)
    {
    }

    PointWithNormalBaseType::
    PointWithNormalBaseType (const PointWithNormalBaseType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Point_ (x.Point_, f, this),
      Normal_ (x.Normal_, f, this),
      id_ (x.id_, f, this)
    {
    }

    PointWithNormalBaseType::
    PointWithNormalBaseType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Point_ (this),
      Normal_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointWithNormalBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Point
        //
        if (n.name () == "Point" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Point_type > r (
            Point_traits::create (i, f, this));

          if (!Point_.present ())
          {
            this->Point_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Point_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Point",
          "http://qifstandards.org/xsd/qif2");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    PointWithNormalBaseType* PointWithNormalBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointWithNormalBaseType (*this, f, c);
    }

    PointWithNormalBaseType& PointWithNormalBaseType::
    operator= (const PointWithNormalBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Point_ = x.Point_;
        this->Normal_ = x.Normal_;
        this->id_ = x.id_;
      }

      return *this;
    }

    PointWithNormalBaseType::
    ~PointWithNormalBaseType ()
    {
    }

    // ActualPointWithNormalBaseType
    //

    ActualPointWithNormalBaseType::
    ActualPointWithNormalBaseType (const Point_type& Point,
                                   const id_type& id)
    : ::xml_schema::type (),
      Point_ (Point, this),
      Normal_ (this),
      id_ (id, this)
    {
    }

    ActualPointWithNormalBaseType::
    ActualPointWithNormalBaseType (::std::auto_ptr< Point_type > Point,
                                   const id_type& id)
    : ::xml_schema::type (),
      Point_ (Point, this),
      Normal_ (this),
      id_ (id, this)
    {
    }

    ActualPointWithNormalBaseType::
    ActualPointWithNormalBaseType (const ActualPointWithNormalBaseType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Point_ (x.Point_, f, this),
      Normal_ (x.Normal_, f, this),
      id_ (x.id_, f, this)
    {
    }

    ActualPointWithNormalBaseType::
    ActualPointWithNormalBaseType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Point_ (this),
      Normal_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ActualPointWithNormalBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Point
        //
        if (n.name () == "Point" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Point_type > r (
            Point_traits::create (i, f, this));

          if (!Point_.present ())
          {
            this->Point_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Point_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Point",
          "http://qifstandards.org/xsd/qif2");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    ActualPointWithNormalBaseType* ActualPointWithNormalBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualPointWithNormalBaseType (*this, f, c);
    }

    ActualPointWithNormalBaseType& ActualPointWithNormalBaseType::
    operator= (const ActualPointWithNormalBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Point_ = x.Point_;
        this->Normal_ = x.Normal_;
        this->id_ = x.id_;
      }

      return *this;
    }

    ActualPointWithNormalBaseType::
    ~ActualPointWithNormalBaseType ()
    {
    }

    // MeasurePointNominalType
    //

    MeasurePointNominalType::
    MeasurePointNominalType (const Point_type& Point,
                             const id_type& id)
    : ::xsd::qif2::PointWithNormalBaseType (Point,
                                            id),
      MeasurementDeviceId_ (this),
      SensorId_ (this)
    {
    }

    MeasurePointNominalType::
    MeasurePointNominalType (::std::auto_ptr< Point_type > Point,
                             const id_type& id)
    : ::xsd::qif2::PointWithNormalBaseType (Point,
                                            id),
      MeasurementDeviceId_ (this),
      SensorId_ (this)
    {
    }

    MeasurePointNominalType::
    MeasurePointNominalType (const MeasurePointNominalType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::PointWithNormalBaseType (x, f, c),
      MeasurementDeviceId_ (x.MeasurementDeviceId_, f, this),
      SensorId_ (x.SensorId_, f, this)
    {
    }

    MeasurePointNominalType::
    MeasurePointNominalType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::PointWithNormalBaseType (e, f | ::xml_schema::flags::base, c),
      MeasurementDeviceId_ (this),
      SensorId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MeasurePointNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::PointWithNormalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MeasurementDeviceId
        //
        if (n.name () == "MeasurementDeviceId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MeasurementDeviceId_type > r (
            MeasurementDeviceId_traits::create (i, f, this));

          if (!this->MeasurementDeviceId_)
          {
            this->MeasurementDeviceId_.set (r);
            continue;
          }
        }

        // SensorId
        //
        if (n.name () == "SensorId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SensorId_type > r (
            SensorId_traits::create (i, f, this));

          if (!this->SensorId_)
          {
            this->SensorId_.set (r);
            continue;
          }
        }

        break;
      }
    }

    MeasurePointNominalType* MeasurePointNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurePointNominalType (*this, f, c);
    }

    MeasurePointNominalType& MeasurePointNominalType::
    operator= (const MeasurePointNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::PointWithNormalBaseType& > (*this) = x;
        this->MeasurementDeviceId_ = x.MeasurementDeviceId_;
        this->SensorId_ = x.SensorId_;
      }

      return *this;
    }

    MeasurePointNominalType::
    ~MeasurePointNominalType ()
    {
    }

    // MeasurePointActualType
    //

    MeasurePointActualType::
    MeasurePointActualType (const Point_type& Point,
                            const id_type& id,
                            const Compensated_type& Compensated)
    : ::xsd::qif2::ActualPointWithNormalBaseType (Point,
                                                  id),
      Compensated_ (Compensated, this),
      ProbeRadius_ (this),
      MeasurementDeviceId_ (this),
      SensorId_ (this),
      MeasurePointNominalId_ (this)
    {
    }

    MeasurePointActualType::
    MeasurePointActualType (::std::auto_ptr< Point_type > Point,
                            const id_type& id,
                            const Compensated_type& Compensated)
    : ::xsd::qif2::ActualPointWithNormalBaseType (Point,
                                                  id),
      Compensated_ (Compensated, this),
      ProbeRadius_ (this),
      MeasurementDeviceId_ (this),
      SensorId_ (this),
      MeasurePointNominalId_ (this)
    {
    }

    MeasurePointActualType::
    MeasurePointActualType (const MeasurePointActualType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ActualPointWithNormalBaseType (x, f, c),
      Compensated_ (x.Compensated_, f, this),
      ProbeRadius_ (x.ProbeRadius_, f, this),
      MeasurementDeviceId_ (x.MeasurementDeviceId_, f, this),
      SensorId_ (x.SensorId_, f, this),
      MeasurePointNominalId_ (x.MeasurePointNominalId_, f, this)
    {
    }

    MeasurePointActualType::
    MeasurePointActualType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ActualPointWithNormalBaseType (e, f | ::xml_schema::flags::base, c),
      Compensated_ (this),
      ProbeRadius_ (this),
      MeasurementDeviceId_ (this),
      SensorId_ (this),
      MeasurePointNominalId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MeasurePointActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActualPointWithNormalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Compensated
        //
        if (n.name () == "Compensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!Compensated_.present ())
          {
            this->Compensated_.set (Compensated_traits::create (i, f, this));
            continue;
          }
        }

        // ProbeRadius
        //
        if (n.name () == "ProbeRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProbeRadius_type > r (
            ProbeRadius_traits::create (i, f, this));

          if (!this->ProbeRadius_)
          {
            this->ProbeRadius_.set (r);
            continue;
          }
        }

        // MeasurementDeviceId
        //
        if (n.name () == "MeasurementDeviceId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MeasurementDeviceId_type > r (
            MeasurementDeviceId_traits::create (i, f, this));

          if (!this->MeasurementDeviceId_)
          {
            this->MeasurementDeviceId_.set (r);
            continue;
          }
        }

        // SensorId
        //
        if (n.name () == "SensorId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SensorId_type > r (
            SensorId_traits::create (i, f, this));

          if (!this->SensorId_)
          {
            this->SensorId_.set (r);
            continue;
          }
        }

        // MeasurePointNominalId
        //
        if (n.name () == "MeasurePointNominalId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MeasurePointNominalId_type > r (
            MeasurePointNominalId_traits::create (i, f, this));

          if (!this->MeasurePointNominalId_)
          {
            this->MeasurePointNominalId_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Compensated_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Compensated",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    MeasurePointActualType* MeasurePointActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurePointActualType (*this, f, c);
    }

    MeasurePointActualType& MeasurePointActualType::
    operator= (const MeasurePointActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ActualPointWithNormalBaseType& > (*this) = x;
        this->Compensated_ = x.Compensated_;
        this->ProbeRadius_ = x.ProbeRadius_;
        this->MeasurementDeviceId_ = x.MeasurementDeviceId_;
        this->SensorId_ = x.SensorId_;
        this->MeasurePointNominalId_ = x.MeasurePointNominalId_;
      }

      return *this;
    }

    MeasurePointActualType::
    ~MeasurePointActualType ()
    {
    }

    // MovableDatumTargetDirectionType
    //

    MovableDatumTargetDirectionType::
    MovableDatumTargetDirectionType (const DatumTargetTranslationDirection_type& DatumTargetTranslationDirection)
    : ::xml_schema::type (),
      DatumTargetTranslationDirection_ (DatumTargetTranslationDirection, this)
    {
    }

    MovableDatumTargetDirectionType::
    MovableDatumTargetDirectionType (::std::auto_ptr< DatumTargetTranslationDirection_type > DatumTargetTranslationDirection)
    : ::xml_schema::type (),
      DatumTargetTranslationDirection_ (DatumTargetTranslationDirection, this)
    {
    }

    MovableDatumTargetDirectionType::
    MovableDatumTargetDirectionType (const MovableDatumTargetDirectionType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DatumTargetTranslationDirection_ (x.DatumTargetTranslationDirection_, f, this)
    {
    }

    MovableDatumTargetDirectionType::
    MovableDatumTargetDirectionType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DatumTargetTranslationDirection_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MovableDatumTargetDirectionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DatumTargetTranslationDirection
        //
        if (n.name () == "DatumTargetTranslationDirection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DatumTargetTranslationDirection_type > r (
            DatumTargetTranslationDirection_traits::create (i, f, this));

          if (!DatumTargetTranslationDirection_.present ())
          {
            this->DatumTargetTranslationDirection_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DatumTargetTranslationDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DatumTargetTranslationDirection",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    MovableDatumTargetDirectionType* MovableDatumTargetDirectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MovableDatumTargetDirectionType (*this, f, c);
    }

    MovableDatumTargetDirectionType& MovableDatumTargetDirectionType::
    operator= (const MovableDatumTargetDirectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DatumTargetTranslationDirection_ = x.DatumTargetTranslationDirection_;
      }

      return *this;
    }

    MovableDatumTargetDirectionType::
    ~MovableDatumTargetDirectionType ()
    {
    }

    // TargetPointActualType
    //

    TargetPointActualType::
    TargetPointActualType (const Point_type& Point,
                           const id_type& id)
    : ::xsd::qif2::ActualPointWithNormalBaseType (Point,
                                                  id)
    {
    }

    TargetPointActualType::
    TargetPointActualType (::std::auto_ptr< Point_type > Point,
                           const id_type& id)
    : ::xsd::qif2::ActualPointWithNormalBaseType (Point,
                                                  id)
    {
    }

    TargetPointActualType::
    TargetPointActualType (const TargetPointActualType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ActualPointWithNormalBaseType (x, f, c)
    {
    }

    TargetPointActualType::
    TargetPointActualType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ActualPointWithNormalBaseType (e, f, c)
    {
    }

    TargetPointActualType* TargetPointActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TargetPointActualType (*this, f, c);
    }

    TargetPointActualType::
    ~TargetPointActualType ()
    {
    }

    // TargetPointNominalType
    //

    TargetPointNominalType::
    TargetPointNominalType (const Point_type& Point,
                            const id_type& id)
    : ::xsd::qif2::PointWithNormalBaseType (Point,
                                            id)
    {
    }

    TargetPointNominalType::
    TargetPointNominalType (::std::auto_ptr< Point_type > Point,
                            const id_type& id)
    : ::xsd::qif2::PointWithNormalBaseType (Point,
                                            id)
    {
    }

    TargetPointNominalType::
    TargetPointNominalType (const TargetPointNominalType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::PointWithNormalBaseType (x, f, c)
    {
    }

    TargetPointNominalType::
    TargetPointNominalType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::PointWithNormalBaseType (e, f, c)
    {
    }

    TargetPointNominalType* TargetPointNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TargetPointNominalType (*this, f, c);
    }

    TargetPointNominalType::
    ~TargetPointNominalType ()
    {
    }

    // TransformListType
    //

    TransformListType::
    TransformListType (const N_type& N)
    : ::xml_schema::type (),
      Transform_ (this),
      N_ (N, this)
    {
    }

    TransformListType::
    TransformListType (const TransformListType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Transform_ (x.Transform_, f, this),
      N_ (x.N_, f, this)
    {
    }

    TransformListType::
    TransformListType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Transform_ (this),
      N_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TransformListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          this->Transform_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          this->N_.set (N_traits::create (i, f, this));
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    TransformListType* TransformListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TransformListType (*this, f, c);
    }

    TransformListType& TransformListType::
    operator= (const TransformListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Transform_ = x.Transform_;
        this->N_ = x.N_;
      }

      return *this;
    }

    TransformListType::
    ~TransformListType ()
    {
    }

    // TransformInstanceType
    //

    TransformInstanceType::
    TransformInstanceType (const id_type& id)
    : ::xsd::qif2::TransformMatrixType (),
      Attributes_ (this),
      Name_ (this),
      id_ (id, this)
    {
    }

    TransformInstanceType::
    TransformInstanceType (const TransformInstanceType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::TransformMatrixType (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      Name_ (x.Name_, f, this),
      id_ (x.id_, f, this)
    {
    }

    TransformInstanceType::
    TransformInstanceType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::TransformMatrixType (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      Name_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TransformInstanceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::TransformMatrixType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Attributes
        //
        if (n.name () == "Attributes" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (r);
            continue;
          }
        }

        // Name
        //
        if (n.name () == "Name" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!this->Name_)
          {
            this->Name_.set (r);
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    TransformInstanceType* TransformInstanceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TransformInstanceType (*this, f, c);
    }

    TransformInstanceType& TransformInstanceType::
    operator= (const TransformInstanceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::TransformMatrixType& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->Name_ = x.Name_;
        this->id_ = x.id_;
      }

      return *this;
    }

    TransformInstanceType::
    ~TransformInstanceType ()
    {
    }

    // LinearCoordinateDirectionEnumType
    //

    LinearCoordinateDirectionEnumType::
    LinearCoordinateDirectionEnumType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_LinearCoordinateDirectionEnumType_convert ();
    }

    LinearCoordinateDirectionEnumType::
    LinearCoordinateDirectionEnumType (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_LinearCoordinateDirectionEnumType_convert ();
    }

    LinearCoordinateDirectionEnumType::
    LinearCoordinateDirectionEnumType (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_LinearCoordinateDirectionEnumType_convert ();
    }

    LinearCoordinateDirectionEnumType* LinearCoordinateDirectionEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearCoordinateDirectionEnumType (*this, f, c);
    }

    LinearCoordinateDirectionEnumType::value LinearCoordinateDirectionEnumType::
    _xsd_LinearCoordinateDirectionEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_LinearCoordinateDirectionEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_LinearCoordinateDirectionEnumType_indexes_,
                        _xsd_LinearCoordinateDirectionEnumType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_LinearCoordinateDirectionEnumType_indexes_ + 4 || _xsd_LinearCoordinateDirectionEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const LinearCoordinateDirectionEnumType::
    _xsd_LinearCoordinateDirectionEnumType_literals_[4] =
    {
      "XAXIS",
      "YAXIS",
      "ZAXIS",
      "RADIAL"
    };

    const LinearCoordinateDirectionEnumType::value LinearCoordinateDirectionEnumType::
    _xsd_LinearCoordinateDirectionEnumType_indexes_[4] =
    {
      ::xsd::qif2::LinearCoordinateDirectionEnumType::RADIAL,
      ::xsd::qif2::LinearCoordinateDirectionEnumType::XAXIS,
      ::xsd::qif2::LinearCoordinateDirectionEnumType::YAXIS,
      ::xsd::qif2::LinearCoordinateDirectionEnumType::ZAXIS
    };

    // AngularCoordinateDirectionEnumType
    //

    AngularCoordinateDirectionEnumType::
    AngularCoordinateDirectionEnumType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_AngularCoordinateDirectionEnumType_convert ();
    }

    AngularCoordinateDirectionEnumType::
    AngularCoordinateDirectionEnumType (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_AngularCoordinateDirectionEnumType_convert ();
    }

    AngularCoordinateDirectionEnumType::
    AngularCoordinateDirectionEnumType (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_AngularCoordinateDirectionEnumType_convert ();
    }

    AngularCoordinateDirectionEnumType* AngularCoordinateDirectionEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngularCoordinateDirectionEnumType (*this, f, c);
    }

    AngularCoordinateDirectionEnumType::value AngularCoordinateDirectionEnumType::
    _xsd_AngularCoordinateDirectionEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_AngularCoordinateDirectionEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_AngularCoordinateDirectionEnumType_indexes_,
                        _xsd_AngularCoordinateDirectionEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_AngularCoordinateDirectionEnumType_indexes_ + 3 || _xsd_AngularCoordinateDirectionEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const AngularCoordinateDirectionEnumType::
    _xsd_AngularCoordinateDirectionEnumType_literals_[3] =
    {
      "ANGULAR",
      "AZIMUTH",
      "POLAR"
    };

    const AngularCoordinateDirectionEnumType::value AngularCoordinateDirectionEnumType::
    _xsd_AngularCoordinateDirectionEnumType_indexes_[3] =
    {
      ::xsd::qif2::AngularCoordinateDirectionEnumType::ANGULAR,
      ::xsd::qif2::AngularCoordinateDirectionEnumType::AZIMUTH,
      ::xsd::qif2::AngularCoordinateDirectionEnumType::POLAR
    };

    // SubstituteFeatureAlgorithmBaseType
    //

    SubstituteFeatureAlgorithmBaseType::
    SubstituteFeatureAlgorithmBaseType ()
    : ::xml_schema::type ()
    {
    }

    SubstituteFeatureAlgorithmBaseType::
    SubstituteFeatureAlgorithmBaseType (const SubstituteFeatureAlgorithmBaseType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    SubstituteFeatureAlgorithmBaseType::
    SubstituteFeatureAlgorithmBaseType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    SubstituteFeatureAlgorithmBaseType::
    SubstituteFeatureAlgorithmBaseType (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    SubstituteFeatureAlgorithmBaseType::
    SubstituteFeatureAlgorithmBaseType (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    SubstituteFeatureAlgorithmBaseType* SubstituteFeatureAlgorithmBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SubstituteFeatureAlgorithmBaseType (*this, f, c);
    }

    SubstituteFeatureAlgorithmBaseType::
    ~SubstituteFeatureAlgorithmBaseType ()
    {
    }

    // FeatureOfSizeSubstituteFeatureAlgorithmEnumType
    //

    FeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    FeatureOfSizeSubstituteFeatureAlgorithmEnumType (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_FeatureOfSizeSubstituteFeatureAlgorithmEnumType_convert ();
    }

    FeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    FeatureOfSizeSubstituteFeatureAlgorithmEnumType (const ::xercesc::DOMAttr& a,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_FeatureOfSizeSubstituteFeatureAlgorithmEnumType_convert ();
    }

    FeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    FeatureOfSizeSubstituteFeatureAlgorithmEnumType (const ::std::string& s,
                                                     const ::xercesc::DOMElement* e,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_FeatureOfSizeSubstituteFeatureAlgorithmEnumType_convert ();
    }

    FeatureOfSizeSubstituteFeatureAlgorithmEnumType* FeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureOfSizeSubstituteFeatureAlgorithmEnumType (*this, f, c);
    }

    FeatureOfSizeSubstituteFeatureAlgorithmEnumType::value FeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    _xsd_FeatureOfSizeSubstituteFeatureAlgorithmEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_FeatureOfSizeSubstituteFeatureAlgorithmEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_FeatureOfSizeSubstituteFeatureAlgorithmEnumType_indexes_,
                        _xsd_FeatureOfSizeSubstituteFeatureAlgorithmEnumType_indexes_ + 5,
                        *this,
                        c));

      if (i == _xsd_FeatureOfSizeSubstituteFeatureAlgorithmEnumType_indexes_ + 5 || _xsd_FeatureOfSizeSubstituteFeatureAlgorithmEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const FeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    _xsd_FeatureOfSizeSubstituteFeatureAlgorithmEnumType_literals_[5] =
    {
      "LEASTSQUARES",
      "MINMAX",
      "MINCIRCUMSCRIBED",
      "MAXINSCRIBED",
      "UNDEFINED"
    };

    const FeatureOfSizeSubstituteFeatureAlgorithmEnumType::value FeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    _xsd_FeatureOfSizeSubstituteFeatureAlgorithmEnumType_indexes_[5] =
    {
      ::xsd::qif2::FeatureOfSizeSubstituteFeatureAlgorithmEnumType::LEASTSQUARES,
      ::xsd::qif2::FeatureOfSizeSubstituteFeatureAlgorithmEnumType::MAXINSCRIBED,
      ::xsd::qif2::FeatureOfSizeSubstituteFeatureAlgorithmEnumType::MINCIRCUMSCRIBED,
      ::xsd::qif2::FeatureOfSizeSubstituteFeatureAlgorithmEnumType::MINMAX,
      ::xsd::qif2::FeatureOfSizeSubstituteFeatureAlgorithmEnumType::UNDEFINED
    };

    // FeatureOfSizeSubstituteFeatureAlgorithmType
    //

    FeatureOfSizeSubstituteFeatureAlgorithmType::
    FeatureOfSizeSubstituteFeatureAlgorithmType ()
    : ::xsd::qif2::SubstituteFeatureAlgorithmBaseType (),
      FeatureOfSizeSubstituteFeatureAlgorithmEnum_ (this),
      OtherFeatureOfSizeSubstituteFeatureAlgorithm_ (this)
    {
    }

    FeatureOfSizeSubstituteFeatureAlgorithmType::
    FeatureOfSizeSubstituteFeatureAlgorithmType (const FeatureOfSizeSubstituteFeatureAlgorithmType& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xsd::qif2::SubstituteFeatureAlgorithmBaseType (x, f, c),
      FeatureOfSizeSubstituteFeatureAlgorithmEnum_ (x.FeatureOfSizeSubstituteFeatureAlgorithmEnum_, f, this),
      OtherFeatureOfSizeSubstituteFeatureAlgorithm_ (x.OtherFeatureOfSizeSubstituteFeatureAlgorithm_, f, this)
    {
    }

    FeatureOfSizeSubstituteFeatureAlgorithmType::
    FeatureOfSizeSubstituteFeatureAlgorithmType (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xsd::qif2::SubstituteFeatureAlgorithmBaseType (e, f | ::xml_schema::flags::base, c),
      FeatureOfSizeSubstituteFeatureAlgorithmEnum_ (this),
      OtherFeatureOfSizeSubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FeatureOfSizeSubstituteFeatureAlgorithmType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FeatureOfSizeSubstituteFeatureAlgorithmEnum
        //
        if (n.name () == "FeatureOfSizeSubstituteFeatureAlgorithmEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureOfSizeSubstituteFeatureAlgorithmEnum_type > r (
            FeatureOfSizeSubstituteFeatureAlgorithmEnum_traits::create (i, f, this));

          if (!this->FeatureOfSizeSubstituteFeatureAlgorithmEnum_)
          {
            this->FeatureOfSizeSubstituteFeatureAlgorithmEnum_.set (r);
            continue;
          }
        }

        // OtherFeatureOfSizeSubstituteFeatureAlgorithm
        //
        if (n.name () == "OtherFeatureOfSizeSubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherFeatureOfSizeSubstituteFeatureAlgorithm_type > r (
            OtherFeatureOfSizeSubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->OtherFeatureOfSizeSubstituteFeatureAlgorithm_)
          {
            this->OtherFeatureOfSizeSubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    FeatureOfSizeSubstituteFeatureAlgorithmType* FeatureOfSizeSubstituteFeatureAlgorithmType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureOfSizeSubstituteFeatureAlgorithmType (*this, f, c);
    }

    FeatureOfSizeSubstituteFeatureAlgorithmType& FeatureOfSizeSubstituteFeatureAlgorithmType::
    operator= (const FeatureOfSizeSubstituteFeatureAlgorithmType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::SubstituteFeatureAlgorithmBaseType& > (*this) = x;
        this->FeatureOfSizeSubstituteFeatureAlgorithmEnum_ = x.FeatureOfSizeSubstituteFeatureAlgorithmEnum_;
        this->OtherFeatureOfSizeSubstituteFeatureAlgorithm_ = x.OtherFeatureOfSizeSubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    FeatureOfSizeSubstituteFeatureAlgorithmType::
    ~FeatureOfSizeSubstituteFeatureAlgorithmType ()
    {
    }

    // NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType
    //

    NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType (const ::xercesc::DOMElement& e,
                                                        ::xml_schema::flags f,
                                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType_convert ();
    }

    NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType (const ::xercesc::DOMAttr& a,
                                                        ::xml_schema::flags f,
                                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType_convert ();
    }

    NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType (const ::std::string& s,
                                                        const ::xercesc::DOMElement* e,
                                                        ::xml_schema::flags f,
                                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType_convert ();
    }

    NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType* NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType (*this, f, c);
    }

    NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType::value NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    _xsd_NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType_indexes_,
                        _xsd_NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType_indexes_ + 3 || _xsd_NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    _xsd_NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType_literals_[3] =
    {
      "LEASTSQUARES",
      "MINMAX",
      "UNDEFINED"
    };

    const NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType::value NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType::
    _xsd_NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType_indexes_[3] =
    {
      ::xsd::qif2::NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType::LEASTSQUARES,
      ::xsd::qif2::NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType::MINMAX,
      ::xsd::qif2::NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType::UNDEFINED
    };

    // NonFeatureOfSizeSubstituteFeatureAlgorithmType
    //

    NonFeatureOfSizeSubstituteFeatureAlgorithmType::
    NonFeatureOfSizeSubstituteFeatureAlgorithmType ()
    : ::xsd::qif2::SubstituteFeatureAlgorithmBaseType (),
      NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_ (this),
      OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_ (this)
    {
    }

    NonFeatureOfSizeSubstituteFeatureAlgorithmType::
    NonFeatureOfSizeSubstituteFeatureAlgorithmType (const NonFeatureOfSizeSubstituteFeatureAlgorithmType& x,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
    : ::xsd::qif2::SubstituteFeatureAlgorithmBaseType (x, f, c),
      NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_ (x.NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_, f, this),
      OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_ (x.OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_, f, this)
    {
    }

    NonFeatureOfSizeSubstituteFeatureAlgorithmType::
    NonFeatureOfSizeSubstituteFeatureAlgorithmType (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
    : ::xsd::qif2::SubstituteFeatureAlgorithmBaseType (e, f | ::xml_schema::flags::base, c),
      NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_ (this),
      OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void NonFeatureOfSizeSubstituteFeatureAlgorithmType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // NonFeatureOfSizeSubstituteFeatureAlgorithmEnum
        //
        if (n.name () == "NonFeatureOfSizeSubstituteFeatureAlgorithmEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_type > r (
            NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_traits::create (i, f, this));

          if (!this->NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_)
          {
            this->NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_.set (r);
            continue;
          }
        }

        // OtherNonFeatureOfSizeSubstituteFeatureAlgorithm
        //
        if (n.name () == "OtherNonFeatureOfSizeSubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_type > r (
            OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_)
          {
            this->OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    NonFeatureOfSizeSubstituteFeatureAlgorithmType* NonFeatureOfSizeSubstituteFeatureAlgorithmType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NonFeatureOfSizeSubstituteFeatureAlgorithmType (*this, f, c);
    }

    NonFeatureOfSizeSubstituteFeatureAlgorithmType& NonFeatureOfSizeSubstituteFeatureAlgorithmType::
    operator= (const NonFeatureOfSizeSubstituteFeatureAlgorithmType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::SubstituteFeatureAlgorithmBaseType& > (*this) = x;
        this->NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_ = x.NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_;
        this->OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_ = x.OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    NonFeatureOfSizeSubstituteFeatureAlgorithmType::
    ~NonFeatureOfSizeSubstituteFeatureAlgorithmType ()
    {
    }

    // CurveSubstituteFeatureAlgorithmEnumType
    //

    CurveSubstituteFeatureAlgorithmEnumType::
    CurveSubstituteFeatureAlgorithmEnumType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_CurveSubstituteFeatureAlgorithmEnumType_convert ();
    }

    CurveSubstituteFeatureAlgorithmEnumType::
    CurveSubstituteFeatureAlgorithmEnumType (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_CurveSubstituteFeatureAlgorithmEnumType_convert ();
    }

    CurveSubstituteFeatureAlgorithmEnumType::
    CurveSubstituteFeatureAlgorithmEnumType (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_CurveSubstituteFeatureAlgorithmEnumType_convert ();
    }

    CurveSubstituteFeatureAlgorithmEnumType* CurveSubstituteFeatureAlgorithmEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CurveSubstituteFeatureAlgorithmEnumType (*this, f, c);
    }

    CurveSubstituteFeatureAlgorithmEnumType::value CurveSubstituteFeatureAlgorithmEnumType::
    _xsd_CurveSubstituteFeatureAlgorithmEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CurveSubstituteFeatureAlgorithmEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_CurveSubstituteFeatureAlgorithmEnumType_indexes_,
                        _xsd_CurveSubstituteFeatureAlgorithmEnumType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_CurveSubstituteFeatureAlgorithmEnumType_indexes_ + 4 || _xsd_CurveSubstituteFeatureAlgorithmEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const CurveSubstituteFeatureAlgorithmEnumType::
    _xsd_CurveSubstituteFeatureAlgorithmEnumType_literals_[4] =
    {
      "LEASTSQUARES",
      "BSPLINE",
      "MINMAX",
      "UNDEFINED"
    };

    const CurveSubstituteFeatureAlgorithmEnumType::value CurveSubstituteFeatureAlgorithmEnumType::
    _xsd_CurveSubstituteFeatureAlgorithmEnumType_indexes_[4] =
    {
      ::xsd::qif2::CurveSubstituteFeatureAlgorithmEnumType::BSPLINE,
      ::xsd::qif2::CurveSubstituteFeatureAlgorithmEnumType::LEASTSQUARES,
      ::xsd::qif2::CurveSubstituteFeatureAlgorithmEnumType::MINMAX,
      ::xsd::qif2::CurveSubstituteFeatureAlgorithmEnumType::UNDEFINED
    };

    // CurveSubstituteFeatureAlgorithmType
    //

    CurveSubstituteFeatureAlgorithmType::
    CurveSubstituteFeatureAlgorithmType ()
    : ::xsd::qif2::SubstituteFeatureAlgorithmBaseType (),
      CurveSubstituteFeatureAlgorithmEnum_ (this),
      OtherCurveSubstituteFeatureAlgorithm_ (this)
    {
    }

    CurveSubstituteFeatureAlgorithmType::
    CurveSubstituteFeatureAlgorithmType (const CurveSubstituteFeatureAlgorithmType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::SubstituteFeatureAlgorithmBaseType (x, f, c),
      CurveSubstituteFeatureAlgorithmEnum_ (x.CurveSubstituteFeatureAlgorithmEnum_, f, this),
      OtherCurveSubstituteFeatureAlgorithm_ (x.OtherCurveSubstituteFeatureAlgorithm_, f, this)
    {
    }

    CurveSubstituteFeatureAlgorithmType::
    CurveSubstituteFeatureAlgorithmType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::SubstituteFeatureAlgorithmBaseType (e, f | ::xml_schema::flags::base, c),
      CurveSubstituteFeatureAlgorithmEnum_ (this),
      OtherCurveSubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CurveSubstituteFeatureAlgorithmType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CurveSubstituteFeatureAlgorithmEnum
        //
        if (n.name () == "CurveSubstituteFeatureAlgorithmEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CurveSubstituteFeatureAlgorithmEnum_type > r (
            CurveSubstituteFeatureAlgorithmEnum_traits::create (i, f, this));

          if (!this->CurveSubstituteFeatureAlgorithmEnum_)
          {
            this->CurveSubstituteFeatureAlgorithmEnum_.set (r);
            continue;
          }
        }

        // OtherCurveSubstituteFeatureAlgorithm
        //
        if (n.name () == "OtherCurveSubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherCurveSubstituteFeatureAlgorithm_type > r (
            OtherCurveSubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->OtherCurveSubstituteFeatureAlgorithm_)
          {
            this->OtherCurveSubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CurveSubstituteFeatureAlgorithmType* CurveSubstituteFeatureAlgorithmType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CurveSubstituteFeatureAlgorithmType (*this, f, c);
    }

    CurveSubstituteFeatureAlgorithmType& CurveSubstituteFeatureAlgorithmType::
    operator= (const CurveSubstituteFeatureAlgorithmType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::SubstituteFeatureAlgorithmBaseType& > (*this) = x;
        this->CurveSubstituteFeatureAlgorithmEnum_ = x.CurveSubstituteFeatureAlgorithmEnum_;
        this->OtherCurveSubstituteFeatureAlgorithm_ = x.OtherCurveSubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    CurveSubstituteFeatureAlgorithmType::
    ~CurveSubstituteFeatureAlgorithmType ()
    {
    }

    // SurfaceSubstituteFeatureAlgorithmEnumType
    //

    SurfaceSubstituteFeatureAlgorithmEnumType::
    SurfaceSubstituteFeatureAlgorithmEnumType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_SurfaceSubstituteFeatureAlgorithmEnumType_convert ();
    }

    SurfaceSubstituteFeatureAlgorithmEnumType::
    SurfaceSubstituteFeatureAlgorithmEnumType (const ::xercesc::DOMAttr& a,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_SurfaceSubstituteFeatureAlgorithmEnumType_convert ();
    }

    SurfaceSubstituteFeatureAlgorithmEnumType::
    SurfaceSubstituteFeatureAlgorithmEnumType (const ::std::string& s,
                                               const ::xercesc::DOMElement* e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_SurfaceSubstituteFeatureAlgorithmEnumType_convert ();
    }

    SurfaceSubstituteFeatureAlgorithmEnumType* SurfaceSubstituteFeatureAlgorithmEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceSubstituteFeatureAlgorithmEnumType (*this, f, c);
    }

    SurfaceSubstituteFeatureAlgorithmEnumType::value SurfaceSubstituteFeatureAlgorithmEnumType::
    _xsd_SurfaceSubstituteFeatureAlgorithmEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_SurfaceSubstituteFeatureAlgorithmEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_SurfaceSubstituteFeatureAlgorithmEnumType_indexes_,
                        _xsd_SurfaceSubstituteFeatureAlgorithmEnumType_indexes_ + 5,
                        *this,
                        c));

      if (i == _xsd_SurfaceSubstituteFeatureAlgorithmEnumType_indexes_ + 5 || _xsd_SurfaceSubstituteFeatureAlgorithmEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const SurfaceSubstituteFeatureAlgorithmEnumType::
    _xsd_SurfaceSubstituteFeatureAlgorithmEnumType_literals_[5] =
    {
      "LEASTSQUARES",
      "BEZIER",
      "NURBS",
      "MINMAX",
      "UNDEFINED"
    };

    const SurfaceSubstituteFeatureAlgorithmEnumType::value SurfaceSubstituteFeatureAlgorithmEnumType::
    _xsd_SurfaceSubstituteFeatureAlgorithmEnumType_indexes_[5] =
    {
      ::xsd::qif2::SurfaceSubstituteFeatureAlgorithmEnumType::BEZIER,
      ::xsd::qif2::SurfaceSubstituteFeatureAlgorithmEnumType::LEASTSQUARES,
      ::xsd::qif2::SurfaceSubstituteFeatureAlgorithmEnumType::MINMAX,
      ::xsd::qif2::SurfaceSubstituteFeatureAlgorithmEnumType::NURBS,
      ::xsd::qif2::SurfaceSubstituteFeatureAlgorithmEnumType::UNDEFINED
    };

    // SurfaceSubstituteFeatureAlgorithmType
    //

    SurfaceSubstituteFeatureAlgorithmType::
    SurfaceSubstituteFeatureAlgorithmType ()
    : ::xsd::qif2::SubstituteFeatureAlgorithmBaseType (),
      SurfaceSubstituteFeatureAlgorithmEnum_ (this),
      OtherSurfaceSubstituteFeatureAlgorithm_ (this)
    {
    }

    SurfaceSubstituteFeatureAlgorithmType::
    SurfaceSubstituteFeatureAlgorithmType (const SurfaceSubstituteFeatureAlgorithmType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::SubstituteFeatureAlgorithmBaseType (x, f, c),
      SurfaceSubstituteFeatureAlgorithmEnum_ (x.SurfaceSubstituteFeatureAlgorithmEnum_, f, this),
      OtherSurfaceSubstituteFeatureAlgorithm_ (x.OtherSurfaceSubstituteFeatureAlgorithm_, f, this)
    {
    }

    SurfaceSubstituteFeatureAlgorithmType::
    SurfaceSubstituteFeatureAlgorithmType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::SubstituteFeatureAlgorithmBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceSubstituteFeatureAlgorithmEnum_ (this),
      OtherSurfaceSubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SurfaceSubstituteFeatureAlgorithmType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceSubstituteFeatureAlgorithmEnum
        //
        if (n.name () == "SurfaceSubstituteFeatureAlgorithmEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceSubstituteFeatureAlgorithmEnum_type > r (
            SurfaceSubstituteFeatureAlgorithmEnum_traits::create (i, f, this));

          if (!this->SurfaceSubstituteFeatureAlgorithmEnum_)
          {
            this->SurfaceSubstituteFeatureAlgorithmEnum_.set (r);
            continue;
          }
        }

        // OtherSurfaceSubstituteFeatureAlgorithm
        //
        if (n.name () == "OtherSurfaceSubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherSurfaceSubstituteFeatureAlgorithm_type > r (
            OtherSurfaceSubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->OtherSurfaceSubstituteFeatureAlgorithm_)
          {
            this->OtherSurfaceSubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SurfaceSubstituteFeatureAlgorithmType* SurfaceSubstituteFeatureAlgorithmType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceSubstituteFeatureAlgorithmType (*this, f, c);
    }

    SurfaceSubstituteFeatureAlgorithmType& SurfaceSubstituteFeatureAlgorithmType::
    operator= (const SurfaceSubstituteFeatureAlgorithmType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::SubstituteFeatureAlgorithmBaseType& > (*this) = x;
        this->SurfaceSubstituteFeatureAlgorithmEnum_ = x.SurfaceSubstituteFeatureAlgorithmEnum_;
        this->OtherSurfaceSubstituteFeatureAlgorithm_ = x.OtherSurfaceSubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    SurfaceSubstituteFeatureAlgorithmType::
    ~SurfaceSubstituteFeatureAlgorithmType ()
    {
    }

    // MaterialModifierEnumType
    //

    MaterialModifierEnumType::
    MaterialModifierEnumType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_MaterialModifierEnumType_convert ();
    }

    MaterialModifierEnumType::
    MaterialModifierEnumType (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_MaterialModifierEnumType_convert ();
    }

    MaterialModifierEnumType::
    MaterialModifierEnumType (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_MaterialModifierEnumType_convert ();
    }

    MaterialModifierEnumType* MaterialModifierEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MaterialModifierEnumType (*this, f, c);
    }

    MaterialModifierEnumType::value MaterialModifierEnumType::
    _xsd_MaterialModifierEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MaterialModifierEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_MaterialModifierEnumType_indexes_,
                        _xsd_MaterialModifierEnumType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_MaterialModifierEnumType_indexes_ + 4 || _xsd_MaterialModifierEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const MaterialModifierEnumType::
    _xsd_MaterialModifierEnumType_literals_[4] =
    {
      "REGARDLESS",
      "LEAST",
      "MAXIMUM",
      "NONE"
    };

    const MaterialModifierEnumType::value MaterialModifierEnumType::
    _xsd_MaterialModifierEnumType_indexes_[4] =
    {
      ::xsd::qif2::MaterialModifierEnumType::LEAST,
      ::xsd::qif2::MaterialModifierEnumType::MAXIMUM,
      ::xsd::qif2::MaterialModifierEnumType::NONE,
      ::xsd::qif2::MaterialModifierEnumType::REGARDLESS
    };

    // PrecedenceEnumType
    //

    PrecedenceEnumType::
    PrecedenceEnumType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_PrecedenceEnumType_convert ();
    }

    PrecedenceEnumType::
    PrecedenceEnumType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_PrecedenceEnumType_convert ();
    }

    PrecedenceEnumType::
    PrecedenceEnumType (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_PrecedenceEnumType_convert ();
    }

    PrecedenceEnumType* PrecedenceEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PrecedenceEnumType (*this, f, c);
    }

    PrecedenceEnumType::value PrecedenceEnumType::
    _xsd_PrecedenceEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_PrecedenceEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_PrecedenceEnumType_indexes_,
                        _xsd_PrecedenceEnumType_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_PrecedenceEnumType_indexes_ + 6 || _xsd_PrecedenceEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const PrecedenceEnumType::
    _xsd_PrecedenceEnumType_literals_[6] =
    {
      "PRIMARY",
      "SECONDARY",
      "TERTIARY",
      "QUATERNARY",
      "QUINARY",
      "SENARY"
    };

    const PrecedenceEnumType::value PrecedenceEnumType::
    _xsd_PrecedenceEnumType_indexes_[6] =
    {
      ::xsd::qif2::PrecedenceEnumType::PRIMARY,
      ::xsd::qif2::PrecedenceEnumType::QUATERNARY,
      ::xsd::qif2::PrecedenceEnumType::QUINARY,
      ::xsd::qif2::PrecedenceEnumType::SECONDARY,
      ::xsd::qif2::PrecedenceEnumType::SENARY,
      ::xsd::qif2::PrecedenceEnumType::TERTIARY
    };

    // PrecedenceType
    //

    PrecedenceType::
    PrecedenceType ()
    : ::xml_schema::type (),
      PrecedenceEnum_ (this),
      OtherPrecedence_ (this)
    {
    }

    PrecedenceType::
    PrecedenceType (const PrecedenceType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PrecedenceEnum_ (x.PrecedenceEnum_, f, this),
      OtherPrecedence_ (x.OtherPrecedence_, f, this)
    {
    }

    PrecedenceType::
    PrecedenceType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PrecedenceEnum_ (this),
      OtherPrecedence_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PrecedenceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PrecedenceEnum
        //
        if (n.name () == "PrecedenceEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PrecedenceEnum_type > r (
            PrecedenceEnum_traits::create (i, f, this));

          if (!this->PrecedenceEnum_)
          {
            this->PrecedenceEnum_.set (r);
            continue;
          }
        }

        // OtherPrecedence
        //
        if (n.name () == "OtherPrecedence" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherPrecedence_type > r (
            OtherPrecedence_traits::create (i, f, this));

          if (!this->OtherPrecedence_)
          {
            this->OtherPrecedence_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PrecedenceType* PrecedenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PrecedenceType (*this, f, c);
    }

    PrecedenceType& PrecedenceType::
    operator= (const PrecedenceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PrecedenceEnum_ = x.PrecedenceEnum_;
        this->OtherPrecedence_ = x.OtherPrecedence_;
      }

      return *this;
    }

    PrecedenceType::
    ~PrecedenceType ()
    {
    }

    // ReferencedComponentEnumType
    //

    ReferencedComponentEnumType::
    ReferencedComponentEnumType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ReferencedComponentEnumType_convert ();
    }

    ReferencedComponentEnumType::
    ReferencedComponentEnumType (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ReferencedComponentEnumType_convert ();
    }

    ReferencedComponentEnumType::
    ReferencedComponentEnumType (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ReferencedComponentEnumType_convert ();
    }

    ReferencedComponentEnumType* ReferencedComponentEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ReferencedComponentEnumType (*this, f, c);
    }

    ReferencedComponentEnumType::value ReferencedComponentEnumType::
    _xsd_ReferencedComponentEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ReferencedComponentEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ReferencedComponentEnumType_indexes_,
                        _xsd_ReferencedComponentEnumType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_ReferencedComponentEnumType_indexes_ + 2 || _xsd_ReferencedComponentEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const ReferencedComponentEnumType::
    _xsd_ReferencedComponentEnumType_literals_[2] =
    {
      "NOMINAL",
      "ACTUAL"
    };

    const ReferencedComponentEnumType::value ReferencedComponentEnumType::
    _xsd_ReferencedComponentEnumType_indexes_[2] =
    {
      ::xsd::qif2::ReferencedComponentEnumType::ACTUAL,
      ::xsd::qif2::ReferencedComponentEnumType::NOMINAL
    };

    // RetrievalMethodEnumType
    //

    RetrievalMethodEnumType::
    RetrievalMethodEnumType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_RetrievalMethodEnumType_convert ();
    }

    RetrievalMethodEnumType::
    RetrievalMethodEnumType (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_RetrievalMethodEnumType_convert ();
    }

    RetrievalMethodEnumType::
    RetrievalMethodEnumType (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_RetrievalMethodEnumType_convert ();
    }

    RetrievalMethodEnumType* RetrievalMethodEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RetrievalMethodEnumType (*this, f, c);
    }

    RetrievalMethodEnumType::value RetrievalMethodEnumType::
    _xsd_RetrievalMethodEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RetrievalMethodEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_RetrievalMethodEnumType_indexes_,
                        _xsd_RetrievalMethodEnumType_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_RetrievalMethodEnumType_indexes_ + 6 || _xsd_RetrievalMethodEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const RetrievalMethodEnumType::
    _xsd_RetrievalMethodEnumType_literals_[6] =
    {
      "AVERAGE",
      "MAXEXTREME",
      "MINEXTREME",
      "CLOSEST1D",
      "CLOSEST2D",
      "CLOSEST3D"
    };

    const RetrievalMethodEnumType::value RetrievalMethodEnumType::
    _xsd_RetrievalMethodEnumType_indexes_[6] =
    {
      ::xsd::qif2::RetrievalMethodEnumType::AVERAGE,
      ::xsd::qif2::RetrievalMethodEnumType::CLOSEST1D,
      ::xsd::qif2::RetrievalMethodEnumType::CLOSEST2D,
      ::xsd::qif2::RetrievalMethodEnumType::CLOSEST3D,
      ::xsd::qif2::RetrievalMethodEnumType::MAXEXTREME,
      ::xsd::qif2::RetrievalMethodEnumType::MINEXTREME
    };

    // MeasurementDirectiveEnumType
    //

    MeasurementDirectiveEnumType::
    MeasurementDirectiveEnumType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_MeasurementDirectiveEnumType_convert ();
    }

    MeasurementDirectiveEnumType::
    MeasurementDirectiveEnumType (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_MeasurementDirectiveEnumType_convert ();
    }

    MeasurementDirectiveEnumType::
    MeasurementDirectiveEnumType (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_MeasurementDirectiveEnumType_convert ();
    }

    MeasurementDirectiveEnumType* MeasurementDirectiveEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementDirectiveEnumType (*this, f, c);
    }

    MeasurementDirectiveEnumType::value MeasurementDirectiveEnumType::
    _xsd_MeasurementDirectiveEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MeasurementDirectiveEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_MeasurementDirectiveEnumType_indexes_,
                        _xsd_MeasurementDirectiveEnumType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_MeasurementDirectiveEnumType_indexes_ + 4 || _xsd_MeasurementDirectiveEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const MeasurementDirectiveEnumType::
    _xsd_MeasurementDirectiveEnumType_literals_[4] =
    {
      "MINIMUM",
      "MAXIMUM",
      "AVERAGE",
      "UNDEFINED"
    };

    const MeasurementDirectiveEnumType::value MeasurementDirectiveEnumType::
    _xsd_MeasurementDirectiveEnumType_indexes_[4] =
    {
      ::xsd::qif2::MeasurementDirectiveEnumType::AVERAGE,
      ::xsd::qif2::MeasurementDirectiveEnumType::MAXIMUM,
      ::xsd::qif2::MeasurementDirectiveEnumType::MINIMUM,
      ::xsd::qif2::MeasurementDirectiveEnumType::UNDEFINED
    };

    // MeasurementDirectiveType
    //

    MeasurementDirectiveType::
    MeasurementDirectiveType ()
    : ::xml_schema::type (),
      MeasurementDirectiveEnum_ (this),
      OtherMeasurementDirective_ (this)
    {
    }

    MeasurementDirectiveType::
    MeasurementDirectiveType (const MeasurementDirectiveType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MeasurementDirectiveEnum_ (x.MeasurementDirectiveEnum_, f, this),
      OtherMeasurementDirective_ (x.OtherMeasurementDirective_, f, this)
    {
    }

    MeasurementDirectiveType::
    MeasurementDirectiveType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MeasurementDirectiveEnum_ (this),
      OtherMeasurementDirective_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasurementDirectiveType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MeasurementDirectiveEnum
        //
        if (n.name () == "MeasurementDirectiveEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MeasurementDirectiveEnum_type > r (
            MeasurementDirectiveEnum_traits::create (i, f, this));

          if (!this->MeasurementDirectiveEnum_)
          {
            this->MeasurementDirectiveEnum_.set (r);
            continue;
          }
        }

        // OtherMeasurementDirective
        //
        if (n.name () == "OtherMeasurementDirective" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherMeasurementDirective_type > r (
            OtherMeasurementDirective_traits::create (i, f, this));

          if (!this->OtherMeasurementDirective_)
          {
            this->OtherMeasurementDirective_.set (r);
            continue;
          }
        }

        break;
      }
    }

    MeasurementDirectiveType* MeasurementDirectiveType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementDirectiveType (*this, f, c);
    }

    MeasurementDirectiveType& MeasurementDirectiveType::
    operator= (const MeasurementDirectiveType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MeasurementDirectiveEnum_ = x.MeasurementDirectiveEnum_;
        this->OtherMeasurementDirective_ = x.OtherMeasurementDirective_;
      }

      return *this;
    }

    MeasurementDirectiveType::
    ~MeasurementDirectiveType ()
    {
    }

    // DistanceBetweenAnalysisModeEnumType
    //

    DistanceBetweenAnalysisModeEnumType::
    DistanceBetweenAnalysisModeEnumType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_DistanceBetweenAnalysisModeEnumType_convert ();
    }

    DistanceBetweenAnalysisModeEnumType::
    DistanceBetweenAnalysisModeEnumType (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_DistanceBetweenAnalysisModeEnumType_convert ();
    }

    DistanceBetweenAnalysisModeEnumType::
    DistanceBetweenAnalysisModeEnumType (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_DistanceBetweenAnalysisModeEnumType_convert ();
    }

    DistanceBetweenAnalysisModeEnumType* DistanceBetweenAnalysisModeEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DistanceBetweenAnalysisModeEnumType (*this, f, c);
    }

    DistanceBetweenAnalysisModeEnumType::value DistanceBetweenAnalysisModeEnumType::
    _xsd_DistanceBetweenAnalysisModeEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_DistanceBetweenAnalysisModeEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_DistanceBetweenAnalysisModeEnumType_indexes_,
                        _xsd_DistanceBetweenAnalysisModeEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_DistanceBetweenAnalysisModeEnumType_indexes_ + 3 || _xsd_DistanceBetweenAnalysisModeEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const DistanceBetweenAnalysisModeEnumType::
    _xsd_DistanceBetweenAnalysisModeEnumType_literals_[3] =
    {
      "ONEDIMENSIONAL",
      "TWODIMENSIONAL",
      "THREEDIMENSIONAL"
    };

    const DistanceBetweenAnalysisModeEnumType::value DistanceBetweenAnalysisModeEnumType::
    _xsd_DistanceBetweenAnalysisModeEnumType_indexes_[3] =
    {
      ::xsd::qif2::DistanceBetweenAnalysisModeEnumType::ONEDIMENSIONAL,
      ::xsd::qif2::DistanceBetweenAnalysisModeEnumType::THREEDIMENSIONAL,
      ::xsd::qif2::DistanceBetweenAnalysisModeEnumType::TWODIMENSIONAL
    };

    // AngleBetweenAnalysisModeEnumType
    //

    AngleBetweenAnalysisModeEnumType::
    AngleBetweenAnalysisModeEnumType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_AngleBetweenAnalysisModeEnumType_convert ();
    }

    AngleBetweenAnalysisModeEnumType::
    AngleBetweenAnalysisModeEnumType (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_AngleBetweenAnalysisModeEnumType_convert ();
    }

    AngleBetweenAnalysisModeEnumType::
    AngleBetweenAnalysisModeEnumType (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_AngleBetweenAnalysisModeEnumType_convert ();
    }

    AngleBetweenAnalysisModeEnumType* AngleBetweenAnalysisModeEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngleBetweenAnalysisModeEnumType (*this, f, c);
    }

    AngleBetweenAnalysisModeEnumType::value AngleBetweenAnalysisModeEnumType::
    _xsd_AngleBetweenAnalysisModeEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_AngleBetweenAnalysisModeEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_AngleBetweenAnalysisModeEnumType_indexes_,
                        _xsd_AngleBetweenAnalysisModeEnumType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_AngleBetweenAnalysisModeEnumType_indexes_ + 2 || _xsd_AngleBetweenAnalysisModeEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const AngleBetweenAnalysisModeEnumType::
    _xsd_AngleBetweenAnalysisModeEnumType_literals_[2] =
    {
      "TWODIMENSIONAL",
      "THREEDIMENSIONAL"
    };

    const AngleBetweenAnalysisModeEnumType::value AngleBetweenAnalysisModeEnumType::
    _xsd_AngleBetweenAnalysisModeEnumType_indexes_[2] =
    {
      ::xsd::qif2::AngleBetweenAnalysisModeEnumType::THREEDIMENSIONAL,
      ::xsd::qif2::AngleBetweenAnalysisModeEnumType::TWODIMENSIONAL
    };

    // BaseFeatureType
    //

    BaseFeatureType::
    BaseFeatureType (const ReferencedComponent_type& ReferencedComponent,
                     const FeatureItemId_type& FeatureItemId)
    : ::xml_schema::type (),
      ReferencedComponent_ (ReferencedComponent, this),
      FeatureItemId_ (FeatureItemId, this)
    {
    }

    BaseFeatureType::
    BaseFeatureType (const ReferencedComponent_type& ReferencedComponent,
                     ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xml_schema::type (),
      ReferencedComponent_ (ReferencedComponent, this),
      FeatureItemId_ (FeatureItemId, this)
    {
    }

    BaseFeatureType::
    BaseFeatureType (const BaseFeatureType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ReferencedComponent_ (x.ReferencedComponent_, f, this),
      FeatureItemId_ (x.FeatureItemId_, f, this)
    {
    }

    BaseFeatureType::
    BaseFeatureType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ReferencedComponent_ (this),
      FeatureItemId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void BaseFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ReferencedComponent
        //
        if (n.name () == "ReferencedComponent" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ReferencedComponent_type > r (
            ReferencedComponent_traits::create (i, f, this));

          if (!ReferencedComponent_.present ())
          {
            this->ReferencedComponent_.set (r);
            continue;
          }
        }

        // FeatureItemId
        //
        if (n.name () == "FeatureItemId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureItemId_type > r (
            FeatureItemId_traits::create (i, f, this));

          if (!FeatureItemId_.present ())
          {
            this->FeatureItemId_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ReferencedComponent_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ReferencedComponent",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!FeatureItemId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "FeatureItemId",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    BaseFeatureType* BaseFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BaseFeatureType (*this, f, c);
    }

    BaseFeatureType& BaseFeatureType::
    operator= (const BaseFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ReferencedComponent_ = x.ReferencedComponent_;
        this->FeatureItemId_ = x.FeatureItemId_;
      }

      return *this;
    }

    BaseFeatureType::
    ~BaseFeatureType ()
    {
    }

    // SequencedBaseFeatureType
    //

    SequencedBaseFeatureType::
    SequencedBaseFeatureType (const ReferencedComponent_type& ReferencedComponent,
                              const FeatureItemId_type& FeatureItemId,
                              const SequenceNumber_type& SequenceNumber)
    : ::xsd::qif2::BaseFeatureType (ReferencedComponent,
                                    FeatureItemId),
      SequenceNumber_ (SequenceNumber, this)
    {
    }

    SequencedBaseFeatureType::
    SequencedBaseFeatureType (const ReferencedComponent_type& ReferencedComponent,
                              ::std::auto_ptr< FeatureItemId_type > FeatureItemId,
                              const SequenceNumber_type& SequenceNumber)
    : ::xsd::qif2::BaseFeatureType (ReferencedComponent,
                                    FeatureItemId),
      SequenceNumber_ (SequenceNumber, this)
    {
    }

    SequencedBaseFeatureType::
    SequencedBaseFeatureType (const SequencedBaseFeatureType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::BaseFeatureType (x, f, c),
      SequenceNumber_ (x.SequenceNumber_, f, this)
    {
    }

    SequencedBaseFeatureType::
    SequencedBaseFeatureType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::BaseFeatureType (e, f | ::xml_schema::flags::base, c),
      SequenceNumber_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SequencedBaseFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::BaseFeatureType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SequenceNumber
        //
        if (n.name () == "SequenceNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!SequenceNumber_.present ())
          {
            this->SequenceNumber_.set (SequenceNumber_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!SequenceNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SequenceNumber",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SequencedBaseFeatureType* SequencedBaseFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SequencedBaseFeatureType (*this, f, c);
    }

    SequencedBaseFeatureType& SequencedBaseFeatureType::
    operator= (const SequencedBaseFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::BaseFeatureType& > (*this) = x;
        this->SequenceNumber_ = x.SequenceNumber_;
      }

      return *this;
    }

    SequencedBaseFeatureType::
    ~SequencedBaseFeatureType ()
    {
    }

    // DirectionalOffsetType
    //

    DirectionalOffsetType::
    DirectionalOffsetType (const Offset_type& Offset)
    : ::xml_schema::type (),
      Offset_ (Offset, this),
      NominalDirection_ (this),
      FeatureDirection_ (this)
    {
    }

    DirectionalOffsetType::
    DirectionalOffsetType (::std::auto_ptr< Offset_type > Offset)
    : ::xml_schema::type (),
      Offset_ (Offset, this),
      NominalDirection_ (this),
      FeatureDirection_ (this)
    {
    }

    DirectionalOffsetType::
    DirectionalOffsetType (const DirectionalOffsetType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Offset_ (x.Offset_, f, this),
      NominalDirection_ (x.NominalDirection_, f, this),
      FeatureDirection_ (x.FeatureDirection_, f, this)
    {
    }

    DirectionalOffsetType::
    DirectionalOffsetType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Offset_ (this),
      NominalDirection_ (this),
      FeatureDirection_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DirectionalOffsetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Offset
        //
        if (n.name () == "Offset" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Offset_type > r (
            Offset_traits::create (i, f, this));

          if (!Offset_.present ())
          {
            this->Offset_.set (r);
            continue;
          }
        }

        // NominalDirection
        //
        if (n.name () == "NominalDirection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< NominalDirection_type > r (
            NominalDirection_traits::create (i, f, this));

          if (!this->NominalDirection_)
          {
            this->NominalDirection_.set (r);
            continue;
          }
        }

        // FeatureDirection
        //
        if (n.name () == "FeatureDirection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureDirection_type > r (
            FeatureDirection_traits::create (i, f, this));

          if (!this->FeatureDirection_)
          {
            this->FeatureDirection_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Offset_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Offset",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    DirectionalOffsetType* DirectionalOffsetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DirectionalOffsetType (*this, f, c);
    }

    DirectionalOffsetType& DirectionalOffsetType::
    operator= (const DirectionalOffsetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Offset_ = x.Offset_;
        this->NominalDirection_ = x.NominalDirection_;
        this->FeatureDirection_ = x.FeatureDirection_;
      }

      return *this;
    }

    DirectionalOffsetType::
    ~DirectionalOffsetType ()
    {
    }

    // AlignmentFeatureType
    //

    AlignmentFeatureType::
    AlignmentFeatureType ()
    : ::xml_schema::type (),
      DatumDefinitionId_ (this),
      BaseFeature_ (this)
    {
    }

    AlignmentFeatureType::
    AlignmentFeatureType (const AlignmentFeatureType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DatumDefinitionId_ (x.DatumDefinitionId_, f, this),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    AlignmentFeatureType::
    AlignmentFeatureType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DatumDefinitionId_ (this),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AlignmentFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DatumDefinitionId
        //
        if (n.name () == "DatumDefinitionId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DatumDefinitionId_type > r (
            DatumDefinitionId_traits::create (i, f, this));

          if (!this->DatumDefinitionId_)
          {
            this->DatumDefinitionId_.set (r);
            continue;
          }
        }

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!this->BaseFeature_)
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }
    }

    AlignmentFeatureType* AlignmentFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AlignmentFeatureType (*this, f, c);
    }

    AlignmentFeatureType& AlignmentFeatureType::
    operator= (const AlignmentFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DatumDefinitionId_ = x.DatumDefinitionId_;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    AlignmentFeatureType::
    ~AlignmentFeatureType ()
    {
    }

    // AlignmentOperationBaseType
    //

    AlignmentOperationBaseType::
    AlignmentOperationBaseType (const SequenceNumber_type& SequenceNumber)
    : ::xml_schema::type (),
      SequenceNumber_ (SequenceNumber, this)
    {
    }

    AlignmentOperationBaseType::
    AlignmentOperationBaseType (const AlignmentOperationBaseType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SequenceNumber_ (x.SequenceNumber_, f, this)
    {
    }

    AlignmentOperationBaseType::
    AlignmentOperationBaseType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SequenceNumber_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AlignmentOperationBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SequenceNumber
        //
        if (n.name () == "SequenceNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!SequenceNumber_.present ())
          {
            this->SequenceNumber_.set (SequenceNumber_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!SequenceNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SequenceNumber",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    AlignmentOperationBaseType* AlignmentOperationBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AlignmentOperationBaseType (*this, f, c);
    }

    AlignmentOperationBaseType& AlignmentOperationBaseType::
    operator= (const AlignmentOperationBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SequenceNumber_ = x.SequenceNumber_;
      }

      return *this;
    }

    AlignmentOperationBaseType::
    ~AlignmentOperationBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, AlignmentOperationBaseType >
    _xsd_AlignmentOperationBaseType_type_factory_init (
      "AlignmentOperationBaseType",
      "http://qifstandards.org/xsd/qif2");

    // PrimaryAlignmentOperationType
    //

    PrimaryAlignmentOperationType::
    PrimaryAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                   const PrimaryEntity_type& PrimaryEntity,
                                   const PrimaryAxis_type& PrimaryAxis)
    : ::xsd::qif2::AlignmentOperationBaseType (SequenceNumber),
      PrimaryEntity_ (PrimaryEntity, this),
      PrimaryAxis_ (PrimaryAxis, this)
    {
    }

    PrimaryAlignmentOperationType::
    PrimaryAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                   ::std::auto_ptr< PrimaryEntity_type > PrimaryEntity,
                                   ::std::auto_ptr< PrimaryAxis_type > PrimaryAxis)
    : ::xsd::qif2::AlignmentOperationBaseType (SequenceNumber),
      PrimaryEntity_ (PrimaryEntity, this),
      PrimaryAxis_ (PrimaryAxis, this)
    {
    }

    PrimaryAlignmentOperationType::
    PrimaryAlignmentOperationType (const PrimaryAlignmentOperationType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::AlignmentOperationBaseType (x, f, c),
      PrimaryEntity_ (x.PrimaryEntity_, f, this),
      PrimaryAxis_ (x.PrimaryAxis_, f, this)
    {
    }

    PrimaryAlignmentOperationType::
    PrimaryAlignmentOperationType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::AlignmentOperationBaseType (e, f | ::xml_schema::flags::base, c),
      PrimaryEntity_ (this),
      PrimaryAxis_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PrimaryAlignmentOperationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::AlignmentOperationBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PrimaryEntity
        //
        if (n.name () == "PrimaryEntity" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PrimaryEntity_type > r (
            PrimaryEntity_traits::create (i, f, this));

          if (!PrimaryEntity_.present ())
          {
            this->PrimaryEntity_.set (r);
            continue;
          }
        }

        // PrimaryAxis
        //
        if (n.name () == "PrimaryAxis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PrimaryAxis_type > r (
            PrimaryAxis_traits::create (i, f, this));

          if (!PrimaryAxis_.present ())
          {
            this->PrimaryAxis_.set (r);
            continue;
          }
        }

        break;
      }

      if (!PrimaryEntity_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PrimaryEntity",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!PrimaryAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PrimaryAxis",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PrimaryAlignmentOperationType* PrimaryAlignmentOperationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PrimaryAlignmentOperationType (*this, f, c);
    }

    PrimaryAlignmentOperationType& PrimaryAlignmentOperationType::
    operator= (const PrimaryAlignmentOperationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::AlignmentOperationBaseType& > (*this) = x;
        this->PrimaryEntity_ = x.PrimaryEntity_;
        this->PrimaryAxis_ = x.PrimaryAxis_;
      }

      return *this;
    }

    PrimaryAlignmentOperationType::
    ~PrimaryAlignmentOperationType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PrimaryAlignmentOperationType >
    _xsd_PrimaryAlignmentOperationType_type_factory_init (
      "PrimaryAlignmentOperationType",
      "http://qifstandards.org/xsd/qif2");

    // SecondaryAlignmentOperationType
    //

    SecondaryAlignmentOperationType::
    SecondaryAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                     const SecondaryEntity_type& SecondaryEntity,
                                     const SecondaryAxis_type& SecondaryAxis)
    : ::xsd::qif2::AlignmentOperationBaseType (SequenceNumber),
      SecondaryEntity_ (SecondaryEntity, this),
      SecondaryAxis_ (SecondaryAxis, this),
      RotationAxis_ (this)
    {
    }

    SecondaryAlignmentOperationType::
    SecondaryAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                     ::std::auto_ptr< SecondaryEntity_type > SecondaryEntity,
                                     ::std::auto_ptr< SecondaryAxis_type > SecondaryAxis)
    : ::xsd::qif2::AlignmentOperationBaseType (SequenceNumber),
      SecondaryEntity_ (SecondaryEntity, this),
      SecondaryAxis_ (SecondaryAxis, this),
      RotationAxis_ (this)
    {
    }

    SecondaryAlignmentOperationType::
    SecondaryAlignmentOperationType (const SecondaryAlignmentOperationType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::AlignmentOperationBaseType (x, f, c),
      SecondaryEntity_ (x.SecondaryEntity_, f, this),
      SecondaryAxis_ (x.SecondaryAxis_, f, this),
      RotationAxis_ (x.RotationAxis_, f, this)
    {
    }

    SecondaryAlignmentOperationType::
    SecondaryAlignmentOperationType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::AlignmentOperationBaseType (e, f | ::xml_schema::flags::base, c),
      SecondaryEntity_ (this),
      SecondaryAxis_ (this),
      RotationAxis_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SecondaryAlignmentOperationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::AlignmentOperationBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SecondaryEntity
        //
        if (n.name () == "SecondaryEntity" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SecondaryEntity_type > r (
            SecondaryEntity_traits::create (i, f, this));

          if (!SecondaryEntity_.present ())
          {
            this->SecondaryEntity_.set (r);
            continue;
          }
        }

        // SecondaryAxis
        //
        if (n.name () == "SecondaryAxis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SecondaryAxis_type > r (
            SecondaryAxis_traits::create (i, f, this));

          if (!SecondaryAxis_.present ())
          {
            this->SecondaryAxis_.set (r);
            continue;
          }
        }

        // RotationAxis
        //
        if (n.name () == "RotationAxis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RotationAxis_type > r (
            RotationAxis_traits::create (i, f, this));

          if (!this->RotationAxis_)
          {
            this->RotationAxis_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SecondaryEntity_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SecondaryEntity",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SecondaryAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SecondaryAxis",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SecondaryAlignmentOperationType* SecondaryAlignmentOperationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SecondaryAlignmentOperationType (*this, f, c);
    }

    SecondaryAlignmentOperationType& SecondaryAlignmentOperationType::
    operator= (const SecondaryAlignmentOperationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::AlignmentOperationBaseType& > (*this) = x;
        this->SecondaryEntity_ = x.SecondaryEntity_;
        this->SecondaryAxis_ = x.SecondaryAxis_;
        this->RotationAxis_ = x.RotationAxis_;
      }

      return *this;
    }

    SecondaryAlignmentOperationType::
    ~SecondaryAlignmentOperationType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SecondaryAlignmentOperationType >
    _xsd_SecondaryAlignmentOperationType_type_factory_init (
      "SecondaryAlignmentOperationType",
      "http://qifstandards.org/xsd/qif2");

    // ActualOriginOffsetType
    //

    ActualOriginOffsetType::
    ActualOriginOffsetType (const OriginEntity_type& OriginEntity,
                            const OriginDirection_type& OriginDirection)
    : ::xml_schema::type (),
      OriginEntity_ (OriginEntity, this),
      OriginDirection_ (OriginDirection, this)
    {
    }

    ActualOriginOffsetType::
    ActualOriginOffsetType (::std::auto_ptr< OriginEntity_type > OriginEntity,
                            ::std::auto_ptr< OriginDirection_type > OriginDirection)
    : ::xml_schema::type (),
      OriginEntity_ (OriginEntity, this),
      OriginDirection_ (OriginDirection, this)
    {
    }

    ActualOriginOffsetType::
    ActualOriginOffsetType (const ActualOriginOffsetType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      OriginEntity_ (x.OriginEntity_, f, this),
      OriginDirection_ (x.OriginDirection_, f, this)
    {
    }

    ActualOriginOffsetType::
    ActualOriginOffsetType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      OriginEntity_ (this),
      OriginDirection_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ActualOriginOffsetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // OriginEntity
        //
        if (n.name () == "OriginEntity" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OriginEntity_type > r (
            OriginEntity_traits::create (i, f, this));

          if (!OriginEntity_.present ())
          {
            this->OriginEntity_.set (r);
            continue;
          }
        }

        // OriginDirection
        //
        if (n.name () == "OriginDirection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OriginDirection_type > r (
            OriginDirection_traits::create (i, f, this));

          if (!OriginDirection_.present ())
          {
            this->OriginDirection_.set (r);
            continue;
          }
        }

        break;
      }

      if (!OriginEntity_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "OriginEntity",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!OriginDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "OriginDirection",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ActualOriginOffsetType* ActualOriginOffsetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualOriginOffsetType (*this, f, c);
    }

    ActualOriginOffsetType& ActualOriginOffsetType::
    operator= (const ActualOriginOffsetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->OriginEntity_ = x.OriginEntity_;
        this->OriginDirection_ = x.OriginDirection_;
      }

      return *this;
    }

    ActualOriginOffsetType::
    ~ActualOriginOffsetType ()
    {
    }

    // ActualOffsetAlignmentOperationType
    //

    ActualOffsetAlignmentOperationType::
    ActualOffsetAlignmentOperationType (const SequenceNumber_type& SequenceNumber)
    : ::xsd::qif2::AlignmentOperationBaseType (SequenceNumber),
      Origin_ (this)
    {
    }

    ActualOffsetAlignmentOperationType::
    ActualOffsetAlignmentOperationType (const ActualOffsetAlignmentOperationType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::AlignmentOperationBaseType (x, f, c),
      Origin_ (x.Origin_, f, this)
    {
    }

    ActualOffsetAlignmentOperationType::
    ActualOffsetAlignmentOperationType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::AlignmentOperationBaseType (e, f | ::xml_schema::flags::base, c),
      Origin_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ActualOffsetAlignmentOperationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::AlignmentOperationBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Origin
        //
        if (n.name () == "Origin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Origin_type > r (
            Origin_traits::create (i, f, this));

          this->Origin_.push_back (r);
          continue;
        }

        break;
      }
    }

    ActualOffsetAlignmentOperationType* ActualOffsetAlignmentOperationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualOffsetAlignmentOperationType (*this, f, c);
    }

    ActualOffsetAlignmentOperationType& ActualOffsetAlignmentOperationType::
    operator= (const ActualOffsetAlignmentOperationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::AlignmentOperationBaseType& > (*this) = x;
        this->Origin_ = x.Origin_;
      }

      return *this;
    }

    ActualOffsetAlignmentOperationType::
    ~ActualOffsetAlignmentOperationType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ActualOffsetAlignmentOperationType >
    _xsd_ActualOffsetAlignmentOperationType_type_factory_init (
      "ActualOffsetAlignmentOperationType",
      "http://qifstandards.org/xsd/qif2");

    // NominalOffsetAlignmentOperationType
    //

    NominalOffsetAlignmentOperationType::
    NominalOffsetAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                         const Offset_type& Offset)
    : ::xsd::qif2::AlignmentOperationBaseType (SequenceNumber),
      Offset_ (Offset, this)
    {
    }

    NominalOffsetAlignmentOperationType::
    NominalOffsetAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                         ::std::auto_ptr< Offset_type > Offset)
    : ::xsd::qif2::AlignmentOperationBaseType (SequenceNumber),
      Offset_ (Offset, this)
    {
    }

    NominalOffsetAlignmentOperationType::
    NominalOffsetAlignmentOperationType (const NominalOffsetAlignmentOperationType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::AlignmentOperationBaseType (x, f, c),
      Offset_ (x.Offset_, f, this)
    {
    }

    NominalOffsetAlignmentOperationType::
    NominalOffsetAlignmentOperationType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::AlignmentOperationBaseType (e, f | ::xml_schema::flags::base, c),
      Offset_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void NominalOffsetAlignmentOperationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::AlignmentOperationBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Offset
        //
        if (n.name () == "Offset" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Offset_type > r (
            Offset_traits::create (i, f, this));

          if (!Offset_.present ())
          {
            this->Offset_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Offset_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Offset",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    NominalOffsetAlignmentOperationType* NominalOffsetAlignmentOperationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NominalOffsetAlignmentOperationType (*this, f, c);
    }

    NominalOffsetAlignmentOperationType& NominalOffsetAlignmentOperationType::
    operator= (const NominalOffsetAlignmentOperationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::AlignmentOperationBaseType& > (*this) = x;
        this->Offset_ = x.Offset_;
      }

      return *this;
    }

    NominalOffsetAlignmentOperationType::
    ~NominalOffsetAlignmentOperationType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, NominalOffsetAlignmentOperationType >
    _xsd_NominalOffsetAlignmentOperationType_type_factory_init (
      "NominalOffsetAlignmentOperationType",
      "http://qifstandards.org/xsd/qif2");

    // NominalRotationAlignmentOperationType
    //

    NominalRotationAlignmentOperationType::
    NominalRotationAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                           const RotationAxis_type& RotationAxis,
                                           const Angle_type& Angle)
    : ::xsd::qif2::AlignmentOperationBaseType (SequenceNumber),
      RotationAxis_ (RotationAxis, this),
      Angle_ (Angle, this)
    {
    }

    NominalRotationAlignmentOperationType::
    NominalRotationAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                           ::std::auto_ptr< RotationAxis_type > RotationAxis,
                                           ::std::auto_ptr< Angle_type > Angle)
    : ::xsd::qif2::AlignmentOperationBaseType (SequenceNumber),
      RotationAxis_ (RotationAxis, this),
      Angle_ (Angle, this)
    {
    }

    NominalRotationAlignmentOperationType::
    NominalRotationAlignmentOperationType (const NominalRotationAlignmentOperationType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::AlignmentOperationBaseType (x, f, c),
      RotationAxis_ (x.RotationAxis_, f, this),
      Angle_ (x.Angle_, f, this)
    {
    }

    NominalRotationAlignmentOperationType::
    NominalRotationAlignmentOperationType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::AlignmentOperationBaseType (e, f | ::xml_schema::flags::base, c),
      RotationAxis_ (this),
      Angle_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void NominalRotationAlignmentOperationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::AlignmentOperationBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // RotationAxis
        //
        if (n.name () == "RotationAxis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RotationAxis_type > r (
            RotationAxis_traits::create (i, f, this));

          if (!RotationAxis_.present ())
          {
            this->RotationAxis_.set (r);
            continue;
          }
        }

        // Angle
        //
        if (n.name () == "Angle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Angle_type > r (
            Angle_traits::create (i, f, this));

          if (!Angle_.present ())
          {
            this->Angle_.set (r);
            continue;
          }
        }

        break;
      }

      if (!RotationAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "RotationAxis",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Angle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Angle",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    NominalRotationAlignmentOperationType* NominalRotationAlignmentOperationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NominalRotationAlignmentOperationType (*this, f, c);
    }

    NominalRotationAlignmentOperationType& NominalRotationAlignmentOperationType::
    operator= (const NominalRotationAlignmentOperationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::AlignmentOperationBaseType& > (*this) = x;
        this->RotationAxis_ = x.RotationAxis_;
        this->Angle_ = x.Angle_;
      }

      return *this;
    }

    NominalRotationAlignmentOperationType::
    ~NominalRotationAlignmentOperationType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, NominalRotationAlignmentOperationType >
    _xsd_NominalRotationAlignmentOperationType_type_factory_init (
      "NominalRotationAlignmentOperationType",
      "http://qifstandards.org/xsd/qif2");

    // DatumPrecedenceAlignmentOperationType
    //

    DatumPrecedenceAlignmentOperationType::
    DatumPrecedenceAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                           const DatumReferenceFrameId_type& DatumReferenceFrameId,
                                           const PrimaryAxis_type& PrimaryAxis)
    : ::xsd::qif2::AlignmentOperationBaseType (SequenceNumber),
      DatumReferenceFrameId_ (DatumReferenceFrameId, this),
      PrimaryAxis_ (PrimaryAxis, this),
      SecondaryAxis_ (this)
    {
    }

    DatumPrecedenceAlignmentOperationType::
    DatumPrecedenceAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                           ::std::auto_ptr< DatumReferenceFrameId_type > DatumReferenceFrameId,
                                           ::std::auto_ptr< PrimaryAxis_type > PrimaryAxis)
    : ::xsd::qif2::AlignmentOperationBaseType (SequenceNumber),
      DatumReferenceFrameId_ (DatumReferenceFrameId, this),
      PrimaryAxis_ (PrimaryAxis, this),
      SecondaryAxis_ (this)
    {
    }

    DatumPrecedenceAlignmentOperationType::
    DatumPrecedenceAlignmentOperationType (const DatumPrecedenceAlignmentOperationType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::AlignmentOperationBaseType (x, f, c),
      DatumReferenceFrameId_ (x.DatumReferenceFrameId_, f, this),
      PrimaryAxis_ (x.PrimaryAxis_, f, this),
      SecondaryAxis_ (x.SecondaryAxis_, f, this)
    {
    }

    DatumPrecedenceAlignmentOperationType::
    DatumPrecedenceAlignmentOperationType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::AlignmentOperationBaseType (e, f | ::xml_schema::flags::base, c),
      DatumReferenceFrameId_ (this),
      PrimaryAxis_ (this),
      SecondaryAxis_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DatumPrecedenceAlignmentOperationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::AlignmentOperationBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DatumReferenceFrameId
        //
        if (n.name () == "DatumReferenceFrameId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DatumReferenceFrameId_type > r (
            DatumReferenceFrameId_traits::create (i, f, this));

          if (!DatumReferenceFrameId_.present ())
          {
            this->DatumReferenceFrameId_.set (r);
            continue;
          }
        }

        // PrimaryAxis
        //
        if (n.name () == "PrimaryAxis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PrimaryAxis_type > r (
            PrimaryAxis_traits::create (i, f, this));

          if (!PrimaryAxis_.present ())
          {
            this->PrimaryAxis_.set (r);
            continue;
          }
        }

        // SecondaryAxis
        //
        if (n.name () == "SecondaryAxis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SecondaryAxis_type > r (
            SecondaryAxis_traits::create (i, f, this));

          if (!this->SecondaryAxis_)
          {
            this->SecondaryAxis_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DatumReferenceFrameId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DatumReferenceFrameId",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!PrimaryAxis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PrimaryAxis",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    DatumPrecedenceAlignmentOperationType* DatumPrecedenceAlignmentOperationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumPrecedenceAlignmentOperationType (*this, f, c);
    }

    DatumPrecedenceAlignmentOperationType& DatumPrecedenceAlignmentOperationType::
    operator= (const DatumPrecedenceAlignmentOperationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::AlignmentOperationBaseType& > (*this) = x;
        this->DatumReferenceFrameId_ = x.DatumReferenceFrameId_;
        this->PrimaryAxis_ = x.PrimaryAxis_;
        this->SecondaryAxis_ = x.SecondaryAxis_;
      }

      return *this;
    }

    DatumPrecedenceAlignmentOperationType::
    ~DatumPrecedenceAlignmentOperationType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DatumPrecedenceAlignmentOperationType >
    _xsd_DatumPrecedenceAlignmentOperationType_type_factory_init (
      "DatumPrecedenceAlignmentOperationType",
      "http://qifstandards.org/xsd/qif2");

    // BestFitAlignmentOperationType
    //

    BestFitAlignmentOperationType::
    BestFitAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                   const DegreesOfFreedom_type& DegreesOfFreedom)
    : ::xsd::qif2::AlignmentOperationBaseType (SequenceNumber),
      DegreesOfFreedom_ (DegreesOfFreedom, this),
      BaseFeature_ (this)
    {
    }

    BestFitAlignmentOperationType::
    BestFitAlignmentOperationType (const SequenceNumber_type& SequenceNumber,
                                   ::std::auto_ptr< DegreesOfFreedom_type > DegreesOfFreedom)
    : ::xsd::qif2::AlignmentOperationBaseType (SequenceNumber),
      DegreesOfFreedom_ (DegreesOfFreedom, this),
      BaseFeature_ (this)
    {
    }

    BestFitAlignmentOperationType::
    BestFitAlignmentOperationType (const BestFitAlignmentOperationType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::AlignmentOperationBaseType (x, f, c),
      DegreesOfFreedom_ (x.DegreesOfFreedom_, f, this),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    BestFitAlignmentOperationType::
    BestFitAlignmentOperationType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::AlignmentOperationBaseType (e, f | ::xml_schema::flags::base, c),
      DegreesOfFreedom_ (this),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void BestFitAlignmentOperationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::AlignmentOperationBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DegreesOfFreedom
        //
        if (n.name () == "DegreesOfFreedom" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DegreesOfFreedom_type > r (
            DegreesOfFreedom_traits::create (i, f, this));

          if (!DegreesOfFreedom_.present ())
          {
            this->DegreesOfFreedom_.set (r);
            continue;
          }
        }

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }

      if (!DegreesOfFreedom_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DegreesOfFreedom",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    BestFitAlignmentOperationType* BestFitAlignmentOperationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BestFitAlignmentOperationType (*this, f, c);
    }

    BestFitAlignmentOperationType& BestFitAlignmentOperationType::
    operator= (const BestFitAlignmentOperationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::AlignmentOperationBaseType& > (*this) = x;
        this->DegreesOfFreedom_ = x.DegreesOfFreedom_;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    BestFitAlignmentOperationType::
    ~BestFitAlignmentOperationType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, BestFitAlignmentOperationType >
    _xsd_BestFitAlignmentOperationType_type_factory_init (
      "BestFitAlignmentOperationType",
      "http://qifstandards.org/xsd/qif2");

    // MachineCoordinateSystemOperationType
    //

    MachineCoordinateSystemOperationType::
    MachineCoordinateSystemOperationType (const SequenceNumber_type& SequenceNumber)
    : ::xsd::qif2::AlignmentOperationBaseType (SequenceNumber)
    {
    }

    MachineCoordinateSystemOperationType::
    MachineCoordinateSystemOperationType (const MachineCoordinateSystemOperationType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif2::AlignmentOperationBaseType (x, f, c)
    {
    }

    MachineCoordinateSystemOperationType::
    MachineCoordinateSystemOperationType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif2::AlignmentOperationBaseType (e, f, c)
    {
    }

    MachineCoordinateSystemOperationType* MachineCoordinateSystemOperationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MachineCoordinateSystemOperationType (*this, f, c);
    }

    MachineCoordinateSystemOperationType::
    ~MachineCoordinateSystemOperationType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, MachineCoordinateSystemOperationType >
    _xsd_MachineCoordinateSystemOperationType_type_factory_init (
      "MachineCoordinateSystemOperationType",
      "http://qifstandards.org/xsd/qif2");

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PrimaryAlignmentOperationType >
    _xsd_PrimaryAlignment_element_factory_init (
      "AlignmentOperation",
      "http://qifstandards.org/xsd/qif2",
      "PrimaryAlignment",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::SecondaryAlignmentOperationType >
    _xsd_SecondaryAlignment_element_factory_init (
      "AlignmentOperation",
      "http://qifstandards.org/xsd/qif2",
      "SecondaryAlignment",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ActualOffsetAlignmentOperationType >
    _xsd_ActualOffset_element_factory_init (
      "AlignmentOperation",
      "http://qifstandards.org/xsd/qif2",
      "ActualOffset",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::NominalOffsetAlignmentOperationType >
    _xsd_NominalOffset_element_factory_init (
      "AlignmentOperation",
      "http://qifstandards.org/xsd/qif2",
      "NominalOffset",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::NominalRotationAlignmentOperationType >
    _xsd_NominalRotation_element_factory_init (
      "AlignmentOperation",
      "http://qifstandards.org/xsd/qif2",
      "NominalRotation",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::DatumPrecedenceAlignmentOperationType >
    _xsd_DatumPrecedence_element_factory_init (
      "AlignmentOperation",
      "http://qifstandards.org/xsd/qif2",
      "DatumPrecedence",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::BestFitAlignmentOperationType >
    _xsd_BestFit_element_factory_init (
      "AlignmentOperation",
      "http://qifstandards.org/xsd/qif2",
      "BestFit",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::MachineCoordinateSystemOperationType >
    _xsd_Machine_element_factory_init (
      "AlignmentOperation",
      "http://qifstandards.org/xsd/qif2",
      "Machine",
      "http://qifstandards.org/xsd/qif2");


    // AlignmentOperationsType
    //

    AlignmentOperationsType::
    AlignmentOperationsType ()
    : ::xml_schema::type (),
      AlignmentOperation_ (this),
      BaseCoordinateSystemId_ (this)
    {
    }

    AlignmentOperationsType::
    AlignmentOperationsType (const AlignmentOperationsType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AlignmentOperation_ (x.AlignmentOperation_, f, this),
      BaseCoordinateSystemId_ (x.BaseCoordinateSystemId_, f, this)
    {
    }

    AlignmentOperationsType::
    AlignmentOperationsType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AlignmentOperation_ (this),
      BaseCoordinateSystemId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AlignmentOperationsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // AlignmentOperation
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "AlignmentOperation",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< AlignmentOperation_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< AlignmentOperation_type > r (
              dynamic_cast< AlignmentOperation_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->AlignmentOperation_.push_back (r);
            continue;
          }
        }

        // BaseCoordinateSystemId
        //
        if (n.name () == "BaseCoordinateSystemId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCoordinateSystemId_type > r (
            BaseCoordinateSystemId_traits::create (i, f, this));

          if (!this->BaseCoordinateSystemId_)
          {
            this->BaseCoordinateSystemId_.set (r);
            continue;
          }
        }

        break;
      }
    }

    AlignmentOperationsType* AlignmentOperationsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AlignmentOperationsType (*this, f, c);
    }

    AlignmentOperationsType& AlignmentOperationsType::
    operator= (const AlignmentOperationsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AlignmentOperation_ = x.AlignmentOperation_;
        this->BaseCoordinateSystemId_ = x.BaseCoordinateSystemId_;
      }

      return *this;
    }

    AlignmentOperationsType::
    ~AlignmentOperationsType ()
    {
    }

    // CoordinateSystemListType
    //

    CoordinateSystemListType::
    CoordinateSystemListType ()
    : ::xml_schema::type (),
      CoordinateSystem_ (this),
      CommonCoordinateSystemId_ (this),
      MachineCoordinateSystemId_ (this)
    {
    }

    CoordinateSystemListType::
    CoordinateSystemListType (const CoordinateSystemListType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CoordinateSystem_ (x.CoordinateSystem_, f, this),
      CommonCoordinateSystemId_ (x.CommonCoordinateSystemId_, f, this),
      MachineCoordinateSystemId_ (x.MachineCoordinateSystemId_, f, this)
    {
    }

    CoordinateSystemListType::
    CoordinateSystemListType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CoordinateSystem_ (this),
      CommonCoordinateSystemId_ (this),
      MachineCoordinateSystemId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CoordinateSystemListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CoordinateSystem
        //
        if (n.name () == "CoordinateSystem" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CoordinateSystem_type > r (
            CoordinateSystem_traits::create (i, f, this));

          this->CoordinateSystem_.push_back (r);
          continue;
        }

        // CommonCoordinateSystemId
        //
        if (n.name () == "CommonCoordinateSystemId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CommonCoordinateSystemId_type > r (
            CommonCoordinateSystemId_traits::create (i, f, this));

          if (!this->CommonCoordinateSystemId_)
          {
            this->CommonCoordinateSystemId_.set (r);
            continue;
          }
        }

        // MachineCoordinateSystemId
        //
        if (n.name () == "MachineCoordinateSystemId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MachineCoordinateSystemId_type > r (
            MachineCoordinateSystemId_traits::create (i, f, this));

          if (!this->MachineCoordinateSystemId_)
          {
            this->MachineCoordinateSystemId_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CoordinateSystemListType* CoordinateSystemListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoordinateSystemListType (*this, f, c);
    }

    CoordinateSystemListType& CoordinateSystemListType::
    operator= (const CoordinateSystemListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CoordinateSystem_ = x.CoordinateSystem_;
        this->CommonCoordinateSystemId_ = x.CommonCoordinateSystemId_;
        this->MachineCoordinateSystemId_ = x.MachineCoordinateSystemId_;
      }

      return *this;
    }

    CoordinateSystemListType::
    ~CoordinateSystemListType ()
    {
    }

    // CoordinateSystemType
    //

    CoordinateSystemType::
    CoordinateSystemType (const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      Name_ (this),
      NominalTransform_ (this),
      InternalCADCoordinateSystemId_ (this),
      ExternalCADCoordinateSystemId_ (this),
      AlignmentOperations_ (this),
      SequenceNumber_ (this),
      id_ (id, this)
    {
    }

    CoordinateSystemType::
    CoordinateSystemType (const CoordinateSystemType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      Name_ (x.Name_, f, this),
      NominalTransform_ (x.NominalTransform_, f, this),
      InternalCADCoordinateSystemId_ (x.InternalCADCoordinateSystemId_, f, this),
      ExternalCADCoordinateSystemId_ (x.ExternalCADCoordinateSystemId_, f, this),
      AlignmentOperations_ (x.AlignmentOperations_, f, this),
      SequenceNumber_ (x.SequenceNumber_, f, this),
      id_ (x.id_, f, this)
    {
    }

    CoordinateSystemType::
    CoordinateSystemType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      Name_ (this),
      NominalTransform_ (this),
      InternalCADCoordinateSystemId_ (this),
      ExternalCADCoordinateSystemId_ (this),
      AlignmentOperations_ (this),
      SequenceNumber_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CoordinateSystemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Attributes
        //
        if (n.name () == "Attributes" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (r);
            continue;
          }
        }

        // Name
        //
        if (n.name () == "Name" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!this->Name_)
          {
            this->Name_.set (r);
            continue;
          }
        }

        // NominalTransform
        //
        if (n.name () == "NominalTransform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< NominalTransform_type > r (
            NominalTransform_traits::create (i, f, this));

          if (!this->NominalTransform_)
          {
            this->NominalTransform_.set (r);
            continue;
          }
        }

        // InternalCADCoordinateSystemId
        //
        if (n.name () == "InternalCADCoordinateSystemId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalCADCoordinateSystemId_type > r (
            InternalCADCoordinateSystemId_traits::create (i, f, this));

          if (!this->InternalCADCoordinateSystemId_)
          {
            this->InternalCADCoordinateSystemId_.set (r);
            continue;
          }
        }

        // ExternalCADCoordinateSystemId
        //
        if (n.name () == "ExternalCADCoordinateSystemId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ExternalCADCoordinateSystemId_type > r (
            ExternalCADCoordinateSystemId_traits::create (i, f, this));

          if (!this->ExternalCADCoordinateSystemId_)
          {
            this->ExternalCADCoordinateSystemId_.set (r);
            continue;
          }
        }

        // AlignmentOperations
        //
        if (n.name () == "AlignmentOperations" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AlignmentOperations_type > r (
            AlignmentOperations_traits::create (i, f, this));

          if (!this->AlignmentOperations_)
          {
            this->AlignmentOperations_.set (r);
            continue;
          }
        }

        // SequenceNumber
        //
        if (n.name () == "SequenceNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->SequenceNumber_)
          {
            this->SequenceNumber_.set (SequenceNumber_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    CoordinateSystemType* CoordinateSystemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoordinateSystemType (*this, f, c);
    }

    CoordinateSystemType& CoordinateSystemType::
    operator= (const CoordinateSystemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->Name_ = x.Name_;
        this->NominalTransform_ = x.NominalTransform_;
        this->InternalCADCoordinateSystemId_ = x.InternalCADCoordinateSystemId_;
        this->ExternalCADCoordinateSystemId_ = x.ExternalCADCoordinateSystemId_;
        this->AlignmentOperations_ = x.AlignmentOperations_;
        this->SequenceNumber_ = x.SequenceNumber_;
        this->id_ = x.id_;
      }

      return *this;
    }

    CoordinateSystemType::
    ~CoordinateSystemType ()
    {
    }

    // CoordinateSystemActualTransformType
    //

    CoordinateSystemActualTransformType::
    CoordinateSystemActualTransformType (const ActualTransform_type& ActualTransform,
                                         const CoordinateSystemId_type& CoordinateSystemId)
    : ::xml_schema::type (),
      ActualTransform_ (ActualTransform, this),
      CoordinateSystemId_ (CoordinateSystemId, this)
    {
    }

    CoordinateSystemActualTransformType::
    CoordinateSystemActualTransformType (::std::auto_ptr< ActualTransform_type > ActualTransform,
                                         ::std::auto_ptr< CoordinateSystemId_type > CoordinateSystemId)
    : ::xml_schema::type (),
      ActualTransform_ (ActualTransform, this),
      CoordinateSystemId_ (CoordinateSystemId, this)
    {
    }

    CoordinateSystemActualTransformType::
    CoordinateSystemActualTransformType (const CoordinateSystemActualTransformType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ActualTransform_ (x.ActualTransform_, f, this),
      CoordinateSystemId_ (x.CoordinateSystemId_, f, this)
    {
    }

    CoordinateSystemActualTransformType::
    CoordinateSystemActualTransformType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ActualTransform_ (this),
      CoordinateSystemId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CoordinateSystemActualTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ActualTransform
        //
        if (n.name () == "ActualTransform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ActualTransform_type > r (
            ActualTransform_traits::create (i, f, this));

          if (!ActualTransform_.present ())
          {
            this->ActualTransform_.set (r);
            continue;
          }
        }

        // CoordinateSystemId
        //
        if (n.name () == "CoordinateSystemId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CoordinateSystemId_type > r (
            CoordinateSystemId_traits::create (i, f, this));

          if (!CoordinateSystemId_.present ())
          {
            this->CoordinateSystemId_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ActualTransform_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ActualTransform",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!CoordinateSystemId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CoordinateSystemId",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CoordinateSystemActualTransformType* CoordinateSystemActualTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoordinateSystemActualTransformType (*this, f, c);
    }

    CoordinateSystemActualTransformType& CoordinateSystemActualTransformType::
    operator= (const CoordinateSystemActualTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ActualTransform_ = x.ActualTransform_;
        this->CoordinateSystemId_ = x.CoordinateSystemId_;
      }

      return *this;
    }

    CoordinateSystemActualTransformType::
    ~CoordinateSystemActualTransformType ()
    {
    }

    // CoordinateSystemActualTransformsType
    //

    CoordinateSystemActualTransformsType::
    CoordinateSystemActualTransformsType ()
    : ::xml_schema::type (),
      Transform_ (this)
    {
    }

    CoordinateSystemActualTransformsType::
    CoordinateSystemActualTransformsType (const CoordinateSystemActualTransformsType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Transform_ (x.Transform_, f, this)
    {
    }

    CoordinateSystemActualTransformsType::
    CoordinateSystemActualTransformsType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CoordinateSystemActualTransformsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          this->Transform_.push_back (r);
          continue;
        }

        break;
      }
    }

    CoordinateSystemActualTransformsType* CoordinateSystemActualTransformsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoordinateSystemActualTransformsType (*this, f, c);
    }

    CoordinateSystemActualTransformsType& CoordinateSystemActualTransformsType::
    operator= (const CoordinateSystemActualTransformsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    CoordinateSystemActualTransformsType::
    ~CoordinateSystemActualTransformsType ()
    {
    }

    // ThreadSpecificationDetailedBaseType
    //

    ThreadSpecificationDetailedBaseType::
    ThreadSpecificationDetailedBaseType (const Diameter_type& Diameter,
                                         const ThreadSeries_type& ThreadSeries,
                                         const ThreadToleranceClass_type& ThreadToleranceClass,
                                         const id_type& id)
    : ::xml_schema::type (),
      Diameter_ (Diameter, this),
      ThreadSeries_ (ThreadSeries, this),
      ThreadToleranceClass_ (ThreadToleranceClass, this),
      CrestDiameterToleranceClass_ (this),
      LeftHanded_ (this),
      ModifiedThread_ (this),
      ThreadLengthEngagement_ (this),
      id_ (id, this)
    {
    }

    ThreadSpecificationDetailedBaseType::
    ThreadSpecificationDetailedBaseType (::std::auto_ptr< Diameter_type > Diameter,
                                         ::std::auto_ptr< ThreadSeries_type > ThreadSeries,
                                         ::std::auto_ptr< ThreadToleranceClass_type > ThreadToleranceClass,
                                         const id_type& id)
    : ::xml_schema::type (),
      Diameter_ (Diameter, this),
      ThreadSeries_ (ThreadSeries, this),
      ThreadToleranceClass_ (ThreadToleranceClass, this),
      CrestDiameterToleranceClass_ (this),
      LeftHanded_ (this),
      ModifiedThread_ (this),
      ThreadLengthEngagement_ (this),
      id_ (id, this)
    {
    }

    ThreadSpecificationDetailedBaseType::
    ThreadSpecificationDetailedBaseType (const ThreadSpecificationDetailedBaseType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Diameter_ (x.Diameter_, f, this),
      ThreadSeries_ (x.ThreadSeries_, f, this),
      ThreadToleranceClass_ (x.ThreadToleranceClass_, f, this),
      CrestDiameterToleranceClass_ (x.CrestDiameterToleranceClass_, f, this),
      LeftHanded_ (x.LeftHanded_, f, this),
      ModifiedThread_ (x.ModifiedThread_, f, this),
      ThreadLengthEngagement_ (x.ThreadLengthEngagement_, f, this),
      id_ (x.id_, f, this)
    {
    }

    ThreadSpecificationDetailedBaseType::
    ThreadSpecificationDetailedBaseType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Diameter_ (this),
      ThreadSeries_ (this),
      ThreadToleranceClass_ (this),
      CrestDiameterToleranceClass_ (this),
      LeftHanded_ (this),
      ModifiedThread_ (this),
      ThreadLengthEngagement_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ThreadSpecificationDetailedBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // ThreadSeries
        //
        if (n.name () == "ThreadSeries" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThreadSeries_type > r (
            ThreadSeries_traits::create (i, f, this));

          if (!ThreadSeries_.present ())
          {
            this->ThreadSeries_.set (r);
            continue;
          }
        }

        // ThreadToleranceClass
        //
        if (n.name () == "ThreadToleranceClass" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThreadToleranceClass_type > r (
            ThreadToleranceClass_traits::create (i, f, this));

          if (!ThreadToleranceClass_.present ())
          {
            this->ThreadToleranceClass_.set (r);
            continue;
          }
        }

        // CrestDiameterToleranceClass
        //
        if (n.name () == "CrestDiameterToleranceClass" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CrestDiameterToleranceClass_type > r (
            CrestDiameterToleranceClass_traits::create (i, f, this));

          if (!this->CrestDiameterToleranceClass_)
          {
            this->CrestDiameterToleranceClass_.set (r);
            continue;
          }
        }

        // LeftHanded
        //
        if (n.name () == "LeftHanded" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->LeftHanded_)
          {
            this->LeftHanded_.set (LeftHanded_traits::create (i, f, this));
            continue;
          }
        }

        // ModifiedThread
        //
        if (n.name () == "ModifiedThread" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->ModifiedThread_)
          {
            this->ModifiedThread_.set (ModifiedThread_traits::create (i, f, this));
            continue;
          }
        }

        // ThreadLengthEngagement
        //
        if (n.name () == "ThreadLengthEngagement" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThreadLengthEngagement_type > r (
            ThreadLengthEngagement_traits::create (i, f, this));

          if (!this->ThreadLengthEngagement_)
          {
            this->ThreadLengthEngagement_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Diameter",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ThreadSeries_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ThreadSeries",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ThreadToleranceClass_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ThreadToleranceClass",
          "http://qifstandards.org/xsd/qif2");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    ThreadSpecificationDetailedBaseType* ThreadSpecificationDetailedBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadSpecificationDetailedBaseType (*this, f, c);
    }

    ThreadSpecificationDetailedBaseType& ThreadSpecificationDetailedBaseType::
    operator= (const ThreadSpecificationDetailedBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Diameter_ = x.Diameter_;
        this->ThreadSeries_ = x.ThreadSeries_;
        this->ThreadToleranceClass_ = x.ThreadToleranceClass_;
        this->CrestDiameterToleranceClass_ = x.CrestDiameterToleranceClass_;
        this->LeftHanded_ = x.LeftHanded_;
        this->ModifiedThread_ = x.ModifiedThread_;
        this->ThreadLengthEngagement_ = x.ThreadLengthEngagement_;
        this->id_ = x.id_;
      }

      return *this;
    }

    ThreadSpecificationDetailedBaseType::
    ~ThreadSpecificationDetailedBaseType ()
    {
    }

    // SingleLeadThreadSpecificationType
    //

    SingleLeadThreadSpecificationType::
    SingleLeadThreadSpecificationType (const Diameter_type& Diameter,
                                       const ThreadSeries_type& ThreadSeries,
                                       const ThreadToleranceClass_type& ThreadToleranceClass,
                                       const id_type& id,
                                       const ThreadDensity_type& ThreadDensity)
    : ::xsd::qif2::ThreadSpecificationDetailedBaseType (Diameter,
                                                        ThreadSeries,
                                                        ThreadToleranceClass,
                                                        id),
      ThreadDensity_ (ThreadDensity, this)
    {
    }

    SingleLeadThreadSpecificationType::
    SingleLeadThreadSpecificationType (::std::auto_ptr< Diameter_type > Diameter,
                                       ::std::auto_ptr< ThreadSeries_type > ThreadSeries,
                                       ::std::auto_ptr< ThreadToleranceClass_type > ThreadToleranceClass,
                                       const id_type& id,
                                       ::std::auto_ptr< ThreadDensity_type > ThreadDensity)
    : ::xsd::qif2::ThreadSpecificationDetailedBaseType (Diameter,
                                                        ThreadSeries,
                                                        ThreadToleranceClass,
                                                        id),
      ThreadDensity_ (ThreadDensity, this)
    {
    }

    SingleLeadThreadSpecificationType::
    SingleLeadThreadSpecificationType (const SingleLeadThreadSpecificationType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::ThreadSpecificationDetailedBaseType (x, f, c),
      ThreadDensity_ (x.ThreadDensity_, f, this)
    {
    }

    SingleLeadThreadSpecificationType::
    SingleLeadThreadSpecificationType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::ThreadSpecificationDetailedBaseType (e, f | ::xml_schema::flags::base, c),
      ThreadDensity_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SingleLeadThreadSpecificationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ThreadSpecificationDetailedBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThreadDensity
        //
        if (n.name () == "ThreadDensity" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThreadDensity_type > r (
            ThreadDensity_traits::create (i, f, this));

          if (!ThreadDensity_.present ())
          {
            this->ThreadDensity_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ThreadDensity_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ThreadDensity",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SingleLeadThreadSpecificationType* SingleLeadThreadSpecificationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SingleLeadThreadSpecificationType (*this, f, c);
    }

    SingleLeadThreadSpecificationType& SingleLeadThreadSpecificationType::
    operator= (const SingleLeadThreadSpecificationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ThreadSpecificationDetailedBaseType& > (*this) = x;
        this->ThreadDensity_ = x.ThreadDensity_;
      }

      return *this;
    }

    SingleLeadThreadSpecificationType::
    ~SingleLeadThreadSpecificationType ()
    {
    }

    // MultiLeadThreadSpecificationType
    //

    MultiLeadThreadSpecificationType::
    MultiLeadThreadSpecificationType (const Diameter_type& Diameter,
                                      const ThreadSeries_type& ThreadSeries,
                                      const ThreadToleranceClass_type& ThreadToleranceClass,
                                      const id_type& id,
                                      const ThreadPitch_type& ThreadPitch,
                                      const ThreadLeadDistance_type& ThreadLeadDistance,
                                      const ThreadLeadStarts_type& ThreadLeadStarts)
    : ::xsd::qif2::ThreadSpecificationDetailedBaseType (Diameter,
                                                        ThreadSeries,
                                                        ThreadToleranceClass,
                                                        id),
      ThreadPitch_ (ThreadPitch, this),
      ThreadLeadDistance_ (ThreadLeadDistance, this),
      ThreadLeadStarts_ (ThreadLeadStarts, this)
    {
    }

    MultiLeadThreadSpecificationType::
    MultiLeadThreadSpecificationType (::std::auto_ptr< Diameter_type > Diameter,
                                      ::std::auto_ptr< ThreadSeries_type > ThreadSeries,
                                      ::std::auto_ptr< ThreadToleranceClass_type > ThreadToleranceClass,
                                      const id_type& id,
                                      ::std::auto_ptr< ThreadPitch_type > ThreadPitch,
                                      ::std::auto_ptr< ThreadLeadDistance_type > ThreadLeadDistance,
                                      const ThreadLeadStarts_type& ThreadLeadStarts)
    : ::xsd::qif2::ThreadSpecificationDetailedBaseType (Diameter,
                                                        ThreadSeries,
                                                        ThreadToleranceClass,
                                                        id),
      ThreadPitch_ (ThreadPitch, this),
      ThreadLeadDistance_ (ThreadLeadDistance, this),
      ThreadLeadStarts_ (ThreadLeadStarts, this)
    {
    }

    MultiLeadThreadSpecificationType::
    MultiLeadThreadSpecificationType (const MultiLeadThreadSpecificationType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::ThreadSpecificationDetailedBaseType (x, f, c),
      ThreadPitch_ (x.ThreadPitch_, f, this),
      ThreadLeadDistance_ (x.ThreadLeadDistance_, f, this),
      ThreadLeadStarts_ (x.ThreadLeadStarts_, f, this)
    {
    }

    MultiLeadThreadSpecificationType::
    MultiLeadThreadSpecificationType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::ThreadSpecificationDetailedBaseType (e, f | ::xml_schema::flags::base, c),
      ThreadPitch_ (this),
      ThreadLeadDistance_ (this),
      ThreadLeadStarts_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MultiLeadThreadSpecificationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ThreadSpecificationDetailedBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThreadPitch
        //
        if (n.name () == "ThreadPitch" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThreadPitch_type > r (
            ThreadPitch_traits::create (i, f, this));

          if (!ThreadPitch_.present ())
          {
            this->ThreadPitch_.set (r);
            continue;
          }
        }

        // ThreadLeadDistance
        //
        if (n.name () == "ThreadLeadDistance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThreadLeadDistance_type > r (
            ThreadLeadDistance_traits::create (i, f, this));

          if (!ThreadLeadDistance_.present ())
          {
            this->ThreadLeadDistance_.set (r);
            continue;
          }
        }

        // ThreadLeadStarts
        //
        if (n.name () == "ThreadLeadStarts" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!ThreadLeadStarts_.present ())
          {
            this->ThreadLeadStarts_.set (ThreadLeadStarts_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!ThreadPitch_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ThreadPitch",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ThreadLeadDistance_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ThreadLeadDistance",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ThreadLeadStarts_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ThreadLeadStarts",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    MultiLeadThreadSpecificationType* MultiLeadThreadSpecificationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MultiLeadThreadSpecificationType (*this, f, c);
    }

    MultiLeadThreadSpecificationType& MultiLeadThreadSpecificationType::
    operator= (const MultiLeadThreadSpecificationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ThreadSpecificationDetailedBaseType& > (*this) = x;
        this->ThreadPitch_ = x.ThreadPitch_;
        this->ThreadLeadDistance_ = x.ThreadLeadDistance_;
        this->ThreadLeadStarts_ = x.ThreadLeadStarts_;
      }

      return *this;
    }

    MultiLeadThreadSpecificationType::
    ~MultiLeadThreadSpecificationType ()
    {
    }

    // ThreadSpecificationType
    //

    ThreadSpecificationType::
    ThreadSpecificationType ()
    : ::xml_schema::type (),
      SingleLeadSpecification_ (this),
      MultiLeadSpecification_ (this),
      TextThreadSpecification_ (this)
    {
    }

    ThreadSpecificationType::
    ThreadSpecificationType (const ThreadSpecificationType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SingleLeadSpecification_ (x.SingleLeadSpecification_, f, this),
      MultiLeadSpecification_ (x.MultiLeadSpecification_, f, this),
      TextThreadSpecification_ (x.TextThreadSpecification_, f, this)
    {
    }

    ThreadSpecificationType::
    ThreadSpecificationType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SingleLeadSpecification_ (this),
      MultiLeadSpecification_ (this),
      TextThreadSpecification_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadSpecificationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SingleLeadSpecification
        //
        if (n.name () == "SingleLeadSpecification" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SingleLeadSpecification_type > r (
            SingleLeadSpecification_traits::create (i, f, this));

          if (!this->SingleLeadSpecification_)
          {
            this->SingleLeadSpecification_.set (r);
            continue;
          }
        }

        // MultiLeadSpecification
        //
        if (n.name () == "MultiLeadSpecification" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MultiLeadSpecification_type > r (
            MultiLeadSpecification_traits::create (i, f, this));

          if (!this->MultiLeadSpecification_)
          {
            this->MultiLeadSpecification_.set (r);
            continue;
          }
        }

        // TextThreadSpecification
        //
        if (n.name () == "TextThreadSpecification" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TextThreadSpecification_type > r (
            TextThreadSpecification_traits::create (i, f, this));

          if (!this->TextThreadSpecification_)
          {
            this->TextThreadSpecification_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ThreadSpecificationType* ThreadSpecificationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadSpecificationType (*this, f, c);
    }

    ThreadSpecificationType& ThreadSpecificationType::
    operator= (const ThreadSpecificationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SingleLeadSpecification_ = x.SingleLeadSpecification_;
        this->MultiLeadSpecification_ = x.MultiLeadSpecification_;
        this->TextThreadSpecification_ = x.TextThreadSpecification_;
      }

      return *this;
    }

    ThreadSpecificationType::
    ~ThreadSpecificationType ()
    {
    }

    // TextThreadSpecificationType
    //

    TextThreadSpecificationType::
    TextThreadSpecificationType (const TextSpecification_type& TextSpecification,
                                 const id_type& id)
    : ::xml_schema::type (),
      TextSpecification_ (TextSpecification, this),
      id_ (id, this)
    {
    }

    TextThreadSpecificationType::
    TextThreadSpecificationType (const TextThreadSpecificationType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      TextSpecification_ (x.TextSpecification_, f, this),
      id_ (x.id_, f, this)
    {
    }

    TextThreadSpecificationType::
    TextThreadSpecificationType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      TextSpecification_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TextThreadSpecificationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // TextSpecification
        //
        if (n.name () == "TextSpecification" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TextSpecification_type > r (
            TextSpecification_traits::create (i, f, this));

          if (!TextSpecification_.present ())
          {
            this->TextSpecification_.set (r);
            continue;
          }
        }

        break;
      }

      if (!TextSpecification_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "TextSpecification",
          "http://qifstandards.org/xsd/qif2");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    TextThreadSpecificationType* TextThreadSpecificationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TextThreadSpecificationType (*this, f, c);
    }

    TextThreadSpecificationType& TextThreadSpecificationType::
    operator= (const TextThreadSpecificationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->TextSpecification_ = x.TextSpecification_;
        this->id_ = x.id_;
      }

      return *this;
    }

    TextThreadSpecificationType::
    ~TextThreadSpecificationType ()
    {
    }

    // ThreadSpecificationsType
    //

    ThreadSpecificationsType::
    ThreadSpecificationsType ()
    : ::xml_schema::type (),
      ThreadSpecification_ (this)
    {
    }

    ThreadSpecificationsType::
    ThreadSpecificationsType (const ThreadSpecificationsType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ThreadSpecification_ (x.ThreadSpecification_, f, this)
    {
    }

    ThreadSpecificationsType::
    ThreadSpecificationsType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ThreadSpecification_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadSpecificationsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThreadSpecification
        //
        if (n.name () == "ThreadSpecification" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThreadSpecification_type > r (
            ThreadSpecification_traits::create (i, f, this));

          this->ThreadSpecification_.push_back (r);
          continue;
        }

        break;
      }
    }

    ThreadSpecificationsType* ThreadSpecificationsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadSpecificationsType (*this, f, c);
    }

    ThreadSpecificationsType& ThreadSpecificationsType::
    operator= (const ThreadSpecificationsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ThreadSpecification_ = x.ThreadSpecification_;
      }

      return *this;
    }

    ThreadSpecificationsType::
    ~ThreadSpecificationsType ()
    {
    }

    // ToleranceZonePerUnitAreaType
    //

    ToleranceZonePerUnitAreaType::
    ToleranceZonePerUnitAreaType (const ToleranceValuePerUnit_type& ToleranceValuePerUnit)
    : ::xml_schema::type (),
      ToleranceValuePerUnit_ (ToleranceValuePerUnit, this),
      RectangularUnitArea_ (this),
      CircularUnitArea_ (this)
    {
    }

    ToleranceZonePerUnitAreaType::
    ToleranceZonePerUnitAreaType (::std::auto_ptr< ToleranceValuePerUnit_type > ToleranceValuePerUnit)
    : ::xml_schema::type (),
      ToleranceValuePerUnit_ (ToleranceValuePerUnit, this),
      RectangularUnitArea_ (this),
      CircularUnitArea_ (this)
    {
    }

    ToleranceZonePerUnitAreaType::
    ToleranceZonePerUnitAreaType (const ToleranceZonePerUnitAreaType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ToleranceValuePerUnit_ (x.ToleranceValuePerUnit_, f, this),
      RectangularUnitArea_ (x.RectangularUnitArea_, f, this),
      CircularUnitArea_ (x.CircularUnitArea_, f, this)
    {
    }

    ToleranceZonePerUnitAreaType::
    ToleranceZonePerUnitAreaType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ToleranceValuePerUnit_ (this),
      RectangularUnitArea_ (this),
      CircularUnitArea_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToleranceZonePerUnitAreaType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ToleranceValuePerUnit
        //
        if (n.name () == "ToleranceValuePerUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ToleranceValuePerUnit_type > r (
            ToleranceValuePerUnit_traits::create (i, f, this));

          if (!ToleranceValuePerUnit_.present ())
          {
            this->ToleranceValuePerUnit_.set (r);
            continue;
          }
        }

        // RectangularUnitArea
        //
        if (n.name () == "RectangularUnitArea" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RectangularUnitArea_type > r (
            RectangularUnitArea_traits::create (i, f, this));

          if (!this->RectangularUnitArea_)
          {
            this->RectangularUnitArea_.set (r);
            continue;
          }
        }

        // CircularUnitArea
        //
        if (n.name () == "CircularUnitArea" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CircularUnitArea_type > r (
            CircularUnitArea_traits::create (i, f, this));

          if (!this->CircularUnitArea_)
          {
            this->CircularUnitArea_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ToleranceValuePerUnit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ToleranceValuePerUnit",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ToleranceZonePerUnitAreaType* ToleranceZonePerUnitAreaType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToleranceZonePerUnitAreaType (*this, f, c);
    }

    ToleranceZonePerUnitAreaType& ToleranceZonePerUnitAreaType::
    operator= (const ToleranceZonePerUnitAreaType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ToleranceValuePerUnit_ = x.ToleranceValuePerUnit_;
        this->RectangularUnitArea_ = x.RectangularUnitArea_;
        this->CircularUnitArea_ = x.CircularUnitArea_;
      }

      return *this;
    }

    ToleranceZonePerUnitAreaType::
    ~ToleranceZonePerUnitAreaType ()
    {
    }

    // ToleranceZonePerUnitLengthType
    //

    ToleranceZonePerUnitLengthType::
    ToleranceZonePerUnitLengthType (const ToleranceValuePerUnit_type& ToleranceValuePerUnit,
                                    const UnitLength_type& UnitLength)
    : ::xml_schema::type (),
      ToleranceValuePerUnit_ (ToleranceValuePerUnit, this),
      UnitLength_ (UnitLength, this)
    {
    }

    ToleranceZonePerUnitLengthType::
    ToleranceZonePerUnitLengthType (::std::auto_ptr< ToleranceValuePerUnit_type > ToleranceValuePerUnit,
                                    ::std::auto_ptr< UnitLength_type > UnitLength)
    : ::xml_schema::type (),
      ToleranceValuePerUnit_ (ToleranceValuePerUnit, this),
      UnitLength_ (UnitLength, this)
    {
    }

    ToleranceZonePerUnitLengthType::
    ToleranceZonePerUnitLengthType (const ToleranceZonePerUnitLengthType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ToleranceValuePerUnit_ (x.ToleranceValuePerUnit_, f, this),
      UnitLength_ (x.UnitLength_, f, this)
    {
    }

    ToleranceZonePerUnitLengthType::
    ToleranceZonePerUnitLengthType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ToleranceValuePerUnit_ (this),
      UnitLength_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToleranceZonePerUnitLengthType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ToleranceValuePerUnit
        //
        if (n.name () == "ToleranceValuePerUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ToleranceValuePerUnit_type > r (
            ToleranceValuePerUnit_traits::create (i, f, this));

          if (!ToleranceValuePerUnit_.present ())
          {
            this->ToleranceValuePerUnit_.set (r);
            continue;
          }
        }

        // UnitLength
        //
        if (n.name () == "UnitLength" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitLength_type > r (
            UnitLength_traits::create (i, f, this));

          if (!UnitLength_.present ())
          {
            this->UnitLength_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ToleranceValuePerUnit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ToleranceValuePerUnit",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!UnitLength_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitLength",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ToleranceZonePerUnitLengthType* ToleranceZonePerUnitLengthType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToleranceZonePerUnitLengthType (*this, f, c);
    }

    ToleranceZonePerUnitLengthType& ToleranceZonePerUnitLengthType::
    operator= (const ToleranceZonePerUnitLengthType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ToleranceValuePerUnit_ = x.ToleranceValuePerUnit_;
        this->UnitLength_ = x.UnitLength_;
      }

      return *this;
    }

    ToleranceZonePerUnitLengthType::
    ~ToleranceZonePerUnitLengthType ()
    {
    }

    // ToleranceZonePerUnitAngleType
    //

    ToleranceZonePerUnitAngleType::
    ToleranceZonePerUnitAngleType (const ToleranceValuePerUnit_type& ToleranceValuePerUnit,
                                   const UnitAngle_type& UnitAngle)
    : ::xml_schema::type (),
      ToleranceValuePerUnit_ (ToleranceValuePerUnit, this),
      UnitAngle_ (UnitAngle, this)
    {
    }

    ToleranceZonePerUnitAngleType::
    ToleranceZonePerUnitAngleType (::std::auto_ptr< ToleranceValuePerUnit_type > ToleranceValuePerUnit,
                                   ::std::auto_ptr< UnitAngle_type > UnitAngle)
    : ::xml_schema::type (),
      ToleranceValuePerUnit_ (ToleranceValuePerUnit, this),
      UnitAngle_ (UnitAngle, this)
    {
    }

    ToleranceZonePerUnitAngleType::
    ToleranceZonePerUnitAngleType (const ToleranceZonePerUnitAngleType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ToleranceValuePerUnit_ (x.ToleranceValuePerUnit_, f, this),
      UnitAngle_ (x.UnitAngle_, f, this)
    {
    }

    ToleranceZonePerUnitAngleType::
    ToleranceZonePerUnitAngleType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ToleranceValuePerUnit_ (this),
      UnitAngle_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToleranceZonePerUnitAngleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ToleranceValuePerUnit
        //
        if (n.name () == "ToleranceValuePerUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ToleranceValuePerUnit_type > r (
            ToleranceValuePerUnit_traits::create (i, f, this));

          if (!ToleranceValuePerUnit_.present ())
          {
            this->ToleranceValuePerUnit_.set (r);
            continue;
          }
        }

        // UnitAngle
        //
        if (n.name () == "UnitAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitAngle_type > r (
            UnitAngle_traits::create (i, f, this));

          if (!UnitAngle_.present ())
          {
            this->UnitAngle_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ToleranceValuePerUnit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ToleranceValuePerUnit",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!UnitAngle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitAngle",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ToleranceZonePerUnitAngleType* ToleranceZonePerUnitAngleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToleranceZonePerUnitAngleType (*this, f, c);
    }

    ToleranceZonePerUnitAngleType& ToleranceZonePerUnitAngleType::
    operator= (const ToleranceZonePerUnitAngleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ToleranceValuePerUnit_ = x.ToleranceValuePerUnit_;
        this->UnitAngle_ = x.UnitAngle_;
      }

      return *this;
    }

    ToleranceZonePerUnitAngleType::
    ~ToleranceZonePerUnitAngleType ()
    {
    }

    // ToleranceZonePerUnitPolarAreaType
    //

    ToleranceZonePerUnitPolarAreaType::
    ToleranceZonePerUnitPolarAreaType (const ToleranceValuePerUnit_type& ToleranceValuePerUnit,
                                       const UnitAngle_type& UnitAngle,
                                       const UnitLength_type& UnitLength)
    : ::xml_schema::type (),
      ToleranceValuePerUnit_ (ToleranceValuePerUnit, this),
      UnitAngle_ (UnitAngle, this),
      UnitLength_ (UnitLength, this)
    {
    }

    ToleranceZonePerUnitPolarAreaType::
    ToleranceZonePerUnitPolarAreaType (::std::auto_ptr< ToleranceValuePerUnit_type > ToleranceValuePerUnit,
                                       ::std::auto_ptr< UnitAngle_type > UnitAngle,
                                       ::std::auto_ptr< UnitLength_type > UnitLength)
    : ::xml_schema::type (),
      ToleranceValuePerUnit_ (ToleranceValuePerUnit, this),
      UnitAngle_ (UnitAngle, this),
      UnitLength_ (UnitLength, this)
    {
    }

    ToleranceZonePerUnitPolarAreaType::
    ToleranceZonePerUnitPolarAreaType (const ToleranceZonePerUnitPolarAreaType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ToleranceValuePerUnit_ (x.ToleranceValuePerUnit_, f, this),
      UnitAngle_ (x.UnitAngle_, f, this),
      UnitLength_ (x.UnitLength_, f, this)
    {
    }

    ToleranceZonePerUnitPolarAreaType::
    ToleranceZonePerUnitPolarAreaType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ToleranceValuePerUnit_ (this),
      UnitAngle_ (this),
      UnitLength_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToleranceZonePerUnitPolarAreaType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ToleranceValuePerUnit
        //
        if (n.name () == "ToleranceValuePerUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ToleranceValuePerUnit_type > r (
            ToleranceValuePerUnit_traits::create (i, f, this));

          if (!ToleranceValuePerUnit_.present ())
          {
            this->ToleranceValuePerUnit_.set (r);
            continue;
          }
        }

        // UnitAngle
        //
        if (n.name () == "UnitAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitAngle_type > r (
            UnitAngle_traits::create (i, f, this));

          if (!UnitAngle_.present ())
          {
            this->UnitAngle_.set (r);
            continue;
          }
        }

        // UnitLength
        //
        if (n.name () == "UnitLength" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitLength_type > r (
            UnitLength_traits::create (i, f, this));

          if (!UnitLength_.present ())
          {
            this->UnitLength_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ToleranceValuePerUnit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ToleranceValuePerUnit",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!UnitAngle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitAngle",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!UnitLength_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitLength",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ToleranceZonePerUnitPolarAreaType* ToleranceZonePerUnitPolarAreaType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToleranceZonePerUnitPolarAreaType (*this, f, c);
    }

    ToleranceZonePerUnitPolarAreaType& ToleranceZonePerUnitPolarAreaType::
    operator= (const ToleranceZonePerUnitPolarAreaType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ToleranceValuePerUnit_ = x.ToleranceValuePerUnit_;
        this->UnitAngle_ = x.UnitAngle_;
        this->UnitLength_ = x.UnitLength_;
      }

      return *this;
    }

    ToleranceZonePerUnitPolarAreaType::
    ~ToleranceZonePerUnitPolarAreaType ()
    {
    }

    // CompoundFeatureGeometryEnumType
    //

    CompoundFeatureGeometryEnumType::
    CompoundFeatureGeometryEnumType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_CompoundFeatureGeometryEnumType_convert ();
    }

    CompoundFeatureGeometryEnumType::
    CompoundFeatureGeometryEnumType (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_CompoundFeatureGeometryEnumType_convert ();
    }

    CompoundFeatureGeometryEnumType::
    CompoundFeatureGeometryEnumType (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_CompoundFeatureGeometryEnumType_convert ();
    }

    CompoundFeatureGeometryEnumType* CompoundFeatureGeometryEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompoundFeatureGeometryEnumType (*this, f, c);
    }

    CompoundFeatureGeometryEnumType::value CompoundFeatureGeometryEnumType::
    _xsd_CompoundFeatureGeometryEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CompoundFeatureGeometryEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_CompoundFeatureGeometryEnumType_indexes_,
                        _xsd_CompoundFeatureGeometryEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_CompoundFeatureGeometryEnumType_indexes_ + 3 || _xsd_CompoundFeatureGeometryEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const CompoundFeatureGeometryEnumType::
    _xsd_CompoundFeatureGeometryEnumType_literals_[3] =
    {
      "COAXIAL",
      "COPLANAR",
      "COCENTERED"
    };

    const CompoundFeatureGeometryEnumType::value CompoundFeatureGeometryEnumType::
    _xsd_CompoundFeatureGeometryEnumType_indexes_[3] =
    {
      ::xsd::qif2::CompoundFeatureGeometryEnumType::COAXIAL,
      ::xsd::qif2::CompoundFeatureGeometryEnumType::COCENTERED,
      ::xsd::qif2::CompoundFeatureGeometryEnumType::COPLANAR
    };

    // DatumReferenceFramesType
    //

    DatumReferenceFramesType::
    DatumReferenceFramesType ()
    : ::xml_schema::type (),
      DatumReferenceFrame_ (this)
    {
    }

    DatumReferenceFramesType::
    DatumReferenceFramesType (const DatumReferenceFramesType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DatumReferenceFrame_ (x.DatumReferenceFrame_, f, this)
    {
    }

    DatumReferenceFramesType::
    DatumReferenceFramesType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DatumReferenceFrame_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DatumReferenceFramesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DatumReferenceFrame
        //
        if (n.name () == "DatumReferenceFrame" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DatumReferenceFrame_type > r (
            DatumReferenceFrame_traits::create (i, f, this));

          this->DatumReferenceFrame_.push_back (r);
          continue;
        }

        break;
      }
    }

    DatumReferenceFramesType* DatumReferenceFramesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumReferenceFramesType (*this, f, c);
    }

    DatumReferenceFramesType& DatumReferenceFramesType::
    operator= (const DatumReferenceFramesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DatumReferenceFrame_ = x.DatumReferenceFrame_;
      }

      return *this;
    }

    DatumReferenceFramesType::
    ~DatumReferenceFramesType ()
    {
    }

    // EventBaseType
    //

    EventBaseType::
    EventBaseType (const Description_type& Description,
                   const id_type& id)
    : ::xml_schema::type (),
      Description_ (Description, this),
      id_ (id, this)
    {
    }

    EventBaseType::
    EventBaseType (const EventBaseType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Description_ (x.Description_, f, this),
      id_ (x.id_, f, this)
    {
    }

    EventBaseType::
    EventBaseType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Description_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EventBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Description
        //
        if (n.name () == "Description" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!Description_.present ())
          {
            this->Description_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Description",
          "http://qifstandards.org/xsd/qif2");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    EventBaseType* EventBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EventBaseType (*this, f, c);
    }

    EventBaseType& EventBaseType::
    operator= (const EventBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Description_ = x.Description_;
        this->id_ = x.id_;
      }

      return *this;
    }

    EventBaseType::
    ~EventBaseType ()
    {
    }

    // NotableEventType
    //

    NotableEventType::
    NotableEventType (const Description_type& Description,
                      const id_type& id,
                      const Active_type& Active)
    : ::xsd::qif2::EventBaseType (Description,
                                  id),
      Active_ (Active, this)
    {
    }

    NotableEventType::
    NotableEventType (const NotableEventType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::EventBaseType (x, f, c),
      Active_ (x.Active_, f, this)
    {
    }

    NotableEventType::
    NotableEventType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::EventBaseType (e, f | ::xml_schema::flags::base, c),
      Active_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void NotableEventType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::EventBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Active
        //
        if (n.name () == "Active" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!Active_.present ())
          {
            this->Active_.set (Active_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!Active_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Active",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    NotableEventType* NotableEventType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NotableEventType (*this, f, c);
    }

    NotableEventType& NotableEventType::
    operator= (const NotableEventType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::EventBaseType& > (*this) = x;
        this->Active_ = x.Active_;
      }

      return *this;
    }

    NotableEventType::
    ~NotableEventType ()
    {
    }

    // NotableEventsType
    //

    NotableEventsType::
    NotableEventsType ()
    : ::xml_schema::type (),
      NotableEvent_ (this)
    {
    }

    NotableEventsType::
    NotableEventsType (const NotableEventsType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      NotableEvent_ (x.NotableEvent_, f, this)
    {
    }

    NotableEventsType::
    NotableEventsType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      NotableEvent_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void NotableEventsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // NotableEvent
        //
        if (n.name () == "NotableEvent" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< NotableEvent_type > r (
            NotableEvent_traits::create (i, f, this));

          this->NotableEvent_.push_back (r);
          continue;
        }

        break;
      }
    }

    NotableEventsType* NotableEventsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NotableEventsType (*this, f, c);
    }

    NotableEventsType& NotableEventsType::
    operator= (const NotableEventsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->NotableEvent_ = x.NotableEvent_;
      }

      return *this;
    }

    NotableEventsType::
    ~NotableEventsType ()
    {
    }

    // NotedEventType
    //

    NotedEventType::
    NotedEventType (const Description_type& Description,
                    const id_type& id,
                    const SequenceNumber_type& SequenceNumber)
    : ::xsd::qif2::EventBaseType (Description,
                                  id),
      SequenceNumber_ (SequenceNumber, this),
      TimeOccurred_ (this),
      NotableEventId_ (this)
    {
    }

    NotedEventType::
    NotedEventType (const NotedEventType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::EventBaseType (x, f, c),
      SequenceNumber_ (x.SequenceNumber_, f, this),
      TimeOccurred_ (x.TimeOccurred_, f, this),
      NotableEventId_ (x.NotableEventId_, f, this)
    {
    }

    NotedEventType::
    NotedEventType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::EventBaseType (e, f | ::xml_schema::flags::base, c),
      SequenceNumber_ (this),
      TimeOccurred_ (this),
      NotableEventId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void NotedEventType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::EventBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SequenceNumber
        //
        if (n.name () == "SequenceNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!SequenceNumber_.present ())
          {
            this->SequenceNumber_.set (SequenceNumber_traits::create (i, f, this));
            continue;
          }
        }

        // TimeOccurred
        //
        if (n.name () == "TimeOccurred" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TimeOccurred_type > r (
            TimeOccurred_traits::create (i, f, this));

          if (!this->TimeOccurred_)
          {
            this->TimeOccurred_.set (r);
            continue;
          }
        }

        // NotableEventId
        //
        if (n.name () == "NotableEventId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< NotableEventId_type > r (
            NotableEventId_traits::create (i, f, this));

          if (!this->NotableEventId_)
          {
            this->NotableEventId_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SequenceNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SequenceNumber",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    NotedEventType* NotedEventType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NotedEventType (*this, f, c);
    }

    NotedEventType& NotedEventType::
    operator= (const NotedEventType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::EventBaseType& > (*this) = x;
        this->SequenceNumber_ = x.SequenceNumber_;
        this->TimeOccurred_ = x.TimeOccurred_;
        this->NotableEventId_ = x.NotableEventId_;
      }

      return *this;
    }

    NotedEventType::
    ~NotedEventType ()
    {
    }

    // NotedEventsType
    //

    NotedEventsType::
    NotedEventsType ()
    : ::xml_schema::type (),
      NotedEvent_ (this)
    {
    }

    NotedEventsType::
    NotedEventsType (const NotedEventsType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      NotedEvent_ (x.NotedEvent_, f, this)
    {
    }

    NotedEventsType::
    NotedEventsType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      NotedEvent_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void NotedEventsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // NotedEvent
        //
        if (n.name () == "NotedEvent" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< NotedEvent_type > r (
            NotedEvent_traits::create (i, f, this));

          this->NotedEvent_.push_back (r);
          continue;
        }

        break;
      }
    }

    NotedEventsType* NotedEventsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NotedEventsType (*this, f, c);
    }

    NotedEventsType& NotedEventsType::
    operator= (const NotedEventsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->NotedEvent_ = x.NotedEvent_;
      }

      return *this;
    }

    NotedEventsType::
    ~NotedEventsType ()
    {
    }

    // InspectionStatusEnumType
    //

    InspectionStatusEnumType::
    InspectionStatusEnumType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_InspectionStatusEnumType_convert ();
    }

    InspectionStatusEnumType::
    InspectionStatusEnumType (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_InspectionStatusEnumType_convert ();
    }

    InspectionStatusEnumType::
    InspectionStatusEnumType (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_InspectionStatusEnumType_convert ();
    }

    InspectionStatusEnumType* InspectionStatusEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class InspectionStatusEnumType (*this, f, c);
    }

    InspectionStatusEnumType::value InspectionStatusEnumType::
    _xsd_InspectionStatusEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_InspectionStatusEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_InspectionStatusEnumType_indexes_,
                        _xsd_InspectionStatusEnumType_indexes_ + 8,
                        *this,
                        c));

      if (i == _xsd_InspectionStatusEnumType_indexes_ + 8 || _xsd_InspectionStatusEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const InspectionStatusEnumType::
    _xsd_InspectionStatusEnumType_literals_[8] =
    {
      "PASS",
      "FAIL",
      "REWORK",
      "SYSERROR",
      "UNKNOWN",
      "NOT_CALCULATED",
      "NOT_MEASURED",
      "UNDEFINED"
    };

    const InspectionStatusEnumType::value InspectionStatusEnumType::
    _xsd_InspectionStatusEnumType_indexes_[8] =
    {
      ::xsd::qif2::InspectionStatusEnumType::FAIL,
      ::xsd::qif2::InspectionStatusEnumType::NOT_CALCULATED,
      ::xsd::qif2::InspectionStatusEnumType::NOT_MEASURED,
      ::xsd::qif2::InspectionStatusEnumType::PASS,
      ::xsd::qif2::InspectionStatusEnumType::REWORK,
      ::xsd::qif2::InspectionStatusEnumType::SYSERROR,
      ::xsd::qif2::InspectionStatusEnumType::UNDEFINED,
      ::xsd::qif2::InspectionStatusEnumType::UNKNOWN
    };

    // InspectionStatusType
    //

    InspectionStatusType::
    InspectionStatusType ()
    : ::xml_schema::type (),
      InspectionStatusEnum_ (this),
      OtherInspectionStatus_ (this)
    {
    }

    InspectionStatusType::
    InspectionStatusType (const InspectionStatusType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      InspectionStatusEnum_ (x.InspectionStatusEnum_, f, this),
      OtherInspectionStatus_ (x.OtherInspectionStatus_, f, this)
    {
    }

    InspectionStatusType::
    InspectionStatusType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      InspectionStatusEnum_ (this),
      OtherInspectionStatus_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void InspectionStatusType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InspectionStatusEnum
        //
        if (n.name () == "InspectionStatusEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InspectionStatusEnum_type > r (
            InspectionStatusEnum_traits::create (i, f, this));

          if (!this->InspectionStatusEnum_)
          {
            this->InspectionStatusEnum_.set (r);
            continue;
          }
        }

        // OtherInspectionStatus
        //
        if (n.name () == "OtherInspectionStatus" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherInspectionStatus_type > r (
            OtherInspectionStatus_traits::create (i, f, this));

          if (!this->OtherInspectionStatus_)
          {
            this->OtherInspectionStatus_.set (r);
            continue;
          }
        }

        break;
      }
    }

    InspectionStatusType* InspectionStatusType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class InspectionStatusType (*this, f, c);
    }

    InspectionStatusType& InspectionStatusType::
    operator= (const InspectionStatusType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->InspectionStatusEnum_ = x.InspectionStatusEnum_;
        this->OtherInspectionStatus_ = x.OtherInspectionStatus_;
      }

      return *this;
    }

    InspectionStatusType::
    ~InspectionStatusType ()
    {
    }

    // EntityExternalType
    //

    EntityExternalType::
    EntityExternalType (const EntityId_type& EntityId,
                        const id_type& id)
    : ::xml_schema::type (),
      EntityId_ (EntityId, this),
      Name_ (this),
      Description_ (this),
      id_ (id, this)
    {
    }

    EntityExternalType::
    EntityExternalType (const EntityExternalType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      EntityId_ (x.EntityId_, f, this),
      Name_ (x.Name_, f, this),
      Description_ (x.Description_, f, this),
      id_ (x.id_, f, this)
    {
    }

    EntityExternalType::
    EntityExternalType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      EntityId_ (this),
      Name_ (this),
      Description_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EntityExternalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EntityId
        //
        if (n.name () == "EntityId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EntityId_type > r (
            EntityId_traits::create (i, f, this));

          if (!EntityId_.present ())
          {
            this->EntityId_.set (r);
            continue;
          }
        }

        // Name
        //
        if (n.name () == "Name" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!this->Name_)
          {
            this->Name_.set (r);
            continue;
          }
        }

        // Description
        //
        if (n.name () == "Description" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (r);
            continue;
          }
        }

        break;
      }

      if (!EntityId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EntityId",
          "http://qifstandards.org/xsd/qif2");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    EntityExternalType* EntityExternalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EntityExternalType (*this, f, c);
    }

    EntityExternalType& EntityExternalType::
    operator= (const EntityExternalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->EntityId_ = x.EntityId_;
        this->Name_ = x.Name_;
        this->Description_ = x.Description_;
        this->id_ = x.id_;
      }

      return *this;
    }

    EntityExternalType::
    ~EntityExternalType ()
    {
    }

    // EntitiesExternalType
    //

    EntitiesExternalType::
    EntitiesExternalType ()
    : ::xml_schema::type (),
      Entity_ (this)
    {
    }

    EntitiesExternalType::
    EntitiesExternalType (const EntitiesExternalType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Entity_ (x.Entity_, f, this)
    {
    }

    EntitiesExternalType::
    EntitiesExternalType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Entity_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EntitiesExternalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Entity
        //
        if (n.name () == "Entity" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Entity_type > r (
            Entity_traits::create (i, f, this));

          this->Entity_.push_back (r);
          continue;
        }

        break;
      }
    }

    EntitiesExternalType* EntitiesExternalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EntitiesExternalType (*this, f, c);
    }

    EntitiesExternalType& EntitiesExternalType::
    operator= (const EntitiesExternalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Entity_ = x.Entity_;
      }

      return *this;
    }

    EntitiesExternalType::
    ~EntitiesExternalType ()
    {
    }

    // ZoneDataType
    //

    ZoneDataType::
    ZoneDataType (const FeatureItemId_type& FeatureItemId,
                  const Bonus_type& Bonus,
                  const ReferenceLength_type& ReferenceLength)
    : ::xml_schema::type (),
      FeatureItemId_ (FeatureItemId, this),
      Bonus_ (Bonus, this),
      ReferenceLength_ (ReferenceLength, this)
    {
    }

    ZoneDataType::
    ZoneDataType (::std::auto_ptr< FeatureItemId_type > FeatureItemId,
                  ::std::auto_ptr< Bonus_type > Bonus,
                  ::std::auto_ptr< ReferenceLength_type > ReferenceLength)
    : ::xml_schema::type (),
      FeatureItemId_ (FeatureItemId, this),
      Bonus_ (Bonus, this),
      ReferenceLength_ (ReferenceLength, this)
    {
    }

    ZoneDataType::
    ZoneDataType (const ZoneDataType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureItemId_ (x.FeatureItemId_, f, this),
      Bonus_ (x.Bonus_, f, this),
      ReferenceLength_ (x.ReferenceLength_, f, this)
    {
    }

    ZoneDataType::
    ZoneDataType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureItemId_ (this),
      Bonus_ (this),
      ReferenceLength_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ZoneDataType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FeatureItemId
        //
        if (n.name () == "FeatureItemId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureItemId_type > r (
            FeatureItemId_traits::create (i, f, this));

          if (!FeatureItemId_.present ())
          {
            this->FeatureItemId_.set (r);
            continue;
          }
        }

        // Bonus
        //
        if (n.name () == "Bonus" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Bonus_type > r (
            Bonus_traits::create (i, f, this));

          if (!Bonus_.present ())
          {
            this->Bonus_.set (r);
            continue;
          }
        }

        // ReferenceLength
        //
        if (n.name () == "ReferenceLength" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ReferenceLength_type > r (
            ReferenceLength_traits::create (i, f, this));

          if (!ReferenceLength_.present ())
          {
            this->ReferenceLength_.set (r);
            continue;
          }
        }

        break;
      }

      if (!FeatureItemId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "FeatureItemId",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Bonus_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Bonus",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ReferenceLength_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ReferenceLength",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ZoneDataType* ZoneDataType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ZoneDataType (*this, f, c);
    }

    ZoneDataType& ZoneDataType::
    operator= (const ZoneDataType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FeatureItemId_ = x.FeatureItemId_;
        this->Bonus_ = x.Bonus_;
        this->ReferenceLength_ = x.ReferenceLength_;
      }

      return *this;
    }

    ZoneDataType::
    ~ZoneDataType ()
    {
    }

    // LinearToleranceType
    //

    LinearToleranceType::
    LinearToleranceType (const DefinedAsLimit_type& DefinedAsLimit)
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinitionId_ (this),
      DefinedAsLimit_ (DefinedAsLimit, this)
    {
    }

    LinearToleranceType::
    LinearToleranceType (const LinearToleranceType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxValue_ (x.MaxValue_, f, this),
      MinValue_ (x.MinValue_, f, this),
      DefinitionId_ (x.DefinitionId_, f, this),
      DefinedAsLimit_ (x.DefinedAsLimit_, f, this)
    {
    }

    LinearToleranceType::
    LinearToleranceType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxValue_ (this),
      MinValue_ (this),
      DefinitionId_ (this),
      DefinedAsLimit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LinearToleranceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MaxValue
        //
        if (n.name () == "MaxValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxValue_type > r (
            MaxValue_traits::create (i, f, this));

          if (!this->MaxValue_)
          {
            this->MaxValue_.set (r);
            continue;
          }
        }

        // MinValue
        //
        if (n.name () == "MinValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinValue_type > r (
            MinValue_traits::create (i, f, this));

          if (!this->MinValue_)
          {
            this->MinValue_.set (r);
            continue;
          }
        }

        // DefinitionId
        //
        if (n.name () == "DefinitionId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DefinitionId_type > r (
            DefinitionId_traits::create (i, f, this));

          if (!this->DefinitionId_)
          {
            this->DefinitionId_.set (r);
            continue;
          }
        }

        // DefinedAsLimit
        //
        if (n.name () == "DefinedAsLimit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!DefinedAsLimit_.present ())
          {
            this->DefinedAsLimit_.set (DefinedAsLimit_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!DefinedAsLimit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DefinedAsLimit",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LinearToleranceType* LinearToleranceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearToleranceType (*this, f, c);
    }

    LinearToleranceType& LinearToleranceType::
    operator= (const LinearToleranceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MaxValue_ = x.MaxValue_;
        this->MinValue_ = x.MinValue_;
        this->DefinitionId_ = x.DefinitionId_;
        this->DefinedAsLimit_ = x.DefinedAsLimit_;
      }

      return *this;
    }

    LinearToleranceType::
    ~LinearToleranceType ()
    {
    }

    // LinearToleranceDefinitionType
    //

    LinearToleranceDefinitionType::
    LinearToleranceDefinitionType (const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      MaxValue_ (this),
      MinValue_ (this),
      id_ (id, this)
    {
    }

    LinearToleranceDefinitionType::
    LinearToleranceDefinitionType (const LinearToleranceDefinitionType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      MaxValue_ (x.MaxValue_, f, this),
      MinValue_ (x.MinValue_, f, this),
      id_ (x.id_, f, this)
    {
    }

    LinearToleranceDefinitionType::
    LinearToleranceDefinitionType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      MaxValue_ (this),
      MinValue_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LinearToleranceDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Attributes
        //
        if (n.name () == "Attributes" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (r);
            continue;
          }
        }

        // MaxValue
        //
        if (n.name () == "MaxValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxValue_type > r (
            MaxValue_traits::create (i, f, this));

          if (!this->MaxValue_)
          {
            this->MaxValue_.set (r);
            continue;
          }
        }

        // MinValue
        //
        if (n.name () == "MinValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinValue_type > r (
            MinValue_traits::create (i, f, this));

          if (!this->MinValue_)
          {
            this->MinValue_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    LinearToleranceDefinitionType* LinearToleranceDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearToleranceDefinitionType (*this, f, c);
    }

    LinearToleranceDefinitionType& LinearToleranceDefinitionType::
    operator= (const LinearToleranceDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->MaxValue_ = x.MaxValue_;
        this->MinValue_ = x.MinValue_;
        this->id_ = x.id_;
      }

      return *this;
    }

    LinearToleranceDefinitionType::
    ~LinearToleranceDefinitionType ()
    {
    }

    // AngularToleranceType
    //

    AngularToleranceType::
    AngularToleranceType (const DefinedAsLimit_type& DefinedAsLimit)
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinitionId_ (this),
      DefinedAsLimit_ (DefinedAsLimit, this)
    {
    }

    AngularToleranceType::
    AngularToleranceType (const AngularToleranceType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxValue_ (x.MaxValue_, f, this),
      MinValue_ (x.MinValue_, f, this),
      DefinitionId_ (x.DefinitionId_, f, this),
      DefinedAsLimit_ (x.DefinedAsLimit_, f, this)
    {
    }

    AngularToleranceType::
    AngularToleranceType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxValue_ (this),
      MinValue_ (this),
      DefinitionId_ (this),
      DefinedAsLimit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AngularToleranceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MaxValue
        //
        if (n.name () == "MaxValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxValue_type > r (
            MaxValue_traits::create (i, f, this));

          if (!this->MaxValue_)
          {
            this->MaxValue_.set (r);
            continue;
          }
        }

        // MinValue
        //
        if (n.name () == "MinValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinValue_type > r (
            MinValue_traits::create (i, f, this));

          if (!this->MinValue_)
          {
            this->MinValue_.set (r);
            continue;
          }
        }

        // DefinitionId
        //
        if (n.name () == "DefinitionId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DefinitionId_type > r (
            DefinitionId_traits::create (i, f, this));

          if (!this->DefinitionId_)
          {
            this->DefinitionId_.set (r);
            continue;
          }
        }

        // DefinedAsLimit
        //
        if (n.name () == "DefinedAsLimit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!DefinedAsLimit_.present ())
          {
            this->DefinedAsLimit_.set (DefinedAsLimit_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!DefinedAsLimit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DefinedAsLimit",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    AngularToleranceType* AngularToleranceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngularToleranceType (*this, f, c);
    }

    AngularToleranceType& AngularToleranceType::
    operator= (const AngularToleranceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MaxValue_ = x.MaxValue_;
        this->MinValue_ = x.MinValue_;
        this->DefinitionId_ = x.DefinitionId_;
        this->DefinedAsLimit_ = x.DefinedAsLimit_;
      }

      return *this;
    }

    AngularToleranceType::
    ~AngularToleranceType ()
    {
    }

    // AngularToleranceDefinitionType
    //

    AngularToleranceDefinitionType::
    AngularToleranceDefinitionType (const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      MaxValue_ (this),
      MinValue_ (this),
      id_ (id, this)
    {
    }

    AngularToleranceDefinitionType::
    AngularToleranceDefinitionType (const AngularToleranceDefinitionType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      MaxValue_ (x.MaxValue_, f, this),
      MinValue_ (x.MinValue_, f, this),
      id_ (x.id_, f, this)
    {
    }

    AngularToleranceDefinitionType::
    AngularToleranceDefinitionType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      MaxValue_ (this),
      MinValue_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AngularToleranceDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Attributes
        //
        if (n.name () == "Attributes" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (r);
            continue;
          }
        }

        // MaxValue
        //
        if (n.name () == "MaxValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxValue_type > r (
            MaxValue_traits::create (i, f, this));

          if (!this->MaxValue_)
          {
            this->MaxValue_.set (r);
            continue;
          }
        }

        // MinValue
        //
        if (n.name () == "MinValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinValue_type > r (
            MinValue_traits::create (i, f, this));

          if (!this->MinValue_)
          {
            this->MinValue_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    AngularToleranceDefinitionType* AngularToleranceDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngularToleranceDefinitionType (*this, f, c);
    }

    AngularToleranceDefinitionType& AngularToleranceDefinitionType::
    operator= (const AngularToleranceDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->MaxValue_ = x.MaxValue_;
        this->MinValue_ = x.MinValue_;
        this->id_ = x.id_;
      }

      return *this;
    }

    AngularToleranceDefinitionType::
    ~AngularToleranceDefinitionType ()
    {
    }

    // TemperatureToleranceType
    //

    TemperatureToleranceType::
    TemperatureToleranceType (const DefinedAsLimit_type& DefinedAsLimit)
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (DefinedAsLimit, this)
    {
    }

    TemperatureToleranceType::
    TemperatureToleranceType (const TemperatureToleranceType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxValue_ (x.MaxValue_, f, this),
      MinValue_ (x.MinValue_, f, this),
      DefinedAsLimit_ (x.DefinedAsLimit_, f, this)
    {
    }

    TemperatureToleranceType::
    TemperatureToleranceType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TemperatureToleranceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MaxValue
        //
        if (n.name () == "MaxValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxValue_type > r (
            MaxValue_traits::create (i, f, this));

          if (!this->MaxValue_)
          {
            this->MaxValue_.set (r);
            continue;
          }
        }

        // MinValue
        //
        if (n.name () == "MinValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinValue_type > r (
            MinValue_traits::create (i, f, this));

          if (!this->MinValue_)
          {
            this->MinValue_.set (r);
            continue;
          }
        }

        // DefinedAsLimit
        //
        if (n.name () == "DefinedAsLimit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!DefinedAsLimit_.present ())
          {
            this->DefinedAsLimit_.set (DefinedAsLimit_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!DefinedAsLimit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DefinedAsLimit",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TemperatureToleranceType* TemperatureToleranceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TemperatureToleranceType (*this, f, c);
    }

    TemperatureToleranceType& TemperatureToleranceType::
    operator= (const TemperatureToleranceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MaxValue_ = x.MaxValue_;
        this->MinValue_ = x.MinValue_;
        this->DefinedAsLimit_ = x.DefinedAsLimit_;
      }

      return *this;
    }

    TemperatureToleranceType::
    ~TemperatureToleranceType ()
    {
    }

    // AreaToleranceType
    //

    AreaToleranceType::
    AreaToleranceType (const DefinedAsLimit_type& DefinedAsLimit)
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (DefinedAsLimit, this)
    {
    }

    AreaToleranceType::
    AreaToleranceType (const AreaToleranceType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxValue_ (x.MaxValue_, f, this),
      MinValue_ (x.MinValue_, f, this),
      DefinedAsLimit_ (x.DefinedAsLimit_, f, this)
    {
    }

    AreaToleranceType::
    AreaToleranceType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AreaToleranceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MaxValue
        //
        if (n.name () == "MaxValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxValue_type > r (
            MaxValue_traits::create (i, f, this));

          if (!this->MaxValue_)
          {
            this->MaxValue_.set (r);
            continue;
          }
        }

        // MinValue
        //
        if (n.name () == "MinValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinValue_type > r (
            MinValue_traits::create (i, f, this));

          if (!this->MinValue_)
          {
            this->MinValue_.set (r);
            continue;
          }
        }

        // DefinedAsLimit
        //
        if (n.name () == "DefinedAsLimit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!DefinedAsLimit_.present ())
          {
            this->DefinedAsLimit_.set (DefinedAsLimit_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!DefinedAsLimit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DefinedAsLimit",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    AreaToleranceType* AreaToleranceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AreaToleranceType (*this, f, c);
    }

    AreaToleranceType& AreaToleranceType::
    operator= (const AreaToleranceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MaxValue_ = x.MaxValue_;
        this->MinValue_ = x.MinValue_;
        this->DefinedAsLimit_ = x.DefinedAsLimit_;
      }

      return *this;
    }

    AreaToleranceType::
    ~AreaToleranceType ()
    {
    }

    // ForceToleranceType
    //

    ForceToleranceType::
    ForceToleranceType (const DefinedAsLimit_type& DefinedAsLimit)
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (DefinedAsLimit, this)
    {
    }

    ForceToleranceType::
    ForceToleranceType (const ForceToleranceType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxValue_ (x.MaxValue_, f, this),
      MinValue_ (x.MinValue_, f, this),
      DefinedAsLimit_ (x.DefinedAsLimit_, f, this)
    {
    }

    ForceToleranceType::
    ForceToleranceType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ForceToleranceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MaxValue
        //
        if (n.name () == "MaxValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxValue_type > r (
            MaxValue_traits::create (i, f, this));

          if (!this->MaxValue_)
          {
            this->MaxValue_.set (r);
            continue;
          }
        }

        // MinValue
        //
        if (n.name () == "MinValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinValue_type > r (
            MinValue_traits::create (i, f, this));

          if (!this->MinValue_)
          {
            this->MinValue_.set (r);
            continue;
          }
        }

        // DefinedAsLimit
        //
        if (n.name () == "DefinedAsLimit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!DefinedAsLimit_.present ())
          {
            this->DefinedAsLimit_.set (DefinedAsLimit_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!DefinedAsLimit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DefinedAsLimit",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ForceToleranceType* ForceToleranceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ForceToleranceType (*this, f, c);
    }

    ForceToleranceType& ForceToleranceType::
    operator= (const ForceToleranceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MaxValue_ = x.MaxValue_;
        this->MinValue_ = x.MinValue_;
        this->DefinedAsLimit_ = x.DefinedAsLimit_;
      }

      return *this;
    }

    ForceToleranceType::
    ~ForceToleranceType ()
    {
    }

    // MassToleranceType
    //

    MassToleranceType::
    MassToleranceType (const DefinedAsLimit_type& DefinedAsLimit)
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (DefinedAsLimit, this)
    {
    }

    MassToleranceType::
    MassToleranceType (const MassToleranceType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxValue_ (x.MaxValue_, f, this),
      MinValue_ (x.MinValue_, f, this),
      DefinedAsLimit_ (x.DefinedAsLimit_, f, this)
    {
    }

    MassToleranceType::
    MassToleranceType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MassToleranceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MaxValue
        //
        if (n.name () == "MaxValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxValue_type > r (
            MaxValue_traits::create (i, f, this));

          if (!this->MaxValue_)
          {
            this->MaxValue_.set (r);
            continue;
          }
        }

        // MinValue
        //
        if (n.name () == "MinValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinValue_type > r (
            MinValue_traits::create (i, f, this));

          if (!this->MinValue_)
          {
            this->MinValue_.set (r);
            continue;
          }
        }

        // DefinedAsLimit
        //
        if (n.name () == "DefinedAsLimit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!DefinedAsLimit_.present ())
          {
            this->DefinedAsLimit_.set (DefinedAsLimit_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!DefinedAsLimit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DefinedAsLimit",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    MassToleranceType* MassToleranceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MassToleranceType (*this, f, c);
    }

    MassToleranceType& MassToleranceType::
    operator= (const MassToleranceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MaxValue_ = x.MaxValue_;
        this->MinValue_ = x.MinValue_;
        this->DefinedAsLimit_ = x.DefinedAsLimit_;
      }

      return *this;
    }

    MassToleranceType::
    ~MassToleranceType ()
    {
    }

    // PressureToleranceType
    //

    PressureToleranceType::
    PressureToleranceType (const DefinedAsLimit_type& DefinedAsLimit)
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (DefinedAsLimit, this)
    {
    }

    PressureToleranceType::
    PressureToleranceType (const PressureToleranceType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxValue_ (x.MaxValue_, f, this),
      MinValue_ (x.MinValue_, f, this),
      DefinedAsLimit_ (x.DefinedAsLimit_, f, this)
    {
    }

    PressureToleranceType::
    PressureToleranceType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PressureToleranceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MaxValue
        //
        if (n.name () == "MaxValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxValue_type > r (
            MaxValue_traits::create (i, f, this));

          if (!this->MaxValue_)
          {
            this->MaxValue_.set (r);
            continue;
          }
        }

        // MinValue
        //
        if (n.name () == "MinValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinValue_type > r (
            MinValue_traits::create (i, f, this));

          if (!this->MinValue_)
          {
            this->MinValue_.set (r);
            continue;
          }
        }

        // DefinedAsLimit
        //
        if (n.name () == "DefinedAsLimit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!DefinedAsLimit_.present ())
          {
            this->DefinedAsLimit_.set (DefinedAsLimit_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!DefinedAsLimit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DefinedAsLimit",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PressureToleranceType* PressureToleranceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PressureToleranceType (*this, f, c);
    }

    PressureToleranceType& PressureToleranceType::
    operator= (const PressureToleranceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MaxValue_ = x.MaxValue_;
        this->MinValue_ = x.MinValue_;
        this->DefinedAsLimit_ = x.DefinedAsLimit_;
      }

      return *this;
    }

    PressureToleranceType::
    ~PressureToleranceType ()
    {
    }

    // SpeedToleranceType
    //

    SpeedToleranceType::
    SpeedToleranceType (const DefinedAsLimit_type& DefinedAsLimit)
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (DefinedAsLimit, this)
    {
    }

    SpeedToleranceType::
    SpeedToleranceType (const SpeedToleranceType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxValue_ (x.MaxValue_, f, this),
      MinValue_ (x.MinValue_, f, this),
      DefinedAsLimit_ (x.DefinedAsLimit_, f, this)
    {
    }

    SpeedToleranceType::
    SpeedToleranceType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SpeedToleranceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MaxValue
        //
        if (n.name () == "MaxValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxValue_type > r (
            MaxValue_traits::create (i, f, this));

          if (!this->MaxValue_)
          {
            this->MaxValue_.set (r);
            continue;
          }
        }

        // MinValue
        //
        if (n.name () == "MinValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinValue_type > r (
            MinValue_traits::create (i, f, this));

          if (!this->MinValue_)
          {
            this->MinValue_.set (r);
            continue;
          }
        }

        // DefinedAsLimit
        //
        if (n.name () == "DefinedAsLimit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!DefinedAsLimit_.present ())
          {
            this->DefinedAsLimit_.set (DefinedAsLimit_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!DefinedAsLimit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DefinedAsLimit",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SpeedToleranceType* SpeedToleranceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SpeedToleranceType (*this, f, c);
    }

    SpeedToleranceType& SpeedToleranceType::
    operator= (const SpeedToleranceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MaxValue_ = x.MaxValue_;
        this->MinValue_ = x.MinValue_;
        this->DefinedAsLimit_ = x.DefinedAsLimit_;
      }

      return *this;
    }

    SpeedToleranceType::
    ~SpeedToleranceType ()
    {
    }

    // TimeToleranceType
    //

    TimeToleranceType::
    TimeToleranceType (const DefinedAsLimit_type& DefinedAsLimit)
    : ::xml_schema::type (),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (DefinedAsLimit, this)
    {
    }

    TimeToleranceType::
    TimeToleranceType (const TimeToleranceType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxValue_ (x.MaxValue_, f, this),
      MinValue_ (x.MinValue_, f, this),
      DefinedAsLimit_ (x.DefinedAsLimit_, f, this)
    {
    }

    TimeToleranceType::
    TimeToleranceType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxValue_ (this),
      MinValue_ (this),
      DefinedAsLimit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TimeToleranceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MaxValue
        //
        if (n.name () == "MaxValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxValue_type > r (
            MaxValue_traits::create (i, f, this));

          if (!this->MaxValue_)
          {
            this->MaxValue_.set (r);
            continue;
          }
        }

        // MinValue
        //
        if (n.name () == "MinValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinValue_type > r (
            MinValue_traits::create (i, f, this));

          if (!this->MinValue_)
          {
            this->MinValue_.set (r);
            continue;
          }
        }

        // DefinedAsLimit
        //
        if (n.name () == "DefinedAsLimit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!DefinedAsLimit_.present ())
          {
            this->DefinedAsLimit_.set (DefinedAsLimit_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!DefinedAsLimit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DefinedAsLimit",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TimeToleranceType* TimeToleranceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TimeToleranceType (*this, f, c);
    }

    TimeToleranceType& TimeToleranceType::
    operator= (const TimeToleranceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MaxValue_ = x.MaxValue_;
        this->MinValue_ = x.MinValue_;
        this->DefinedAsLimit_ = x.DefinedAsLimit_;
      }

      return *this;
    }

    TimeToleranceType::
    ~TimeToleranceType ()
    {
    }

    // DimensionModifierEnumType
    //

    DimensionModifierEnumType::
    DimensionModifierEnumType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_DimensionModifierEnumType_convert ();
    }

    DimensionModifierEnumType::
    DimensionModifierEnumType (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_DimensionModifierEnumType_convert ();
    }

    DimensionModifierEnumType::
    DimensionModifierEnumType (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_DimensionModifierEnumType_convert ();
    }

    DimensionModifierEnumType* DimensionModifierEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DimensionModifierEnumType (*this, f, c);
    }

    DimensionModifierEnumType::value DimensionModifierEnumType::
    _xsd_DimensionModifierEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_DimensionModifierEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_DimensionModifierEnumType_indexes_,
                        _xsd_DimensionModifierEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_DimensionModifierEnumType_indexes_ + 3 || _xsd_DimensionModifierEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const DimensionModifierEnumType::
    _xsd_DimensionModifierEnumType_literals_[3] =
    {
      "BASIC",
      "SET",
      "REFERENCE"
    };

    const DimensionModifierEnumType::value DimensionModifierEnumType::
    _xsd_DimensionModifierEnumType_indexes_[3] =
    {
      ::xsd::qif2::DimensionModifierEnumType::BASIC,
      ::xsd::qif2::DimensionModifierEnumType::REFERENCE,
      ::xsd::qif2::DimensionModifierEnumType::SET
    };

    // NonToleranceEnumType
    //

    NonToleranceEnumType::
    NonToleranceEnumType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_NonToleranceEnumType_convert ();
    }

    NonToleranceEnumType::
    NonToleranceEnumType (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_NonToleranceEnumType_convert ();
    }

    NonToleranceEnumType::
    NonToleranceEnumType (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_NonToleranceEnumType_convert ();
    }

    NonToleranceEnumType* NonToleranceEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NonToleranceEnumType (*this, f, c);
    }

    NonToleranceEnumType::value NonToleranceEnumType::
    _xsd_NonToleranceEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_NonToleranceEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_NonToleranceEnumType_indexes_,
                        _xsd_NonToleranceEnumType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_NonToleranceEnumType_indexes_ + 2 || _xsd_NonToleranceEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const NonToleranceEnumType::
    _xsd_NonToleranceEnumType_literals_[2] =
    {
      "MEASURED",
      "SET"
    };

    const NonToleranceEnumType::value NonToleranceEnumType::
    _xsd_NonToleranceEnumType_indexes_[2] =
    {
      ::xsd::qif2::NonToleranceEnumType::MEASURED,
      ::xsd::qif2::NonToleranceEnumType::SET
    };

    // CommonFileSpecEnumType
    //

    CommonFileSpecEnumType::
    CommonFileSpecEnumType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_CommonFileSpecEnumType_convert ();
    }

    CommonFileSpecEnumType::
    CommonFileSpecEnumType (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_CommonFileSpecEnumType_convert ();
    }

    CommonFileSpecEnumType::
    CommonFileSpecEnumType (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_CommonFileSpecEnumType_convert ();
    }

    CommonFileSpecEnumType* CommonFileSpecEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CommonFileSpecEnumType (*this, f, c);
    }

    CommonFileSpecEnumType::value CommonFileSpecEnumType::
    _xsd_CommonFileSpecEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CommonFileSpecEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_CommonFileSpecEnumType_indexes_,
                        _xsd_CommonFileSpecEnumType_indexes_ + 36,
                        *this,
                        c));

      if (i == _xsd_CommonFileSpecEnumType_indexes_ + 36 || _xsd_CommonFileSpecEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const CommonFileSpecEnumType::
    _xsd_CommonFileSpecEnumType_literals_[36] =
    {
      "AVI",
      "BMP",
      "DOC",
      "DOCX",
      "DXF",
      "DTD",
      "GIF",
      "GZIP",
      "HTML",
      "IGES",
      "JPEG",
      "JPG",
      "MOV",
      "MPEG",
      "MPG",
      "PDF",
      "PNG",
      "PPM",
      "PPT",
      "PRT",
      "RAR",
      "RTF",
      "STL",
      "STEP",
      "STP",
      "TAR",
      "TIF",
      "TIFF",
      "TXT",
      "WMV",
      "XLS",
      "XLSX",
      "XML",
      "XSD",
      "X_T",
      "ZIP"
    };

    const CommonFileSpecEnumType::value CommonFileSpecEnumType::
    _xsd_CommonFileSpecEnumType_indexes_[36] =
    {
      ::xsd::qif2::CommonFileSpecEnumType::AVI,
      ::xsd::qif2::CommonFileSpecEnumType::BMP,
      ::xsd::qif2::CommonFileSpecEnumType::DOC,
      ::xsd::qif2::CommonFileSpecEnumType::DOCX,
      ::xsd::qif2::CommonFileSpecEnumType::DTD,
      ::xsd::qif2::CommonFileSpecEnumType::DXF,
      ::xsd::qif2::CommonFileSpecEnumType::GIF,
      ::xsd::qif2::CommonFileSpecEnumType::GZIP,
      ::xsd::qif2::CommonFileSpecEnumType::HTML,
      ::xsd::qif2::CommonFileSpecEnumType::IGES,
      ::xsd::qif2::CommonFileSpecEnumType::JPEG,
      ::xsd::qif2::CommonFileSpecEnumType::JPG,
      ::xsd::qif2::CommonFileSpecEnumType::MOV,
      ::xsd::qif2::CommonFileSpecEnumType::MPEG,
      ::xsd::qif2::CommonFileSpecEnumType::MPG,
      ::xsd::qif2::CommonFileSpecEnumType::PDF,
      ::xsd::qif2::CommonFileSpecEnumType::PNG,
      ::xsd::qif2::CommonFileSpecEnumType::PPM,
      ::xsd::qif2::CommonFileSpecEnumType::PPT,
      ::xsd::qif2::CommonFileSpecEnumType::PRT,
      ::xsd::qif2::CommonFileSpecEnumType::RAR,
      ::xsd::qif2::CommonFileSpecEnumType::RTF,
      ::xsd::qif2::CommonFileSpecEnumType::STEP,
      ::xsd::qif2::CommonFileSpecEnumType::STL,
      ::xsd::qif2::CommonFileSpecEnumType::STP,
      ::xsd::qif2::CommonFileSpecEnumType::TAR,
      ::xsd::qif2::CommonFileSpecEnumType::TIF,
      ::xsd::qif2::CommonFileSpecEnumType::TIFF,
      ::xsd::qif2::CommonFileSpecEnumType::TXT,
      ::xsd::qif2::CommonFileSpecEnumType::WMV,
      ::xsd::qif2::CommonFileSpecEnumType::XLS,
      ::xsd::qif2::CommonFileSpecEnumType::XLSX,
      ::xsd::qif2::CommonFileSpecEnumType::XML,
      ::xsd::qif2::CommonFileSpecEnumType::XSD,
      ::xsd::qif2::CommonFileSpecEnumType::X_T,
      ::xsd::qif2::CommonFileSpecEnumType::ZIP
    };

    // FileSpecType
    //

    FileSpecType::
    FileSpecType ()
    : ::xml_schema::type (),
      CommonFileSpecEnum_ (this),
      OtherFileSpec_ (this)
    {
    }

    FileSpecType::
    FileSpecType (const FileSpecType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CommonFileSpecEnum_ (x.CommonFileSpecEnum_, f, this),
      OtherFileSpec_ (x.OtherFileSpec_, f, this)
    {
    }

    FileSpecType::
    FileSpecType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CommonFileSpecEnum_ (this),
      OtherFileSpec_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FileSpecType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CommonFileSpecEnum
        //
        if (n.name () == "CommonFileSpecEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CommonFileSpecEnum_type > r (
            CommonFileSpecEnum_traits::create (i, f, this));

          if (!this->CommonFileSpecEnum_)
          {
            this->CommonFileSpecEnum_.set (r);
            continue;
          }
        }

        // OtherFileSpec
        //
        if (n.name () == "OtherFileSpec" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherFileSpec_type > r (
            OtherFileSpec_traits::create (i, f, this));

          if (!this->OtherFileSpec_)
          {
            this->OtherFileSpec_.set (r);
            continue;
          }
        }

        break;
      }
    }

    FileSpecType* FileSpecType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FileSpecType (*this, f, c);
    }

    FileSpecType& FileSpecType::
    operator= (const FileSpecType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CommonFileSpecEnum_ = x.CommonFileSpecEnum_;
        this->OtherFileSpec_ = x.OtherFileSpec_;
      }

      return *this;
    }

    FileSpecType::
    ~FileSpecType ()
    {
    }

    // ExternalFileReferenceType
    //

    ExternalFileReferenceType::
    ExternalFileReferenceType (const URI_type& URI,
                               const FileSpec_type& FileSpec,
                               const Description_type& Description)
    : ::xml_schema::type (),
      URI_ (URI, this),
      FileSpec_ (FileSpec, this),
      Description_ (Description, this)
    {
    }

    ExternalFileReferenceType::
    ExternalFileReferenceType (const URI_type& URI,
                               ::std::auto_ptr< FileSpec_type > FileSpec,
                               const Description_type& Description)
    : ::xml_schema::type (),
      URI_ (URI, this),
      FileSpec_ (FileSpec, this),
      Description_ (Description, this)
    {
    }

    ExternalFileReferenceType::
    ExternalFileReferenceType (const ExternalFileReferenceType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      URI_ (x.URI_, f, this),
      FileSpec_ (x.FileSpec_, f, this),
      Description_ (x.Description_, f, this)
    {
    }

    ExternalFileReferenceType::
    ExternalFileReferenceType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      URI_ (this),
      FileSpec_ (this),
      Description_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExternalFileReferenceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // URI
        //
        if (n.name () == "URI" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< URI_type > r (
            URI_traits::create (i, f, this));

          if (!URI_.present ())
          {
            this->URI_.set (r);
            continue;
          }
        }

        // FileSpec
        //
        if (n.name () == "FileSpec" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FileSpec_type > r (
            FileSpec_traits::create (i, f, this));

          if (!FileSpec_.present ())
          {
            this->FileSpec_.set (r);
            continue;
          }
        }

        // Description
        //
        if (n.name () == "Description" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!Description_.present ())
          {
            this->Description_.set (r);
            continue;
          }
        }

        break;
      }

      if (!URI_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "URI",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!FileSpec_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "FileSpec",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Description",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ExternalFileReferenceType* ExternalFileReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExternalFileReferenceType (*this, f, c);
    }

    ExternalFileReferenceType& ExternalFileReferenceType::
    operator= (const ExternalFileReferenceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->URI_ = x.URI_;
        this->FileSpec_ = x.FileSpec_;
        this->Description_ = x.Description_;
      }

      return *this;
    }

    ExternalFileReferenceType::
    ~ExternalFileReferenceType ()
    {
    }

    // DatumTargetDefinitionsType
    //

    DatumTargetDefinitionsType::
    DatumTargetDefinitionsType (const N_type& N)
    : ::xml_schema::type (),
      DatumTarget_ (this),
      N_ (N, this)
    {
    }

    DatumTargetDefinitionsType::
    DatumTargetDefinitionsType (const DatumTargetDefinitionsType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DatumTarget_ (x.DatumTarget_, f, this),
      N_ (x.N_, f, this)
    {
    }

    DatumTargetDefinitionsType::
    DatumTargetDefinitionsType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DatumTarget_ (this),
      N_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DatumTargetDefinitionsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DatumTarget
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "DatumTarget",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< DatumTarget_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< DatumTarget_type > r (
              dynamic_cast< DatumTarget_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->DatumTarget_.push_back (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          this->N_.set (N_traits::create (i, f, this));
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    DatumTargetDefinitionsType* DatumTargetDefinitionsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumTargetDefinitionsType (*this, f, c);
    }

    DatumTargetDefinitionsType& DatumTargetDefinitionsType::
    operator= (const DatumTargetDefinitionsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DatumTarget_ = x.DatumTarget_;
        this->N_ = x.N_;
      }

      return *this;
    }

    DatumTargetDefinitionsType::
    ~DatumTargetDefinitionsType ()
    {
    }

    // DatumDefinitionType
    //

    DatumDefinitionType::
    DatumDefinitionType (const DatumLabel_type& DatumLabel,
                         const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      DatumLabel_ (DatumLabel, this),
      DatumTargetIds_ (this),
      FeatureNominalIds_ (this),
      id_ (id, this)
    {
    }

    DatumDefinitionType::
    DatumDefinitionType (const DatumDefinitionType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      DatumLabel_ (x.DatumLabel_, f, this),
      DatumTargetIds_ (x.DatumTargetIds_, f, this),
      FeatureNominalIds_ (x.FeatureNominalIds_, f, this),
      id_ (x.id_, f, this)
    {
    }

    DatumDefinitionType::
    DatumDefinitionType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      DatumLabel_ (this),
      DatumTargetIds_ (this),
      FeatureNominalIds_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DatumDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Attributes
        //
        if (n.name () == "Attributes" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (r);
            continue;
          }
        }

        // DatumLabel
        //
        if (n.name () == "DatumLabel" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DatumLabel_type > r (
            DatumLabel_traits::create (i, f, this));

          if (!DatumLabel_.present ())
          {
            this->DatumLabel_.set (r);
            continue;
          }
        }

        // DatumTargetIds
        //
        if (n.name () == "DatumTargetIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DatumTargetIds_type > r (
            DatumTargetIds_traits::create (i, f, this));

          if (!this->DatumTargetIds_)
          {
            this->DatumTargetIds_.set (r);
            continue;
          }
        }

        // FeatureNominalIds
        //
        if (n.name () == "FeatureNominalIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureNominalIds_type > r (
            FeatureNominalIds_traits::create (i, f, this));

          if (!this->FeatureNominalIds_)
          {
            this->FeatureNominalIds_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DatumLabel_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DatumLabel",
          "http://qifstandards.org/xsd/qif2");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    DatumDefinitionType* DatumDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumDefinitionType (*this, f, c);
    }

    DatumDefinitionType& DatumDefinitionType::
    operator= (const DatumDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->DatumLabel_ = x.DatumLabel_;
        this->DatumTargetIds_ = x.DatumTargetIds_;
        this->FeatureNominalIds_ = x.FeatureNominalIds_;
        this->id_ = x.id_;
      }

      return *this;
    }

    DatumDefinitionType::
    ~DatumDefinitionType ()
    {
    }

    // DatumDefinitionsType
    //

    DatumDefinitionsType::
    DatumDefinitionsType ()
    : ::xml_schema::type (),
      DatumDefinition_ (this)
    {
    }

    DatumDefinitionsType::
    DatumDefinitionsType (const DatumDefinitionsType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DatumDefinition_ (x.DatumDefinition_, f, this)
    {
    }

    DatumDefinitionsType::
    DatumDefinitionsType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DatumDefinition_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void DatumDefinitionsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DatumDefinition
        //
        if (n.name () == "DatumDefinition" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DatumDefinition_type > r (
            DatumDefinition_traits::create (i, f, this));

          this->DatumDefinition_.push_back (r);
          continue;
        }

        break;
      }
    }

    DatumDefinitionsType* DatumDefinitionsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumDefinitionsType (*this, f, c);
    }

    DatumDefinitionsType& DatumDefinitionsType::
    operator= (const DatumDefinitionsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DatumDefinition_ = x.DatumDefinition_;
      }

      return *this;
    }

    DatumDefinitionsType::
    ~DatumDefinitionsType ()
    {
    }

    // DatumTargetDefinitionBaseType
    //

    DatumTargetDefinitionBaseType::
    DatumTargetDefinitionBaseType (const DatumTargetLabel_type& DatumTargetLabel,
                                   const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      DatumTargetLabel_ (DatumTargetLabel, this),
      FeatureNominalId_ (this),
      MovableDatumTarget_ (this),
      id_ (id, this)
    {
    }

    DatumTargetDefinitionBaseType::
    DatumTargetDefinitionBaseType (const DatumTargetDefinitionBaseType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      DatumTargetLabel_ (x.DatumTargetLabel_, f, this),
      FeatureNominalId_ (x.FeatureNominalId_, f, this),
      MovableDatumTarget_ (x.MovableDatumTarget_, f, this),
      id_ (x.id_, f, this)
    {
    }

    DatumTargetDefinitionBaseType::
    DatumTargetDefinitionBaseType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      DatumTargetLabel_ (this),
      FeatureNominalId_ (this),
      MovableDatumTarget_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DatumTargetDefinitionBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Attributes
        //
        if (n.name () == "Attributes" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (r);
            continue;
          }
        }

        // DatumTargetLabel
        //
        if (n.name () == "DatumTargetLabel" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DatumTargetLabel_type > r (
            DatumTargetLabel_traits::create (i, f, this));

          if (!DatumTargetLabel_.present ())
          {
            this->DatumTargetLabel_.set (r);
            continue;
          }
        }

        // FeatureNominalId
        //
        if (n.name () == "FeatureNominalId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureNominalId_type > r (
            FeatureNominalId_traits::create (i, f, this));

          if (!this->FeatureNominalId_)
          {
            this->FeatureNominalId_.set (r);
            continue;
          }
        }

        // MovableDatumTarget
        //
        if (n.name () == "MovableDatumTarget" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MovableDatumTarget_type > r (
            MovableDatumTarget_traits::create (i, f, this));

          if (!this->MovableDatumTarget_)
          {
            this->MovableDatumTarget_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DatumTargetLabel_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DatumTargetLabel",
          "http://qifstandards.org/xsd/qif2");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    DatumTargetDefinitionBaseType* DatumTargetDefinitionBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumTargetDefinitionBaseType (*this, f, c);
    }

    DatumTargetDefinitionBaseType& DatumTargetDefinitionBaseType::
    operator= (const DatumTargetDefinitionBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->DatumTargetLabel_ = x.DatumTargetLabel_;
        this->FeatureNominalId_ = x.FeatureNominalId_;
        this->MovableDatumTarget_ = x.MovableDatumTarget_;
        this->id_ = x.id_;
      }

      return *this;
    }

    DatumTargetDefinitionBaseType::
    ~DatumTargetDefinitionBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DatumTargetDefinitionBaseType >
    _xsd_DatumTargetDefinitionBaseType_type_factory_init (
      "DatumTargetDefinitionBaseType",
      "http://qifstandards.org/xsd/qif2");

    // DatumTargetPointDefinitionType
    //

    DatumTargetPointDefinitionType::
    DatumTargetPointDefinitionType (const DatumTargetLabel_type& DatumTargetLabel,
                                    const id_type& id,
                                    const Point_type& Point)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (DatumTargetLabel,
                                                  id),
      Point_ (Point, this)
    {
    }

    DatumTargetPointDefinitionType::
    DatumTargetPointDefinitionType (const DatumTargetLabel_type& DatumTargetLabel,
                                    const id_type& id,
                                    ::std::auto_ptr< Point_type > Point)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (DatumTargetLabel,
                                                  id),
      Point_ (Point, this)
    {
    }

    DatumTargetPointDefinitionType::
    DatumTargetPointDefinitionType (const DatumTargetPointDefinitionType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (x, f, c),
      Point_ (x.Point_, f, this)
    {
    }

    DatumTargetPointDefinitionType::
    DatumTargetPointDefinitionType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      Point_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DatumTargetPointDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::DatumTargetDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Point
        //
        if (n.name () == "Point" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Point_type > r (
            Point_traits::create (i, f, this));

          if (!Point_.present ())
          {
            this->Point_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Point_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Point",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    DatumTargetPointDefinitionType* DatumTargetPointDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumTargetPointDefinitionType (*this, f, c);
    }

    DatumTargetPointDefinitionType& DatumTargetPointDefinitionType::
    operator= (const DatumTargetPointDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::DatumTargetDefinitionBaseType& > (*this) = x;
        this->Point_ = x.Point_;
      }

      return *this;
    }

    DatumTargetPointDefinitionType::
    ~DatumTargetPointDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DatumTargetPointDefinitionType >
    _xsd_DatumTargetPointDefinitionType_type_factory_init (
      "DatumTargetPointDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // DatumTargetLineDefinitionType
    //

    DatumTargetLineDefinitionType::
    DatumTargetLineDefinitionType (const DatumTargetLabel_type& DatumTargetLabel,
                                   const id_type& id,
                                   const Line_type& Line)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (DatumTargetLabel,
                                                  id),
      Line_ (Line, this)
    {
    }

    DatumTargetLineDefinitionType::
    DatumTargetLineDefinitionType (const DatumTargetLabel_type& DatumTargetLabel,
                                   const id_type& id,
                                   ::std::auto_ptr< Line_type > Line)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (DatumTargetLabel,
                                                  id),
      Line_ (Line, this)
    {
    }

    DatumTargetLineDefinitionType::
    DatumTargetLineDefinitionType (const DatumTargetLineDefinitionType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (x, f, c),
      Line_ (x.Line_, f, this)
    {
    }

    DatumTargetLineDefinitionType::
    DatumTargetLineDefinitionType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      Line_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DatumTargetLineDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::DatumTargetDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Line
        //
        if (n.name () == "Line" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Line_type > r (
            Line_traits::create (i, f, this));

          if (!Line_.present ())
          {
            this->Line_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Line_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Line",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    DatumTargetLineDefinitionType* DatumTargetLineDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumTargetLineDefinitionType (*this, f, c);
    }

    DatumTargetLineDefinitionType& DatumTargetLineDefinitionType::
    operator= (const DatumTargetLineDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::DatumTargetDefinitionBaseType& > (*this) = x;
        this->Line_ = x.Line_;
      }

      return *this;
    }

    DatumTargetLineDefinitionType::
    ~DatumTargetLineDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DatumTargetLineDefinitionType >
    _xsd_DatumTargetLineDefinitionType_type_factory_init (
      "DatumTargetLineDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // DatumTargetCircularAreaDefinitionType
    //

    DatumTargetCircularAreaDefinitionType::
    DatumTargetCircularAreaDefinitionType (const DatumTargetLabel_type& DatumTargetLabel,
                                           const id_type& id,
                                           const Circle_type& Circle)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (DatumTargetLabel,
                                                  id),
      Circle_ (Circle, this)
    {
    }

    DatumTargetCircularAreaDefinitionType::
    DatumTargetCircularAreaDefinitionType (const DatumTargetLabel_type& DatumTargetLabel,
                                           const id_type& id,
                                           ::std::auto_ptr< Circle_type > Circle)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (DatumTargetLabel,
                                                  id),
      Circle_ (Circle, this)
    {
    }

    DatumTargetCircularAreaDefinitionType::
    DatumTargetCircularAreaDefinitionType (const DatumTargetCircularAreaDefinitionType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (x, f, c),
      Circle_ (x.Circle_, f, this)
    {
    }

    DatumTargetCircularAreaDefinitionType::
    DatumTargetCircularAreaDefinitionType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      Circle_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DatumTargetCircularAreaDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::DatumTargetDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Circle
        //
        if (n.name () == "Circle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Circle_type > r (
            Circle_traits::create (i, f, this));

          if (!Circle_.present ())
          {
            this->Circle_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Circle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Circle",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    DatumTargetCircularAreaDefinitionType* DatumTargetCircularAreaDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumTargetCircularAreaDefinitionType (*this, f, c);
    }

    DatumTargetCircularAreaDefinitionType& DatumTargetCircularAreaDefinitionType::
    operator= (const DatumTargetCircularAreaDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::DatumTargetDefinitionBaseType& > (*this) = x;
        this->Circle_ = x.Circle_;
      }

      return *this;
    }

    DatumTargetCircularAreaDefinitionType::
    ~DatumTargetCircularAreaDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DatumTargetCircularAreaDefinitionType >
    _xsd_DatumTargetCircularAreaDefinitionType_type_factory_init (
      "DatumTargetCircularAreaDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // DatumTargetCircularLineDefinitionType
    //

    DatumTargetCircularLineDefinitionType::
    DatumTargetCircularLineDefinitionType (const DatumTargetLabel_type& DatumTargetLabel,
                                           const id_type& id,
                                           const Circle_type& Circle)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (DatumTargetLabel,
                                                  id),
      Circle_ (Circle, this)
    {
    }

    DatumTargetCircularLineDefinitionType::
    DatumTargetCircularLineDefinitionType (const DatumTargetLabel_type& DatumTargetLabel,
                                           const id_type& id,
                                           ::std::auto_ptr< Circle_type > Circle)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (DatumTargetLabel,
                                                  id),
      Circle_ (Circle, this)
    {
    }

    DatumTargetCircularLineDefinitionType::
    DatumTargetCircularLineDefinitionType (const DatumTargetCircularLineDefinitionType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (x, f, c),
      Circle_ (x.Circle_, f, this)
    {
    }

    DatumTargetCircularLineDefinitionType::
    DatumTargetCircularLineDefinitionType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      Circle_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DatumTargetCircularLineDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::DatumTargetDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Circle
        //
        if (n.name () == "Circle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Circle_type > r (
            Circle_traits::create (i, f, this));

          if (!Circle_.present ())
          {
            this->Circle_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Circle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Circle",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    DatumTargetCircularLineDefinitionType* DatumTargetCircularLineDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumTargetCircularLineDefinitionType (*this, f, c);
    }

    DatumTargetCircularLineDefinitionType& DatumTargetCircularLineDefinitionType::
    operator= (const DatumTargetCircularLineDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::DatumTargetDefinitionBaseType& > (*this) = x;
        this->Circle_ = x.Circle_;
      }

      return *this;
    }

    DatumTargetCircularLineDefinitionType::
    ~DatumTargetCircularLineDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DatumTargetCircularLineDefinitionType >
    _xsd_DatumTargetCircularLineDefinitionType_type_factory_init (
      "DatumTargetCircularLineDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // DatumTargetCylindricalAreaDefinitionType
    //

    DatumTargetCylindricalAreaDefinitionType::
    DatumTargetCylindricalAreaDefinitionType (const DatumTargetLabel_type& DatumTargetLabel,
                                              const id_type& id,
                                              const Cylinder_type& Cylinder)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (DatumTargetLabel,
                                                  id),
      Cylinder_ (Cylinder, this)
    {
    }

    DatumTargetCylindricalAreaDefinitionType::
    DatumTargetCylindricalAreaDefinitionType (const DatumTargetLabel_type& DatumTargetLabel,
                                              const id_type& id,
                                              ::std::auto_ptr< Cylinder_type > Cylinder)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (DatumTargetLabel,
                                                  id),
      Cylinder_ (Cylinder, this)
    {
    }

    DatumTargetCylindricalAreaDefinitionType::
    DatumTargetCylindricalAreaDefinitionType (const DatumTargetCylindricalAreaDefinitionType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (x, f, c),
      Cylinder_ (x.Cylinder_, f, this)
    {
    }

    DatumTargetCylindricalAreaDefinitionType::
    DatumTargetCylindricalAreaDefinitionType (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      Cylinder_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DatumTargetCylindricalAreaDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::DatumTargetDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Cylinder
        //
        if (n.name () == "Cylinder" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cylinder_type > r (
            Cylinder_traits::create (i, f, this));

          if (!Cylinder_.present ())
          {
            this->Cylinder_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Cylinder_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Cylinder",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    DatumTargetCylindricalAreaDefinitionType* DatumTargetCylindricalAreaDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumTargetCylindricalAreaDefinitionType (*this, f, c);
    }

    DatumTargetCylindricalAreaDefinitionType& DatumTargetCylindricalAreaDefinitionType::
    operator= (const DatumTargetCylindricalAreaDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::DatumTargetDefinitionBaseType& > (*this) = x;
        this->Cylinder_ = x.Cylinder_;
      }

      return *this;
    }

    DatumTargetCylindricalAreaDefinitionType::
    ~DatumTargetCylindricalAreaDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DatumTargetCylindricalAreaDefinitionType >
    _xsd_DatumTargetCylindricalAreaDefinitionType_type_factory_init (
      "DatumTargetCylindricalAreaDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // DatumTargetRectangularAreaDefinitionType
    //

    DatumTargetRectangularAreaDefinitionType::
    DatumTargetRectangularAreaDefinitionType (const DatumTargetLabel_type& DatumTargetLabel,
                                              const id_type& id,
                                              const Rectangle_type& Rectangle)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (DatumTargetLabel,
                                                  id),
      Rectangle_ (Rectangle, this)
    {
    }

    DatumTargetRectangularAreaDefinitionType::
    DatumTargetRectangularAreaDefinitionType (const DatumTargetLabel_type& DatumTargetLabel,
                                              const id_type& id,
                                              ::std::auto_ptr< Rectangle_type > Rectangle)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (DatumTargetLabel,
                                                  id),
      Rectangle_ (Rectangle, this)
    {
    }

    DatumTargetRectangularAreaDefinitionType::
    DatumTargetRectangularAreaDefinitionType (const DatumTargetRectangularAreaDefinitionType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (x, f, c),
      Rectangle_ (x.Rectangle_, f, this)
    {
    }

    DatumTargetRectangularAreaDefinitionType::
    DatumTargetRectangularAreaDefinitionType (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      Rectangle_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DatumTargetRectangularAreaDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::DatumTargetDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Rectangle
        //
        if (n.name () == "Rectangle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Rectangle_type > r (
            Rectangle_traits::create (i, f, this));

          if (!Rectangle_.present ())
          {
            this->Rectangle_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Rectangle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Rectangle",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    DatumTargetRectangularAreaDefinitionType* DatumTargetRectangularAreaDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumTargetRectangularAreaDefinitionType (*this, f, c);
    }

    DatumTargetRectangularAreaDefinitionType& DatumTargetRectangularAreaDefinitionType::
    operator= (const DatumTargetRectangularAreaDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::DatumTargetDefinitionBaseType& > (*this) = x;
        this->Rectangle_ = x.Rectangle_;
      }

      return *this;
    }

    DatumTargetRectangularAreaDefinitionType::
    ~DatumTargetRectangularAreaDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DatumTargetRectangularAreaDefinitionType >
    _xsd_DatumTargetRectangularAreaDefinitionType_type_factory_init (
      "DatumTargetRectangularAreaDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // DatumTargetSphereDefinitionType
    //

    DatumTargetSphereDefinitionType::
    DatumTargetSphereDefinitionType (const DatumTargetLabel_type& DatumTargetLabel,
                                     const id_type& id,
                                     const Sphere_type& Sphere)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (DatumTargetLabel,
                                                  id),
      Sphere_ (Sphere, this)
    {
    }

    DatumTargetSphereDefinitionType::
    DatumTargetSphereDefinitionType (const DatumTargetLabel_type& DatumTargetLabel,
                                     const id_type& id,
                                     ::std::auto_ptr< Sphere_type > Sphere)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (DatumTargetLabel,
                                                  id),
      Sphere_ (Sphere, this)
    {
    }

    DatumTargetSphereDefinitionType::
    DatumTargetSphereDefinitionType (const DatumTargetSphereDefinitionType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (x, f, c),
      Sphere_ (x.Sphere_, f, this)
    {
    }

    DatumTargetSphereDefinitionType::
    DatumTargetSphereDefinitionType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      Sphere_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DatumTargetSphereDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::DatumTargetDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Sphere
        //
        if (n.name () == "Sphere" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sphere_type > r (
            Sphere_traits::create (i, f, this));

          if (!Sphere_.present ())
          {
            this->Sphere_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Sphere_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Sphere",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    DatumTargetSphereDefinitionType* DatumTargetSphereDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumTargetSphereDefinitionType (*this, f, c);
    }

    DatumTargetSphereDefinitionType& DatumTargetSphereDefinitionType::
    operator= (const DatumTargetSphereDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::DatumTargetDefinitionBaseType& > (*this) = x;
        this->Sphere_ = x.Sphere_;
      }

      return *this;
    }

    DatumTargetSphereDefinitionType::
    ~DatumTargetSphereDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DatumTargetSphereDefinitionType >
    _xsd_DatumTargetSphereDefinitionType_type_factory_init (
      "DatumTargetSphereDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // DatumTargetIrregularAreaDefinitionType
    //

    DatumTargetIrregularAreaDefinitionType::
    DatumTargetIrregularAreaDefinitionType (const DatumTargetLabel_type& DatumTargetLabel,
                                            const id_type& id,
                                            const Boundary_type& Boundary)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (DatumTargetLabel,
                                                  id),
      Boundary_ (Boundary, this)
    {
    }

    DatumTargetIrregularAreaDefinitionType::
    DatumTargetIrregularAreaDefinitionType (const DatumTargetLabel_type& DatumTargetLabel,
                                            const id_type& id,
                                            ::std::auto_ptr< Boundary_type > Boundary)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (DatumTargetLabel,
                                                  id),
      Boundary_ (Boundary, this)
    {
    }

    DatumTargetIrregularAreaDefinitionType::
    DatumTargetIrregularAreaDefinitionType (const DatumTargetIrregularAreaDefinitionType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (x, f, c),
      Boundary_ (x.Boundary_, f, this)
    {
    }

    DatumTargetIrregularAreaDefinitionType::
    DatumTargetIrregularAreaDefinitionType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif2::DatumTargetDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      Boundary_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DatumTargetIrregularAreaDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::DatumTargetDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Boundary
        //
        if (n.name () == "Boundary" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Boundary_type > r (
            Boundary_traits::create (i, f, this));

          if (!Boundary_.present ())
          {
            this->Boundary_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Boundary_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Boundary",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    DatumTargetIrregularAreaDefinitionType* DatumTargetIrregularAreaDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DatumTargetIrregularAreaDefinitionType (*this, f, c);
    }

    DatumTargetIrregularAreaDefinitionType& DatumTargetIrregularAreaDefinitionType::
    operator= (const DatumTargetIrregularAreaDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::DatumTargetDefinitionBaseType& > (*this) = x;
        this->Boundary_ = x.Boundary_;
      }

      return *this;
    }

    DatumTargetIrregularAreaDefinitionType::
    ~DatumTargetIrregularAreaDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DatumTargetIrregularAreaDefinitionType >
    _xsd_DatumTargetIrregularAreaDefinitionType_type_factory_init (
      "DatumTargetIrregularAreaDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // EmployeeType
    //

    EmployeeType::
    EmployeeType (const Name_type& Name)
    : ::xml_schema::type (),
      Name_ (Name, this),
      EmployeeId_ (this),
      Shift_ (this)
    {
    }

    EmployeeType::
    EmployeeType (const EmployeeType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      EmployeeId_ (x.EmployeeId_, f, this),
      Shift_ (x.Shift_, f, this)
    {
    }

    EmployeeType::
    EmployeeType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      EmployeeId_ (this),
      Shift_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EmployeeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (r);
            continue;
          }
        }

        // EmployeeId
        //
        if (n.name () == "EmployeeId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EmployeeId_type > r (
            EmployeeId_traits::create (i, f, this));

          if (!this->EmployeeId_)
          {
            this->EmployeeId_.set (r);
            continue;
          }
        }

        // Shift
        //
        if (n.name () == "Shift" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Shift_type > r (
            Shift_traits::create (i, f, this));

          if (!this->Shift_)
          {
            this->Shift_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Name",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EmployeeType* EmployeeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EmployeeType (*this, f, c);
    }

    EmployeeType& EmployeeType::
    operator= (const EmployeeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->EmployeeId_ = x.EmployeeId_;
        this->Shift_ = x.Shift_;
      }

      return *this;
    }

    EmployeeType::
    ~EmployeeType ()
    {
    }

    // FileType
    //

    FileType::
    FileType (const Name_type& Name)
    : ::xml_schema::type (),
      Name_ (Name, this),
      Version_ (this),
      Format_ (this)
    {
    }

    FileType::
    FileType (const FileType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Version_ (x.Version_, f, this),
      Format_ (x.Format_, f, this)
    {
    }

    FileType::
    FileType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Version_ (this),
      Format_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FileType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (r);
            continue;
          }
        }

        // Version
        //
        if (n.name () == "Version" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          if (!this->Version_)
          {
            this->Version_.set (r);
            continue;
          }
        }

        // Format
        //
        if (n.name () == "Format" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Format_type > r (
            Format_traits::create (i, f, this));

          if (!this->Format_)
          {
            this->Format_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Name",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    FileType* FileType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FileType (*this, f, c);
    }

    FileType& FileType::
    operator= (const FileType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Version_ = x.Version_;
        this->Format_ = x.Format_;
      }

      return *this;
    }

    FileType::
    ~FileType ()
    {
    }

    // SoftwareType
    //

    SoftwareType::
    SoftwareType (const VendorName_type& VendorName,
                  const ApplicationName_type& ApplicationName)
    : ::xml_schema::type (),
      VendorName_ (VendorName, this),
      ApplicationName_ (ApplicationName, this),
      Version_ (this),
      Description_ (this)
    {
    }

    SoftwareType::
    SoftwareType (const SoftwareType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      VendorName_ (x.VendorName_, f, this),
      ApplicationName_ (x.ApplicationName_, f, this),
      Version_ (x.Version_, f, this),
      Description_ (x.Description_, f, this)
    {
    }

    SoftwareType::
    SoftwareType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      VendorName_ (this),
      ApplicationName_ (this),
      Version_ (this),
      Description_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SoftwareType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // VendorName
        //
        if (n.name () == "VendorName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< VendorName_type > r (
            VendorName_traits::create (i, f, this));

          if (!VendorName_.present ())
          {
            this->VendorName_.set (r);
            continue;
          }
        }

        // ApplicationName
        //
        if (n.name () == "ApplicationName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ApplicationName_type > r (
            ApplicationName_traits::create (i, f, this));

          if (!ApplicationName_.present ())
          {
            this->ApplicationName_.set (r);
            continue;
          }
        }

        // Version
        //
        if (n.name () == "Version" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          if (!this->Version_)
          {
            this->Version_.set (r);
            continue;
          }
        }

        // Description
        //
        if (n.name () == "Description" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (r);
            continue;
          }
        }

        break;
      }

      if (!VendorName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "VendorName",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ApplicationName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ApplicationName",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SoftwareType* SoftwareType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SoftwareType (*this, f, c);
    }

    SoftwareType& SoftwareType::
    operator= (const SoftwareType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->VendorName_ = x.VendorName_;
        this->ApplicationName_ = x.ApplicationName_;
        this->Version_ = x.Version_;
        this->Description_ = x.Description_;
      }

      return *this;
    }

    SoftwareType::
    ~SoftwareType ()
    {
    }

    // OrganizationType
    //

    OrganizationType::
    OrganizationType (const Name_type& Name)
    : ::xml_schema::type (),
      Name_ (Name, this),
      Address_ (this)
    {
    }

    OrganizationType::
    OrganizationType (const OrganizationType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Address_ (x.Address_, f, this)
    {
    }

    OrganizationType::
    OrganizationType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Address_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OrganizationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (r);
            continue;
          }
        }

        // Address
        //
        if (n.name () == "Address" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Address_type > r (
            Address_traits::create (i, f, this));

          if (!this->Address_)
          {
            this->Address_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Name",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OrganizationType* OrganizationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OrganizationType (*this, f, c);
    }

    OrganizationType& OrganizationType::
    operator= (const OrganizationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Address_ = x.Address_;
      }

      return *this;
    }

    OrganizationType::
    ~OrganizationType ()
    {
    }

    // PhysicalAddressType
    //

    PhysicalAddressType::
    PhysicalAddressType ()
    : ::xml_schema::type (),
      Description_ (this),
      InternalLocation_ (this),
      StreetNumber_ (this),
      Street_ (this),
      PostalBox_ (this),
      Town_ (this),
      Region_ (this),
      PostalCode_ (this),
      Country_ (this),
      FacsimileNumber_ (this),
      TelephoneNumber_ (this),
      ElectronicMailAddress_ (this),
      TelexNumber_ (this)
    {
    }

    PhysicalAddressType::
    PhysicalAddressType (const PhysicalAddressType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Description_ (x.Description_, f, this),
      InternalLocation_ (x.InternalLocation_, f, this),
      StreetNumber_ (x.StreetNumber_, f, this),
      Street_ (x.Street_, f, this),
      PostalBox_ (x.PostalBox_, f, this),
      Town_ (x.Town_, f, this),
      Region_ (x.Region_, f, this),
      PostalCode_ (x.PostalCode_, f, this),
      Country_ (x.Country_, f, this),
      FacsimileNumber_ (x.FacsimileNumber_, f, this),
      TelephoneNumber_ (x.TelephoneNumber_, f, this),
      ElectronicMailAddress_ (x.ElectronicMailAddress_, f, this),
      TelexNumber_ (x.TelexNumber_, f, this)
    {
    }

    PhysicalAddressType::
    PhysicalAddressType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Description_ (this),
      InternalLocation_ (this),
      StreetNumber_ (this),
      Street_ (this),
      PostalBox_ (this),
      Town_ (this),
      Region_ (this),
      PostalCode_ (this),
      Country_ (this),
      FacsimileNumber_ (this),
      TelephoneNumber_ (this),
      ElectronicMailAddress_ (this),
      TelexNumber_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PhysicalAddressType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Description
        //
        if (n.name () == "Description" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (r);
            continue;
          }
        }

        // InternalLocation
        //
        if (n.name () == "InternalLocation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalLocation_type > r (
            InternalLocation_traits::create (i, f, this));

          if (!this->InternalLocation_)
          {
            this->InternalLocation_.set (r);
            continue;
          }
        }

        // StreetNumber
        //
        if (n.name () == "StreetNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< StreetNumber_type > r (
            StreetNumber_traits::create (i, f, this));

          if (!this->StreetNumber_)
          {
            this->StreetNumber_.set (r);
            continue;
          }
        }

        // Street
        //
        if (n.name () == "Street" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Street_type > r (
            Street_traits::create (i, f, this));

          if (!this->Street_)
          {
            this->Street_.set (r);
            continue;
          }
        }

        // PostalBox
        //
        if (n.name () == "PostalBox" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PostalBox_type > r (
            PostalBox_traits::create (i, f, this));

          if (!this->PostalBox_)
          {
            this->PostalBox_.set (r);
            continue;
          }
        }

        // Town
        //
        if (n.name () == "Town" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Town_type > r (
            Town_traits::create (i, f, this));

          if (!this->Town_)
          {
            this->Town_.set (r);
            continue;
          }
        }

        // Region
        //
        if (n.name () == "Region" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Region_type > r (
            Region_traits::create (i, f, this));

          if (!this->Region_)
          {
            this->Region_.set (r);
            continue;
          }
        }

        // PostalCode
        //
        if (n.name () == "PostalCode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PostalCode_type > r (
            PostalCode_traits::create (i, f, this));

          if (!this->PostalCode_)
          {
            this->PostalCode_.set (r);
            continue;
          }
        }

        // Country
        //
        if (n.name () == "Country" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Country_type > r (
            Country_traits::create (i, f, this));

          if (!this->Country_)
          {
            this->Country_.set (r);
            continue;
          }
        }

        // FacsimileNumber
        //
        if (n.name () == "FacsimileNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FacsimileNumber_type > r (
            FacsimileNumber_traits::create (i, f, this));

          if (!this->FacsimileNumber_)
          {
            this->FacsimileNumber_.set (r);
            continue;
          }
        }

        // TelephoneNumber
        //
        if (n.name () == "TelephoneNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TelephoneNumber_type > r (
            TelephoneNumber_traits::create (i, f, this));

          if (!this->TelephoneNumber_)
          {
            this->TelephoneNumber_.set (r);
            continue;
          }
        }

        // ElectronicMailAddress
        //
        if (n.name () == "ElectronicMailAddress" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ElectronicMailAddress_type > r (
            ElectronicMailAddress_traits::create (i, f, this));

          if (!this->ElectronicMailAddress_)
          {
            this->ElectronicMailAddress_.set (r);
            continue;
          }
        }

        // TelexNumber
        //
        if (n.name () == "TelexNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TelexNumber_type > r (
            TelexNumber_traits::create (i, f, this));

          if (!this->TelexNumber_)
          {
            this->TelexNumber_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PhysicalAddressType* PhysicalAddressType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PhysicalAddressType (*this, f, c);
    }

    PhysicalAddressType& PhysicalAddressType::
    operator= (const PhysicalAddressType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Description_ = x.Description_;
        this->InternalLocation_ = x.InternalLocation_;
        this->StreetNumber_ = x.StreetNumber_;
        this->Street_ = x.Street_;
        this->PostalBox_ = x.PostalBox_;
        this->Town_ = x.Town_;
        this->Region_ = x.Region_;
        this->PostalCode_ = x.PostalCode_;
        this->Country_ = x.Country_;
        this->FacsimileNumber_ = x.FacsimileNumber_;
        this->TelephoneNumber_ = x.TelephoneNumber_;
        this->ElectronicMailAddress_ = x.ElectronicMailAddress_;
        this->TelexNumber_ = x.TelexNumber_;
      }

      return *this;
    }

    PhysicalAddressType::
    ~PhysicalAddressType ()
    {
    }

    // AddressDescriptionEnumType
    //

    AddressDescriptionEnumType::
    AddressDescriptionEnumType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_AddressDescriptionEnumType_convert ();
    }

    AddressDescriptionEnumType::
    AddressDescriptionEnumType (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_AddressDescriptionEnumType_convert ();
    }

    AddressDescriptionEnumType::
    AddressDescriptionEnumType (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_AddressDescriptionEnumType_convert ();
    }

    AddressDescriptionEnumType* AddressDescriptionEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AddressDescriptionEnumType (*this, f, c);
    }

    AddressDescriptionEnumType::value AddressDescriptionEnumType::
    _xsd_AddressDescriptionEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_AddressDescriptionEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_AddressDescriptionEnumType_indexes_,
                        _xsd_AddressDescriptionEnumType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_AddressDescriptionEnumType_indexes_ + 4 || _xsd_AddressDescriptionEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const AddressDescriptionEnumType::
    _xsd_AddressDescriptionEnumType_literals_[4] =
    {
      "DELIVERY",
      "POSTAL",
      "VISITOR",
      "NOTDEFINED"
    };

    const AddressDescriptionEnumType::value AddressDescriptionEnumType::
    _xsd_AddressDescriptionEnumType_indexes_[4] =
    {
      ::xsd::qif2::AddressDescriptionEnumType::DELIVERY,
      ::xsd::qif2::AddressDescriptionEnumType::NOTDEFINED,
      ::xsd::qif2::AddressDescriptionEnumType::POSTAL,
      ::xsd::qif2::AddressDescriptionEnumType::VISITOR
    };

    // AddressDescriptionType
    //

    AddressDescriptionType::
    AddressDescriptionType ()
    : ::xml_schema::type (),
      AddressDescriptionEnum_ (this),
      OtherAddressDescription_ (this)
    {
    }

    AddressDescriptionType::
    AddressDescriptionType (const AddressDescriptionType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AddressDescriptionEnum_ (x.AddressDescriptionEnum_, f, this),
      OtherAddressDescription_ (x.OtherAddressDescription_, f, this)
    {
    }

    AddressDescriptionType::
    AddressDescriptionType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AddressDescriptionEnum_ (this),
      OtherAddressDescription_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AddressDescriptionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // AddressDescriptionEnum
        //
        if (n.name () == "AddressDescriptionEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AddressDescriptionEnum_type > r (
            AddressDescriptionEnum_traits::create (i, f, this));

          if (!this->AddressDescriptionEnum_)
          {
            this->AddressDescriptionEnum_.set (r);
            continue;
          }
        }

        // OtherAddressDescription
        //
        if (n.name () == "OtherAddressDescription" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherAddressDescription_type > r (
            OtherAddressDescription_traits::create (i, f, this));

          if (!this->OtherAddressDescription_)
          {
            this->OtherAddressDescription_.set (r);
            continue;
          }
        }

        break;
      }
    }

    AddressDescriptionType* AddressDescriptionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AddressDescriptionType (*this, f, c);
    }

    AddressDescriptionType& AddressDescriptionType::
    operator= (const AddressDescriptionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AddressDescriptionEnum_ = x.AddressDescriptionEnum_;
        this->OtherAddressDescription_ = x.OtherAddressDescription_;
      }

      return *this;
    }

    AddressDescriptionType::
    ~AddressDescriptionType ()
    {
    }

    // LocationType
    //

    LocationType::
    LocationType (const LocationDescription_type& LocationDescription,
                  const id_type& id)
    : ::xml_schema::type (),
      LocationDescription_ (LocationDescription, this),
      Address_ (this),
      id_ (id, this)
    {
    }

    LocationType::
    LocationType (const LocationType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      LocationDescription_ (x.LocationDescription_, f, this),
      Address_ (x.Address_, f, this),
      id_ (x.id_, f, this)
    {
    }

    LocationType::
    LocationType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      LocationDescription_ (this),
      Address_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LocationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // LocationDescription
        //
        if (n.name () == "LocationDescription" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LocationDescription_type > r (
            LocationDescription_traits::create (i, f, this));

          if (!LocationDescription_.present ())
          {
            this->LocationDescription_.set (r);
            continue;
          }
        }

        // Address
        //
        if (n.name () == "Address" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Address_type > r (
            Address_traits::create (i, f, this));

          if (!this->Address_)
          {
            this->Address_.set (r);
            continue;
          }
        }

        break;
      }

      if (!LocationDescription_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "LocationDescription",
          "http://qifstandards.org/xsd/qif2");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    LocationType* LocationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LocationType (*this, f, c);
    }

    LocationType& LocationType::
    operator= (const LocationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->LocationDescription_ = x.LocationDescription_;
        this->Address_ = x.Address_;
        this->id_ = x.id_;
      }

      return *this;
    }

    LocationType::
    ~LocationType ()
    {
    }

    // CustomerOrganizationType
    //

    CustomerOrganizationType::
    CustomerOrganizationType (const Name_type& Name,
                              const CustomerNumber_type& CustomerNumber)
    : ::xsd::qif2::OrganizationType (Name),
      CustomerNumber_ (CustomerNumber, this)
    {
    }

    CustomerOrganizationType::
    CustomerOrganizationType (const CustomerOrganizationType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::OrganizationType (x, f, c),
      CustomerNumber_ (x.CustomerNumber_, f, this)
    {
    }

    CustomerOrganizationType::
    CustomerOrganizationType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::OrganizationType (e, f | ::xml_schema::flags::base, c),
      CustomerNumber_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CustomerOrganizationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::OrganizationType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CustomerNumber
        //
        if (n.name () == "CustomerNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CustomerNumber_type > r (
            CustomerNumber_traits::create (i, f, this));

          if (!CustomerNumber_.present ())
          {
            this->CustomerNumber_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CustomerNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CustomerNumber",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CustomerOrganizationType* CustomerOrganizationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CustomerOrganizationType (*this, f, c);
    }

    CustomerOrganizationType& CustomerOrganizationType::
    operator= (const CustomerOrganizationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::OrganizationType& > (*this) = x;
        this->CustomerNumber_ = x.CustomerNumber_;
      }

      return *this;
    }

    CustomerOrganizationType::
    ~CustomerOrganizationType ()
    {
    }

    // VersionHistoryType
    //

    VersionHistoryType::
    VersionHistoryType ()
    : ::xml_schema::type (),
      EarlierVersion_ (this)
    {
    }

    VersionHistoryType::
    VersionHistoryType (const VersionHistoryType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      EarlierVersion_ (x.EarlierVersion_, f, this)
    {
    }

    VersionHistoryType::
    VersionHistoryType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      EarlierVersion_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void VersionHistoryType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EarlierVersion
        //
        if (n.name () == "EarlierVersion" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EarlierVersion_type > r (
            EarlierVersion_traits::create (i, f, this));

          this->EarlierVersion_.push_back (r);
          continue;
        }

        break;
      }
    }

    VersionHistoryType* VersionHistoryType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VersionHistoryType (*this, f, c);
    }

    VersionHistoryType& VersionHistoryType::
    operator= (const VersionHistoryType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->EarlierVersion_ = x.EarlierVersion_;
      }

      return *this;
    }

    VersionHistoryType::
    ~VersionHistoryType ()
    {
    }

    // VersionBaseType
    //

    VersionBaseType::
    VersionBaseType ()
    : ::xml_schema::type (),
      TimeCreated_ (this),
      SignOffs_ (this)
    {
    }

    VersionBaseType::
    VersionBaseType (const VersionBaseType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      TimeCreated_ (x.TimeCreated_, f, this),
      SignOffs_ (x.SignOffs_, f, this)
    {
    }

    VersionBaseType::
    VersionBaseType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      TimeCreated_ (this),
      SignOffs_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void VersionBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // TimeCreated
        //
        if (n.name () == "TimeCreated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TimeCreated_type > r (
            TimeCreated_traits::create (i, f, this));

          if (!this->TimeCreated_)
          {
            this->TimeCreated_.set (r);
            continue;
          }
        }

        // SignOffs
        //
        if (n.name () == "SignOffs" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SignOffs_type > r (
            SignOffs_traits::create (i, f, this));

          if (!this->SignOffs_)
          {
            this->SignOffs_.set (r);
            continue;
          }
        }

        break;
      }
    }

    VersionBaseType* VersionBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VersionBaseType (*this, f, c);
    }

    VersionBaseType& VersionBaseType::
    operator= (const VersionBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->TimeCreated_ = x.TimeCreated_;
        this->SignOffs_ = x.SignOffs_;
      }

      return *this;
    }

    VersionBaseType::
    ~VersionBaseType ()
    {
    }

    // VersionType
    //

    VersionType::
    VersionType ()
    : ::xsd::qif2::VersionBaseType (),
      ThisInstanceQPId_ (this)
    {
    }

    VersionType::
    VersionType (const VersionType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::VersionBaseType (x, f, c),
      ThisInstanceQPId_ (x.ThisInstanceQPId_, f, this)
    {
    }

    VersionType::
    VersionType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::VersionBaseType (e, f | ::xml_schema::flags::base, c),
      ThisInstanceQPId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void VersionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::VersionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThisInstanceQPId
        //
        if (n.name () == "ThisInstanceQPId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThisInstanceQPId_type > r (
            ThisInstanceQPId_traits::create (i, f, this));

          if (!this->ThisInstanceQPId_)
          {
            this->ThisInstanceQPId_.set (r);
            continue;
          }
        }

        break;
      }
    }

    VersionType* VersionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VersionType (*this, f, c);
    }

    VersionType& VersionType::
    operator= (const VersionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::VersionBaseType& > (*this) = x;
        this->ThisInstanceQPId_ = x.ThisInstanceQPId_;
      }

      return *this;
    }

    VersionType::
    ~VersionType ()
    {
    }

    // VersionReferenceType
    //

    VersionReferenceType::
    VersionReferenceType ()
    : ::xsd::qif2::VersionBaseType (),
      QPIdReference_ (this)
    {
    }

    VersionReferenceType::
    VersionReferenceType (const VersionReferenceType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::VersionBaseType (x, f, c),
      QPIdReference_ (x.QPIdReference_, f, this)
    {
    }

    VersionReferenceType::
    VersionReferenceType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::VersionBaseType (e, f | ::xml_schema::flags::base, c),
      QPIdReference_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void VersionReferenceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::VersionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // QPIdReference
        //
        if (n.name () == "QPIdReference" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< QPIdReference_type > r (
            QPIdReference_traits::create (i, f, this));

          if (!this->QPIdReference_)
          {
            this->QPIdReference_.set (r);
            continue;
          }
        }

        break;
      }
    }

    VersionReferenceType* VersionReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VersionReferenceType (*this, f, c);
    }

    VersionReferenceType& VersionReferenceType::
    operator= (const VersionReferenceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::VersionBaseType& > (*this) = x;
        this->QPIdReference_ = x.QPIdReference_;
      }

      return *this;
    }

    VersionReferenceType::
    ~VersionReferenceType ()
    {
    }

    // SignOffsType
    //

    SignOffsType::
    SignOffsType ()
    : ::xml_schema::type (),
      Employee_ (this)
    {
    }

    SignOffsType::
    SignOffsType (const SignOffsType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Employee_ (x.Employee_, f, this)
    {
    }

    SignOffsType::
    SignOffsType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Employee_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SignOffsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Employee
        //
        if (n.name () == "Employee" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Employee_type > r (
            Employee_traits::create (i, f, this));

          this->Employee_.push_back (r);
          continue;
        }

        break;
      }
    }

    SignOffsType* SignOffsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SignOffsType (*this, f, c);
    }

    SignOffsType& SignOffsType::
    operator= (const SignOffsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Employee_ = x.Employee_;
      }

      return *this;
    }

    SignOffsType::
    ~SignOffsType ()
    {
    }

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::DatumTargetIrregularAreaDefinitionType >
    _xsd_DatumTargetIrregularAreaDefinition_element_factory_init (
      "DatumTarget",
      "http://qifstandards.org/xsd/qif2",
      "DatumTargetIrregularAreaDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::DatumTargetCircularAreaDefinitionType >
    _xsd_DatumTargetCircularAreaDefinition_element_factory_init (
      "DatumTarget",
      "http://qifstandards.org/xsd/qif2",
      "DatumTargetCircularAreaDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::DatumTargetCircularLineDefinitionType >
    _xsd_DatumTargetCircularLineDefinition_element_factory_init (
      "DatumTarget",
      "http://qifstandards.org/xsd/qif2",
      "DatumTargetCircularLineDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::DatumTargetCylindricalAreaDefinitionType >
    _xsd_DatumTargetCylindricalAreaDefinition_element_factory_init (
      "DatumTarget",
      "http://qifstandards.org/xsd/qif2",
      "DatumTargetCylindricalAreaDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::DatumTargetLineDefinitionType >
    _xsd_DatumTargetLineDefinition_element_factory_init (
      "DatumTarget",
      "http://qifstandards.org/xsd/qif2",
      "DatumTargetLineDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::DatumTargetPointDefinitionType >
    _xsd_DatumTargetPointDefinition_element_factory_init (
      "DatumTarget",
      "http://qifstandards.org/xsd/qif2",
      "DatumTargetPointDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::DatumTargetRectangularAreaDefinitionType >
    _xsd_DatumTargetRectangularAreaDefinition_element_factory_init (
      "DatumTarget",
      "http://qifstandards.org/xsd/qif2",
      "DatumTargetRectangularAreaDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::DatumTargetSphereDefinitionType >
    _xsd_DatumTargetSphereDefinition_element_factory_init (
      "DatumTarget",
      "http://qifstandards.org/xsd/qif2",
      "DatumTargetSphereDefinition",
      "http://qifstandards.org/xsd/qif2");
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif2
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif2
  {
    void
    operator<< (::xercesc::DOMElement& e, const FormalStandardEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const FormalStandardEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const FormalStandardEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const FormalStandardType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FormalStandardEnum
      //
      if (i.FormalStandardEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FormalStandardEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FormalStandardEnum ();
      }

      // OtherFormalStandard
      //
      if (i.OtherFormalStandard ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherFormalStandard",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.OtherFormalStandard ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SequencedDatumType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SimpleDatum
      //
      if (i.SimpleDatum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SimpleDatum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SimpleDatum ();
      }

      // CompoundDatum
      //
      if (i.CompoundDatum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CompoundDatum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CompoundDatum ();
      }

      // SequenceNumber
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SequenceNumber",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SequenceNumber ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CompoundDatumType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Datum
      //
      for (CompoundDatumType::Datum_const_iterator
           b (i.Datum ().begin ()), n (i.Datum ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Datum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // ReducedDatum
      //
      if (i.ReducedDatum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ReducedDatum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ReducedDatum ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DatumWithPrecedenceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SimpleDatum
      //
      if (i.SimpleDatum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SimpleDatum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SimpleDatum ();
      }

      // NominalDatumFeature
      //
      if (i.NominalDatumFeature ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "NominalDatumFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.NominalDatumFeature ();
      }

      // ActualDatumFeature
      //
      if (i.ActualDatumFeature ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ActualDatumFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ActualDatumFeature ();
      }

      // CompoundDatum
      //
      if (i.CompoundDatum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CompoundDatum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CompoundDatum ();
      }

      // Precedence
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Precedence",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Precedence ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DatumType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DatumDefinitionId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DatumDefinitionId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DatumDefinitionId ();
      }

      // MaterialModifier
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaterialModifier",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.MaterialModifier ();
      }

      // ReferencedComponent
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ReferencedComponent",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ReferencedComponent ();
      }

      // DatumFeatureSimulatorModifier
      //
      if (i.DatumFeatureSimulatorModifier ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DatumFeatureSimulatorModifier",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DatumFeatureSimulatorModifier ();
      }

      // DatumTranslation
      //
      if (i.DatumTranslation ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DatumTranslation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DatumTranslation ();
      }

      // DegreesOfFreedom
      //
      if (i.DegreesOfFreedom ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DegreesOfFreedom",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DegreesOfFreedom ();
      }

      // ProjectedDatum
      //
      if (i.ProjectedDatum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ProjectedDatum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ProjectedDatum ();
      }

      // DiameterModifier
      //
      if (i.DiameterModifier ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DiameterModifier",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DiameterModifier ();
      }

      // SectionModifier
      //
      if (i.SectionModifier ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SectionModifier",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SectionModifier ();
      }

      // ContactingFeature
      //
      if (i.ContactingFeature ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ContactingFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ContactingFeature ();
      }

      // DistanceVariable
      //
      if (i.DistanceVariable ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DistanceVariable",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DistanceVariable ();
      }

      // DatumFixed
      //
      if (i.DatumFixed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DatumFixed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DatumFixed ();
      }

      // ReducedDatum
      //
      if (i.ReducedDatum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ReducedDatum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ReducedDatum ();
      }

      // ConstrainOrientation
      //
      if (i.ConstrainOrientation ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ConstrainOrientation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ConstrainOrientation ();
      }

      // ConstrainSubsequent
      //
      if (i.ConstrainSubsequent ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ConstrainSubsequent",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ConstrainSubsequent ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DatumTranslationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DatumTranslationAllowed
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DatumTranslationAllowed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DatumTranslationAllowed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DatumFeatureBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FeatureItemId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FeatureItemId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.FeatureItemId ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ActualDatumFeatureType& i)
    {
      e << static_cast< const ::xsd::qif2::DatumFeatureBaseType& > (i);

      // MaterialModifier
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaterialModifier",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.MaterialModifier ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const NominalDatumFeatureType& i)
    {
      e << static_cast< const ::xsd::qif2::DatumFeatureBaseType& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const DatumFeatureSimulatorModifierType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // LinearSize
      //
      if (i.LinearSize ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LinearSize",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LinearSize ();
      }

      // DiametricalSize
      //
      if (i.DiametricalSize ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DiametricalSize",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DiametricalSize ();
      }

      // BasicSize
      //
      if (i.BasicSize ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BasicSize",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BasicSize ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DatumReferenceFrameType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Attributes",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Attributes ();
      }

      // Datum
      //
      for (DatumReferenceFrameType::Datum_const_iterator
           b (i.Datum ().begin ()), n (i.Datum ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Datum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // Name
      //
      if (i.Name ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Name",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Name ();
      }

      // Description
      //
      if (i.Description ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Description",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Description ();
      }

      // CoordinateSystemId
      //
      if (i.CoordinateSystemId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CoordinateSystemId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CoordinateSystemId ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DegreeOfFreedomEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DegreeOfFreedomEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const DegreeOfFreedomEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const ISODegreeOfFreedomEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const ISODegreeOfFreedomEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ISODegreeOfFreedomEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const IntersectionPlaneEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const IntersectionPlaneEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const IntersectionPlaneEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const IntersectionPlaneType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // IntersectionPlaneEnum
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "IntersectionPlaneEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.IntersectionPlaneEnum ();
      }

      // DatumDefinitionId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DatumDefinitionId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DatumDefinitionId ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ModifyingPlaneEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const ModifyingPlaneEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ModifyingPlaneEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const DirectionFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DirectionFeatureEnum
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DirectionFeatureEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DirectionFeatureEnum ();
      }

      // DatumDefinitionId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DatumDefinitionId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DatumDefinitionId ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CollectionPlaneType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CollectionPlaneEnum
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CollectionPlaneEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.CollectionPlaneEnum ();
      }

      // DatumDefinitionId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DatumDefinitionId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DatumDefinitionId ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OrientationPlaneType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // OrientationPlaneEnum
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OrientationPlaneEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.OrientationPlaneEnum ();
      }

      // DatumDefinitionId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DatumDefinitionId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DatumDefinitionId ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ReducedDatumEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const ReducedDatumEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ReducedDatumEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const DegreesOfFreedomType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DegreeOfFreedom
      //
      for (DegreesOfFreedomType::DegreeOfFreedom_const_iterator
           b (i.DegreeOfFreedom ().begin ()), n (i.DegreeOfFreedom ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DegreeOfFreedom",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // ISODegreeOfFreedom
      //
      for (DegreesOfFreedomType::ISODegreeOfFreedom_const_iterator
           b (i.ISODegreeOfFreedom ().begin ()), n (i.ISODegreeOfFreedom ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ISODegreeOfFreedom",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DiameterModifierEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DiameterModifierEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const DiameterModifierEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const SectionModifierEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const SectionModifierEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const SectionModifierEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointWithNormalBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Point
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Point",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Point ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Normal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Normal ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ActualPointWithNormalBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Point
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Point",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Point ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Normal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Normal ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const MeasurePointNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::PointWithNormalBaseType& > (i);

      // MeasurementDeviceId
      //
      if (i.MeasurementDeviceId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MeasurementDeviceId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MeasurementDeviceId ();
      }

      // SensorId
      //
      if (i.SensorId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SensorId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SensorId ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const MeasurePointActualType& i)
    {
      e << static_cast< const ::xsd::qif2::ActualPointWithNormalBaseType& > (i);

      // Compensated
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Compensated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Compensated ();
      }

      // ProbeRadius
      //
      if (i.ProbeRadius ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ProbeRadius",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ProbeRadius ();
      }

      // MeasurementDeviceId
      //
      if (i.MeasurementDeviceId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MeasurementDeviceId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MeasurementDeviceId ();
      }

      // SensorId
      //
      if (i.SensorId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SensorId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SensorId ();
      }

      // MeasurePointNominalId
      //
      if (i.MeasurePointNominalId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MeasurePointNominalId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MeasurePointNominalId ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const MovableDatumTargetDirectionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DatumTargetTranslationDirection
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DatumTargetTranslationDirection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DatumTargetTranslationDirection ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TargetPointActualType& i)
    {
      e << static_cast< const ::xsd::qif2::ActualPointWithNormalBaseType& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const TargetPointNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::PointWithNormalBaseType& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const TransformListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Transform
      //
      for (TransformListType::Transform_const_iterator
           b (i.Transform ().begin ()), n (i.Transform ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // N
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "N",
            e));

        a << i.N ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TransformInstanceType& i)
    {
      e << static_cast< const ::xsd::qif2::TransformMatrixType& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Attributes",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Attributes ();
      }

      // Name
      //
      if (i.Name ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Name",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Name ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LinearCoordinateDirectionEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const LinearCoordinateDirectionEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const LinearCoordinateDirectionEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const AngularCoordinateDirectionEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const AngularCoordinateDirectionEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const AngularCoordinateDirectionEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const SubstituteFeatureAlgorithmBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr&, const SubstituteFeatureAlgorithmBaseType&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const SubstituteFeatureAlgorithmBaseType&)
    {
    }

    void
    operator<< (::xercesc::DOMElement& e, const FeatureOfSizeSubstituteFeatureAlgorithmEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const FeatureOfSizeSubstituteFeatureAlgorithmEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const FeatureOfSizeSubstituteFeatureAlgorithmEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const FeatureOfSizeSubstituteFeatureAlgorithmType& i)
    {
      e << static_cast< const ::xsd::qif2::SubstituteFeatureAlgorithmBaseType& > (i);

      // FeatureOfSizeSubstituteFeatureAlgorithmEnum
      //
      if (i.FeatureOfSizeSubstituteFeatureAlgorithmEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FeatureOfSizeSubstituteFeatureAlgorithmEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FeatureOfSizeSubstituteFeatureAlgorithmEnum ();
      }

      // OtherFeatureOfSizeSubstituteFeatureAlgorithm
      //
      if (i.OtherFeatureOfSizeSubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherFeatureOfSizeSubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.OtherFeatureOfSizeSubstituteFeatureAlgorithm ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const NonFeatureOfSizeSubstituteFeatureAlgorithmType& i)
    {
      e << static_cast< const ::xsd::qif2::SubstituteFeatureAlgorithmBaseType& > (i);

      // NonFeatureOfSizeSubstituteFeatureAlgorithmEnum
      //
      if (i.NonFeatureOfSizeSubstituteFeatureAlgorithmEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "NonFeatureOfSizeSubstituteFeatureAlgorithmEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.NonFeatureOfSizeSubstituteFeatureAlgorithmEnum ();
      }

      // OtherNonFeatureOfSizeSubstituteFeatureAlgorithm
      //
      if (i.OtherNonFeatureOfSizeSubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherNonFeatureOfSizeSubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.OtherNonFeatureOfSizeSubstituteFeatureAlgorithm ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CurveSubstituteFeatureAlgorithmEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const CurveSubstituteFeatureAlgorithmEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const CurveSubstituteFeatureAlgorithmEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const CurveSubstituteFeatureAlgorithmType& i)
    {
      e << static_cast< const ::xsd::qif2::SubstituteFeatureAlgorithmBaseType& > (i);

      // CurveSubstituteFeatureAlgorithmEnum
      //
      if (i.CurveSubstituteFeatureAlgorithmEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CurveSubstituteFeatureAlgorithmEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CurveSubstituteFeatureAlgorithmEnum ();
      }

      // OtherCurveSubstituteFeatureAlgorithm
      //
      if (i.OtherCurveSubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherCurveSubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.OtherCurveSubstituteFeatureAlgorithm ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SurfaceSubstituteFeatureAlgorithmEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const SurfaceSubstituteFeatureAlgorithmEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const SurfaceSubstituteFeatureAlgorithmEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const SurfaceSubstituteFeatureAlgorithmType& i)
    {
      e << static_cast< const ::xsd::qif2::SubstituteFeatureAlgorithmBaseType& > (i);

      // SurfaceSubstituteFeatureAlgorithmEnum
      //
      if (i.SurfaceSubstituteFeatureAlgorithmEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SurfaceSubstituteFeatureAlgorithmEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SurfaceSubstituteFeatureAlgorithmEnum ();
      }

      // OtherSurfaceSubstituteFeatureAlgorithm
      //
      if (i.OtherSurfaceSubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherSurfaceSubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.OtherSurfaceSubstituteFeatureAlgorithm ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const MaterialModifierEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const MaterialModifierEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const MaterialModifierEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const PrecedenceEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const PrecedenceEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const PrecedenceEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const PrecedenceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PrecedenceEnum
      //
      if (i.PrecedenceEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PrecedenceEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PrecedenceEnum ();
      }

      // OtherPrecedence
      //
      if (i.OtherPrecedence ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherPrecedence",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.OtherPrecedence ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ReferencedComponentEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const ReferencedComponentEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const ReferencedComponentEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const RetrievalMethodEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const RetrievalMethodEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const RetrievalMethodEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const MeasurementDirectiveEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const MeasurementDirectiveEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const MeasurementDirectiveEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const MeasurementDirectiveType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MeasurementDirectiveEnum
      //
      if (i.MeasurementDirectiveEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MeasurementDirectiveEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MeasurementDirectiveEnum ();
      }

      // OtherMeasurementDirective
      //
      if (i.OtherMeasurementDirective ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherMeasurementDirective",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.OtherMeasurementDirective ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DistanceBetweenAnalysisModeEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DistanceBetweenAnalysisModeEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const DistanceBetweenAnalysisModeEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const AngleBetweenAnalysisModeEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const AngleBetweenAnalysisModeEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const AngleBetweenAnalysisModeEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const BaseFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ReferencedComponent
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ReferencedComponent",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ReferencedComponent ();
      }

      // FeatureItemId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FeatureItemId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.FeatureItemId ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SequencedBaseFeatureType& i)
    {
      e << static_cast< const ::xsd::qif2::BaseFeatureType& > (i);

      // SequenceNumber
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SequenceNumber",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SequenceNumber ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DirectionalOffsetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Offset
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Offset",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Offset ();
      }

      // NominalDirection
      //
      if (i.NominalDirection ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "NominalDirection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.NominalDirection ();
      }

      // FeatureDirection
      //
      if (i.FeatureDirection ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FeatureDirection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FeatureDirection ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AlignmentFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DatumDefinitionId
      //
      if (i.DatumDefinitionId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DatumDefinitionId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DatumDefinitionId ();
      }

      // BaseFeature
      //
      if (i.BaseFeature ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BaseFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AlignmentOperationBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SequenceNumber
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SequenceNumber",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SequenceNumber ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AlignmentOperationBaseType >
    _xsd_AlignmentOperationBaseType_type_serializer_init (
      "AlignmentOperationBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PrimaryAlignmentOperationType& i)
    {
      e << static_cast< const ::xsd::qif2::AlignmentOperationBaseType& > (i);

      // PrimaryEntity
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PrimaryEntity",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.PrimaryEntity ();
      }

      // PrimaryAxis
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PrimaryAxis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.PrimaryAxis ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PrimaryAlignmentOperationType >
    _xsd_PrimaryAlignmentOperationType_type_serializer_init (
      "PrimaryAlignmentOperationType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const SecondaryAlignmentOperationType& i)
    {
      e << static_cast< const ::xsd::qif2::AlignmentOperationBaseType& > (i);

      // SecondaryEntity
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SecondaryEntity",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SecondaryEntity ();
      }

      // SecondaryAxis
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SecondaryAxis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SecondaryAxis ();
      }

      // RotationAxis
      //
      if (i.RotationAxis ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RotationAxis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.RotationAxis ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SecondaryAlignmentOperationType >
    _xsd_SecondaryAlignmentOperationType_type_serializer_init (
      "SecondaryAlignmentOperationType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ActualOriginOffsetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // OriginEntity
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OriginEntity",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.OriginEntity ();
      }

      // OriginDirection
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OriginDirection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.OriginDirection ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ActualOffsetAlignmentOperationType& i)
    {
      e << static_cast< const ::xsd::qif2::AlignmentOperationBaseType& > (i);

      // Origin
      //
      for (ActualOffsetAlignmentOperationType::Origin_const_iterator
           b (i.Origin ().begin ()), n (i.Origin ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Origin",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ActualOffsetAlignmentOperationType >
    _xsd_ActualOffsetAlignmentOperationType_type_serializer_init (
      "ActualOffsetAlignmentOperationType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const NominalOffsetAlignmentOperationType& i)
    {
      e << static_cast< const ::xsd::qif2::AlignmentOperationBaseType& > (i);

      // Offset
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Offset",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Offset ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, NominalOffsetAlignmentOperationType >
    _xsd_NominalOffsetAlignmentOperationType_type_serializer_init (
      "NominalOffsetAlignmentOperationType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const NominalRotationAlignmentOperationType& i)
    {
      e << static_cast< const ::xsd::qif2::AlignmentOperationBaseType& > (i);

      // RotationAxis
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RotationAxis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.RotationAxis ();
      }

      // Angle
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Angle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Angle ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, NominalRotationAlignmentOperationType >
    _xsd_NominalRotationAlignmentOperationType_type_serializer_init (
      "NominalRotationAlignmentOperationType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const DatumPrecedenceAlignmentOperationType& i)
    {
      e << static_cast< const ::xsd::qif2::AlignmentOperationBaseType& > (i);

      // DatumReferenceFrameId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DatumReferenceFrameId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DatumReferenceFrameId ();
      }

      // PrimaryAxis
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PrimaryAxis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.PrimaryAxis ();
      }

      // SecondaryAxis
      //
      if (i.SecondaryAxis ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SecondaryAxis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SecondaryAxis ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DatumPrecedenceAlignmentOperationType >
    _xsd_DatumPrecedenceAlignmentOperationType_type_serializer_init (
      "DatumPrecedenceAlignmentOperationType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const BestFitAlignmentOperationType& i)
    {
      e << static_cast< const ::xsd::qif2::AlignmentOperationBaseType& > (i);

      // DegreesOfFreedom
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DegreesOfFreedom",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DegreesOfFreedom ();
      }

      // BaseFeature
      //
      for (BestFitAlignmentOperationType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, BestFitAlignmentOperationType >
    _xsd_BestFitAlignmentOperationType_type_serializer_init (
      "BestFitAlignmentOperationType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const MachineCoordinateSystemOperationType& i)
    {
      e << static_cast< const ::xsd::qif2::AlignmentOperationBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MachineCoordinateSystemOperationType >
    _xsd_MachineCoordinateSystemOperationType_type_serializer_init (
      "MachineCoordinateSystemOperationType",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PrimaryAlignmentOperationType >
    _xsd_PrimaryAlignment_element_serializer_init (
      "AlignmentOperation",
      "http://qifstandards.org/xsd/qif2",
      "PrimaryAlignment",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::SecondaryAlignmentOperationType >
    _xsd_SecondaryAlignment_element_serializer_init (
      "AlignmentOperation",
      "http://qifstandards.org/xsd/qif2",
      "SecondaryAlignment",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ActualOffsetAlignmentOperationType >
    _xsd_ActualOffset_element_serializer_init (
      "AlignmentOperation",
      "http://qifstandards.org/xsd/qif2",
      "ActualOffset",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::NominalOffsetAlignmentOperationType >
    _xsd_NominalOffset_element_serializer_init (
      "AlignmentOperation",
      "http://qifstandards.org/xsd/qif2",
      "NominalOffset",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::NominalRotationAlignmentOperationType >
    _xsd_NominalRotation_element_serializer_init (
      "AlignmentOperation",
      "http://qifstandards.org/xsd/qif2",
      "NominalRotation",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::DatumPrecedenceAlignmentOperationType >
    _xsd_DatumPrecedence_element_serializer_init (
      "AlignmentOperation",
      "http://qifstandards.org/xsd/qif2",
      "DatumPrecedence",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::BestFitAlignmentOperationType >
    _xsd_BestFit_element_serializer_init (
      "AlignmentOperation",
      "http://qifstandards.org/xsd/qif2",
      "BestFit",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::MachineCoordinateSystemOperationType >
    _xsd_Machine_element_serializer_init (
      "AlignmentOperation",
      "http://qifstandards.org/xsd/qif2",
      "Machine",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const AlignmentOperationsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AlignmentOperation
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (AlignmentOperationsType::AlignmentOperation_const_iterator
             b (i.AlignmentOperation ().begin ()), n (i.AlignmentOperation ().end ());
             b != n; ++b)
        {
          if (typeid (AlignmentOperationsType::AlignmentOperation_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "AlignmentOperation",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "AlignmentOperation",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }

      // BaseCoordinateSystemId
      //
      if (i.BaseCoordinateSystemId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseCoordinateSystemId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BaseCoordinateSystemId ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CoordinateSystemListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CoordinateSystem
      //
      for (CoordinateSystemListType::CoordinateSystem_const_iterator
           b (i.CoordinateSystem ().begin ()), n (i.CoordinateSystem ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CoordinateSystem",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // CommonCoordinateSystemId
      //
      if (i.CommonCoordinateSystemId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CommonCoordinateSystemId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CommonCoordinateSystemId ();
      }

      // MachineCoordinateSystemId
      //
      if (i.MachineCoordinateSystemId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MachineCoordinateSystemId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MachineCoordinateSystemId ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CoordinateSystemType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Attributes",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Attributes ();
      }

      // Name
      //
      if (i.Name ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Name",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Name ();
      }

      // NominalTransform
      //
      if (i.NominalTransform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "NominalTransform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.NominalTransform ();
      }

      // InternalCADCoordinateSystemId
      //
      if (i.InternalCADCoordinateSystemId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InternalCADCoordinateSystemId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.InternalCADCoordinateSystemId ();
      }

      // ExternalCADCoordinateSystemId
      //
      if (i.ExternalCADCoordinateSystemId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ExternalCADCoordinateSystemId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ExternalCADCoordinateSystemId ();
      }

      // AlignmentOperations
      //
      if (i.AlignmentOperations ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AlignmentOperations",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.AlignmentOperations ();
      }

      // SequenceNumber
      //
      if (i.SequenceNumber ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SequenceNumber",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SequenceNumber ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CoordinateSystemActualTransformType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ActualTransform
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ActualTransform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ActualTransform ();
      }

      // CoordinateSystemId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CoordinateSystemId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.CoordinateSystemId ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CoordinateSystemActualTransformsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Transform
      //
      for (CoordinateSystemActualTransformsType::Transform_const_iterator
           b (i.Transform ().begin ()), n (i.Transform ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ThreadSpecificationDetailedBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Diameter
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Diameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Diameter ();
      }

      // ThreadSeries
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThreadSeries",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ThreadSeries ();
      }

      // ThreadToleranceClass
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThreadToleranceClass",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ThreadToleranceClass ();
      }

      // CrestDiameterToleranceClass
      //
      if (i.CrestDiameterToleranceClass ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CrestDiameterToleranceClass",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CrestDiameterToleranceClass ();
      }

      // LeftHanded
      //
      if (i.LeftHanded ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LeftHanded",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LeftHanded ();
      }

      // ModifiedThread
      //
      if (i.ModifiedThread ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ModifiedThread",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ModifiedThread ();
      }

      // ThreadLengthEngagement
      //
      if (i.ThreadLengthEngagement ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThreadLengthEngagement",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThreadLengthEngagement ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SingleLeadThreadSpecificationType& i)
    {
      e << static_cast< const ::xsd::qif2::ThreadSpecificationDetailedBaseType& > (i);

      // ThreadDensity
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThreadDensity",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ThreadDensity ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const MultiLeadThreadSpecificationType& i)
    {
      e << static_cast< const ::xsd::qif2::ThreadSpecificationDetailedBaseType& > (i);

      // ThreadPitch
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThreadPitch",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ThreadPitch ();
      }

      // ThreadLeadDistance
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThreadLeadDistance",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ThreadLeadDistance ();
      }

      // ThreadLeadStarts
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThreadLeadStarts",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ThreadLeadStarts ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ThreadSpecificationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SingleLeadSpecification
      //
      if (i.SingleLeadSpecification ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SingleLeadSpecification",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SingleLeadSpecification ();
      }

      // MultiLeadSpecification
      //
      if (i.MultiLeadSpecification ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MultiLeadSpecification",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MultiLeadSpecification ();
      }

      // TextThreadSpecification
      //
      if (i.TextThreadSpecification ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TextThreadSpecification",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.TextThreadSpecification ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TextThreadSpecificationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // TextSpecification
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TextSpecification",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.TextSpecification ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ThreadSpecificationsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ThreadSpecification
      //
      for (ThreadSpecificationsType::ThreadSpecification_const_iterator
           b (i.ThreadSpecification ().begin ()), n (i.ThreadSpecification ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThreadSpecification",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ToleranceZonePerUnitAreaType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ToleranceValuePerUnit
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ToleranceValuePerUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ToleranceValuePerUnit ();
      }

      // RectangularUnitArea
      //
      if (i.RectangularUnitArea ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RectangularUnitArea",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.RectangularUnitArea ();
      }

      // CircularUnitArea
      //
      if (i.CircularUnitArea ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CircularUnitArea",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CircularUnitArea ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ToleranceZonePerUnitLengthType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ToleranceValuePerUnit
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ToleranceValuePerUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ToleranceValuePerUnit ();
      }

      // UnitLength
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitLength",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.UnitLength ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ToleranceZonePerUnitAngleType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ToleranceValuePerUnit
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ToleranceValuePerUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ToleranceValuePerUnit ();
      }

      // UnitAngle
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitAngle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.UnitAngle ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ToleranceZonePerUnitPolarAreaType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ToleranceValuePerUnit
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ToleranceValuePerUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ToleranceValuePerUnit ();
      }

      // UnitAngle
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitAngle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.UnitAngle ();
      }

      // UnitLength
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "UnitLength",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.UnitLength ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CompoundFeatureGeometryEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const CompoundFeatureGeometryEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const CompoundFeatureGeometryEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const DatumReferenceFramesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DatumReferenceFrame
      //
      for (DatumReferenceFramesType::DatumReferenceFrame_const_iterator
           b (i.DatumReferenceFrame ().begin ()), n (i.DatumReferenceFrame ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DatumReferenceFrame",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EventBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Description
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Description",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Description ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const NotableEventType& i)
    {
      e << static_cast< const ::xsd::qif2::EventBaseType& > (i);

      // Active
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Active",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Active ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const NotableEventsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // NotableEvent
      //
      for (NotableEventsType::NotableEvent_const_iterator
           b (i.NotableEvent ().begin ()), n (i.NotableEvent ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "NotableEvent",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const NotedEventType& i)
    {
      e << static_cast< const ::xsd::qif2::EventBaseType& > (i);

      // SequenceNumber
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SequenceNumber",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SequenceNumber ();
      }

      // TimeOccurred
      //
      if (i.TimeOccurred ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TimeOccurred",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.TimeOccurred ();
      }

      // NotableEventId
      //
      if (i.NotableEventId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "NotableEventId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.NotableEventId ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const NotedEventsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // NotedEvent
      //
      for (NotedEventsType::NotedEvent_const_iterator
           b (i.NotedEvent ().begin ()), n (i.NotedEvent ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "NotedEvent",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const InspectionStatusEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const InspectionStatusEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const InspectionStatusEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const InspectionStatusType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // InspectionStatusEnum
      //
      if (i.InspectionStatusEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InspectionStatusEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.InspectionStatusEnum ();
      }

      // OtherInspectionStatus
      //
      if (i.OtherInspectionStatus ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherInspectionStatus",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.OtherInspectionStatus ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EntityExternalType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // EntityId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EntityId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.EntityId ();
      }

      // Name
      //
      if (i.Name ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Name",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Name ();
      }

      // Description
      //
      if (i.Description ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Description",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Description ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EntitiesExternalType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Entity
      //
      for (EntitiesExternalType::Entity_const_iterator
           b (i.Entity ().begin ()), n (i.Entity ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Entity",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ZoneDataType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FeatureItemId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FeatureItemId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.FeatureItemId ();
      }

      // Bonus
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Bonus",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Bonus ();
      }

      // ReferenceLength
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ReferenceLength",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ReferenceLength ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LinearToleranceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MaxValue
      //
      if (i.MaxValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxValue",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MaxValue ();
      }

      // MinValue
      //
      if (i.MinValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinValue",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MinValue ();
      }

      // DefinitionId
      //
      if (i.DefinitionId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DefinitionId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DefinitionId ();
      }

      // DefinedAsLimit
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DefinedAsLimit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DefinedAsLimit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LinearToleranceDefinitionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Attributes",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Attributes ();
      }

      // MaxValue
      //
      if (i.MaxValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxValue",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MaxValue ();
      }

      // MinValue
      //
      if (i.MinValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinValue",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MinValue ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AngularToleranceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MaxValue
      //
      if (i.MaxValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxValue",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MaxValue ();
      }

      // MinValue
      //
      if (i.MinValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinValue",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MinValue ();
      }

      // DefinitionId
      //
      if (i.DefinitionId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DefinitionId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DefinitionId ();
      }

      // DefinedAsLimit
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DefinedAsLimit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DefinedAsLimit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AngularToleranceDefinitionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Attributes",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Attributes ();
      }

      // MaxValue
      //
      if (i.MaxValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxValue",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MaxValue ();
      }

      // MinValue
      //
      if (i.MinValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinValue",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MinValue ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TemperatureToleranceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MaxValue
      //
      if (i.MaxValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxValue",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MaxValue ();
      }

      // MinValue
      //
      if (i.MinValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinValue",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MinValue ();
      }

      // DefinedAsLimit
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DefinedAsLimit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DefinedAsLimit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AreaToleranceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MaxValue
      //
      if (i.MaxValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxValue",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MaxValue ();
      }

      // MinValue
      //
      if (i.MinValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinValue",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MinValue ();
      }

      // DefinedAsLimit
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DefinedAsLimit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DefinedAsLimit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ForceToleranceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MaxValue
      //
      if (i.MaxValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxValue",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MaxValue ();
      }

      // MinValue
      //
      if (i.MinValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinValue",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MinValue ();
      }

      // DefinedAsLimit
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DefinedAsLimit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DefinedAsLimit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const MassToleranceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MaxValue
      //
      if (i.MaxValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxValue",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MaxValue ();
      }

      // MinValue
      //
      if (i.MinValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinValue",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MinValue ();
      }

      // DefinedAsLimit
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DefinedAsLimit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DefinedAsLimit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PressureToleranceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MaxValue
      //
      if (i.MaxValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxValue",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MaxValue ();
      }

      // MinValue
      //
      if (i.MinValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinValue",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MinValue ();
      }

      // DefinedAsLimit
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DefinedAsLimit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DefinedAsLimit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SpeedToleranceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MaxValue
      //
      if (i.MaxValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxValue",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MaxValue ();
      }

      // MinValue
      //
      if (i.MinValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinValue",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MinValue ();
      }

      // DefinedAsLimit
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DefinedAsLimit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DefinedAsLimit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TimeToleranceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MaxValue
      //
      if (i.MaxValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxValue",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MaxValue ();
      }

      // MinValue
      //
      if (i.MinValue ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinValue",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MinValue ();
      }

      // DefinedAsLimit
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DefinedAsLimit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DefinedAsLimit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DimensionModifierEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const DimensionModifierEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const DimensionModifierEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const NonToleranceEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const NonToleranceEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const NonToleranceEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const CommonFileSpecEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const CommonFileSpecEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const CommonFileSpecEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const FileSpecType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CommonFileSpecEnum
      //
      if (i.CommonFileSpecEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CommonFileSpecEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CommonFileSpecEnum ();
      }

      // OtherFileSpec
      //
      if (i.OtherFileSpec ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherFileSpec",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.OtherFileSpec ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ExternalFileReferenceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // URI
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "URI",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.URI ();
      }

      // FileSpec
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FileSpec",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.FileSpec ();
      }

      // Description
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Description",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Description ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DatumTargetDefinitionsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DatumTarget
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (DatumTargetDefinitionsType::DatumTarget_const_iterator
             b (i.DatumTarget ().begin ()), n (i.DatumTarget ().end ());
             b != n; ++b)
        {
          if (typeid (DatumTargetDefinitionsType::DatumTarget_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "DatumTarget",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "DatumTarget",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }

      // N
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "N",
            e));

        a << i.N ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DatumDefinitionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Attributes",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Attributes ();
      }

      // DatumLabel
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DatumLabel",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DatumLabel ();
      }

      // DatumTargetIds
      //
      if (i.DatumTargetIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DatumTargetIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DatumTargetIds ();
      }

      // FeatureNominalIds
      //
      if (i.FeatureNominalIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FeatureNominalIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FeatureNominalIds ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DatumDefinitionsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DatumDefinition
      //
      for (DatumDefinitionsType::DatumDefinition_const_iterator
           b (i.DatumDefinition ().begin ()), n (i.DatumDefinition ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DatumDefinition",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const DatumTargetDefinitionBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Attributes",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Attributes ();
      }

      // DatumTargetLabel
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DatumTargetLabel",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DatumTargetLabel ();
      }

      // FeatureNominalId
      //
      if (i.FeatureNominalId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FeatureNominalId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FeatureNominalId ();
      }

      // MovableDatumTarget
      //
      if (i.MovableDatumTarget ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MovableDatumTarget",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MovableDatumTarget ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DatumTargetDefinitionBaseType >
    _xsd_DatumTargetDefinitionBaseType_type_serializer_init (
      "DatumTargetDefinitionBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const DatumTargetPointDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::DatumTargetDefinitionBaseType& > (i);

      // Point
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Point",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Point ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DatumTargetPointDefinitionType >
    _xsd_DatumTargetPointDefinitionType_type_serializer_init (
      "DatumTargetPointDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const DatumTargetLineDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::DatumTargetDefinitionBaseType& > (i);

      // Line
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Line",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Line ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DatumTargetLineDefinitionType >
    _xsd_DatumTargetLineDefinitionType_type_serializer_init (
      "DatumTargetLineDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const DatumTargetCircularAreaDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::DatumTargetDefinitionBaseType& > (i);

      // Circle
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Circle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Circle ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DatumTargetCircularAreaDefinitionType >
    _xsd_DatumTargetCircularAreaDefinitionType_type_serializer_init (
      "DatumTargetCircularAreaDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const DatumTargetCircularLineDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::DatumTargetDefinitionBaseType& > (i);

      // Circle
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Circle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Circle ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DatumTargetCircularLineDefinitionType >
    _xsd_DatumTargetCircularLineDefinitionType_type_serializer_init (
      "DatumTargetCircularLineDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const DatumTargetCylindricalAreaDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::DatumTargetDefinitionBaseType& > (i);

      // Cylinder
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cylinder",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Cylinder ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DatumTargetCylindricalAreaDefinitionType >
    _xsd_DatumTargetCylindricalAreaDefinitionType_type_serializer_init (
      "DatumTargetCylindricalAreaDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const DatumTargetRectangularAreaDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::DatumTargetDefinitionBaseType& > (i);

      // Rectangle
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Rectangle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Rectangle ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DatumTargetRectangularAreaDefinitionType >
    _xsd_DatumTargetRectangularAreaDefinitionType_type_serializer_init (
      "DatumTargetRectangularAreaDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const DatumTargetSphereDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::DatumTargetDefinitionBaseType& > (i);

      // Sphere
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Sphere",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Sphere ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DatumTargetSphereDefinitionType >
    _xsd_DatumTargetSphereDefinitionType_type_serializer_init (
      "DatumTargetSphereDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const DatumTargetIrregularAreaDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::DatumTargetDefinitionBaseType& > (i);

      // Boundary
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Boundary",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Boundary ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DatumTargetIrregularAreaDefinitionType >
    _xsd_DatumTargetIrregularAreaDefinitionType_type_serializer_init (
      "DatumTargetIrregularAreaDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const EmployeeType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Name
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Name",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Name ();
      }

      // EmployeeId
      //
      if (i.EmployeeId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EmployeeId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.EmployeeId ();
      }

      // Shift
      //
      if (i.Shift ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Shift",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Shift ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FileType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Name
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Name",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Name ();
      }

      // Version
      //
      if (i.Version ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Version",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Version ();
      }

      // Format
      //
      if (i.Format ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Format",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Format ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SoftwareType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // VendorName
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "VendorName",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.VendorName ();
      }

      // ApplicationName
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ApplicationName",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ApplicationName ();
      }

      // Version
      //
      if (i.Version ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Version",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Version ();
      }

      // Description
      //
      if (i.Description ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Description",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Description ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OrganizationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Name
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Name",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Name ();
      }

      // Address
      //
      if (i.Address ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Address",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Address ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PhysicalAddressType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Description
      //
      if (i.Description ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Description",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Description ();
      }

      // InternalLocation
      //
      if (i.InternalLocation ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InternalLocation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.InternalLocation ();
      }

      // StreetNumber
      //
      if (i.StreetNumber ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "StreetNumber",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.StreetNumber ();
      }

      // Street
      //
      if (i.Street ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Street",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Street ();
      }

      // PostalBox
      //
      if (i.PostalBox ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PostalBox",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PostalBox ();
      }

      // Town
      //
      if (i.Town ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Town",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Town ();
      }

      // Region
      //
      if (i.Region ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Region",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Region ();
      }

      // PostalCode
      //
      if (i.PostalCode ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PostalCode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PostalCode ();
      }

      // Country
      //
      if (i.Country ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Country",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Country ();
      }

      // FacsimileNumber
      //
      if (i.FacsimileNumber ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FacsimileNumber",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FacsimileNumber ();
      }

      // TelephoneNumber
      //
      if (i.TelephoneNumber ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TelephoneNumber",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.TelephoneNumber ();
      }

      // ElectronicMailAddress
      //
      if (i.ElectronicMailAddress ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ElectronicMailAddress",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ElectronicMailAddress ();
      }

      // TelexNumber
      //
      if (i.TelexNumber ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TelexNumber",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.TelexNumber ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AddressDescriptionEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const AddressDescriptionEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const AddressDescriptionEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const AddressDescriptionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AddressDescriptionEnum
      //
      if (i.AddressDescriptionEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AddressDescriptionEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.AddressDescriptionEnum ();
      }

      // OtherAddressDescription
      //
      if (i.OtherAddressDescription ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherAddressDescription",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.OtherAddressDescription ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LocationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // LocationDescription
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LocationDescription",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.LocationDescription ();
      }

      // Address
      //
      if (i.Address ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Address",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Address ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CustomerOrganizationType& i)
    {
      e << static_cast< const ::xsd::qif2::OrganizationType& > (i);

      // CustomerNumber
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CustomerNumber",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.CustomerNumber ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const VersionHistoryType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // EarlierVersion
      //
      for (VersionHistoryType::EarlierVersion_const_iterator
           b (i.EarlierVersion ().begin ()), n (i.EarlierVersion ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EarlierVersion",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const VersionBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // TimeCreated
      //
      if (i.TimeCreated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TimeCreated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.TimeCreated ();
      }

      // SignOffs
      //
      if (i.SignOffs ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SignOffs",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SignOffs ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const VersionType& i)
    {
      e << static_cast< const ::xsd::qif2::VersionBaseType& > (i);

      // ThisInstanceQPId
      //
      if (i.ThisInstanceQPId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThisInstanceQPId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ThisInstanceQPId ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const VersionReferenceType& i)
    {
      e << static_cast< const ::xsd::qif2::VersionBaseType& > (i);

      // QPIdReference
      //
      if (i.QPIdReference ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "QPIdReference",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.QPIdReference ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SignOffsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Employee
      //
      for (SignOffsType::Employee_const_iterator
           b (i.Employee ().begin ()), n (i.Employee ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Employee",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::DatumTargetIrregularAreaDefinitionType >
    _xsd_DatumTargetIrregularAreaDefinition_element_serializer_init (
      "DatumTarget",
      "http://qifstandards.org/xsd/qif2",
      "DatumTargetIrregularAreaDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::DatumTargetCircularAreaDefinitionType >
    _xsd_DatumTargetCircularAreaDefinition_element_serializer_init (
      "DatumTarget",
      "http://qifstandards.org/xsd/qif2",
      "DatumTargetCircularAreaDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::DatumTargetCircularLineDefinitionType >
    _xsd_DatumTargetCircularLineDefinition_element_serializer_init (
      "DatumTarget",
      "http://qifstandards.org/xsd/qif2",
      "DatumTargetCircularLineDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::DatumTargetCylindricalAreaDefinitionType >
    _xsd_DatumTargetCylindricalAreaDefinition_element_serializer_init (
      "DatumTarget",
      "http://qifstandards.org/xsd/qif2",
      "DatumTargetCylindricalAreaDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::DatumTargetLineDefinitionType >
    _xsd_DatumTargetLineDefinition_element_serializer_init (
      "DatumTarget",
      "http://qifstandards.org/xsd/qif2",
      "DatumTargetLineDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::DatumTargetPointDefinitionType >
    _xsd_DatumTargetPointDefinition_element_serializer_init (
      "DatumTarget",
      "http://qifstandards.org/xsd/qif2",
      "DatumTargetPointDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::DatumTargetRectangularAreaDefinitionType >
    _xsd_DatumTargetRectangularAreaDefinition_element_serializer_init (
      "DatumTarget",
      "http://qifstandards.org/xsd/qif2",
      "DatumTargetRectangularAreaDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::DatumTargetSphereDefinitionType >
    _xsd_DatumTargetSphereDefinition_element_serializer_init (
      "DatumTarget",
      "http://qifstandards.org/xsd/qif2",
      "DatumTargetSphereDefinition",
      "http://qifstandards.org/xsd/qif2");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

