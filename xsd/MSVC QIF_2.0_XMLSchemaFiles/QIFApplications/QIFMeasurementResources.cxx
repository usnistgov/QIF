// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "QIFMeasurementResources.hxx"

namespace xsd
{
  namespace qif2
  {
    // MeasurementResourcesType
    // 

    const MeasurementResourcesType::Version_optional& MeasurementResourcesType::
    Version () const
    {
      return this->Version_;
    }

    MeasurementResourcesType::Version_optional& MeasurementResourcesType::
    Version ()
    {
      return this->Version_;
    }

    void MeasurementResourcesType::
    Version (const Version_type& x)
    {
      this->Version_.set (x);
    }

    void MeasurementResourcesType::
    Version (const Version_optional& x)
    {
      this->Version_ = x;
    }

    void MeasurementResourcesType::
    Version (::std::auto_ptr< Version_type > x)
    {
      this->Version_.set (x);
    }

    const MeasurementResourcesType::Carriages_optional& MeasurementResourcesType::
    Carriages () const
    {
      return this->Carriages_;
    }

    MeasurementResourcesType::Carriages_optional& MeasurementResourcesType::
    Carriages ()
    {
      return this->Carriages_;
    }

    void MeasurementResourcesType::
    Carriages (const Carriages_type& x)
    {
      this->Carriages_.set (x);
    }

    void MeasurementResourcesType::
    Carriages (const Carriages_optional& x)
    {
      this->Carriages_ = x;
    }

    void MeasurementResourcesType::
    Carriages (::std::auto_ptr< Carriages_type > x)
    {
      this->Carriages_.set (x);
    }

    const MeasurementResourcesType::Fixtures_optional& MeasurementResourcesType::
    Fixtures () const
    {
      return this->Fixtures_;
    }

    MeasurementResourcesType::Fixtures_optional& MeasurementResourcesType::
    Fixtures ()
    {
      return this->Fixtures_;
    }

    void MeasurementResourcesType::
    Fixtures (const Fixtures_type& x)
    {
      this->Fixtures_.set (x);
    }

    void MeasurementResourcesType::
    Fixtures (const Fixtures_optional& x)
    {
      this->Fixtures_ = x;
    }

    void MeasurementResourcesType::
    Fixtures (::std::auto_ptr< Fixtures_type > x)
    {
      this->Fixtures_.set (x);
    }

    const MeasurementResourcesType::MeasurementDevices_optional& MeasurementResourcesType::
    MeasurementDevices () const
    {
      return this->MeasurementDevices_;
    }

    MeasurementResourcesType::MeasurementDevices_optional& MeasurementResourcesType::
    MeasurementDevices ()
    {
      return this->MeasurementDevices_;
    }

    void MeasurementResourcesType::
    MeasurementDevices (const MeasurementDevices_type& x)
    {
      this->MeasurementDevices_.set (x);
    }

    void MeasurementResourcesType::
    MeasurementDevices (const MeasurementDevices_optional& x)
    {
      this->MeasurementDevices_ = x;
    }

    void MeasurementResourcesType::
    MeasurementDevices (::std::auto_ptr< MeasurementDevices_type > x)
    {
      this->MeasurementDevices_.set (x);
    }

    const MeasurementResourcesType::Sensors_optional& MeasurementResourcesType::
    Sensors () const
    {
      return this->Sensors_;
    }

    MeasurementResourcesType::Sensors_optional& MeasurementResourcesType::
    Sensors ()
    {
      return this->Sensors_;
    }

    void MeasurementResourcesType::
    Sensors (const Sensors_type& x)
    {
      this->Sensors_.set (x);
    }

    void MeasurementResourcesType::
    Sensors (const Sensors_optional& x)
    {
      this->Sensors_ = x;
    }

    void MeasurementResourcesType::
    Sensors (::std::auto_ptr< Sensors_type > x)
    {
      this->Sensors_.set (x);
    }

    const MeasurementResourcesType::Tools_optional& MeasurementResourcesType::
    Tools () const
    {
      return this->Tools_;
    }

    MeasurementResourcesType::Tools_optional& MeasurementResourcesType::
    Tools ()
    {
      return this->Tools_;
    }

    void MeasurementResourcesType::
    Tools (const Tools_type& x)
    {
      this->Tools_.set (x);
    }

    void MeasurementResourcesType::
    Tools (const Tools_optional& x)
    {
      this->Tools_ = x;
    }

    void MeasurementResourcesType::
    Tools (::std::auto_ptr< Tools_type > x)
    {
      this->Tools_.set (x);
    }


    // CarriagesType
    // 

    const CarriagesType::Carriage_sequence& CarriagesType::
    Carriage () const
    {
      return this->Carriage_;
    }

    CarriagesType::Carriage_sequence& CarriagesType::
    Carriage ()
    {
      return this->Carriage_;
    }

    void CarriagesType::
    Carriage (const Carriage_sequence& s)
    {
      this->Carriage_ = s;
    }


    // FixturesType
    // 

    const FixturesType::Fixture_sequence& FixturesType::
    Fixture () const
    {
      return this->Fixture_;
    }

    FixturesType::Fixture_sequence& FixturesType::
    Fixture ()
    {
      return this->Fixture_;
    }

    void FixturesType::
    Fixture (const Fixture_sequence& s)
    {
      this->Fixture_ = s;
    }


    // SensorsType
    // 

    const SensorsType::Sensor_sequence& SensorsType::
    Sensor () const
    {
      return this->Sensor_;
    }

    SensorsType::Sensor_sequence& SensorsType::
    Sensor ()
    {
      return this->Sensor_;
    }

    void SensorsType::
    Sensor (const Sensor_sequence& s)
    {
      this->Sensor_ = s;
    }


    // ToolsType
    // 

    const ToolsType::Tool_sequence& ToolsType::
    Tool () const
    {
      return this->Tool_;
    }

    ToolsType::Tool_sequence& ToolsType::
    Tool ()
    {
      return this->Tool_;
    }

    void ToolsType::
    Tool (const Tool_sequence& s)
    {
      this->Tool_ = s;
    }


    // MeasurementDevicesType
    // 

    const MeasurementDevicesType::MeasurementDevice_sequence& MeasurementDevicesType::
    MeasurementDevice () const
    {
      return this->MeasurementDevice_;
    }

    MeasurementDevicesType::MeasurementDevice_sequence& MeasurementDevicesType::
    MeasurementDevice ()
    {
      return this->MeasurementDevice_;
    }

    void MeasurementDevicesType::
    MeasurementDevice (const MeasurementDevice_sequence& s)
    {
      this->MeasurementDevice_ = s;
    }


    // MeasurementResourceBaseType
    // 

    const MeasurementResourceBaseType::Name_type& MeasurementResourceBaseType::
    Name () const
    {
      return this->Name_.get ();
    }

    MeasurementResourceBaseType::Name_type& MeasurementResourceBaseType::
    Name ()
    {
      return this->Name_.get ();
    }

    void MeasurementResourceBaseType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void MeasurementResourceBaseType::
    Name (::std::auto_ptr< Name_type > x)
    {
      this->Name_.set (x);
    }

    const MeasurementResourceBaseType::Description_optional& MeasurementResourceBaseType::
    Description () const
    {
      return this->Description_;
    }

    MeasurementResourceBaseType::Description_optional& MeasurementResourceBaseType::
    Description ()
    {
      return this->Description_;
    }

    void MeasurementResourceBaseType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void MeasurementResourceBaseType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void MeasurementResourceBaseType::
    Description (::std::auto_ptr< Description_type > x)
    {
      this->Description_.set (x);
    }

    const MeasurementResourceBaseType::Manufacturer_optional& MeasurementResourceBaseType::
    Manufacturer () const
    {
      return this->Manufacturer_;
    }

    MeasurementResourceBaseType::Manufacturer_optional& MeasurementResourceBaseType::
    Manufacturer ()
    {
      return this->Manufacturer_;
    }

    void MeasurementResourceBaseType::
    Manufacturer (const Manufacturer_type& x)
    {
      this->Manufacturer_.set (x);
    }

    void MeasurementResourceBaseType::
    Manufacturer (const Manufacturer_optional& x)
    {
      this->Manufacturer_ = x;
    }

    void MeasurementResourceBaseType::
    Manufacturer (::std::auto_ptr< Manufacturer_type > x)
    {
      this->Manufacturer_.set (x);
    }

    const MeasurementResourceBaseType::ModelNumber_optional& MeasurementResourceBaseType::
    ModelNumber () const
    {
      return this->ModelNumber_;
    }

    MeasurementResourceBaseType::ModelNumber_optional& MeasurementResourceBaseType::
    ModelNumber ()
    {
      return this->ModelNumber_;
    }

    void MeasurementResourceBaseType::
    ModelNumber (const ModelNumber_type& x)
    {
      this->ModelNumber_.set (x);
    }

    void MeasurementResourceBaseType::
    ModelNumber (const ModelNumber_optional& x)
    {
      this->ModelNumber_ = x;
    }

    void MeasurementResourceBaseType::
    ModelNumber (::std::auto_ptr< ModelNumber_type > x)
    {
      this->ModelNumber_.set (x);
    }

    const MeasurementResourceBaseType::SerialNumber_optional& MeasurementResourceBaseType::
    SerialNumber () const
    {
      return this->SerialNumber_;
    }

    MeasurementResourceBaseType::SerialNumber_optional& MeasurementResourceBaseType::
    SerialNumber ()
    {
      return this->SerialNumber_;
    }

    void MeasurementResourceBaseType::
    SerialNumber (const SerialNumber_type& x)
    {
      this->SerialNumber_.set (x);
    }

    void MeasurementResourceBaseType::
    SerialNumber (const SerialNumber_optional& x)
    {
      this->SerialNumber_ = x;
    }

    void MeasurementResourceBaseType::
    SerialNumber (::std::auto_ptr< SerialNumber_type > x)
    {
      this->SerialNumber_.set (x);
    }

    const MeasurementResourceBaseType::LocationId_optional& MeasurementResourceBaseType::
    LocationId () const
    {
      return this->LocationId_;
    }

    MeasurementResourceBaseType::LocationId_optional& MeasurementResourceBaseType::
    LocationId ()
    {
      return this->LocationId_;
    }

    void MeasurementResourceBaseType::
    LocationId (const LocationId_type& x)
    {
      this->LocationId_.set (x);
    }

    void MeasurementResourceBaseType::
    LocationId (const LocationId_optional& x)
    {
      this->LocationId_ = x;
    }

    void MeasurementResourceBaseType::
    LocationId (::std::auto_ptr< LocationId_type > x)
    {
      this->LocationId_.set (x);
    }

    const MeasurementResourceBaseType::Location_optional& MeasurementResourceBaseType::
    Location () const
    {
      return this->Location_;
    }

    MeasurementResourceBaseType::Location_optional& MeasurementResourceBaseType::
    Location ()
    {
      return this->Location_;
    }

    void MeasurementResourceBaseType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void MeasurementResourceBaseType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void MeasurementResourceBaseType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const MeasurementResourceBaseType::id_type& MeasurementResourceBaseType::
    id () const
    {
      return this->id_.get ();
    }

    MeasurementResourceBaseType::id_type& MeasurementResourceBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void MeasurementResourceBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void MeasurementResourceBaseType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // FixtureType
    // 


    // MeasurementDeviceAccuracyBaseType
    // 


    // NumericalLengthAccuracyType
    // 

    const NumericalLengthAccuracyType::AccuracyValue_type& NumericalLengthAccuracyType::
    AccuracyValue () const
    {
      return this->AccuracyValue_.get ();
    }

    NumericalLengthAccuracyType::AccuracyValue_type& NumericalLengthAccuracyType::
    AccuracyValue ()
    {
      return this->AccuracyValue_.get ();
    }

    void NumericalLengthAccuracyType::
    AccuracyValue (const AccuracyValue_type& x)
    {
      this->AccuracyValue_.set (x);
    }

    void NumericalLengthAccuracyType::
    AccuracyValue (::std::auto_ptr< AccuracyValue_type > x)
    {
      this->AccuracyValue_.set (x);
    }


    // MeasurementDeviceType
    // 

    const MeasurementDeviceType::Calibrations_optional& MeasurementDeviceType::
    Calibrations () const
    {
      return this->Calibrations_;
    }

    MeasurementDeviceType::Calibrations_optional& MeasurementDeviceType::
    Calibrations ()
    {
      return this->Calibrations_;
    }

    void MeasurementDeviceType::
    Calibrations (const Calibrations_type& x)
    {
      this->Calibrations_.set (x);
    }

    void MeasurementDeviceType::
    Calibrations (const Calibrations_optional& x)
    {
      this->Calibrations_ = x;
    }

    void MeasurementDeviceType::
    Calibrations (::std::auto_ptr< Calibrations_type > x)
    {
      this->Calibrations_.set (x);
    }

    const MeasurementDeviceType::InspectionTemperatures_optional& MeasurementDeviceType::
    InspectionTemperatures () const
    {
      return this->InspectionTemperatures_;
    }

    MeasurementDeviceType::InspectionTemperatures_optional& MeasurementDeviceType::
    InspectionTemperatures ()
    {
      return this->InspectionTemperatures_;
    }

    void MeasurementDeviceType::
    InspectionTemperatures (const InspectionTemperatures_type& x)
    {
      this->InspectionTemperatures_.set (x);
    }

    void MeasurementDeviceType::
    InspectionTemperatures (const InspectionTemperatures_optional& x)
    {
      this->InspectionTemperatures_ = x;
    }

    void MeasurementDeviceType::
    InspectionTemperatures (::std::auto_ptr< InspectionTemperatures_type > x)
    {
      this->InspectionTemperatures_.set (x);
    }


    // CalibrationMasterType
    // 

    const CalibrationMasterType::SerialNumber_type& CalibrationMasterType::
    SerialNumber () const
    {
      return this->SerialNumber_.get ();
    }

    CalibrationMasterType::SerialNumber_type& CalibrationMasterType::
    SerialNumber ()
    {
      return this->SerialNumber_.get ();
    }

    void CalibrationMasterType::
    SerialNumber (const SerialNumber_type& x)
    {
      this->SerialNumber_.set (x);
    }

    void CalibrationMasterType::
    SerialNumber (::std::auto_ptr< SerialNumber_type > x)
    {
      this->SerialNumber_.set (x);
    }

    const CalibrationMasterType::description_optional& CalibrationMasterType::
    description () const
    {
      return this->description_;
    }

    CalibrationMasterType::description_optional& CalibrationMasterType::
    description ()
    {
      return this->description_;
    }

    void CalibrationMasterType::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void CalibrationMasterType::
    description (const description_optional& x)
    {
      this->description_ = x;
    }

    void CalibrationMasterType::
    description (::std::auto_ptr< description_type > x)
    {
      this->description_.set (x);
    }


    // CalibrationType
    // 

    const CalibrationType::CalibrationMaster_optional& CalibrationType::
    CalibrationMaster () const
    {
      return this->CalibrationMaster_;
    }

    CalibrationType::CalibrationMaster_optional& CalibrationType::
    CalibrationMaster ()
    {
      return this->CalibrationMaster_;
    }

    void CalibrationType::
    CalibrationMaster (const CalibrationMaster_type& x)
    {
      this->CalibrationMaster_.set (x);
    }

    void CalibrationType::
    CalibrationMaster (const CalibrationMaster_optional& x)
    {
      this->CalibrationMaster_ = x;
    }

    void CalibrationType::
    CalibrationMaster (::std::auto_ptr< CalibrationMaster_type > x)
    {
      this->CalibrationMaster_.set (x);
    }

    const CalibrationType::Temperatures_type& CalibrationType::
    Temperatures () const
    {
      return this->Temperatures_.get ();
    }

    CalibrationType::Temperatures_type& CalibrationType::
    Temperatures ()
    {
      return this->Temperatures_.get ();
    }

    void CalibrationType::
    Temperatures (const Temperatures_type& x)
    {
      this->Temperatures_.set (x);
    }

    void CalibrationType::
    Temperatures (::std::auto_ptr< Temperatures_type > x)
    {
      this->Temperatures_.set (x);
    }

    const CalibrationType::TimeStamp_type& CalibrationType::
    TimeStamp () const
    {
      return this->TimeStamp_.get ();
    }

    CalibrationType::TimeStamp_type& CalibrationType::
    TimeStamp ()
    {
      return this->TimeStamp_.get ();
    }

    void CalibrationType::
    TimeStamp (const TimeStamp_type& x)
    {
      this->TimeStamp_.set (x);
    }

    void CalibrationType::
    TimeStamp (::std::auto_ptr< TimeStamp_type > x)
    {
      this->TimeStamp_.set (x);
    }


    // CalibrationsType
    // 

    const CalibrationsType::Calibration_sequence& CalibrationsType::
    Calibration () const
    {
      return this->Calibration_;
    }

    CalibrationsType::Calibration_sequence& CalibrationsType::
    Calibration ()
    {
      return this->Calibration_;
    }

    void CalibrationsType::
    Calibration (const Calibration_sequence& s)
    {
      this->Calibration_ = s;
    }


    // TemperaturesType
    // 

    const TemperaturesType::Temperature_sequence& TemperaturesType::
    Temperature () const
    {
      return this->Temperature_;
    }

    TemperaturesType::Temperature_sequence& TemperaturesType::
    Temperature ()
    {
      return this->Temperature_;
    }

    void TemperaturesType::
    Temperature (const Temperature_sequence& s)
    {
      this->Temperature_ = s;
    }


    // TemperatureType
    // 

    const TemperatureType::Attributes_optional& TemperatureType::
    Attributes () const
    {
      return this->Attributes_;
    }

    TemperatureType::Attributes_optional& TemperatureType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void TemperatureType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void TemperatureType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void TemperatureType::
    Attributes (::std::auto_ptr< Attributes_type > x)
    {
      this->Attributes_.set (x);
    }

    const TemperatureType::Temperature_type& TemperatureType::
    Temperature () const
    {
      return this->Temperature_.get ();
    }

    TemperatureType::Temperature_type& TemperatureType::
    Temperature ()
    {
      return this->Temperature_.get ();
    }

    void TemperatureType::
    Temperature (const Temperature_type& x)
    {
      this->Temperature_.set (x);
    }

    void TemperatureType::
    Temperature (::std::auto_ptr< Temperature_type > x)
    {
      this->Temperature_.set (x);
    }

    const TemperatureType::TimeStamp_type& TemperatureType::
    TimeStamp () const
    {
      return this->TimeStamp_.get ();
    }

    TemperatureType::TimeStamp_type& TemperatureType::
    TimeStamp ()
    {
      return this->TimeStamp_.get ();
    }

    void TemperatureType::
    TimeStamp (const TimeStamp_type& x)
    {
      this->TimeStamp_.set (x);
    }

    void TemperatureType::
    TimeStamp (::std::auto_ptr< TimeStamp_type > x)
    {
      this->TimeStamp_.set (x);
    }


    // QualificationsType
    // 

    const QualificationsType::Qualification_sequence& QualificationsType::
    Qualification () const
    {
      return this->Qualification_;
    }

    QualificationsType::Qualification_sequence& QualificationsType::
    Qualification ()
    {
      return this->Qualification_;
    }

    void QualificationsType::
    Qualification (const Qualification_sequence& s)
    {
      this->Qualification_ = s;
    }


    // QualificationType
    // 

    const QualificationType::Attributes_optional& QualificationType::
    Attributes () const
    {
      return this->Attributes_;
    }

    QualificationType::Attributes_optional& QualificationType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void QualificationType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void QualificationType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void QualificationType::
    Attributes (::std::auto_ptr< Attributes_type > x)
    {
      this->Attributes_.set (x);
    }

    const QualificationType::Description_type& QualificationType::
    Description () const
    {
      return this->Description_.get ();
    }

    QualificationType::Description_type& QualificationType::
    Description ()
    {
      return this->Description_.get ();
    }

    void QualificationType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void QualificationType::
    Description (::std::auto_ptr< Description_type > x)
    {
      this->Description_.set (x);
    }


    // SensorType
    // 

    const SensorType::Qualifications_type& SensorType::
    Qualifications () const
    {
      return this->Qualifications_.get ();
    }

    SensorType::Qualifications_type& SensorType::
    Qualifications ()
    {
      return this->Qualifications_.get ();
    }

    void SensorType::
    Qualifications (const Qualifications_type& x)
    {
      this->Qualifications_.set (x);
    }

    void SensorType::
    Qualifications (::std::auto_ptr< Qualifications_type > x)
    {
      this->Qualifications_.set (x);
    }

    const SensorType::AAngle_optional& SensorType::
    AAngle () const
    {
      return this->AAngle_;
    }

    SensorType::AAngle_optional& SensorType::
    AAngle ()
    {
      return this->AAngle_;
    }

    void SensorType::
    AAngle (const AAngle_type& x)
    {
      this->AAngle_.set (x);
    }

    void SensorType::
    AAngle (const AAngle_optional& x)
    {
      this->AAngle_ = x;
    }

    void SensorType::
    AAngle (::std::auto_ptr< AAngle_type > x)
    {
      this->AAngle_.set (x);
    }

    const SensorType::BAngle_optional& SensorType::
    BAngle () const
    {
      return this->BAngle_;
    }

    SensorType::BAngle_optional& SensorType::
    BAngle ()
    {
      return this->BAngle_;
    }

    void SensorType::
    BAngle (const BAngle_type& x)
    {
      this->BAngle_.set (x);
    }

    void SensorType::
    BAngle (const BAngle_optional& x)
    {
      this->BAngle_ = x;
    }

    void SensorType::
    BAngle (::std::auto_ptr< BAngle_type > x)
    {
      this->BAngle_.set (x);
    }


    // TouchProbeType
    // 

    const TouchProbeType::TipDiameter_type& TouchProbeType::
    TipDiameter () const
    {
      return this->TipDiameter_.get ();
    }

    TouchProbeType::TipDiameter_type& TouchProbeType::
    TipDiameter ()
    {
      return this->TipDiameter_.get ();
    }

    void TouchProbeType::
    TipDiameter (const TipDiameter_type& x)
    {
      this->TipDiameter_.set (x);
    }

    void TouchProbeType::
    TipDiameter (::std::auto_ptr< TipDiameter_type > x)
    {
      this->TipDiameter_.set (x);
    }


    // ToolType
    // 

    const ToolType::SensorIds_optional& ToolType::
    SensorIds () const
    {
      return this->SensorIds_;
    }

    ToolType::SensorIds_optional& ToolType::
    SensorIds ()
    {
      return this->SensorIds_;
    }

    void ToolType::
    SensorIds (const SensorIds_type& x)
    {
      this->SensorIds_.set (x);
    }

    void ToolType::
    SensorIds (const SensorIds_optional& x)
    {
      this->SensorIds_ = x;
    }

    void ToolType::
    SensorIds (::std::auto_ptr< SensorIds_type > x)
    {
      this->SensorIds_.set (x);
    }


    // CarriageType
    // 

    const CarriageType::ToolIds_optional& CarriageType::
    ToolIds () const
    {
      return this->ToolIds_;
    }

    CarriageType::ToolIds_optional& CarriageType::
    ToolIds ()
    {
      return this->ToolIds_;
    }

    void CarriageType::
    ToolIds (const ToolIds_type& x)
    {
      this->ToolIds_.set (x);
    }

    void CarriageType::
    ToolIds (const ToolIds_optional& x)
    {
      this->ToolIds_ = x;
    }

    void CarriageType::
    ToolIds (::std::auto_ptr< ToolIds_type > x)
    {
      this->ToolIds_.set (x);
    }


    // ProbingDeviceType
    // 

    const ProbingDeviceType::WorkingVolume_optional& ProbingDeviceType::
    WorkingVolume () const
    {
      return this->WorkingVolume_;
    }

    ProbingDeviceType::WorkingVolume_optional& ProbingDeviceType::
    WorkingVolume ()
    {
      return this->WorkingVolume_;
    }

    void ProbingDeviceType::
    WorkingVolume (const WorkingVolume_type& x)
    {
      this->WorkingVolume_.set (x);
    }

    void ProbingDeviceType::
    WorkingVolume (const WorkingVolume_optional& x)
    {
      this->WorkingVolume_ = x;
    }

    void ProbingDeviceType::
    WorkingVolume (::std::auto_ptr< WorkingVolume_type > x)
    {
      this->WorkingVolume_.set (x);
    }

    const ProbingDeviceType::EffectiveWorkingVolume_optional& ProbingDeviceType::
    EffectiveWorkingVolume () const
    {
      return this->EffectiveWorkingVolume_;
    }

    ProbingDeviceType::EffectiveWorkingVolume_optional& ProbingDeviceType::
    EffectiveWorkingVolume ()
    {
      return this->EffectiveWorkingVolume_;
    }

    void ProbingDeviceType::
    EffectiveWorkingVolume (const EffectiveWorkingVolume_type& x)
    {
      this->EffectiveWorkingVolume_.set (x);
    }

    void ProbingDeviceType::
    EffectiveWorkingVolume (const EffectiveWorkingVolume_optional& x)
    {
      this->EffectiveWorkingVolume_ = x;
    }

    void ProbingDeviceType::
    EffectiveWorkingVolume (::std::auto_ptr< EffectiveWorkingVolume_type > x)
    {
      this->EffectiveWorkingVolume_.set (x);
    }

    const ProbingDeviceType::Resolution_optional& ProbingDeviceType::
    Resolution () const
    {
      return this->Resolution_;
    }

    ProbingDeviceType::Resolution_optional& ProbingDeviceType::
    Resolution ()
    {
      return this->Resolution_;
    }

    void ProbingDeviceType::
    Resolution (const Resolution_type& x)
    {
      this->Resolution_.set (x);
    }

    void ProbingDeviceType::
    Resolution (const Resolution_optional& x)
    {
      this->Resolution_ = x;
    }

    void ProbingDeviceType::
    Resolution (::std::auto_ptr< Resolution_type > x)
    {
      this->Resolution_.set (x);
    }


    // CMMType
    // 

    const CMMType::HomeLocation_optional& CMMType::
    HomeLocation () const
    {
      return this->HomeLocation_;
    }

    CMMType::HomeLocation_optional& CMMType::
    HomeLocation ()
    {
      return this->HomeLocation_;
    }

    void CMMType::
    HomeLocation (const HomeLocation_type& x)
    {
      this->HomeLocation_.set (x);
    }

    void CMMType::
    HomeLocation (const HomeLocation_optional& x)
    {
      this->HomeLocation_ = x;
    }

    void CMMType::
    HomeLocation (::std::auto_ptr< HomeLocation_type > x)
    {
      this->HomeLocation_.set (x);
    }

    const CMMType::MachineGeometry_optional& CMMType::
    MachineGeometry () const
    {
      return this->MachineGeometry_;
    }

    CMMType::MachineGeometry_optional& CMMType::
    MachineGeometry ()
    {
      return this->MachineGeometry_;
    }

    void CMMType::
    MachineGeometry (const MachineGeometry_type& x)
    {
      this->MachineGeometry_.set (x);
    }

    void CMMType::
    MachineGeometry (const MachineGeometry_optional& x)
    {
      this->MachineGeometry_ = x;
    }

    void CMMType::
    MachineGeometry (::std::auto_ptr< MachineGeometry_type > x)
    {
      this->MachineGeometry_.set (x);
    }

    const CMMType::AxisOrientation_optional& CMMType::
    AxisOrientation () const
    {
      return this->AxisOrientation_;
    }

    CMMType::AxisOrientation_optional& CMMType::
    AxisOrientation ()
    {
      return this->AxisOrientation_;
    }

    void CMMType::
    AxisOrientation (const AxisOrientation_type& x)
    {
      this->AxisOrientation_.set (x);
    }

    void CMMType::
    AxisOrientation (const AxisOrientation_optional& x)
    {
      this->AxisOrientation_ = x;
    }

    void CMMType::
    AxisOrientation (::std::auto_ptr< AxisOrientation_type > x)
    {
      this->AxisOrientation_.set (x);
    }

    const CMMType::CMMScales_optional& CMMType::
    CMMScales () const
    {
      return this->CMMScales_;
    }

    CMMType::CMMScales_optional& CMMType::
    CMMScales ()
    {
      return this->CMMScales_;
    }

    void CMMType::
    CMMScales (const CMMScales_type& x)
    {
      this->CMMScales_.set (x);
    }

    void CMMType::
    CMMScales (const CMMScales_optional& x)
    {
      this->CMMScales_ = x;
    }

    void CMMType::
    CMMScales (::std::auto_ptr< CMMScales_type > x)
    {
      this->CMMScales_.set (x);
    }

    const CMMType::MaxWorkpieceHeight_optional& CMMType::
    MaxWorkpieceHeight () const
    {
      return this->MaxWorkpieceHeight_;
    }

    CMMType::MaxWorkpieceHeight_optional& CMMType::
    MaxWorkpieceHeight ()
    {
      return this->MaxWorkpieceHeight_;
    }

    void CMMType::
    MaxWorkpieceHeight (const MaxWorkpieceHeight_type& x)
    {
      this->MaxWorkpieceHeight_.set (x);
    }

    void CMMType::
    MaxWorkpieceHeight (const MaxWorkpieceHeight_optional& x)
    {
      this->MaxWorkpieceHeight_ = x;
    }

    void CMMType::
    MaxWorkpieceHeight (::std::auto_ptr< MaxWorkpieceHeight_type > x)
    {
      this->MaxWorkpieceHeight_.set (x);
    }

    const CMMType::MaxWorkpieceMass_optional& CMMType::
    MaxWorkpieceMass () const
    {
      return this->MaxWorkpieceMass_;
    }

    CMMType::MaxWorkpieceMass_optional& CMMType::
    MaxWorkpieceMass ()
    {
      return this->MaxWorkpieceMass_;
    }

    void CMMType::
    MaxWorkpieceMass (const MaxWorkpieceMass_type& x)
    {
      this->MaxWorkpieceMass_.set (x);
    }

    void CMMType::
    MaxWorkpieceMass (const MaxWorkpieceMass_optional& x)
    {
      this->MaxWorkpieceMass_ = x;
    }

    void CMMType::
    MaxWorkpieceMass (::std::auto_ptr< MaxWorkpieceMass_type > x)
    {
      this->MaxWorkpieceMass_.set (x);
    }

    const CMMType::JoystickSpeeds_optional& CMMType::
    JoystickSpeeds () const
    {
      return this->JoystickSpeeds_;
    }

    CMMType::JoystickSpeeds_optional& CMMType::
    JoystickSpeeds ()
    {
      return this->JoystickSpeeds_;
    }

    void CMMType::
    JoystickSpeeds (const JoystickSpeeds_type& x)
    {
      this->JoystickSpeeds_.set (x);
    }

    void CMMType::
    JoystickSpeeds (const JoystickSpeeds_optional& x)
    {
      this->JoystickSpeeds_ = x;
    }

    void CMMType::
    JoystickSpeeds (::std::auto_ptr< JoystickSpeeds_type > x)
    {
      this->JoystickSpeeds_.set (x);
    }

    const CMMType::CNCSpeeds_optional& CMMType::
    CNCSpeeds () const
    {
      return this->CNCSpeeds_;
    }

    CMMType::CNCSpeeds_optional& CMMType::
    CNCSpeeds ()
    {
      return this->CNCSpeeds_;
    }

    void CMMType::
    CNCSpeeds (const CNCSpeeds_type& x)
    {
      this->CNCSpeeds_.set (x);
    }

    void CMMType::
    CNCSpeeds (const CNCSpeeds_optional& x)
    {
      this->CNCSpeeds_ = x;
    }

    void CMMType::
    CNCSpeeds (::std::auto_ptr< CNCSpeeds_type > x)
    {
      this->CNCSpeeds_.set (x);
    }

    const CMMType::RotaryTable_optional& CMMType::
    RotaryTable () const
    {
      return this->RotaryTable_;
    }

    CMMType::RotaryTable_optional& CMMType::
    RotaryTable ()
    {
      return this->RotaryTable_;
    }

    void CMMType::
    RotaryTable (const RotaryTable_type& x)
    {
      this->RotaryTable_.set (x);
    }

    void CMMType::
    RotaryTable (const RotaryTable_optional& x)
    {
      this->RotaryTable_ = x;
    }

    void CMMType::
    RotaryTable (::std::auto_ptr< RotaryTable_type > x)
    {
      this->RotaryTable_.set (x);
    }

    const CMMType::NominalAccuracy_optional& CMMType::
    NominalAccuracy () const
    {
      return this->NominalAccuracy_;
    }

    CMMType::NominalAccuracy_optional& CMMType::
    NominalAccuracy ()
    {
      return this->NominalAccuracy_;
    }

    void CMMType::
    NominalAccuracy (const NominalAccuracy_type& x)
    {
      this->NominalAccuracy_.set (x);
    }

    void CMMType::
    NominalAccuracy (const NominalAccuracy_optional& x)
    {
      this->NominalAccuracy_ = x;
    }

    void CMMType::
    NominalAccuracy (::std::auto_ptr< NominalAccuracy_type > x)
    {
      this->NominalAccuracy_.set (x);
    }

    const CMMType::ActualAccuracy_optional& CMMType::
    ActualAccuracy () const
    {
      return this->ActualAccuracy_;
    }

    CMMType::ActualAccuracy_optional& CMMType::
    ActualAccuracy ()
    {
      return this->ActualAccuracy_;
    }

    void CMMType::
    ActualAccuracy (const ActualAccuracy_type& x)
    {
      this->ActualAccuracy_.set (x);
    }

    void CMMType::
    ActualAccuracy (const ActualAccuracy_optional& x)
    {
      this->ActualAccuracy_ = x;
    }

    void CMMType::
    ActualAccuracy (::std::auto_ptr< ActualAccuracy_type > x)
    {
      this->ActualAccuracy_.set (x);
    }

    const CMMType::CarriageIds_optional& CMMType::
    CarriageIds () const
    {
      return this->CarriageIds_;
    }

    CMMType::CarriageIds_optional& CMMType::
    CarriageIds ()
    {
      return this->CarriageIds_;
    }

    void CMMType::
    CarriageIds (const CarriageIds_type& x)
    {
      this->CarriageIds_.set (x);
    }

    void CMMType::
    CarriageIds (const CarriageIds_optional& x)
    {
      this->CarriageIds_ = x;
    }

    void CMMType::
    CarriageIds (::std::auto_ptr< CarriageIds_type > x)
    {
      this->CarriageIds_.set (x);
    }

    const CMMType::ToolIds_optional& CMMType::
    ToolIds () const
    {
      return this->ToolIds_;
    }

    CMMType::ToolIds_optional& CMMType::
    ToolIds ()
    {
      return this->ToolIds_;
    }

    void CMMType::
    ToolIds (const ToolIds_type& x)
    {
      this->ToolIds_.set (x);
    }

    void CMMType::
    ToolIds (const ToolIds_optional& x)
    {
      this->ToolIds_ = x;
    }

    void CMMType::
    ToolIds (::std::auto_ptr< ToolIds_type > x)
    {
      this->ToolIds_.set (x);
    }


    // CMMScalesType
    // 

    const CMMScalesType::XScale_type& CMMScalesType::
    XScale () const
    {
      return this->XScale_.get ();
    }

    CMMScalesType::XScale_type& CMMScalesType::
    XScale ()
    {
      return this->XScale_.get ();
    }

    void CMMScalesType::
    XScale (const XScale_type& x)
    {
      this->XScale_.set (x);
    }

    void CMMScalesType::
    XScale (::std::auto_ptr< XScale_type > x)
    {
      this->XScale_.set (x);
    }

    const CMMScalesType::YScale_type& CMMScalesType::
    YScale () const
    {
      return this->YScale_.get ();
    }

    CMMScalesType::YScale_type& CMMScalesType::
    YScale ()
    {
      return this->YScale_.get ();
    }

    void CMMScalesType::
    YScale (const YScale_type& x)
    {
      this->YScale_.set (x);
    }

    void CMMScalesType::
    YScale (::std::auto_ptr< YScale_type > x)
    {
      this->YScale_.set (x);
    }

    const CMMScalesType::ZScale_type& CMMScalesType::
    ZScale () const
    {
      return this->ZScale_.get ();
    }

    CMMScalesType::ZScale_type& CMMScalesType::
    ZScale ()
    {
      return this->ZScale_.get ();
    }

    void CMMScalesType::
    ZScale (const ZScale_type& x)
    {
      this->ZScale_.set (x);
    }

    void CMMScalesType::
    ZScale (::std::auto_ptr< ZScale_type > x)
    {
      this->ZScale_.set (x);
    }


    // CMMScaleType
    // 

    const CMMScaleType::ScaleMaterial_type& CMMScaleType::
    ScaleMaterial () const
    {
      return this->ScaleMaterial_.get ();
    }

    CMMScaleType::ScaleMaterial_type& CMMScaleType::
    ScaleMaterial ()
    {
      return this->ScaleMaterial_.get ();
    }

    void CMMScaleType::
    ScaleMaterial (const ScaleMaterial_type& x)
    {
      this->ScaleMaterial_.set (x);
    }

    void CMMScaleType::
    ScaleMaterial (::std::auto_ptr< ScaleMaterial_type > x)
    {
      this->ScaleMaterial_.set (x);
    }

    const CMMScaleType::ScaleCoefficientOfExpansion_type& CMMScaleType::
    ScaleCoefficientOfExpansion () const
    {
      return this->ScaleCoefficientOfExpansion_.get ();
    }

    CMMScaleType::ScaleCoefficientOfExpansion_type& CMMScaleType::
    ScaleCoefficientOfExpansion ()
    {
      return this->ScaleCoefficientOfExpansion_.get ();
    }

    void CMMScaleType::
    ScaleCoefficientOfExpansion (const ScaleCoefficientOfExpansion_type& x)
    {
      this->ScaleCoefficientOfExpansion_.set (x);
    }

    const CMMScaleType::ScaleCoefficientOfExpansionUncertainty_type& CMMScaleType::
    ScaleCoefficientOfExpansionUncertainty () const
    {
      return this->ScaleCoefficientOfExpansionUncertainty_.get ();
    }

    CMMScaleType::ScaleCoefficientOfExpansionUncertainty_type& CMMScaleType::
    ScaleCoefficientOfExpansionUncertainty ()
    {
      return this->ScaleCoefficientOfExpansionUncertainty_.get ();
    }

    void CMMScaleType::
    ScaleCoefficientOfExpansionUncertainty (const ScaleCoefficientOfExpansionUncertainty_type& x)
    {
      this->ScaleCoefficientOfExpansionUncertainty_.set (x);
    }

    const CMMScaleType::TypeOfScale_type& CMMScaleType::
    TypeOfScale () const
    {
      return this->TypeOfScale_.get ();
    }

    CMMScaleType::TypeOfScale_type& CMMScaleType::
    TypeOfScale ()
    {
      return this->TypeOfScale_.get ();
    }

    void CMMScaleType::
    TypeOfScale (const TypeOfScale_type& x)
    {
      this->TypeOfScale_.set (x);
    }

    void CMMScaleType::
    TypeOfScale (::std::auto_ptr< TypeOfScale_type > x)
    {
      this->TypeOfScale_.set (x);
    }

    const CMMScaleType::ScaleResolution_type& CMMScaleType::
    ScaleResolution () const
    {
      return this->ScaleResolution_.get ();
    }

    CMMScaleType::ScaleResolution_type& CMMScaleType::
    ScaleResolution ()
    {
      return this->ScaleResolution_.get ();
    }

    void CMMScaleType::
    ScaleResolution (const ScaleResolution_type& x)
    {
      this->ScaleResolution_.set (x);
    }

    void CMMScaleType::
    ScaleResolution (::std::auto_ptr< ScaleResolution_type > x)
    {
      this->ScaleResolution_.set (x);
    }


    // CMMSpeedsType
    // 

    const CMMSpeedsType::MaxXTraverseSpeed_type& CMMSpeedsType::
    MaxXTraverseSpeed () const
    {
      return this->MaxXTraverseSpeed_.get ();
    }

    CMMSpeedsType::MaxXTraverseSpeed_type& CMMSpeedsType::
    MaxXTraverseSpeed ()
    {
      return this->MaxXTraverseSpeed_.get ();
    }

    void CMMSpeedsType::
    MaxXTraverseSpeed (const MaxXTraverseSpeed_type& x)
    {
      this->MaxXTraverseSpeed_.set (x);
    }

    void CMMSpeedsType::
    MaxXTraverseSpeed (::std::auto_ptr< MaxXTraverseSpeed_type > x)
    {
      this->MaxXTraverseSpeed_.set (x);
    }

    const CMMSpeedsType::MaxYTraverseSpeed_type& CMMSpeedsType::
    MaxYTraverseSpeed () const
    {
      return this->MaxYTraverseSpeed_.get ();
    }

    CMMSpeedsType::MaxYTraverseSpeed_type& CMMSpeedsType::
    MaxYTraverseSpeed ()
    {
      return this->MaxYTraverseSpeed_.get ();
    }

    void CMMSpeedsType::
    MaxYTraverseSpeed (const MaxYTraverseSpeed_type& x)
    {
      this->MaxYTraverseSpeed_.set (x);
    }

    void CMMSpeedsType::
    MaxYTraverseSpeed (::std::auto_ptr< MaxYTraverseSpeed_type > x)
    {
      this->MaxYTraverseSpeed_.set (x);
    }

    const CMMSpeedsType::MaxZTraverseSpeed_type& CMMSpeedsType::
    MaxZTraverseSpeed () const
    {
      return this->MaxZTraverseSpeed_.get ();
    }

    CMMSpeedsType::MaxZTraverseSpeed_type& CMMSpeedsType::
    MaxZTraverseSpeed ()
    {
      return this->MaxZTraverseSpeed_.get ();
    }

    void CMMSpeedsType::
    MaxZTraverseSpeed (const MaxZTraverseSpeed_type& x)
    {
      this->MaxZTraverseSpeed_.set (x);
    }

    void CMMSpeedsType::
    MaxZTraverseSpeed (::std::auto_ptr< MaxZTraverseSpeed_type > x)
    {
      this->MaxZTraverseSpeed_.set (x);
    }

    const CMMSpeedsType::MaxXProbingSpeed_type& CMMSpeedsType::
    MaxXProbingSpeed () const
    {
      return this->MaxXProbingSpeed_.get ();
    }

    CMMSpeedsType::MaxXProbingSpeed_type& CMMSpeedsType::
    MaxXProbingSpeed ()
    {
      return this->MaxXProbingSpeed_.get ();
    }

    void CMMSpeedsType::
    MaxXProbingSpeed (const MaxXProbingSpeed_type& x)
    {
      this->MaxXProbingSpeed_.set (x);
    }

    void CMMSpeedsType::
    MaxXProbingSpeed (::std::auto_ptr< MaxXProbingSpeed_type > x)
    {
      this->MaxXProbingSpeed_.set (x);
    }

    const CMMSpeedsType::MaxYProbingSpeed_type& CMMSpeedsType::
    MaxYProbingSpeed () const
    {
      return this->MaxYProbingSpeed_.get ();
    }

    CMMSpeedsType::MaxYProbingSpeed_type& CMMSpeedsType::
    MaxYProbingSpeed ()
    {
      return this->MaxYProbingSpeed_.get ();
    }

    void CMMSpeedsType::
    MaxYProbingSpeed (const MaxYProbingSpeed_type& x)
    {
      this->MaxYProbingSpeed_.set (x);
    }

    void CMMSpeedsType::
    MaxYProbingSpeed (::std::auto_ptr< MaxYProbingSpeed_type > x)
    {
      this->MaxYProbingSpeed_.set (x);
    }

    const CMMSpeedsType::MaxZProbingSpeed_type& CMMSpeedsType::
    MaxZProbingSpeed () const
    {
      return this->MaxZProbingSpeed_.get ();
    }

    CMMSpeedsType::MaxZProbingSpeed_type& CMMSpeedsType::
    MaxZProbingSpeed ()
    {
      return this->MaxZProbingSpeed_.get ();
    }

    void CMMSpeedsType::
    MaxZProbingSpeed (const MaxZProbingSpeed_type& x)
    {
      this->MaxZProbingSpeed_.set (x);
    }

    void CMMSpeedsType::
    MaxZProbingSpeed (::std::auto_ptr< MaxZProbingSpeed_type > x)
    {
      this->MaxZProbingSpeed_.set (x);
    }


    // GageDeviceType
    // 


    // ManualDeviceType
    // 


    // CaliperType
    // 

    const CaliperType::Resolution_optional& CaliperType::
    Resolution () const
    {
      return this->Resolution_;
    }

    CaliperType::Resolution_optional& CaliperType::
    Resolution ()
    {
      return this->Resolution_;
    }

    void CaliperType::
    Resolution (const Resolution_type& x)
    {
      this->Resolution_.set (x);
    }

    void CaliperType::
    Resolution (const Resolution_optional& x)
    {
      this->Resolution_ = x;
    }

    void CaliperType::
    Resolution (::std::auto_ptr< Resolution_type > x)
    {
      this->Resolution_.set (x);
    }

    const CaliperType::Accuracy_optional& CaliperType::
    Accuracy () const
    {
      return this->Accuracy_;
    }

    CaliperType::Accuracy_optional& CaliperType::
    Accuracy ()
    {
      return this->Accuracy_;
    }

    void CaliperType::
    Accuracy (const Accuracy_type& x)
    {
      this->Accuracy_.set (x);
    }

    void CaliperType::
    Accuracy (const Accuracy_optional& x)
    {
      this->Accuracy_ = x;
    }

    void CaliperType::
    Accuracy (::std::auto_ptr< Accuracy_type > x)
    {
      this->Accuracy_.set (x);
    }

    const CaliperType::MinMeasurement_optional& CaliperType::
    MinMeasurement () const
    {
      return this->MinMeasurement_;
    }

    CaliperType::MinMeasurement_optional& CaliperType::
    MinMeasurement ()
    {
      return this->MinMeasurement_;
    }

    void CaliperType::
    MinMeasurement (const MinMeasurement_type& x)
    {
      this->MinMeasurement_.set (x);
    }

    void CaliperType::
    MinMeasurement (const MinMeasurement_optional& x)
    {
      this->MinMeasurement_ = x;
    }

    void CaliperType::
    MinMeasurement (::std::auto_ptr< MinMeasurement_type > x)
    {
      this->MinMeasurement_.set (x);
    }

    const CaliperType::MaxMeasurement_optional& CaliperType::
    MaxMeasurement () const
    {
      return this->MaxMeasurement_;
    }

    CaliperType::MaxMeasurement_optional& CaliperType::
    MaxMeasurement ()
    {
      return this->MaxMeasurement_;
    }

    void CaliperType::
    MaxMeasurement (const MaxMeasurement_type& x)
    {
      this->MaxMeasurement_.set (x);
    }

    void CaliperType::
    MaxMeasurement (const MaxMeasurement_optional& x)
    {
      this->MaxMeasurement_ = x;
    }

    void CaliperType::
    MaxMeasurement (::std::auto_ptr< MaxMeasurement_type > x)
    {
      this->MaxMeasurement_.set (x);
    }

    const CaliperType::CanMeasureInnerD_optional& CaliperType::
    CanMeasureInnerD () const
    {
      return this->CanMeasureInnerD_;
    }

    CaliperType::CanMeasureInnerD_optional& CaliperType::
    CanMeasureInnerD ()
    {
      return this->CanMeasureInnerD_;
    }

    void CaliperType::
    CanMeasureInnerD (const CanMeasureInnerD_type& x)
    {
      this->CanMeasureInnerD_.set (x);
    }

    void CaliperType::
    CanMeasureInnerD (const CanMeasureInnerD_optional& x)
    {
      this->CanMeasureInnerD_ = x;
    }

    const CaliperType::CanMeasureOuterD_optional& CaliperType::
    CanMeasureOuterD () const
    {
      return this->CanMeasureOuterD_;
    }

    CaliperType::CanMeasureOuterD_optional& CaliperType::
    CanMeasureOuterD ()
    {
      return this->CanMeasureOuterD_;
    }

    void CaliperType::
    CanMeasureOuterD (const CanMeasureOuterD_type& x)
    {
      this->CanMeasureOuterD_.set (x);
    }

    void CaliperType::
    CanMeasureOuterD (const CanMeasureOuterD_optional& x)
    {
      this->CanMeasureOuterD_ = x;
    }

    const CaliperType::CanMeasureDepth_optional& CaliperType::
    CanMeasureDepth () const
    {
      return this->CanMeasureDepth_;
    }

    CaliperType::CanMeasureDepth_optional& CaliperType::
    CanMeasureDepth ()
    {
      return this->CanMeasureDepth_;
    }

    void CaliperType::
    CanMeasureDepth (const CanMeasureDepth_type& x)
    {
      this->CanMeasureDepth_.set (x);
    }

    void CaliperType::
    CanMeasureDepth (const CanMeasureDepth_optional& x)
    {
      this->CanMeasureDepth_ = x;
    }


    // CMMDirectionEnumType
    // 

    CMMDirectionEnumType::
    CMMDirectionEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_CMMDirectionEnumType_literals_[v])
    {
    }

    CMMDirectionEnumType::
    CMMDirectionEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CMMDirectionEnumType::
    CMMDirectionEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CMMDirectionEnumType::
    CMMDirectionEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CMMDirectionEnumType::
    CMMDirectionEnumType (const CMMDirectionEnumType& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    CMMDirectionEnumType& CMMDirectionEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_CMMDirectionEnumType_literals_[v]);

      return *this;
    }


    // CMMGeometryType
    // 

    const CMMGeometryType::CMMGeometryEnum_optional& CMMGeometryType::
    CMMGeometryEnum () const
    {
      return this->CMMGeometryEnum_;
    }

    CMMGeometryType::CMMGeometryEnum_optional& CMMGeometryType::
    CMMGeometryEnum ()
    {
      return this->CMMGeometryEnum_;
    }

    void CMMGeometryType::
    CMMGeometryEnum (const CMMGeometryEnum_type& x)
    {
      this->CMMGeometryEnum_.set (x);
    }

    void CMMGeometryType::
    CMMGeometryEnum (const CMMGeometryEnum_optional& x)
    {
      this->CMMGeometryEnum_ = x;
    }

    void CMMGeometryType::
    CMMGeometryEnum (::std::auto_ptr< CMMGeometryEnum_type > x)
    {
      this->CMMGeometryEnum_.set (x);
    }

    const CMMGeometryType::OtherCMMGeometry_optional& CMMGeometryType::
    OtherCMMGeometry () const
    {
      return this->OtherCMMGeometry_;
    }

    CMMGeometryType::OtherCMMGeometry_optional& CMMGeometryType::
    OtherCMMGeometry ()
    {
      return this->OtherCMMGeometry_;
    }

    void CMMGeometryType::
    OtherCMMGeometry (const OtherCMMGeometry_type& x)
    {
      this->OtherCMMGeometry_.set (x);
    }

    void CMMGeometryType::
    OtherCMMGeometry (const OtherCMMGeometry_optional& x)
    {
      this->OtherCMMGeometry_ = x;
    }

    void CMMGeometryType::
    OtherCMMGeometry (::std::auto_ptr< OtherCMMGeometry_type > x)
    {
      this->OtherCMMGeometry_.set (x);
    }


    // CMMGeometryEnumType
    // 

    CMMGeometryEnumType::
    CMMGeometryEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_CMMGeometryEnumType_literals_[v])
    {
    }

    CMMGeometryEnumType::
    CMMGeometryEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CMMGeometryEnumType::
    CMMGeometryEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CMMGeometryEnumType::
    CMMGeometryEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CMMGeometryEnumType::
    CMMGeometryEnumType (const CMMGeometryEnumType& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    CMMGeometryEnumType& CMMGeometryEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_CMMGeometryEnumType_literals_[v]);

      return *this;
    }


    // CMMAxisDirectionsType
    // 

    const CMMAxisDirectionsType::XAxisDirection_type& CMMAxisDirectionsType::
    XAxisDirection () const
    {
      return this->XAxisDirection_.get ();
    }

    CMMAxisDirectionsType::XAxisDirection_type& CMMAxisDirectionsType::
    XAxisDirection ()
    {
      return this->XAxisDirection_.get ();
    }

    void CMMAxisDirectionsType::
    XAxisDirection (const XAxisDirection_type& x)
    {
      this->XAxisDirection_.set (x);
    }

    void CMMAxisDirectionsType::
    XAxisDirection (::std::auto_ptr< XAxisDirection_type > x)
    {
      this->XAxisDirection_.set (x);
    }

    const CMMAxisDirectionsType::YAxisDirection_type& CMMAxisDirectionsType::
    YAxisDirection () const
    {
      return this->YAxisDirection_.get ();
    }

    CMMAxisDirectionsType::YAxisDirection_type& CMMAxisDirectionsType::
    YAxisDirection ()
    {
      return this->YAxisDirection_.get ();
    }

    void CMMAxisDirectionsType::
    YAxisDirection (const YAxisDirection_type& x)
    {
      this->YAxisDirection_.set (x);
    }

    void CMMAxisDirectionsType::
    YAxisDirection (::std::auto_ptr< YAxisDirection_type > x)
    {
      this->YAxisDirection_.set (x);
    }

    const CMMAxisDirectionsType::ZAxisDirection_type& CMMAxisDirectionsType::
    ZAxisDirection () const
    {
      return this->ZAxisDirection_.get ();
    }

    CMMAxisDirectionsType::ZAxisDirection_type& CMMAxisDirectionsType::
    ZAxisDirection ()
    {
      return this->ZAxisDirection_.get ();
    }

    void CMMAxisDirectionsType::
    ZAxisDirection (const ZAxisDirection_type& x)
    {
      this->ZAxisDirection_.set (x);
    }

    void CMMAxisDirectionsType::
    ZAxisDirection (::std::auto_ptr< ZAxisDirection_type > x)
    {
      this->ZAxisDirection_.set (x);
    }


    // WorkingVolumeType
    // 

    const WorkingVolumeType::XAxisLength_type& WorkingVolumeType::
    XAxisLength () const
    {
      return this->XAxisLength_.get ();
    }

    WorkingVolumeType::XAxisLength_type& WorkingVolumeType::
    XAxisLength ()
    {
      return this->XAxisLength_.get ();
    }

    void WorkingVolumeType::
    XAxisLength (const XAxisLength_type& x)
    {
      this->XAxisLength_.set (x);
    }

    void WorkingVolumeType::
    XAxisLength (::std::auto_ptr< XAxisLength_type > x)
    {
      this->XAxisLength_.set (x);
    }

    const WorkingVolumeType::YAxisLength_type& WorkingVolumeType::
    YAxisLength () const
    {
      return this->YAxisLength_.get ();
    }

    WorkingVolumeType::YAxisLength_type& WorkingVolumeType::
    YAxisLength ()
    {
      return this->YAxisLength_.get ();
    }

    void WorkingVolumeType::
    YAxisLength (const YAxisLength_type& x)
    {
      this->YAxisLength_.set (x);
    }

    void WorkingVolumeType::
    YAxisLength (::std::auto_ptr< YAxisLength_type > x)
    {
      this->YAxisLength_.set (x);
    }

    const WorkingVolumeType::ZAxisLength_type& WorkingVolumeType::
    ZAxisLength () const
    {
      return this->ZAxisLength_.get ();
    }

    WorkingVolumeType::ZAxisLength_type& WorkingVolumeType::
    ZAxisLength ()
    {
      return this->ZAxisLength_.get ();
    }

    void WorkingVolumeType::
    ZAxisLength (const ZAxisLength_type& x)
    {
      this->ZAxisLength_.set (x);
    }

    void WorkingVolumeType::
    ZAxisLength (::std::auto_ptr< ZAxisLength_type > x)
    {
      this->ZAxisLength_.set (x);
    }


    // EffectiveWorkingVolumeType
    // 

    const EffectiveWorkingVolumeType::MinPoint_type& EffectiveWorkingVolumeType::
    MinPoint () const
    {
      return this->MinPoint_.get ();
    }

    EffectiveWorkingVolumeType::MinPoint_type& EffectiveWorkingVolumeType::
    MinPoint ()
    {
      return this->MinPoint_.get ();
    }

    void EffectiveWorkingVolumeType::
    MinPoint (const MinPoint_type& x)
    {
      this->MinPoint_.set (x);
    }

    void EffectiveWorkingVolumeType::
    MinPoint (::std::auto_ptr< MinPoint_type > x)
    {
      this->MinPoint_.set (x);
    }

    const EffectiveWorkingVolumeType::MaxPoint_type& EffectiveWorkingVolumeType::
    MaxPoint () const
    {
      return this->MaxPoint_.get ();
    }

    EffectiveWorkingVolumeType::MaxPoint_type& EffectiveWorkingVolumeType::
    MaxPoint ()
    {
      return this->MaxPoint_.get ();
    }

    void EffectiveWorkingVolumeType::
    MaxPoint (const MaxPoint_type& x)
    {
      this->MaxPoint_.set (x);
    }

    void EffectiveWorkingVolumeType::
    MaxPoint (::std::auto_ptr< MaxPoint_type > x)
    {
      this->MaxPoint_.set (x);
    }


    // RotaryTableType
    // 

    const RotaryTableType::LocationOnCMM_type& RotaryTableType::
    LocationOnCMM () const
    {
      return this->LocationOnCMM_.get ();
    }

    RotaryTableType::LocationOnCMM_type& RotaryTableType::
    LocationOnCMM ()
    {
      return this->LocationOnCMM_.get ();
    }

    void RotaryTableType::
    LocationOnCMM (const LocationOnCMM_type& x)
    {
      this->LocationOnCMM_.set (x);
    }

    void RotaryTableType::
    LocationOnCMM (::std::auto_ptr< LocationOnCMM_type > x)
    {
      this->LocationOnCMM_.set (x);
    }

    const RotaryTableType::AxisDirection_type& RotaryTableType::
    AxisDirection () const
    {
      return this->AxisDirection_.get ();
    }

    RotaryTableType::AxisDirection_type& RotaryTableType::
    AxisDirection ()
    {
      return this->AxisDirection_.get ();
    }

    void RotaryTableType::
    AxisDirection (const AxisDirection_type& x)
    {
      this->AxisDirection_.set (x);
    }

    void RotaryTableType::
    AxisDirection (::std::auto_ptr< AxisDirection_type > x)
    {
      this->AxisDirection_.set (x);
    }

    const RotaryTableType::ZeroIndexDirection_type& RotaryTableType::
    ZeroIndexDirection () const
    {
      return this->ZeroIndexDirection_.get ();
    }

    RotaryTableType::ZeroIndexDirection_type& RotaryTableType::
    ZeroIndexDirection ()
    {
      return this->ZeroIndexDirection_.get ();
    }

    void RotaryTableType::
    ZeroIndexDirection (const ZeroIndexDirection_type& x)
    {
      this->ZeroIndexDirection_.set (x);
    }

    void RotaryTableType::
    ZeroIndexDirection (::std::auto_ptr< ZeroIndexDirection_type > x)
    {
      this->ZeroIndexDirection_.set (x);
    }

    const RotaryTableType::TableRadius_type& RotaryTableType::
    TableRadius () const
    {
      return this->TableRadius_.get ();
    }

    RotaryTableType::TableRadius_type& RotaryTableType::
    TableRadius ()
    {
      return this->TableRadius_.get ();
    }

    void RotaryTableType::
    TableRadius (const TableRadius_type& x)
    {
      this->TableRadius_.set (x);
    }

    void RotaryTableType::
    TableRadius (::std::auto_ptr< TableRadius_type > x)
    {
      this->TableRadius_.set (x);
    }

    const RotaryTableType::TableErrors_type& RotaryTableType::
    TableErrors () const
    {
      return this->TableErrors_.get ();
    }

    RotaryTableType::TableErrors_type& RotaryTableType::
    TableErrors ()
    {
      return this->TableErrors_.get ();
    }

    void RotaryTableType::
    TableErrors (const TableErrors_type& x)
    {
      this->TableErrors_.set (x);
    }

    void RotaryTableType::
    TableErrors (::std::auto_ptr< TableErrors_type > x)
    {
      this->TableErrors_.set (x);
    }


    // TableErrorsType
    // 

    const TableErrorsType::AxialError_type& TableErrorsType::
    AxialError () const
    {
      return this->AxialError_.get ();
    }

    TableErrorsType::AxialError_type& TableErrorsType::
    AxialError ()
    {
      return this->AxialError_.get ();
    }

    void TableErrorsType::
    AxialError (const AxialError_type& x)
    {
      this->AxialError_.set (x);
    }

    void TableErrorsType::
    AxialError (::std::auto_ptr< AxialError_type > x)
    {
      this->AxialError_.set (x);
    }

    const TableErrorsType::RadialError_type& TableErrorsType::
    RadialError () const
    {
      return this->RadialError_.get ();
    }

    TableErrorsType::RadialError_type& TableErrorsType::
    RadialError ()
    {
      return this->RadialError_.get ();
    }

    void TableErrorsType::
    RadialError (const RadialError_type& x)
    {
      this->RadialError_.set (x);
    }

    void TableErrorsType::
    RadialError (::std::auto_ptr< RadialError_type > x)
    {
      this->RadialError_.set (x);
    }

    const TableErrorsType::TangentialError_type& TableErrorsType::
    TangentialError () const
    {
      return this->TangentialError_.get ();
    }

    TableErrorsType::TangentialError_type& TableErrorsType::
    TangentialError ()
    {
      return this->TangentialError_.get ();
    }

    void TableErrorsType::
    TangentialError (const TangentialError_type& x)
    {
      this->TangentialError_.set (x);
    }

    void TableErrorsType::
    TangentialError (::std::auto_ptr< TangentialError_type > x)
    {
      this->TangentialError_.set (x);
    }


    // ResolutionType
    // 

    const ResolutionType::CombinedResolution_optional& ResolutionType::
    CombinedResolution () const
    {
      return this->CombinedResolution_;
    }

    ResolutionType::CombinedResolution_optional& ResolutionType::
    CombinedResolution ()
    {
      return this->CombinedResolution_;
    }

    void ResolutionType::
    CombinedResolution (const CombinedResolution_type& x)
    {
      this->CombinedResolution_.set (x);
    }

    void ResolutionType::
    CombinedResolution (const CombinedResolution_optional& x)
    {
      this->CombinedResolution_ = x;
    }

    void ResolutionType::
    CombinedResolution (::std::auto_ptr< CombinedResolution_type > x)
    {
      this->CombinedResolution_.set (x);
    }

    const ResolutionType::XYZResolution_optional& ResolutionType::
    XYZResolution () const
    {
      return this->XYZResolution_;
    }

    ResolutionType::XYZResolution_optional& ResolutionType::
    XYZResolution ()
    {
      return this->XYZResolution_;
    }

    void ResolutionType::
    XYZResolution (const XYZResolution_type& x)
    {
      this->XYZResolution_.set (x);
    }

    void ResolutionType::
    XYZResolution (const XYZResolution_optional& x)
    {
      this->XYZResolution_ = x;
    }

    void ResolutionType::
    XYZResolution (::std::auto_ptr< XYZResolution_type > x)
    {
      this->XYZResolution_.set (x);
    }


    // XYZResolutionType
    // 

    const XYZResolutionType::XResolution_type& XYZResolutionType::
    XResolution () const
    {
      return this->XResolution_.get ();
    }

    XYZResolutionType::XResolution_type& XYZResolutionType::
    XResolution ()
    {
      return this->XResolution_.get ();
    }

    void XYZResolutionType::
    XResolution (const XResolution_type& x)
    {
      this->XResolution_.set (x);
    }

    void XYZResolutionType::
    XResolution (::std::auto_ptr< XResolution_type > x)
    {
      this->XResolution_.set (x);
    }

    const XYZResolutionType::YResolution_type& XYZResolutionType::
    YResolution () const
    {
      return this->YResolution_.get ();
    }

    XYZResolutionType::YResolution_type& XYZResolutionType::
    YResolution ()
    {
      return this->YResolution_.get ();
    }

    void XYZResolutionType::
    YResolution (const YResolution_type& x)
    {
      this->YResolution_.set (x);
    }

    void XYZResolutionType::
    YResolution (::std::auto_ptr< YResolution_type > x)
    {
      this->YResolution_.set (x);
    }

    const XYZResolutionType::ZResolution_type& XYZResolutionType::
    ZResolution () const
    {
      return this->ZResolution_.get ();
    }

    XYZResolutionType::ZResolution_type& XYZResolutionType::
    ZResolution ()
    {
      return this->ZResolution_.get ();
    }

    void XYZResolutionType::
    ZResolution (const ZResolution_type& x)
    {
      this->ZResolution_.set (x);
    }

    void XYZResolutionType::
    ZResolution (::std::auto_ptr< ZResolution_type > x)
    {
      this->ZResolution_.set (x);
    }


    // CMMAccuracyTestBaseType
    // 


    // FPSTestType
    // 

    const FPSTestType::XLinearity_type& FPSTestType::
    XLinearity () const
    {
      return this->XLinearity_.get ();
    }

    FPSTestType::XLinearity_type& FPSTestType::
    XLinearity ()
    {
      return this->XLinearity_.get ();
    }

    void FPSTestType::
    XLinearity (const XLinearity_type& x)
    {
      this->XLinearity_.set (x);
    }

    void FPSTestType::
    XLinearity (::std::auto_ptr< XLinearity_type > x)
    {
      this->XLinearity_.set (x);
    }

    const FPSTestType::YLinearity_type& FPSTestType::
    YLinearity () const
    {
      return this->YLinearity_.get ();
    }

    FPSTestType::YLinearity_type& FPSTestType::
    YLinearity ()
    {
      return this->YLinearity_.get ();
    }

    void FPSTestType::
    YLinearity (const YLinearity_type& x)
    {
      this->YLinearity_.set (x);
    }

    void FPSTestType::
    YLinearity (::std::auto_ptr< YLinearity_type > x)
    {
      this->YLinearity_.set (x);
    }

    const FPSTestType::ZLinearity_type& FPSTestType::
    ZLinearity () const
    {
      return this->ZLinearity_.get ();
    }

    FPSTestType::ZLinearity_type& FPSTestType::
    ZLinearity ()
    {
      return this->ZLinearity_.get ();
    }

    void FPSTestType::
    ZLinearity (const ZLinearity_type& x)
    {
      this->ZLinearity_.set (x);
    }

    void FPSTestType::
    ZLinearity (::std::auto_ptr< ZLinearity_type > x)
    {
      this->ZLinearity_.set (x);
    }

    const FPSTestType::XAxisRoll_type& FPSTestType::
    XAxisRoll () const
    {
      return this->XAxisRoll_.get ();
    }

    FPSTestType::XAxisRoll_type& FPSTestType::
    XAxisRoll ()
    {
      return this->XAxisRoll_.get ();
    }

    void FPSTestType::
    XAxisRoll (const XAxisRoll_type& x)
    {
      this->XAxisRoll_.set (x);
    }

    void FPSTestType::
    XAxisRoll (::std::auto_ptr< XAxisRoll_type > x)
    {
      this->XAxisRoll_.set (x);
    }

    const FPSTestType::XAxisPitch_type& FPSTestType::
    XAxisPitch () const
    {
      return this->XAxisPitch_.get ();
    }

    FPSTestType::XAxisPitch_type& FPSTestType::
    XAxisPitch ()
    {
      return this->XAxisPitch_.get ();
    }

    void FPSTestType::
    XAxisPitch (const XAxisPitch_type& x)
    {
      this->XAxisPitch_.set (x);
    }

    void FPSTestType::
    XAxisPitch (::std::auto_ptr< XAxisPitch_type > x)
    {
      this->XAxisPitch_.set (x);
    }

    const FPSTestType::XAxisYaw_type& FPSTestType::
    XAxisYaw () const
    {
      return this->XAxisYaw_.get ();
    }

    FPSTestType::XAxisYaw_type& FPSTestType::
    XAxisYaw ()
    {
      return this->XAxisYaw_.get ();
    }

    void FPSTestType::
    XAxisYaw (const XAxisYaw_type& x)
    {
      this->XAxisYaw_.set (x);
    }

    void FPSTestType::
    XAxisYaw (::std::auto_ptr< XAxisYaw_type > x)
    {
      this->XAxisYaw_.set (x);
    }

    const FPSTestType::YAxisRoll_type& FPSTestType::
    YAxisRoll () const
    {
      return this->YAxisRoll_.get ();
    }

    FPSTestType::YAxisRoll_type& FPSTestType::
    YAxisRoll ()
    {
      return this->YAxisRoll_.get ();
    }

    void FPSTestType::
    YAxisRoll (const YAxisRoll_type& x)
    {
      this->YAxisRoll_.set (x);
    }

    void FPSTestType::
    YAxisRoll (::std::auto_ptr< YAxisRoll_type > x)
    {
      this->YAxisRoll_.set (x);
    }

    const FPSTestType::YAxisPitch_type& FPSTestType::
    YAxisPitch () const
    {
      return this->YAxisPitch_.get ();
    }

    FPSTestType::YAxisPitch_type& FPSTestType::
    YAxisPitch ()
    {
      return this->YAxisPitch_.get ();
    }

    void FPSTestType::
    YAxisPitch (const YAxisPitch_type& x)
    {
      this->YAxisPitch_.set (x);
    }

    void FPSTestType::
    YAxisPitch (::std::auto_ptr< YAxisPitch_type > x)
    {
      this->YAxisPitch_.set (x);
    }

    const FPSTestType::YAxisYaw_type& FPSTestType::
    YAxisYaw () const
    {
      return this->YAxisYaw_.get ();
    }

    FPSTestType::YAxisYaw_type& FPSTestType::
    YAxisYaw ()
    {
      return this->YAxisYaw_.get ();
    }

    void FPSTestType::
    YAxisYaw (const YAxisYaw_type& x)
    {
      this->YAxisYaw_.set (x);
    }

    void FPSTestType::
    YAxisYaw (::std::auto_ptr< YAxisYaw_type > x)
    {
      this->YAxisYaw_.set (x);
    }

    const FPSTestType::ZAxisRoll_type& FPSTestType::
    ZAxisRoll () const
    {
      return this->ZAxisRoll_.get ();
    }

    FPSTestType::ZAxisRoll_type& FPSTestType::
    ZAxisRoll ()
    {
      return this->ZAxisRoll_.get ();
    }

    void FPSTestType::
    ZAxisRoll (const ZAxisRoll_type& x)
    {
      this->ZAxisRoll_.set (x);
    }

    void FPSTestType::
    ZAxisRoll (::std::auto_ptr< ZAxisRoll_type > x)
    {
      this->ZAxisRoll_.set (x);
    }

    const FPSTestType::ZAxisPitch_type& FPSTestType::
    ZAxisPitch () const
    {
      return this->ZAxisPitch_.get ();
    }

    FPSTestType::ZAxisPitch_type& FPSTestType::
    ZAxisPitch ()
    {
      return this->ZAxisPitch_.get ();
    }

    void FPSTestType::
    ZAxisPitch (const ZAxisPitch_type& x)
    {
      this->ZAxisPitch_.set (x);
    }

    void FPSTestType::
    ZAxisPitch (::std::auto_ptr< ZAxisPitch_type > x)
    {
      this->ZAxisPitch_.set (x);
    }

    const FPSTestType::ZAxisYaw_type& FPSTestType::
    ZAxisYaw () const
    {
      return this->ZAxisYaw_.get ();
    }

    FPSTestType::ZAxisYaw_type& FPSTestType::
    ZAxisYaw ()
    {
      return this->ZAxisYaw_.get ();
    }

    void FPSTestType::
    ZAxisYaw (const ZAxisYaw_type& x)
    {
      this->ZAxisYaw_.set (x);
    }

    void FPSTestType::
    ZAxisYaw (::std::auto_ptr< ZAxisYaw_type > x)
    {
      this->ZAxisYaw_.set (x);
    }

    const FPSTestType::XAxisStraightnessY_type& FPSTestType::
    XAxisStraightnessY () const
    {
      return this->XAxisStraightnessY_.get ();
    }

    FPSTestType::XAxisStraightnessY_type& FPSTestType::
    XAxisStraightnessY ()
    {
      return this->XAxisStraightnessY_.get ();
    }

    void FPSTestType::
    XAxisStraightnessY (const XAxisStraightnessY_type& x)
    {
      this->XAxisStraightnessY_.set (x);
    }

    void FPSTestType::
    XAxisStraightnessY (::std::auto_ptr< XAxisStraightnessY_type > x)
    {
      this->XAxisStraightnessY_.set (x);
    }

    const FPSTestType::XAxisStraightnessZ_type& FPSTestType::
    XAxisStraightnessZ () const
    {
      return this->XAxisStraightnessZ_.get ();
    }

    FPSTestType::XAxisStraightnessZ_type& FPSTestType::
    XAxisStraightnessZ ()
    {
      return this->XAxisStraightnessZ_.get ();
    }

    void FPSTestType::
    XAxisStraightnessZ (const XAxisStraightnessZ_type& x)
    {
      this->XAxisStraightnessZ_.set (x);
    }

    void FPSTestType::
    XAxisStraightnessZ (::std::auto_ptr< XAxisStraightnessZ_type > x)
    {
      this->XAxisStraightnessZ_.set (x);
    }

    const FPSTestType::YAxisStraightnessX_type& FPSTestType::
    YAxisStraightnessX () const
    {
      return this->YAxisStraightnessX_.get ();
    }

    FPSTestType::YAxisStraightnessX_type& FPSTestType::
    YAxisStraightnessX ()
    {
      return this->YAxisStraightnessX_.get ();
    }

    void FPSTestType::
    YAxisStraightnessX (const YAxisStraightnessX_type& x)
    {
      this->YAxisStraightnessX_.set (x);
    }

    void FPSTestType::
    YAxisStraightnessX (::std::auto_ptr< YAxisStraightnessX_type > x)
    {
      this->YAxisStraightnessX_.set (x);
    }

    const FPSTestType::YAxisStraightnessZ_type& FPSTestType::
    YAxisStraightnessZ () const
    {
      return this->YAxisStraightnessZ_.get ();
    }

    FPSTestType::YAxisStraightnessZ_type& FPSTestType::
    YAxisStraightnessZ ()
    {
      return this->YAxisStraightnessZ_.get ();
    }

    void FPSTestType::
    YAxisStraightnessZ (const YAxisStraightnessZ_type& x)
    {
      this->YAxisStraightnessZ_.set (x);
    }

    void FPSTestType::
    YAxisStraightnessZ (::std::auto_ptr< YAxisStraightnessZ_type > x)
    {
      this->YAxisStraightnessZ_.set (x);
    }

    const FPSTestType::ZAxisStraightnessX_type& FPSTestType::
    ZAxisStraightnessX () const
    {
      return this->ZAxisStraightnessX_.get ();
    }

    FPSTestType::ZAxisStraightnessX_type& FPSTestType::
    ZAxisStraightnessX ()
    {
      return this->ZAxisStraightnessX_.get ();
    }

    void FPSTestType::
    ZAxisStraightnessX (const ZAxisStraightnessX_type& x)
    {
      this->ZAxisStraightnessX_.set (x);
    }

    void FPSTestType::
    ZAxisStraightnessX (::std::auto_ptr< ZAxisStraightnessX_type > x)
    {
      this->ZAxisStraightnessX_.set (x);
    }

    const FPSTestType::ZAxisStraightnessY_type& FPSTestType::
    ZAxisStraightnessY () const
    {
      return this->ZAxisStraightnessY_.get ();
    }

    FPSTestType::ZAxisStraightnessY_type& FPSTestType::
    ZAxisStraightnessY ()
    {
      return this->ZAxisStraightnessY_.get ();
    }

    void FPSTestType::
    ZAxisStraightnessY (const ZAxisStraightnessY_type& x)
    {
      this->ZAxisStraightnessY_.set (x);
    }

    void FPSTestType::
    ZAxisStraightnessY (::std::auto_ptr< ZAxisStraightnessY_type > x)
    {
      this->ZAxisStraightnessY_.set (x);
    }

    const FPSTestType::XYSquareness_type& FPSTestType::
    XYSquareness () const
    {
      return this->XYSquareness_.get ();
    }

    FPSTestType::XYSquareness_type& FPSTestType::
    XYSquareness ()
    {
      return this->XYSquareness_.get ();
    }

    void FPSTestType::
    XYSquareness (const XYSquareness_type& x)
    {
      this->XYSquareness_.set (x);
    }

    const FPSTestType::XZSquareness_type& FPSTestType::
    XZSquareness () const
    {
      return this->XZSquareness_.get ();
    }

    FPSTestType::XZSquareness_type& FPSTestType::
    XZSquareness ()
    {
      return this->XZSquareness_.get ();
    }

    void FPSTestType::
    XZSquareness (const XZSquareness_type& x)
    {
      this->XZSquareness_.set (x);
    }

    const FPSTestType::YZSquareness_type& FPSTestType::
    YZSquareness () const
    {
      return this->YZSquareness_.get ();
    }

    FPSTestType::YZSquareness_type& FPSTestType::
    YZSquareness ()
    {
      return this->YZSquareness_.get ();
    }

    void FPSTestType::
    YZSquareness (const YZSquareness_type& x)
    {
      this->YZSquareness_.set (x);
    }


    // FunctionDiscreteType
    // 

    const FunctionDiscreteType::DomainValues_type& FunctionDiscreteType::
    DomainValues () const
    {
      return this->DomainValues_.get ();
    }

    FunctionDiscreteType::DomainValues_type& FunctionDiscreteType::
    DomainValues ()
    {
      return this->DomainValues_.get ();
    }

    void FunctionDiscreteType::
    DomainValues (const DomainValues_type& x)
    {
      this->DomainValues_.set (x);
    }

    void FunctionDiscreteType::
    DomainValues (::std::auto_ptr< DomainValues_type > x)
    {
      this->DomainValues_.set (x);
    }

    const FunctionDiscreteType::RangeValues_type& FunctionDiscreteType::
    RangeValues () const
    {
      return this->RangeValues_.get ();
    }

    FunctionDiscreteType::RangeValues_type& FunctionDiscreteType::
    RangeValues ()
    {
      return this->RangeValues_.get ();
    }

    void FunctionDiscreteType::
    RangeValues (const RangeValues_type& x)
    {
      this->RangeValues_.set (x);
    }

    void FunctionDiscreteType::
    RangeValues (::std::auto_ptr< RangeValues_type > x)
    {
      this->RangeValues_.set (x);
    }

    const FunctionDiscreteType::N_type& FunctionDiscreteType::
    N () const
    {
      return this->N_.get ();
    }

    FunctionDiscreteType::N_type& FunctionDiscreteType::
    N ()
    {
      return this->N_.get ();
    }

    void FunctionDiscreteType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void FunctionDiscreteType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // LengthFunctionDiscreteType
    // 

    const LengthFunctionDiscreteType::DomainLinearUnit_type& LengthFunctionDiscreteType::
    DomainLinearUnit () const
    {
      return this->DomainLinearUnit_.get ();
    }

    LengthFunctionDiscreteType::DomainLinearUnit_type& LengthFunctionDiscreteType::
    DomainLinearUnit ()
    {
      return this->DomainLinearUnit_.get ();
    }

    void LengthFunctionDiscreteType::
    DomainLinearUnit (const DomainLinearUnit_type& x)
    {
      this->DomainLinearUnit_.set (x);
    }

    void LengthFunctionDiscreteType::
    DomainLinearUnit (::std::auto_ptr< DomainLinearUnit_type > x)
    {
      this->DomainLinearUnit_.set (x);
    }

    const LengthFunctionDiscreteType::RangeLinearUnit_type& LengthFunctionDiscreteType::
    RangeLinearUnit () const
    {
      return this->RangeLinearUnit_.get ();
    }

    LengthFunctionDiscreteType::RangeLinearUnit_type& LengthFunctionDiscreteType::
    RangeLinearUnit ()
    {
      return this->RangeLinearUnit_.get ();
    }

    void LengthFunctionDiscreteType::
    RangeLinearUnit (const RangeLinearUnit_type& x)
    {
      this->RangeLinearUnit_.set (x);
    }

    void LengthFunctionDiscreteType::
    RangeLinearUnit (::std::auto_ptr< RangeLinearUnit_type > x)
    {
      this->RangeLinearUnit_.set (x);
    }


    // AngleFunctionDiscreteType
    // 

    const AngleFunctionDiscreteType::DomainLinearUnit_type& AngleFunctionDiscreteType::
    DomainLinearUnit () const
    {
      return this->DomainLinearUnit_.get ();
    }

    AngleFunctionDiscreteType::DomainLinearUnit_type& AngleFunctionDiscreteType::
    DomainLinearUnit ()
    {
      return this->DomainLinearUnit_.get ();
    }

    void AngleFunctionDiscreteType::
    DomainLinearUnit (const DomainLinearUnit_type& x)
    {
      this->DomainLinearUnit_.set (x);
    }

    void AngleFunctionDiscreteType::
    DomainLinearUnit (::std::auto_ptr< DomainLinearUnit_type > x)
    {
      this->DomainLinearUnit_.set (x);
    }

    const AngleFunctionDiscreteType::RangeAngularUnit_type& AngleFunctionDiscreteType::
    RangeAngularUnit () const
    {
      return this->RangeAngularUnit_.get ();
    }

    AngleFunctionDiscreteType::RangeAngularUnit_type& AngleFunctionDiscreteType::
    RangeAngularUnit ()
    {
      return this->RangeAngularUnit_.get ();
    }

    void AngleFunctionDiscreteType::
    RangeAngularUnit (const RangeAngularUnit_type& x)
    {
      this->RangeAngularUnit_.set (x);
    }

    void AngleFunctionDiscreteType::
    RangeAngularUnit (::std::auto_ptr< RangeAngularUnit_type > x)
    {
      this->RangeAngularUnit_.set (x);
    }


    // B89TestType
    // 

    const B89TestType::XLinearAccuracy_type& B89TestType::
    XLinearAccuracy () const
    {
      return this->XLinearAccuracy_.get ();
    }

    B89TestType::XLinearAccuracy_type& B89TestType::
    XLinearAccuracy ()
    {
      return this->XLinearAccuracy_.get ();
    }

    void B89TestType::
    XLinearAccuracy (const XLinearAccuracy_type& x)
    {
      this->XLinearAccuracy_.set (x);
    }

    void B89TestType::
    XLinearAccuracy (::std::auto_ptr< XLinearAccuracy_type > x)
    {
      this->XLinearAccuracy_.set (x);
    }

    const B89TestType::YLinearAccuracy_type& B89TestType::
    YLinearAccuracy () const
    {
      return this->YLinearAccuracy_.get ();
    }

    B89TestType::YLinearAccuracy_type& B89TestType::
    YLinearAccuracy ()
    {
      return this->YLinearAccuracy_.get ();
    }

    void B89TestType::
    YLinearAccuracy (const YLinearAccuracy_type& x)
    {
      this->YLinearAccuracy_.set (x);
    }

    void B89TestType::
    YLinearAccuracy (::std::auto_ptr< YLinearAccuracy_type > x)
    {
      this->YLinearAccuracy_.set (x);
    }

    const B89TestType::ZLinearAccuracy_type& B89TestType::
    ZLinearAccuracy () const
    {
      return this->ZLinearAccuracy_.get ();
    }

    B89TestType::ZLinearAccuracy_type& B89TestType::
    ZLinearAccuracy ()
    {
      return this->ZLinearAccuracy_.get ();
    }

    void B89TestType::
    ZLinearAccuracy (const ZLinearAccuracy_type& x)
    {
      this->ZLinearAccuracy_.set (x);
    }

    void B89TestType::
    ZLinearAccuracy (::std::auto_ptr< ZLinearAccuracy_type > x)
    {
      this->ZLinearAccuracy_.set (x);
    }

    const B89TestType::OffsetVolumetricPerformance_type& B89TestType::
    OffsetVolumetricPerformance () const
    {
      return this->OffsetVolumetricPerformance_.get ();
    }

    B89TestType::OffsetVolumetricPerformance_type& B89TestType::
    OffsetVolumetricPerformance ()
    {
      return this->OffsetVolumetricPerformance_.get ();
    }

    void B89TestType::
    OffsetVolumetricPerformance (const OffsetVolumetricPerformance_type& x)
    {
      this->OffsetVolumetricPerformance_.set (x);
    }

    void B89TestType::
    OffsetVolumetricPerformance (::std::auto_ptr< OffsetVolumetricPerformance_type > x)
    {
      this->OffsetVolumetricPerformance_.set (x);
    }

    const B89TestType::VolumetricPerformance_type& B89TestType::
    VolumetricPerformance () const
    {
      return this->VolumetricPerformance_.get ();
    }

    B89TestType::VolumetricPerformance_type& B89TestType::
    VolumetricPerformance ()
    {
      return this->VolumetricPerformance_.get ();
    }

    void B89TestType::
    VolumetricPerformance (const VolumetricPerformance_type& x)
    {
      this->VolumetricPerformance_.set (x);
    }

    void B89TestType::
    VolumetricPerformance (::std::auto_ptr< VolumetricPerformance_type > x)
    {
      this->VolumetricPerformance_.set (x);
    }

    const B89TestType::Repeatability_type& B89TestType::
    Repeatability () const
    {
      return this->Repeatability_.get ();
    }

    B89TestType::Repeatability_type& B89TestType::
    Repeatability ()
    {
      return this->Repeatability_.get ();
    }

    void B89TestType::
    Repeatability (const Repeatability_type& x)
    {
      this->Repeatability_.set (x);
    }

    void B89TestType::
    Repeatability (::std::auto_ptr< Repeatability_type > x)
    {
      this->Repeatability_.set (x);
    }


    // ISO10360TestType
    // 

    const ISO10360TestType::MaxErrorConstant_optional& ISO10360TestType::
    MaxErrorConstant () const
    {
      return this->MaxErrorConstant_;
    }

    ISO10360TestType::MaxErrorConstant_optional& ISO10360TestType::
    MaxErrorConstant ()
    {
      return this->MaxErrorConstant_;
    }

    void ISO10360TestType::
    MaxErrorConstant (const MaxErrorConstant_type& x)
    {
      this->MaxErrorConstant_.set (x);
    }

    void ISO10360TestType::
    MaxErrorConstant (const MaxErrorConstant_optional& x)
    {
      this->MaxErrorConstant_ = x;
    }

    void ISO10360TestType::
    MaxErrorConstant (::std::auto_ptr< MaxErrorConstant_type > x)
    {
      this->MaxErrorConstant_.set (x);
    }

    const ISO10360TestType::LinearError_optional& ISO10360TestType::
    LinearError () const
    {
      return this->LinearError_;
    }

    ISO10360TestType::LinearError_optional& ISO10360TestType::
    LinearError ()
    {
      return this->LinearError_;
    }

    void ISO10360TestType::
    LinearError (const LinearError_type& x)
    {
      this->LinearError_.set (x);
    }

    void ISO10360TestType::
    LinearError (const LinearError_optional& x)
    {
      this->LinearError_ = x;
    }

    void ISO10360TestType::
    LinearError (::std::auto_ptr< LinearError_type > x)
    {
      this->LinearError_.set (x);
    }

    const ISO10360TestType::LesserError_optional& ISO10360TestType::
    LesserError () const
    {
      return this->LesserError_;
    }

    ISO10360TestType::LesserError_optional& ISO10360TestType::
    LesserError ()
    {
      return this->LesserError_;
    }

    void ISO10360TestType::
    LesserError (const LesserError_type& x)
    {
      this->LesserError_.set (x);
    }

    void ISO10360TestType::
    LesserError (const LesserError_optional& x)
    {
      this->LesserError_ = x;
    }

    void ISO10360TestType::
    LesserError (::std::auto_ptr< LesserError_type > x)
    {
      this->LesserError_.set (x);
    }


    // LinearErrorType
    // 

    const LinearErrorType::BaseError_type& LinearErrorType::
    BaseError () const
    {
      return this->BaseError_.get ();
    }

    LinearErrorType::BaseError_type& LinearErrorType::
    BaseError ()
    {
      return this->BaseError_.get ();
    }

    void LinearErrorType::
    BaseError (const BaseError_type& x)
    {
      this->BaseError_.set (x);
    }

    void LinearErrorType::
    BaseError (::std::auto_ptr< BaseError_type > x)
    {
      this->BaseError_.set (x);
    }

    const LinearErrorType::ErrorRate_type& LinearErrorType::
    ErrorRate () const
    {
      return this->ErrorRate_.get ();
    }

    LinearErrorType::ErrorRate_type& LinearErrorType::
    ErrorRate ()
    {
      return this->ErrorRate_.get ();
    }

    void LinearErrorType::
    ErrorRate (const ErrorRate_type& x)
    {
      this->ErrorRate_.set (x);
    }


    // LesserErrorType
    // 

    const LesserErrorType::MaxErrorConstant_type& LesserErrorType::
    MaxErrorConstant () const
    {
      return this->MaxErrorConstant_.get ();
    }

    LesserErrorType::MaxErrorConstant_type& LesserErrorType::
    MaxErrorConstant ()
    {
      return this->MaxErrorConstant_.get ();
    }

    void LesserErrorType::
    MaxErrorConstant (const MaxErrorConstant_type& x)
    {
      this->MaxErrorConstant_.set (x);
    }

    void LesserErrorType::
    MaxErrorConstant (::std::auto_ptr< MaxErrorConstant_type > x)
    {
      this->MaxErrorConstant_.set (x);
    }

    const LesserErrorType::LinearError_type& LesserErrorType::
    LinearError () const
    {
      return this->LinearError_.get ();
    }

    LesserErrorType::LinearError_type& LesserErrorType::
    LinearError ()
    {
      return this->LinearError_.get ();
    }

    void LesserErrorType::
    LinearError (const LinearError_type& x)
    {
      this->LinearError_.set (x);
    }

    void LesserErrorType::
    LinearError (::std::auto_ptr< LinearError_type > x)
    {
      this->LinearError_.set (x);
    }


    // PointAccuracyTestType
    // 

    const PointAccuracyTestType::Accuracy_type& PointAccuracyTestType::
    Accuracy () const
    {
      return this->Accuracy_.get ();
    }

    PointAccuracyTestType::Accuracy_type& PointAccuracyTestType::
    Accuracy ()
    {
      return this->Accuracy_.get ();
    }

    void PointAccuracyTestType::
    Accuracy (const Accuracy_type& x)
    {
      this->Accuracy_.set (x);
    }

    void PointAccuracyTestType::
    Accuracy (::std::auto_ptr< Accuracy_type > x)
    {
      this->Accuracy_.set (x);
    }


    // CMMAccuracyType
    // 

    const CMMAccuracyType::MinTemperature_type& CMMAccuracyType::
    MinTemperature () const
    {
      return this->MinTemperature_.get ();
    }

    CMMAccuracyType::MinTemperature_type& CMMAccuracyType::
    MinTemperature ()
    {
      return this->MinTemperature_.get ();
    }

    void CMMAccuracyType::
    MinTemperature (const MinTemperature_type& x)
    {
      this->MinTemperature_.set (x);
    }

    void CMMAccuracyType::
    MinTemperature (::std::auto_ptr< MinTemperature_type > x)
    {
      this->MinTemperature_.set (x);
    }

    const CMMAccuracyType::MaxTemperature_type& CMMAccuracyType::
    MaxTemperature () const
    {
      return this->MaxTemperature_.get ();
    }

    CMMAccuracyType::MaxTemperature_type& CMMAccuracyType::
    MaxTemperature ()
    {
      return this->MaxTemperature_.get ();
    }

    void CMMAccuracyType::
    MaxTemperature (const MaxTemperature_type& x)
    {
      this->MaxTemperature_.set (x);
    }

    void CMMAccuracyType::
    MaxTemperature (::std::auto_ptr< MaxTemperature_type > x)
    {
      this->MaxTemperature_.set (x);
    }

    const CMMAccuracyType::CMMAccuracyTest_type& CMMAccuracyType::
    CMMAccuracyTest () const
    {
      return this->CMMAccuracyTest_.get ();
    }

    CMMAccuracyType::CMMAccuracyTest_type& CMMAccuracyType::
    CMMAccuracyTest ()
    {
      return this->CMMAccuracyTest_.get ();
    }

    void CMMAccuracyType::
    CMMAccuracyTest (const CMMAccuracyTest_type& x)
    {
      this->CMMAccuracyTest_.set (x);
    }

    void CMMAccuracyType::
    CMMAccuracyTest (::std::auto_ptr< CMMAccuracyTest_type > x)
    {
      this->CMMAccuracyTest_.set (x);
    }


    // ComparatorType
    // 
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif2
  {
    // MeasurementResourcesType
    //

    MeasurementResourcesType::
    MeasurementResourcesType ()
    : ::xml_schema::type (),
      Version_ (this),
      Carriages_ (this),
      Fixtures_ (this),
      MeasurementDevices_ (this),
      Sensors_ (this),
      Tools_ (this)
    {
    }

    MeasurementResourcesType::
    MeasurementResourcesType (const MeasurementResourcesType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Version_ (x.Version_, f, this),
      Carriages_ (x.Carriages_, f, this),
      Fixtures_ (x.Fixtures_, f, this),
      MeasurementDevices_ (x.MeasurementDevices_, f, this),
      Sensors_ (x.Sensors_, f, this),
      Tools_ (x.Tools_, f, this)
    {
    }

    MeasurementResourcesType::
    MeasurementResourcesType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Version_ (this),
      Carriages_ (this),
      Fixtures_ (this),
      MeasurementDevices_ (this),
      Sensors_ (this),
      Tools_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasurementResourcesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Version
        //
        if (n.name () == "Version" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          if (!this->Version_)
          {
            this->Version_.set (r);
            continue;
          }
        }

        // Carriages
        //
        if (n.name () == "Carriages" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Carriages_type > r (
            Carriages_traits::create (i, f, this));

          if (!this->Carriages_)
          {
            this->Carriages_.set (r);
            continue;
          }
        }

        // Fixtures
        //
        if (n.name () == "Fixtures" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Fixtures_type > r (
            Fixtures_traits::create (i, f, this));

          if (!this->Fixtures_)
          {
            this->Fixtures_.set (r);
            continue;
          }
        }

        // MeasurementDevices
        //
        if (n.name () == "MeasurementDevices" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MeasurementDevices_type > r (
            MeasurementDevices_traits::create (i, f, this));

          if (!this->MeasurementDevices_)
          {
            this->MeasurementDevices_.set (r);
            continue;
          }
        }

        // Sensors
        //
        if (n.name () == "Sensors" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sensors_type > r (
            Sensors_traits::create (i, f, this));

          if (!this->Sensors_)
          {
            this->Sensors_.set (r);
            continue;
          }
        }

        // Tools
        //
        if (n.name () == "Tools" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Tools_type > r (
            Tools_traits::create (i, f, this));

          if (!this->Tools_)
          {
            this->Tools_.set (r);
            continue;
          }
        }

        break;
      }
    }

    MeasurementResourcesType* MeasurementResourcesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementResourcesType (*this, f, c);
    }

    MeasurementResourcesType& MeasurementResourcesType::
    operator= (const MeasurementResourcesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Version_ = x.Version_;
        this->Carriages_ = x.Carriages_;
        this->Fixtures_ = x.Fixtures_;
        this->MeasurementDevices_ = x.MeasurementDevices_;
        this->Sensors_ = x.Sensors_;
        this->Tools_ = x.Tools_;
      }

      return *this;
    }

    MeasurementResourcesType::
    ~MeasurementResourcesType ()
    {
    }

    // CarriagesType
    //

    CarriagesType::
    CarriagesType ()
    : ::xml_schema::type (),
      Carriage_ (this)
    {
    }

    CarriagesType::
    CarriagesType (const CarriagesType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Carriage_ (x.Carriage_, f, this)
    {
    }

    CarriagesType::
    CarriagesType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Carriage_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CarriagesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Carriage
        //
        if (n.name () == "Carriage" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Carriage_type > r (
            Carriage_traits::create (i, f, this));

          this->Carriage_.push_back (r);
          continue;
        }

        break;
      }
    }

    CarriagesType* CarriagesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CarriagesType (*this, f, c);
    }

    CarriagesType& CarriagesType::
    operator= (const CarriagesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Carriage_ = x.Carriage_;
      }

      return *this;
    }

    CarriagesType::
    ~CarriagesType ()
    {
    }

    // FixturesType
    //

    FixturesType::
    FixturesType ()
    : ::xml_schema::type (),
      Fixture_ (this)
    {
    }

    FixturesType::
    FixturesType (const FixturesType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Fixture_ (x.Fixture_, f, this)
    {
    }

    FixturesType::
    FixturesType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Fixture_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FixturesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Fixture
        //
        if (n.name () == "Fixture" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Fixture_type > r (
            Fixture_traits::create (i, f, this));

          this->Fixture_.push_back (r);
          continue;
        }

        break;
      }
    }

    FixturesType* FixturesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FixturesType (*this, f, c);
    }

    FixturesType& FixturesType::
    operator= (const FixturesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Fixture_ = x.Fixture_;
      }

      return *this;
    }

    FixturesType::
    ~FixturesType ()
    {
    }

    // SensorsType
    //

    SensorsType::
    SensorsType ()
    : ::xml_schema::type (),
      Sensor_ (this)
    {
    }

    SensorsType::
    SensorsType (const SensorsType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Sensor_ (x.Sensor_, f, this)
    {
    }

    SensorsType::
    SensorsType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Sensor_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SensorsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Sensor
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Sensor",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< Sensor_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< Sensor_type > r (
              dynamic_cast< Sensor_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Sensor_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    SensorsType* SensorsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SensorsType (*this, f, c);
    }

    SensorsType& SensorsType::
    operator= (const SensorsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Sensor_ = x.Sensor_;
      }

      return *this;
    }

    SensorsType::
    ~SensorsType ()
    {
    }

    // ToolsType
    //

    ToolsType::
    ToolsType ()
    : ::xml_schema::type (),
      Tool_ (this)
    {
    }

    ToolsType::
    ToolsType (const ToolsType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Tool_ (x.Tool_, f, this)
    {
    }

    ToolsType::
    ToolsType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Tool_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToolsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Tool
        //
        if (n.name () == "Tool" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Tool_type > r (
            Tool_traits::create (i, f, this));

          this->Tool_.push_back (r);
          continue;
        }

        break;
      }
    }

    ToolsType* ToolsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToolsType (*this, f, c);
    }

    ToolsType& ToolsType::
    operator= (const ToolsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Tool_ = x.Tool_;
      }

      return *this;
    }

    ToolsType::
    ~ToolsType ()
    {
    }

    // MeasurementDevicesType
    //

    MeasurementDevicesType::
    MeasurementDevicesType ()
    : ::xml_schema::type (),
      MeasurementDevice_ (this)
    {
    }

    MeasurementDevicesType::
    MeasurementDevicesType (const MeasurementDevicesType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MeasurementDevice_ (x.MeasurementDevice_, f, this)
    {
    }

    MeasurementDevicesType::
    MeasurementDevicesType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MeasurementDevice_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasurementDevicesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MeasurementDevice
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "MeasurementDevice",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< MeasurementDevice_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< MeasurementDevice_type > r (
              dynamic_cast< MeasurementDevice_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->MeasurementDevice_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    MeasurementDevicesType* MeasurementDevicesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementDevicesType (*this, f, c);
    }

    MeasurementDevicesType& MeasurementDevicesType::
    operator= (const MeasurementDevicesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MeasurementDevice_ = x.MeasurementDevice_;
      }

      return *this;
    }

    MeasurementDevicesType::
    ~MeasurementDevicesType ()
    {
    }

    // MeasurementResourceBaseType
    //

    MeasurementResourceBaseType::
    MeasurementResourceBaseType (const Name_type& Name,
                                 const id_type& id)
    : ::xml_schema::type (),
      Name_ (Name, this),
      Description_ (this),
      Manufacturer_ (this),
      ModelNumber_ (this),
      SerialNumber_ (this),
      LocationId_ (this),
      Location_ (this),
      id_ (id, this)
    {
    }

    MeasurementResourceBaseType::
    MeasurementResourceBaseType (const MeasurementResourceBaseType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Description_ (x.Description_, f, this),
      Manufacturer_ (x.Manufacturer_, f, this),
      ModelNumber_ (x.ModelNumber_, f, this),
      SerialNumber_ (x.SerialNumber_, f, this),
      LocationId_ (x.LocationId_, f, this),
      Location_ (x.Location_, f, this),
      id_ (x.id_, f, this)
    {
    }

    MeasurementResourceBaseType::
    MeasurementResourceBaseType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      Description_ (this),
      Manufacturer_ (this),
      ModelNumber_ (this),
      SerialNumber_ (this),
      LocationId_ (this),
      Location_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MeasurementResourceBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (r);
            continue;
          }
        }

        // Description
        //
        if (n.name () == "Description" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (r);
            continue;
          }
        }

        // Manufacturer
        //
        if (n.name () == "Manufacturer" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Manufacturer_type > r (
            Manufacturer_traits::create (i, f, this));

          if (!this->Manufacturer_)
          {
            this->Manufacturer_.set (r);
            continue;
          }
        }

        // ModelNumber
        //
        if (n.name () == "ModelNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ModelNumber_type > r (
            ModelNumber_traits::create (i, f, this));

          if (!this->ModelNumber_)
          {
            this->ModelNumber_.set (r);
            continue;
          }
        }

        // SerialNumber
        //
        if (n.name () == "SerialNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SerialNumber_type > r (
            SerialNumber_traits::create (i, f, this));

          if (!this->SerialNumber_)
          {
            this->SerialNumber_.set (r);
            continue;
          }
        }

        // LocationId
        //
        if (n.name () == "LocationId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LocationId_type > r (
            LocationId_traits::create (i, f, this));

          if (!this->LocationId_)
          {
            this->LocationId_.set (r);
            continue;
          }
        }

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Name",
          "http://qifstandards.org/xsd/qif2");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    MeasurementResourceBaseType* MeasurementResourceBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementResourceBaseType (*this, f, c);
    }

    MeasurementResourceBaseType& MeasurementResourceBaseType::
    operator= (const MeasurementResourceBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Name_ = x.Name_;
        this->Description_ = x.Description_;
        this->Manufacturer_ = x.Manufacturer_;
        this->ModelNumber_ = x.ModelNumber_;
        this->SerialNumber_ = x.SerialNumber_;
        this->LocationId_ = x.LocationId_;
        this->Location_ = x.Location_;
        this->id_ = x.id_;
      }

      return *this;
    }

    MeasurementResourceBaseType::
    ~MeasurementResourceBaseType ()
    {
    }

    // FixtureType
    //

    FixtureType::
    FixtureType (const Name_type& Name,
                 const id_type& id)
    : ::xsd::qif2::MeasurementResourceBaseType (Name,
                                                id)
    {
    }

    FixtureType::
    FixtureType (const FixtureType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementResourceBaseType (x, f, c)
    {
    }

    FixtureType::
    FixtureType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementResourceBaseType (e, f, c)
    {
    }

    FixtureType* FixtureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FixtureType (*this, f, c);
    }

    FixtureType::
    ~FixtureType ()
    {
    }

    // MeasurementDeviceAccuracyBaseType
    //

    MeasurementDeviceAccuracyBaseType::
    MeasurementDeviceAccuracyBaseType ()
    : ::xml_schema::type ()
    {
    }

    MeasurementDeviceAccuracyBaseType::
    MeasurementDeviceAccuracyBaseType (const MeasurementDeviceAccuracyBaseType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    MeasurementDeviceAccuracyBaseType::
    MeasurementDeviceAccuracyBaseType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    MeasurementDeviceAccuracyBaseType::
    MeasurementDeviceAccuracyBaseType (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    MeasurementDeviceAccuracyBaseType::
    MeasurementDeviceAccuracyBaseType (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    MeasurementDeviceAccuracyBaseType* MeasurementDeviceAccuracyBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementDeviceAccuracyBaseType (*this, f, c);
    }

    MeasurementDeviceAccuracyBaseType::
    ~MeasurementDeviceAccuracyBaseType ()
    {
    }

    // NumericalLengthAccuracyType
    //

    NumericalLengthAccuracyType::
    NumericalLengthAccuracyType (const AccuracyValue_type& AccuracyValue)
    : ::xsd::qif2::MeasurementDeviceAccuracyBaseType (),
      AccuracyValue_ (AccuracyValue, this)
    {
    }

    NumericalLengthAccuracyType::
    NumericalLengthAccuracyType (::std::auto_ptr< AccuracyValue_type > AccuracyValue)
    : ::xsd::qif2::MeasurementDeviceAccuracyBaseType (),
      AccuracyValue_ (AccuracyValue, this)
    {
    }

    NumericalLengthAccuracyType::
    NumericalLengthAccuracyType (const NumericalLengthAccuracyType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementDeviceAccuracyBaseType (x, f, c),
      AccuracyValue_ (x.AccuracyValue_, f, this)
    {
    }

    NumericalLengthAccuracyType::
    NumericalLengthAccuracyType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementDeviceAccuracyBaseType (e, f | ::xml_schema::flags::base, c),
      AccuracyValue_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void NumericalLengthAccuracyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // AccuracyValue
        //
        if (n.name () == "AccuracyValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AccuracyValue_type > r (
            AccuracyValue_traits::create (i, f, this));

          if (!AccuracyValue_.present ())
          {
            this->AccuracyValue_.set (r);
            continue;
          }
        }

        break;
      }

      if (!AccuracyValue_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "AccuracyValue",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    NumericalLengthAccuracyType* NumericalLengthAccuracyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NumericalLengthAccuracyType (*this, f, c);
    }

    NumericalLengthAccuracyType& NumericalLengthAccuracyType::
    operator= (const NumericalLengthAccuracyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::MeasurementDeviceAccuracyBaseType& > (*this) = x;
        this->AccuracyValue_ = x.AccuracyValue_;
      }

      return *this;
    }

    NumericalLengthAccuracyType::
    ~NumericalLengthAccuracyType ()
    {
    }

    // MeasurementDeviceType
    //

    MeasurementDeviceType::
    MeasurementDeviceType (const Name_type& Name,
                           const id_type& id)
    : ::xsd::qif2::MeasurementResourceBaseType (Name,
                                                id),
      Calibrations_ (this),
      InspectionTemperatures_ (this)
    {
    }

    MeasurementDeviceType::
    MeasurementDeviceType (const MeasurementDeviceType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementResourceBaseType (x, f, c),
      Calibrations_ (x.Calibrations_, f, this),
      InspectionTemperatures_ (x.InspectionTemperatures_, f, this)
    {
    }

    MeasurementDeviceType::
    MeasurementDeviceType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementResourceBaseType (e, f | ::xml_schema::flags::base, c),
      Calibrations_ (this),
      InspectionTemperatures_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void MeasurementDeviceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::MeasurementResourceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Calibrations
        //
        if (n.name () == "Calibrations" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Calibrations_type > r (
            Calibrations_traits::create (i, f, this));

          if (!this->Calibrations_)
          {
            this->Calibrations_.set (r);
            continue;
          }
        }

        // InspectionTemperatures
        //
        if (n.name () == "InspectionTemperatures" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InspectionTemperatures_type > r (
            InspectionTemperatures_traits::create (i, f, this));

          if (!this->InspectionTemperatures_)
          {
            this->InspectionTemperatures_.set (r);
            continue;
          }
        }

        break;
      }
    }

    MeasurementDeviceType* MeasurementDeviceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementDeviceType (*this, f, c);
    }

    MeasurementDeviceType& MeasurementDeviceType::
    operator= (const MeasurementDeviceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::MeasurementResourceBaseType& > (*this) = x;
        this->Calibrations_ = x.Calibrations_;
        this->InspectionTemperatures_ = x.InspectionTemperatures_;
      }

      return *this;
    }

    MeasurementDeviceType::
    ~MeasurementDeviceType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, MeasurementDeviceType >
    _xsd_MeasurementDeviceType_type_factory_init (
      "MeasurementDeviceType",
      "http://qifstandards.org/xsd/qif2");

    // CalibrationMasterType
    //

    CalibrationMasterType::
    CalibrationMasterType (const SerialNumber_type& SerialNumber)
    : ::xml_schema::type (),
      SerialNumber_ (SerialNumber, this),
      description_ (this)
    {
    }

    CalibrationMasterType::
    CalibrationMasterType (const CalibrationMasterType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SerialNumber_ (x.SerialNumber_, f, this),
      description_ (x.description_, f, this)
    {
    }

    CalibrationMasterType::
    CalibrationMasterType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SerialNumber_ (this),
      description_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CalibrationMasterType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SerialNumber
        //
        if (n.name () == "SerialNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SerialNumber_type > r (
            SerialNumber_traits::create (i, f, this));

          if (!SerialNumber_.present ())
          {
            this->SerialNumber_.set (r);
            continue;
          }
        }

        // description
        //
        if (n.name () == "description" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< description_type > r (
            description_traits::create (i, f, this));

          if (!this->description_)
          {
            this->description_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SerialNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SerialNumber",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CalibrationMasterType* CalibrationMasterType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CalibrationMasterType (*this, f, c);
    }

    CalibrationMasterType& CalibrationMasterType::
    operator= (const CalibrationMasterType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SerialNumber_ = x.SerialNumber_;
        this->description_ = x.description_;
      }

      return *this;
    }

    CalibrationMasterType::
    ~CalibrationMasterType ()
    {
    }

    // CalibrationType
    //

    CalibrationType::
    CalibrationType (const Temperatures_type& Temperatures,
                     const TimeStamp_type& TimeStamp)
    : ::xml_schema::type (),
      CalibrationMaster_ (this),
      Temperatures_ (Temperatures, this),
      TimeStamp_ (TimeStamp, this)
    {
    }

    CalibrationType::
    CalibrationType (::std::auto_ptr< Temperatures_type > Temperatures,
                     const TimeStamp_type& TimeStamp)
    : ::xml_schema::type (),
      CalibrationMaster_ (this),
      Temperatures_ (Temperatures, this),
      TimeStamp_ (TimeStamp, this)
    {
    }

    CalibrationType::
    CalibrationType (const CalibrationType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CalibrationMaster_ (x.CalibrationMaster_, f, this),
      Temperatures_ (x.Temperatures_, f, this),
      TimeStamp_ (x.TimeStamp_, f, this)
    {
    }

    CalibrationType::
    CalibrationType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CalibrationMaster_ (this),
      Temperatures_ (this),
      TimeStamp_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CalibrationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CalibrationMaster
        //
        if (n.name () == "CalibrationMaster" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CalibrationMaster_type > r (
            CalibrationMaster_traits::create (i, f, this));

          if (!this->CalibrationMaster_)
          {
            this->CalibrationMaster_.set (r);
            continue;
          }
        }

        // Temperatures
        //
        if (n.name () == "Temperatures" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Temperatures_type > r (
            Temperatures_traits::create (i, f, this));

          if (!Temperatures_.present ())
          {
            this->Temperatures_.set (r);
            continue;
          }
        }

        // TimeStamp
        //
        if (n.name () == "TimeStamp" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TimeStamp_type > r (
            TimeStamp_traits::create (i, f, this));

          if (!TimeStamp_.present ())
          {
            this->TimeStamp_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Temperatures_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Temperatures",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!TimeStamp_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "TimeStamp",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CalibrationType* CalibrationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CalibrationType (*this, f, c);
    }

    CalibrationType& CalibrationType::
    operator= (const CalibrationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CalibrationMaster_ = x.CalibrationMaster_;
        this->Temperatures_ = x.Temperatures_;
        this->TimeStamp_ = x.TimeStamp_;
      }

      return *this;
    }

    CalibrationType::
    ~CalibrationType ()
    {
    }

    // CalibrationsType
    //

    CalibrationsType::
    CalibrationsType ()
    : ::xml_schema::type (),
      Calibration_ (this)
    {
    }

    CalibrationsType::
    CalibrationsType (const CalibrationsType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Calibration_ (x.Calibration_, f, this)
    {
    }

    CalibrationsType::
    CalibrationsType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Calibration_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CalibrationsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Calibration
        //
        if (n.name () == "Calibration" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Calibration_type > r (
            Calibration_traits::create (i, f, this));

          this->Calibration_.push_back (r);
          continue;
        }

        break;
      }
    }

    CalibrationsType* CalibrationsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CalibrationsType (*this, f, c);
    }

    CalibrationsType& CalibrationsType::
    operator= (const CalibrationsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Calibration_ = x.Calibration_;
      }

      return *this;
    }

    CalibrationsType::
    ~CalibrationsType ()
    {
    }

    // TemperaturesType
    //

    TemperaturesType::
    TemperaturesType ()
    : ::xml_schema::type (),
      Temperature_ (this)
    {
    }

    TemperaturesType::
    TemperaturesType (const TemperaturesType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Temperature_ (x.Temperature_, f, this)
    {
    }

    TemperaturesType::
    TemperaturesType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Temperature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TemperaturesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Temperature
        //
        if (n.name () == "Temperature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Temperature_type > r (
            Temperature_traits::create (i, f, this));

          this->Temperature_.push_back (r);
          continue;
        }

        break;
      }
    }

    TemperaturesType* TemperaturesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TemperaturesType (*this, f, c);
    }

    TemperaturesType& TemperaturesType::
    operator= (const TemperaturesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Temperature_ = x.Temperature_;
      }

      return *this;
    }

    TemperaturesType::
    ~TemperaturesType ()
    {
    }

    // TemperatureType
    //

    TemperatureType::
    TemperatureType (const Temperature_type& Temperature,
                     const TimeStamp_type& TimeStamp)
    : ::xml_schema::type (),
      Attributes_ (this),
      Temperature_ (Temperature, this),
      TimeStamp_ (TimeStamp, this)
    {
    }

    TemperatureType::
    TemperatureType (::std::auto_ptr< Temperature_type > Temperature,
                     const TimeStamp_type& TimeStamp)
    : ::xml_schema::type (),
      Attributes_ (this),
      Temperature_ (Temperature, this),
      TimeStamp_ (TimeStamp, this)
    {
    }

    TemperatureType::
    TemperatureType (const TemperatureType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      Temperature_ (x.Temperature_, f, this),
      TimeStamp_ (x.TimeStamp_, f, this)
    {
    }

    TemperatureType::
    TemperatureType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      Temperature_ (this),
      TimeStamp_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TemperatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Attributes
        //
        if (n.name () == "Attributes" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (r);
            continue;
          }
        }

        // Temperature
        //
        if (n.name () == "Temperature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Temperature_type > r (
            Temperature_traits::create (i, f, this));

          if (!Temperature_.present ())
          {
            this->Temperature_.set (r);
            continue;
          }
        }

        // TimeStamp
        //
        if (n.name () == "TimeStamp" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TimeStamp_type > r (
            TimeStamp_traits::create (i, f, this));

          if (!TimeStamp_.present ())
          {
            this->TimeStamp_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Temperature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Temperature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!TimeStamp_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "TimeStamp",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TemperatureType* TemperatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TemperatureType (*this, f, c);
    }

    TemperatureType& TemperatureType::
    operator= (const TemperatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->Temperature_ = x.Temperature_;
        this->TimeStamp_ = x.TimeStamp_;
      }

      return *this;
    }

    TemperatureType::
    ~TemperatureType ()
    {
    }

    // QualificationsType
    //

    QualificationsType::
    QualificationsType ()
    : ::xml_schema::type (),
      Qualification_ (this)
    {
    }

    QualificationsType::
    QualificationsType (const QualificationsType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Qualification_ (x.Qualification_, f, this)
    {
    }

    QualificationsType::
    QualificationsType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Qualification_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void QualificationsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Qualification
        //
        if (n.name () == "Qualification" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Qualification_type > r (
            Qualification_traits::create (i, f, this));

          this->Qualification_.push_back (r);
          continue;
        }

        break;
      }
    }

    QualificationsType* QualificationsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QualificationsType (*this, f, c);
    }

    QualificationsType& QualificationsType::
    operator= (const QualificationsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Qualification_ = x.Qualification_;
      }

      return *this;
    }

    QualificationsType::
    ~QualificationsType ()
    {
    }

    // QualificationType
    //

    QualificationType::
    QualificationType (const Description_type& Description)
    : ::xml_schema::type (),
      Attributes_ (this),
      Description_ (Description, this)
    {
    }

    QualificationType::
    QualificationType (const QualificationType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      Description_ (x.Description_, f, this)
    {
    }

    QualificationType::
    QualificationType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      Description_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void QualificationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Attributes
        //
        if (n.name () == "Attributes" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (r);
            continue;
          }
        }

        // Description
        //
        if (n.name () == "Description" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!Description_.present ())
          {
            this->Description_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Description",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    QualificationType* QualificationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QualificationType (*this, f, c);
    }

    QualificationType& QualificationType::
    operator= (const QualificationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->Description_ = x.Description_;
      }

      return *this;
    }

    QualificationType::
    ~QualificationType ()
    {
    }

    // SensorType
    //

    SensorType::
    SensorType (const Name_type& Name,
                const id_type& id,
                const Qualifications_type& Qualifications)
    : ::xsd::qif2::MeasurementResourceBaseType (Name,
                                                id),
      Qualifications_ (Qualifications, this),
      AAngle_ (this),
      BAngle_ (this)
    {
    }

    SensorType::
    SensorType (const Name_type& Name,
                const id_type& id,
                ::std::auto_ptr< Qualifications_type > Qualifications)
    : ::xsd::qif2::MeasurementResourceBaseType (Name,
                                                id),
      Qualifications_ (Qualifications, this),
      AAngle_ (this),
      BAngle_ (this)
    {
    }

    SensorType::
    SensorType (const SensorType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementResourceBaseType (x, f, c),
      Qualifications_ (x.Qualifications_, f, this),
      AAngle_ (x.AAngle_, f, this),
      BAngle_ (x.BAngle_, f, this)
    {
    }

    SensorType::
    SensorType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementResourceBaseType (e, f | ::xml_schema::flags::base, c),
      Qualifications_ (this),
      AAngle_ (this),
      BAngle_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SensorType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::MeasurementResourceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Qualifications
        //
        if (n.name () == "Qualifications" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Qualifications_type > r (
            Qualifications_traits::create (i, f, this));

          if (!Qualifications_.present ())
          {
            this->Qualifications_.set (r);
            continue;
          }
        }

        // AAngle
        //
        if (n.name () == "AAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AAngle_type > r (
            AAngle_traits::create (i, f, this));

          if (!this->AAngle_)
          {
            this->AAngle_.set (r);
            continue;
          }
        }

        // BAngle
        //
        if (n.name () == "BAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BAngle_type > r (
            BAngle_traits::create (i, f, this));

          if (!this->BAngle_)
          {
            this->BAngle_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Qualifications_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Qualifications",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SensorType* SensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SensorType (*this, f, c);
    }

    SensorType& SensorType::
    operator= (const SensorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::MeasurementResourceBaseType& > (*this) = x;
        this->Qualifications_ = x.Qualifications_;
        this->AAngle_ = x.AAngle_;
        this->BAngle_ = x.BAngle_;
      }

      return *this;
    }

    SensorType::
    ~SensorType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SensorType >
    _xsd_SensorType_type_factory_init (
      "SensorType",
      "http://qifstandards.org/xsd/qif2");

    // TouchProbeType
    //

    TouchProbeType::
    TouchProbeType (const Name_type& Name,
                    const id_type& id,
                    const Qualifications_type& Qualifications,
                    const TipDiameter_type& TipDiameter)
    : ::xsd::qif2::SensorType (Name,
                               id,
                               Qualifications),
      TipDiameter_ (TipDiameter, this)
    {
    }

    TouchProbeType::
    TouchProbeType (const Name_type& Name,
                    const id_type& id,
                    ::std::auto_ptr< Qualifications_type > Qualifications,
                    ::std::auto_ptr< TipDiameter_type > TipDiameter)
    : ::xsd::qif2::SensorType (Name,
                               id,
                               Qualifications),
      TipDiameter_ (TipDiameter, this)
    {
    }

    TouchProbeType::
    TouchProbeType (const TouchProbeType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::SensorType (x, f, c),
      TipDiameter_ (x.TipDiameter_, f, this)
    {
    }

    TouchProbeType::
    TouchProbeType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::SensorType (e, f | ::xml_schema::flags::base, c),
      TipDiameter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TouchProbeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SensorType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // TipDiameter
        //
        if (n.name () == "TipDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TipDiameter_type > r (
            TipDiameter_traits::create (i, f, this));

          if (!TipDiameter_.present ())
          {
            this->TipDiameter_.set (r);
            continue;
          }
        }

        break;
      }

      if (!TipDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "TipDiameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TouchProbeType* TouchProbeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TouchProbeType (*this, f, c);
    }

    TouchProbeType& TouchProbeType::
    operator= (const TouchProbeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::SensorType& > (*this) = x;
        this->TipDiameter_ = x.TipDiameter_;
      }

      return *this;
    }

    TouchProbeType::
    ~TouchProbeType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TouchProbeType >
    _xsd_TouchProbeType_type_factory_init (
      "TouchProbeType",
      "http://qifstandards.org/xsd/qif2");

    // ToolType
    //

    ToolType::
    ToolType (const Name_type& Name,
              const id_type& id)
    : ::xsd::qif2::MeasurementResourceBaseType (Name,
                                                id),
      SensorIds_ (this)
    {
    }

    ToolType::
    ToolType (const ToolType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementResourceBaseType (x, f, c),
      SensorIds_ (x.SensorIds_, f, this)
    {
    }

    ToolType::
    ToolType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementResourceBaseType (e, f | ::xml_schema::flags::base, c),
      SensorIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToolType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::MeasurementResourceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SensorIds
        //
        if (n.name () == "SensorIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SensorIds_type > r (
            SensorIds_traits::create (i, f, this));

          if (!this->SensorIds_)
          {
            this->SensorIds_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ToolType* ToolType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToolType (*this, f, c);
    }

    ToolType& ToolType::
    operator= (const ToolType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::MeasurementResourceBaseType& > (*this) = x;
        this->SensorIds_ = x.SensorIds_;
      }

      return *this;
    }

    ToolType::
    ~ToolType ()
    {
    }

    // CarriageType
    //

    CarriageType::
    CarriageType (const Name_type& Name,
                  const id_type& id)
    : ::xsd::qif2::MeasurementResourceBaseType (Name,
                                                id),
      ToolIds_ (this)
    {
    }

    CarriageType::
    CarriageType (const CarriageType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementResourceBaseType (x, f, c),
      ToolIds_ (x.ToolIds_, f, this)
    {
    }

    CarriageType::
    CarriageType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementResourceBaseType (e, f | ::xml_schema::flags::base, c),
      ToolIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CarriageType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::MeasurementResourceBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ToolIds
        //
        if (n.name () == "ToolIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ToolIds_type > r (
            ToolIds_traits::create (i, f, this));

          if (!this->ToolIds_)
          {
            this->ToolIds_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CarriageType* CarriageType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CarriageType (*this, f, c);
    }

    CarriageType& CarriageType::
    operator= (const CarriageType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::MeasurementResourceBaseType& > (*this) = x;
        this->ToolIds_ = x.ToolIds_;
      }

      return *this;
    }

    CarriageType::
    ~CarriageType ()
    {
    }

    // ProbingDeviceType
    //

    ProbingDeviceType::
    ProbingDeviceType (const Name_type& Name,
                       const id_type& id)
    : ::xsd::qif2::MeasurementDeviceType (Name,
                                          id),
      WorkingVolume_ (this),
      EffectiveWorkingVolume_ (this),
      Resolution_ (this)
    {
    }

    ProbingDeviceType::
    ProbingDeviceType (const ProbingDeviceType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementDeviceType (x, f, c),
      WorkingVolume_ (x.WorkingVolume_, f, this),
      EffectiveWorkingVolume_ (x.EffectiveWorkingVolume_, f, this),
      Resolution_ (x.Resolution_, f, this)
    {
    }

    ProbingDeviceType::
    ProbingDeviceType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementDeviceType (e, f | ::xml_schema::flags::base, c),
      WorkingVolume_ (this),
      EffectiveWorkingVolume_ (this),
      Resolution_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ProbingDeviceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::MeasurementDeviceType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // WorkingVolume
        //
        if (n.name () == "WorkingVolume" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WorkingVolume_type > r (
            WorkingVolume_traits::create (i, f, this));

          if (!this->WorkingVolume_)
          {
            this->WorkingVolume_.set (r);
            continue;
          }
        }

        // EffectiveWorkingVolume
        //
        if (n.name () == "EffectiveWorkingVolume" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EffectiveWorkingVolume_type > r (
            EffectiveWorkingVolume_traits::create (i, f, this));

          if (!this->EffectiveWorkingVolume_)
          {
            this->EffectiveWorkingVolume_.set (r);
            continue;
          }
        }

        // Resolution
        //
        if (n.name () == "Resolution" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Resolution_type > r (
            Resolution_traits::create (i, f, this));

          if (!this->Resolution_)
          {
            this->Resolution_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ProbingDeviceType* ProbingDeviceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProbingDeviceType (*this, f, c);
    }

    ProbingDeviceType& ProbingDeviceType::
    operator= (const ProbingDeviceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::MeasurementDeviceType& > (*this) = x;
        this->WorkingVolume_ = x.WorkingVolume_;
        this->EffectiveWorkingVolume_ = x.EffectiveWorkingVolume_;
        this->Resolution_ = x.Resolution_;
      }

      return *this;
    }

    ProbingDeviceType::
    ~ProbingDeviceType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ProbingDeviceType >
    _xsd_ProbingDeviceType_type_factory_init (
      "ProbingDeviceType",
      "http://qifstandards.org/xsd/qif2");

    // CMMType
    //

    CMMType::
    CMMType (const Name_type& Name,
             const id_type& id)
    : ::xsd::qif2::ProbingDeviceType (Name,
                                      id),
      HomeLocation_ (this),
      MachineGeometry_ (this),
      AxisOrientation_ (this),
      CMMScales_ (this),
      MaxWorkpieceHeight_ (this),
      MaxWorkpieceMass_ (this),
      JoystickSpeeds_ (this),
      CNCSpeeds_ (this),
      RotaryTable_ (this),
      NominalAccuracy_ (this),
      ActualAccuracy_ (this),
      CarriageIds_ (this),
      ToolIds_ (this)
    {
    }

    CMMType::
    CMMType (const CMMType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::qif2::ProbingDeviceType (x, f, c),
      HomeLocation_ (x.HomeLocation_, f, this),
      MachineGeometry_ (x.MachineGeometry_, f, this),
      AxisOrientation_ (x.AxisOrientation_, f, this),
      CMMScales_ (x.CMMScales_, f, this),
      MaxWorkpieceHeight_ (x.MaxWorkpieceHeight_, f, this),
      MaxWorkpieceMass_ (x.MaxWorkpieceMass_, f, this),
      JoystickSpeeds_ (x.JoystickSpeeds_, f, this),
      CNCSpeeds_ (x.CNCSpeeds_, f, this),
      RotaryTable_ (x.RotaryTable_, f, this),
      NominalAccuracy_ (x.NominalAccuracy_, f, this),
      ActualAccuracy_ (x.ActualAccuracy_, f, this),
      CarriageIds_ (x.CarriageIds_, f, this),
      ToolIds_ (x.ToolIds_, f, this)
    {
    }

    CMMType::
    CMMType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::qif2::ProbingDeviceType (e, f | ::xml_schema::flags::base, c),
      HomeLocation_ (this),
      MachineGeometry_ (this),
      AxisOrientation_ (this),
      CMMScales_ (this),
      MaxWorkpieceHeight_ (this),
      MaxWorkpieceMass_ (this),
      JoystickSpeeds_ (this),
      CNCSpeeds_ (this),
      RotaryTable_ (this),
      NominalAccuracy_ (this),
      ActualAccuracy_ (this),
      CarriageIds_ (this),
      ToolIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CMMType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ProbingDeviceType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // HomeLocation
        //
        if (n.name () == "HomeLocation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< HomeLocation_type > r (
            HomeLocation_traits::create (i, f, this));

          if (!this->HomeLocation_)
          {
            this->HomeLocation_.set (r);
            continue;
          }
        }

        // MachineGeometry
        //
        if (n.name () == "MachineGeometry" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MachineGeometry_type > r (
            MachineGeometry_traits::create (i, f, this));

          if (!this->MachineGeometry_)
          {
            this->MachineGeometry_.set (r);
            continue;
          }
        }

        // AxisOrientation
        //
        if (n.name () == "AxisOrientation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AxisOrientation_type > r (
            AxisOrientation_traits::create (i, f, this));

          if (!this->AxisOrientation_)
          {
            this->AxisOrientation_.set (r);
            continue;
          }
        }

        // CMMScales
        //
        if (n.name () == "CMMScales" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CMMScales_type > r (
            CMMScales_traits::create (i, f, this));

          if (!this->CMMScales_)
          {
            this->CMMScales_.set (r);
            continue;
          }
        }

        // MaxWorkpieceHeight
        //
        if (n.name () == "MaxWorkpieceHeight" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxWorkpieceHeight_type > r (
            MaxWorkpieceHeight_traits::create (i, f, this));

          if (!this->MaxWorkpieceHeight_)
          {
            this->MaxWorkpieceHeight_.set (r);
            continue;
          }
        }

        // MaxWorkpieceMass
        //
        if (n.name () == "MaxWorkpieceMass" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxWorkpieceMass_type > r (
            MaxWorkpieceMass_traits::create (i, f, this));

          if (!this->MaxWorkpieceMass_)
          {
            this->MaxWorkpieceMass_.set (r);
            continue;
          }
        }

        // JoystickSpeeds
        //
        if (n.name () == "JoystickSpeeds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< JoystickSpeeds_type > r (
            JoystickSpeeds_traits::create (i, f, this));

          if (!this->JoystickSpeeds_)
          {
            this->JoystickSpeeds_.set (r);
            continue;
          }
        }

        // CNCSpeeds
        //
        if (n.name () == "CNCSpeeds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CNCSpeeds_type > r (
            CNCSpeeds_traits::create (i, f, this));

          if (!this->CNCSpeeds_)
          {
            this->CNCSpeeds_.set (r);
            continue;
          }
        }

        // RotaryTable
        //
        if (n.name () == "RotaryTable" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RotaryTable_type > r (
            RotaryTable_traits::create (i, f, this));

          if (!this->RotaryTable_)
          {
            this->RotaryTable_.set (r);
            continue;
          }
        }

        // NominalAccuracy
        //
        if (n.name () == "NominalAccuracy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< NominalAccuracy_type > r (
            NominalAccuracy_traits::create (i, f, this));

          if (!this->NominalAccuracy_)
          {
            this->NominalAccuracy_.set (r);
            continue;
          }
        }

        // ActualAccuracy
        //
        if (n.name () == "ActualAccuracy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ActualAccuracy_type > r (
            ActualAccuracy_traits::create (i, f, this));

          if (!this->ActualAccuracy_)
          {
            this->ActualAccuracy_.set (r);
            continue;
          }
        }

        // CarriageIds
        //
        if (n.name () == "CarriageIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CarriageIds_type > r (
            CarriageIds_traits::create (i, f, this));

          if (!this->CarriageIds_)
          {
            this->CarriageIds_.set (r);
            continue;
          }
        }

        // ToolIds
        //
        if (n.name () == "ToolIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ToolIds_type > r (
            ToolIds_traits::create (i, f, this));

          if (!this->ToolIds_)
          {
            this->ToolIds_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CMMType* CMMType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CMMType (*this, f, c);
    }

    CMMType& CMMType::
    operator= (const CMMType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ProbingDeviceType& > (*this) = x;
        this->HomeLocation_ = x.HomeLocation_;
        this->MachineGeometry_ = x.MachineGeometry_;
        this->AxisOrientation_ = x.AxisOrientation_;
        this->CMMScales_ = x.CMMScales_;
        this->MaxWorkpieceHeight_ = x.MaxWorkpieceHeight_;
        this->MaxWorkpieceMass_ = x.MaxWorkpieceMass_;
        this->JoystickSpeeds_ = x.JoystickSpeeds_;
        this->CNCSpeeds_ = x.CNCSpeeds_;
        this->RotaryTable_ = x.RotaryTable_;
        this->NominalAccuracy_ = x.NominalAccuracy_;
        this->ActualAccuracy_ = x.ActualAccuracy_;
        this->CarriageIds_ = x.CarriageIds_;
        this->ToolIds_ = x.ToolIds_;
      }

      return *this;
    }

    CMMType::
    ~CMMType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CMMType >
    _xsd_CMMType_type_factory_init (
      "CMMType",
      "http://qifstandards.org/xsd/qif2");

    // CMMScalesType
    //

    CMMScalesType::
    CMMScalesType (const XScale_type& XScale,
                   const YScale_type& YScale,
                   const ZScale_type& ZScale)
    : ::xml_schema::type (),
      XScale_ (XScale, this),
      YScale_ (YScale, this),
      ZScale_ (ZScale, this)
    {
    }

    CMMScalesType::
    CMMScalesType (::std::auto_ptr< XScale_type > XScale,
                   ::std::auto_ptr< YScale_type > YScale,
                   ::std::auto_ptr< ZScale_type > ZScale)
    : ::xml_schema::type (),
      XScale_ (XScale, this),
      YScale_ (YScale, this),
      ZScale_ (ZScale, this)
    {
    }

    CMMScalesType::
    CMMScalesType (const CMMScalesType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      XScale_ (x.XScale_, f, this),
      YScale_ (x.YScale_, f, this),
      ZScale_ (x.ZScale_, f, this)
    {
    }

    CMMScalesType::
    CMMScalesType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      XScale_ (this),
      YScale_ (this),
      ZScale_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CMMScalesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // XScale
        //
        if (n.name () == "XScale" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XScale_type > r (
            XScale_traits::create (i, f, this));

          if (!XScale_.present ())
          {
            this->XScale_.set (r);
            continue;
          }
        }

        // YScale
        //
        if (n.name () == "YScale" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YScale_type > r (
            YScale_traits::create (i, f, this));

          if (!YScale_.present ())
          {
            this->YScale_.set (r);
            continue;
          }
        }

        // ZScale
        //
        if (n.name () == "ZScale" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZScale_type > r (
            ZScale_traits::create (i, f, this));

          if (!ZScale_.present ())
          {
            this->ZScale_.set (r);
            continue;
          }
        }

        break;
      }

      if (!XScale_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XScale",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YScale_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YScale",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZScale_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZScale",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CMMScalesType* CMMScalesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CMMScalesType (*this, f, c);
    }

    CMMScalesType& CMMScalesType::
    operator= (const CMMScalesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->XScale_ = x.XScale_;
        this->YScale_ = x.YScale_;
        this->ZScale_ = x.ZScale_;
      }

      return *this;
    }

    CMMScalesType::
    ~CMMScalesType ()
    {
    }

    // CMMScaleType
    //

    CMMScaleType::
    CMMScaleType (const ScaleMaterial_type& ScaleMaterial,
                  const ScaleCoefficientOfExpansion_type& ScaleCoefficientOfExpansion,
                  const ScaleCoefficientOfExpansionUncertainty_type& ScaleCoefficientOfExpansionUncertainty,
                  const TypeOfScale_type& TypeOfScale,
                  const ScaleResolution_type& ScaleResolution)
    : ::xml_schema::type (),
      ScaleMaterial_ (ScaleMaterial, this),
      ScaleCoefficientOfExpansion_ (ScaleCoefficientOfExpansion, this),
      ScaleCoefficientOfExpansionUncertainty_ (ScaleCoefficientOfExpansionUncertainty, this),
      TypeOfScale_ (TypeOfScale, this),
      ScaleResolution_ (ScaleResolution, this)
    {
    }

    CMMScaleType::
    CMMScaleType (const ScaleMaterial_type& ScaleMaterial,
                  const ScaleCoefficientOfExpansion_type& ScaleCoefficientOfExpansion,
                  const ScaleCoefficientOfExpansionUncertainty_type& ScaleCoefficientOfExpansionUncertainty,
                  const TypeOfScale_type& TypeOfScale,
                  ::std::auto_ptr< ScaleResolution_type > ScaleResolution)
    : ::xml_schema::type (),
      ScaleMaterial_ (ScaleMaterial, this),
      ScaleCoefficientOfExpansion_ (ScaleCoefficientOfExpansion, this),
      ScaleCoefficientOfExpansionUncertainty_ (ScaleCoefficientOfExpansionUncertainty, this),
      TypeOfScale_ (TypeOfScale, this),
      ScaleResolution_ (ScaleResolution, this)
    {
    }

    CMMScaleType::
    CMMScaleType (const CMMScaleType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ScaleMaterial_ (x.ScaleMaterial_, f, this),
      ScaleCoefficientOfExpansion_ (x.ScaleCoefficientOfExpansion_, f, this),
      ScaleCoefficientOfExpansionUncertainty_ (x.ScaleCoefficientOfExpansionUncertainty_, f, this),
      TypeOfScale_ (x.TypeOfScale_, f, this),
      ScaleResolution_ (x.ScaleResolution_, f, this)
    {
    }

    CMMScaleType::
    CMMScaleType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ScaleMaterial_ (this),
      ScaleCoefficientOfExpansion_ (this),
      ScaleCoefficientOfExpansionUncertainty_ (this),
      TypeOfScale_ (this),
      ScaleResolution_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CMMScaleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ScaleMaterial
        //
        if (n.name () == "ScaleMaterial" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ScaleMaterial_type > r (
            ScaleMaterial_traits::create (i, f, this));

          if (!ScaleMaterial_.present ())
          {
            this->ScaleMaterial_.set (r);
            continue;
          }
        }

        // ScaleCoefficientOfExpansion
        //
        if (n.name () == "ScaleCoefficientOfExpansion" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!ScaleCoefficientOfExpansion_.present ())
          {
            this->ScaleCoefficientOfExpansion_.set (ScaleCoefficientOfExpansion_traits::create (i, f, this));
            continue;
          }
        }

        // ScaleCoefficientOfExpansionUncertainty
        //
        if (n.name () == "ScaleCoefficientOfExpansionUncertainty" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!ScaleCoefficientOfExpansionUncertainty_.present ())
          {
            this->ScaleCoefficientOfExpansionUncertainty_.set (ScaleCoefficientOfExpansionUncertainty_traits::create (i, f, this));
            continue;
          }
        }

        // TypeOfScale
        //
        if (n.name () == "TypeOfScale" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TypeOfScale_type > r (
            TypeOfScale_traits::create (i, f, this));

          if (!TypeOfScale_.present ())
          {
            this->TypeOfScale_.set (r);
            continue;
          }
        }

        // ScaleResolution
        //
        if (n.name () == "ScaleResolution" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ScaleResolution_type > r (
            ScaleResolution_traits::create (i, f, this));

          if (!ScaleResolution_.present ())
          {
            this->ScaleResolution_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ScaleMaterial_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ScaleMaterial",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ScaleCoefficientOfExpansion_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ScaleCoefficientOfExpansion",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ScaleCoefficientOfExpansionUncertainty_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ScaleCoefficientOfExpansionUncertainty",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!TypeOfScale_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "TypeOfScale",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ScaleResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ScaleResolution",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CMMScaleType* CMMScaleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CMMScaleType (*this, f, c);
    }

    CMMScaleType& CMMScaleType::
    operator= (const CMMScaleType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ScaleMaterial_ = x.ScaleMaterial_;
        this->ScaleCoefficientOfExpansion_ = x.ScaleCoefficientOfExpansion_;
        this->ScaleCoefficientOfExpansionUncertainty_ = x.ScaleCoefficientOfExpansionUncertainty_;
        this->TypeOfScale_ = x.TypeOfScale_;
        this->ScaleResolution_ = x.ScaleResolution_;
      }

      return *this;
    }

    CMMScaleType::
    ~CMMScaleType ()
    {
    }

    // CMMSpeedsType
    //

    CMMSpeedsType::
    CMMSpeedsType (const MaxXTraverseSpeed_type& MaxXTraverseSpeed,
                   const MaxYTraverseSpeed_type& MaxYTraverseSpeed,
                   const MaxZTraverseSpeed_type& MaxZTraverseSpeed,
                   const MaxXProbingSpeed_type& MaxXProbingSpeed,
                   const MaxYProbingSpeed_type& MaxYProbingSpeed,
                   const MaxZProbingSpeed_type& MaxZProbingSpeed)
    : ::xml_schema::type (),
      MaxXTraverseSpeed_ (MaxXTraverseSpeed, this),
      MaxYTraverseSpeed_ (MaxYTraverseSpeed, this),
      MaxZTraverseSpeed_ (MaxZTraverseSpeed, this),
      MaxXProbingSpeed_ (MaxXProbingSpeed, this),
      MaxYProbingSpeed_ (MaxYProbingSpeed, this),
      MaxZProbingSpeed_ (MaxZProbingSpeed, this)
    {
    }

    CMMSpeedsType::
    CMMSpeedsType (::std::auto_ptr< MaxXTraverseSpeed_type > MaxXTraverseSpeed,
                   ::std::auto_ptr< MaxYTraverseSpeed_type > MaxYTraverseSpeed,
                   ::std::auto_ptr< MaxZTraverseSpeed_type > MaxZTraverseSpeed,
                   ::std::auto_ptr< MaxXProbingSpeed_type > MaxXProbingSpeed,
                   ::std::auto_ptr< MaxYProbingSpeed_type > MaxYProbingSpeed,
                   ::std::auto_ptr< MaxZProbingSpeed_type > MaxZProbingSpeed)
    : ::xml_schema::type (),
      MaxXTraverseSpeed_ (MaxXTraverseSpeed, this),
      MaxYTraverseSpeed_ (MaxYTraverseSpeed, this),
      MaxZTraverseSpeed_ (MaxZTraverseSpeed, this),
      MaxXProbingSpeed_ (MaxXProbingSpeed, this),
      MaxYProbingSpeed_ (MaxYProbingSpeed, this),
      MaxZProbingSpeed_ (MaxZProbingSpeed, this)
    {
    }

    CMMSpeedsType::
    CMMSpeedsType (const CMMSpeedsType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxXTraverseSpeed_ (x.MaxXTraverseSpeed_, f, this),
      MaxYTraverseSpeed_ (x.MaxYTraverseSpeed_, f, this),
      MaxZTraverseSpeed_ (x.MaxZTraverseSpeed_, f, this),
      MaxXProbingSpeed_ (x.MaxXProbingSpeed_, f, this),
      MaxYProbingSpeed_ (x.MaxYProbingSpeed_, f, this),
      MaxZProbingSpeed_ (x.MaxZProbingSpeed_, f, this)
    {
    }

    CMMSpeedsType::
    CMMSpeedsType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxXTraverseSpeed_ (this),
      MaxYTraverseSpeed_ (this),
      MaxZTraverseSpeed_ (this),
      MaxXProbingSpeed_ (this),
      MaxYProbingSpeed_ (this),
      MaxZProbingSpeed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CMMSpeedsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MaxXTraverseSpeed
        //
        if (n.name () == "MaxXTraverseSpeed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxXTraverseSpeed_type > r (
            MaxXTraverseSpeed_traits::create (i, f, this));

          if (!MaxXTraverseSpeed_.present ())
          {
            this->MaxXTraverseSpeed_.set (r);
            continue;
          }
        }

        // MaxYTraverseSpeed
        //
        if (n.name () == "MaxYTraverseSpeed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxYTraverseSpeed_type > r (
            MaxYTraverseSpeed_traits::create (i, f, this));

          if (!MaxYTraverseSpeed_.present ())
          {
            this->MaxYTraverseSpeed_.set (r);
            continue;
          }
        }

        // MaxZTraverseSpeed
        //
        if (n.name () == "MaxZTraverseSpeed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxZTraverseSpeed_type > r (
            MaxZTraverseSpeed_traits::create (i, f, this));

          if (!MaxZTraverseSpeed_.present ())
          {
            this->MaxZTraverseSpeed_.set (r);
            continue;
          }
        }

        // MaxXProbingSpeed
        //
        if (n.name () == "MaxXProbingSpeed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxXProbingSpeed_type > r (
            MaxXProbingSpeed_traits::create (i, f, this));

          if (!MaxXProbingSpeed_.present ())
          {
            this->MaxXProbingSpeed_.set (r);
            continue;
          }
        }

        // MaxYProbingSpeed
        //
        if (n.name () == "MaxYProbingSpeed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxYProbingSpeed_type > r (
            MaxYProbingSpeed_traits::create (i, f, this));

          if (!MaxYProbingSpeed_.present ())
          {
            this->MaxYProbingSpeed_.set (r);
            continue;
          }
        }

        // MaxZProbingSpeed
        //
        if (n.name () == "MaxZProbingSpeed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxZProbingSpeed_type > r (
            MaxZProbingSpeed_traits::create (i, f, this));

          if (!MaxZProbingSpeed_.present ())
          {
            this->MaxZProbingSpeed_.set (r);
            continue;
          }
        }

        break;
      }

      if (!MaxXTraverseSpeed_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MaxXTraverseSpeed",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MaxYTraverseSpeed_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MaxYTraverseSpeed",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MaxZTraverseSpeed_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MaxZTraverseSpeed",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MaxXProbingSpeed_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MaxXProbingSpeed",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MaxYProbingSpeed_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MaxYProbingSpeed",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MaxZProbingSpeed_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MaxZProbingSpeed",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CMMSpeedsType* CMMSpeedsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CMMSpeedsType (*this, f, c);
    }

    CMMSpeedsType& CMMSpeedsType::
    operator= (const CMMSpeedsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MaxXTraverseSpeed_ = x.MaxXTraverseSpeed_;
        this->MaxYTraverseSpeed_ = x.MaxYTraverseSpeed_;
        this->MaxZTraverseSpeed_ = x.MaxZTraverseSpeed_;
        this->MaxXProbingSpeed_ = x.MaxXProbingSpeed_;
        this->MaxYProbingSpeed_ = x.MaxYProbingSpeed_;
        this->MaxZProbingSpeed_ = x.MaxZProbingSpeed_;
      }

      return *this;
    }

    CMMSpeedsType::
    ~CMMSpeedsType ()
    {
    }

    // GageDeviceType
    //

    GageDeviceType::
    GageDeviceType (const Name_type& Name,
                    const id_type& id)
    : ::xsd::qif2::MeasurementDeviceType (Name,
                                          id)
    {
    }

    GageDeviceType::
    GageDeviceType (const GageDeviceType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementDeviceType (x, f, c)
    {
    }

    GageDeviceType::
    GageDeviceType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementDeviceType (e, f, c)
    {
    }

    GageDeviceType* GageDeviceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GageDeviceType (*this, f, c);
    }

    GageDeviceType::
    ~GageDeviceType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, GageDeviceType >
    _xsd_GageDeviceType_type_factory_init (
      "GageDeviceType",
      "http://qifstandards.org/xsd/qif2");

    // ManualDeviceType
    //

    ManualDeviceType::
    ManualDeviceType (const Name_type& Name,
                      const id_type& id)
    : ::xsd::qif2::MeasurementDeviceType (Name,
                                          id)
    {
    }

    ManualDeviceType::
    ManualDeviceType (const ManualDeviceType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementDeviceType (x, f, c)
    {
    }

    ManualDeviceType::
    ManualDeviceType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementDeviceType (e, f, c)
    {
    }

    ManualDeviceType* ManualDeviceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ManualDeviceType (*this, f, c);
    }

    ManualDeviceType::
    ~ManualDeviceType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ManualDeviceType >
    _xsd_ManualDeviceType_type_factory_init (
      "ManualDeviceType",
      "http://qifstandards.org/xsd/qif2");

    // CaliperType
    //

    CaliperType::
    CaliperType (const Name_type& Name,
                 const id_type& id)
    : ::xsd::qif2::ManualDeviceType (Name,
                                     id),
      Resolution_ (this),
      Accuracy_ (this),
      MinMeasurement_ (this),
      MaxMeasurement_ (this),
      CanMeasureInnerD_ (this),
      CanMeasureOuterD_ (this),
      CanMeasureDepth_ (this)
    {
    }

    CaliperType::
    CaliperType (const CaliperType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::ManualDeviceType (x, f, c),
      Resolution_ (x.Resolution_, f, this),
      Accuracy_ (x.Accuracy_, f, this),
      MinMeasurement_ (x.MinMeasurement_, f, this),
      MaxMeasurement_ (x.MaxMeasurement_, f, this),
      CanMeasureInnerD_ (x.CanMeasureInnerD_, f, this),
      CanMeasureOuterD_ (x.CanMeasureOuterD_, f, this),
      CanMeasureDepth_ (x.CanMeasureDepth_, f, this)
    {
    }

    CaliperType::
    CaliperType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::ManualDeviceType (e, f | ::xml_schema::flags::base, c),
      Resolution_ (this),
      Accuracy_ (this),
      MinMeasurement_ (this),
      MaxMeasurement_ (this),
      CanMeasureInnerD_ (this),
      CanMeasureOuterD_ (this),
      CanMeasureDepth_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CaliperType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ManualDeviceType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Resolution
        //
        if (n.name () == "Resolution" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Resolution_type > r (
            Resolution_traits::create (i, f, this));

          if (!this->Resolution_)
          {
            this->Resolution_.set (r);
            continue;
          }
        }

        // Accuracy
        //
        if (n.name () == "Accuracy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Accuracy_type > r (
            Accuracy_traits::create (i, f, this));

          if (!this->Accuracy_)
          {
            this->Accuracy_.set (r);
            continue;
          }
        }

        // MinMeasurement
        //
        if (n.name () == "MinMeasurement" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinMeasurement_type > r (
            MinMeasurement_traits::create (i, f, this));

          if (!this->MinMeasurement_)
          {
            this->MinMeasurement_.set (r);
            continue;
          }
        }

        // MaxMeasurement
        //
        if (n.name () == "MaxMeasurement" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxMeasurement_type > r (
            MaxMeasurement_traits::create (i, f, this));

          if (!this->MaxMeasurement_)
          {
            this->MaxMeasurement_.set (r);
            continue;
          }
        }

        // CanMeasureInnerD
        //
        if (n.name () == "CanMeasureInnerD" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->CanMeasureInnerD_)
          {
            this->CanMeasureInnerD_.set (CanMeasureInnerD_traits::create (i, f, this));
            continue;
          }
        }

        // CanMeasureOuterD
        //
        if (n.name () == "CanMeasureOuterD" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->CanMeasureOuterD_)
          {
            this->CanMeasureOuterD_.set (CanMeasureOuterD_traits::create (i, f, this));
            continue;
          }
        }

        // CanMeasureDepth
        //
        if (n.name () == "CanMeasureDepth" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->CanMeasureDepth_)
          {
            this->CanMeasureDepth_.set (CanMeasureDepth_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }
    }

    CaliperType* CaliperType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CaliperType (*this, f, c);
    }

    CaliperType& CaliperType::
    operator= (const CaliperType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ManualDeviceType& > (*this) = x;
        this->Resolution_ = x.Resolution_;
        this->Accuracy_ = x.Accuracy_;
        this->MinMeasurement_ = x.MinMeasurement_;
        this->MaxMeasurement_ = x.MaxMeasurement_;
        this->CanMeasureInnerD_ = x.CanMeasureInnerD_;
        this->CanMeasureOuterD_ = x.CanMeasureOuterD_;
        this->CanMeasureDepth_ = x.CanMeasureDepth_;
      }

      return *this;
    }

    CaliperType::
    ~CaliperType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CaliperType >
    _xsd_CaliperType_type_factory_init (
      "CaliperType",
      "http://qifstandards.org/xsd/qif2");

    // CMMDirectionEnumType
    //

    CMMDirectionEnumType::
    CMMDirectionEnumType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_CMMDirectionEnumType_convert ();
    }

    CMMDirectionEnumType::
    CMMDirectionEnumType (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_CMMDirectionEnumType_convert ();
    }

    CMMDirectionEnumType::
    CMMDirectionEnumType (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_CMMDirectionEnumType_convert ();
    }

    CMMDirectionEnumType* CMMDirectionEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CMMDirectionEnumType (*this, f, c);
    }

    CMMDirectionEnumType::value CMMDirectionEnumType::
    _xsd_CMMDirectionEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CMMDirectionEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_CMMDirectionEnumType_indexes_,
                        _xsd_CMMDirectionEnumType_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_CMMDirectionEnumType_indexes_ + 6 || _xsd_CMMDirectionEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const CMMDirectionEnumType::
    _xsd_CMMDirectionEnumType_literals_[6] =
    {
      "RIGHT",
      "LEFT",
      "FRONT",
      "BACK",
      "UP",
      "DOWN"
    };

    const CMMDirectionEnumType::value CMMDirectionEnumType::
    _xsd_CMMDirectionEnumType_indexes_[6] =
    {
      ::xsd::qif2::CMMDirectionEnumType::BACK,
      ::xsd::qif2::CMMDirectionEnumType::DOWN,
      ::xsd::qif2::CMMDirectionEnumType::FRONT,
      ::xsd::qif2::CMMDirectionEnumType::LEFT,
      ::xsd::qif2::CMMDirectionEnumType::RIGHT,
      ::xsd::qif2::CMMDirectionEnumType::UP
    };

    // CMMGeometryType
    //

    CMMGeometryType::
    CMMGeometryType ()
    : ::xml_schema::type (),
      CMMGeometryEnum_ (this),
      OtherCMMGeometry_ (this)
    {
    }

    CMMGeometryType::
    CMMGeometryType (const CMMGeometryType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CMMGeometryEnum_ (x.CMMGeometryEnum_, f, this),
      OtherCMMGeometry_ (x.OtherCMMGeometry_, f, this)
    {
    }

    CMMGeometryType::
    CMMGeometryType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CMMGeometryEnum_ (this),
      OtherCMMGeometry_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CMMGeometryType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CMMGeometryEnum
        //
        if (n.name () == "CMMGeometryEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CMMGeometryEnum_type > r (
            CMMGeometryEnum_traits::create (i, f, this));

          if (!this->CMMGeometryEnum_)
          {
            this->CMMGeometryEnum_.set (r);
            continue;
          }
        }

        // OtherCMMGeometry
        //
        if (n.name () == "OtherCMMGeometry" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherCMMGeometry_type > r (
            OtherCMMGeometry_traits::create (i, f, this));

          if (!this->OtherCMMGeometry_)
          {
            this->OtherCMMGeometry_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CMMGeometryType* CMMGeometryType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CMMGeometryType (*this, f, c);
    }

    CMMGeometryType& CMMGeometryType::
    operator= (const CMMGeometryType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CMMGeometryEnum_ = x.CMMGeometryEnum_;
        this->OtherCMMGeometry_ = x.OtherCMMGeometry_;
      }

      return *this;
    }

    CMMGeometryType::
    ~CMMGeometryType ()
    {
    }

    // CMMGeometryEnumType
    //

    CMMGeometryEnumType::
    CMMGeometryEnumType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_CMMGeometryEnumType_convert ();
    }

    CMMGeometryEnumType::
    CMMGeometryEnumType (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_CMMGeometryEnumType_convert ();
    }

    CMMGeometryEnumType::
    CMMGeometryEnumType (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_CMMGeometryEnumType_convert ();
    }

    CMMGeometryEnumType* CMMGeometryEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CMMGeometryEnumType (*this, f, c);
    }

    CMMGeometryEnumType::value CMMGeometryEnumType::
    _xsd_CMMGeometryEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CMMGeometryEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_CMMGeometryEnumType_indexes_,
                        _xsd_CMMGeometryEnumType_indexes_ + 8,
                        *this,
                        c));

      if (i == _xsd_CMMGeometryEnumType_indexes_ + 8 || _xsd_CMMGeometryEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const CMMGeometryEnumType::
    _xsd_CMMGeometryEnumType_literals_[8] =
    {
      "CANTILEVER",
      "BRIDGEMOVINGBRIDGE",
      "BRIDGEMOVINGTABLE",
      "COLUMN",
      "GANTRY",
      "HORIZONTALARMMOVINGARM",
      "HORIZONTALARMMOVINGTABLE",
      "ARTICULATEDARM"
    };

    const CMMGeometryEnumType::value CMMGeometryEnumType::
    _xsd_CMMGeometryEnumType_indexes_[8] =
    {
      ::xsd::qif2::CMMGeometryEnumType::ARTICULATEDARM,
      ::xsd::qif2::CMMGeometryEnumType::BRIDGEMOVINGBRIDGE,
      ::xsd::qif2::CMMGeometryEnumType::BRIDGEMOVINGTABLE,
      ::xsd::qif2::CMMGeometryEnumType::CANTILEVER,
      ::xsd::qif2::CMMGeometryEnumType::COLUMN,
      ::xsd::qif2::CMMGeometryEnumType::GANTRY,
      ::xsd::qif2::CMMGeometryEnumType::HORIZONTALARMMOVINGARM,
      ::xsd::qif2::CMMGeometryEnumType::HORIZONTALARMMOVINGTABLE
    };

    // CMMAxisDirectionsType
    //

    CMMAxisDirectionsType::
    CMMAxisDirectionsType (const XAxisDirection_type& XAxisDirection,
                           const YAxisDirection_type& YAxisDirection,
                           const ZAxisDirection_type& ZAxisDirection)
    : ::xml_schema::type (),
      XAxisDirection_ (XAxisDirection, this),
      YAxisDirection_ (YAxisDirection, this),
      ZAxisDirection_ (ZAxisDirection, this)
    {
    }

    CMMAxisDirectionsType::
    CMMAxisDirectionsType (const CMMAxisDirectionsType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      XAxisDirection_ (x.XAxisDirection_, f, this),
      YAxisDirection_ (x.YAxisDirection_, f, this),
      ZAxisDirection_ (x.ZAxisDirection_, f, this)
    {
    }

    CMMAxisDirectionsType::
    CMMAxisDirectionsType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      XAxisDirection_ (this),
      YAxisDirection_ (this),
      ZAxisDirection_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CMMAxisDirectionsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // XAxisDirection
        //
        if (n.name () == "XAxisDirection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XAxisDirection_type > r (
            XAxisDirection_traits::create (i, f, this));

          if (!XAxisDirection_.present ())
          {
            this->XAxisDirection_.set (r);
            continue;
          }
        }

        // YAxisDirection
        //
        if (n.name () == "YAxisDirection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YAxisDirection_type > r (
            YAxisDirection_traits::create (i, f, this));

          if (!YAxisDirection_.present ())
          {
            this->YAxisDirection_.set (r);
            continue;
          }
        }

        // ZAxisDirection
        //
        if (n.name () == "ZAxisDirection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZAxisDirection_type > r (
            ZAxisDirection_traits::create (i, f, this));

          if (!ZAxisDirection_.present ())
          {
            this->ZAxisDirection_.set (r);
            continue;
          }
        }

        break;
      }

      if (!XAxisDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XAxisDirection",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YAxisDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YAxisDirection",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZAxisDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZAxisDirection",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CMMAxisDirectionsType* CMMAxisDirectionsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CMMAxisDirectionsType (*this, f, c);
    }

    CMMAxisDirectionsType& CMMAxisDirectionsType::
    operator= (const CMMAxisDirectionsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->XAxisDirection_ = x.XAxisDirection_;
        this->YAxisDirection_ = x.YAxisDirection_;
        this->ZAxisDirection_ = x.ZAxisDirection_;
      }

      return *this;
    }

    CMMAxisDirectionsType::
    ~CMMAxisDirectionsType ()
    {
    }

    // WorkingVolumeType
    //

    WorkingVolumeType::
    WorkingVolumeType (const XAxisLength_type& XAxisLength,
                       const YAxisLength_type& YAxisLength,
                       const ZAxisLength_type& ZAxisLength)
    : ::xml_schema::type (),
      XAxisLength_ (XAxisLength, this),
      YAxisLength_ (YAxisLength, this),
      ZAxisLength_ (ZAxisLength, this)
    {
    }

    WorkingVolumeType::
    WorkingVolumeType (::std::auto_ptr< XAxisLength_type > XAxisLength,
                       ::std::auto_ptr< YAxisLength_type > YAxisLength,
                       ::std::auto_ptr< ZAxisLength_type > ZAxisLength)
    : ::xml_schema::type (),
      XAxisLength_ (XAxisLength, this),
      YAxisLength_ (YAxisLength, this),
      ZAxisLength_ (ZAxisLength, this)
    {
    }

    WorkingVolumeType::
    WorkingVolumeType (const WorkingVolumeType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      XAxisLength_ (x.XAxisLength_, f, this),
      YAxisLength_ (x.YAxisLength_, f, this),
      ZAxisLength_ (x.ZAxisLength_, f, this)
    {
    }

    WorkingVolumeType::
    WorkingVolumeType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      XAxisLength_ (this),
      YAxisLength_ (this),
      ZAxisLength_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void WorkingVolumeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // XAxisLength
        //
        if (n.name () == "XAxisLength" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XAxisLength_type > r (
            XAxisLength_traits::create (i, f, this));

          if (!XAxisLength_.present ())
          {
            this->XAxisLength_.set (r);
            continue;
          }
        }

        // YAxisLength
        //
        if (n.name () == "YAxisLength" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YAxisLength_type > r (
            YAxisLength_traits::create (i, f, this));

          if (!YAxisLength_.present ())
          {
            this->YAxisLength_.set (r);
            continue;
          }
        }

        // ZAxisLength
        //
        if (n.name () == "ZAxisLength" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZAxisLength_type > r (
            ZAxisLength_traits::create (i, f, this));

          if (!ZAxisLength_.present ())
          {
            this->ZAxisLength_.set (r);
            continue;
          }
        }

        break;
      }

      if (!XAxisLength_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XAxisLength",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YAxisLength_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YAxisLength",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZAxisLength_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZAxisLength",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    WorkingVolumeType* WorkingVolumeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WorkingVolumeType (*this, f, c);
    }

    WorkingVolumeType& WorkingVolumeType::
    operator= (const WorkingVolumeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->XAxisLength_ = x.XAxisLength_;
        this->YAxisLength_ = x.YAxisLength_;
        this->ZAxisLength_ = x.ZAxisLength_;
      }

      return *this;
    }

    WorkingVolumeType::
    ~WorkingVolumeType ()
    {
    }

    // EffectiveWorkingVolumeType
    //

    EffectiveWorkingVolumeType::
    EffectiveWorkingVolumeType (const MinPoint_type& MinPoint,
                                const MaxPoint_type& MaxPoint)
    : ::xml_schema::type (),
      MinPoint_ (MinPoint, this),
      MaxPoint_ (MaxPoint, this)
    {
    }

    EffectiveWorkingVolumeType::
    EffectiveWorkingVolumeType (::std::auto_ptr< MinPoint_type > MinPoint,
                                ::std::auto_ptr< MaxPoint_type > MaxPoint)
    : ::xml_schema::type (),
      MinPoint_ (MinPoint, this),
      MaxPoint_ (MaxPoint, this)
    {
    }

    EffectiveWorkingVolumeType::
    EffectiveWorkingVolumeType (const EffectiveWorkingVolumeType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MinPoint_ (x.MinPoint_, f, this),
      MaxPoint_ (x.MaxPoint_, f, this)
    {
    }

    EffectiveWorkingVolumeType::
    EffectiveWorkingVolumeType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MinPoint_ (this),
      MaxPoint_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EffectiveWorkingVolumeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MinPoint
        //
        if (n.name () == "MinPoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinPoint_type > r (
            MinPoint_traits::create (i, f, this));

          if (!MinPoint_.present ())
          {
            this->MinPoint_.set (r);
            continue;
          }
        }

        // MaxPoint
        //
        if (n.name () == "MaxPoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxPoint_type > r (
            MaxPoint_traits::create (i, f, this));

          if (!MaxPoint_.present ())
          {
            this->MaxPoint_.set (r);
            continue;
          }
        }

        break;
      }

      if (!MinPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MinPoint",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MaxPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MaxPoint",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EffectiveWorkingVolumeType* EffectiveWorkingVolumeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EffectiveWorkingVolumeType (*this, f, c);
    }

    EffectiveWorkingVolumeType& EffectiveWorkingVolumeType::
    operator= (const EffectiveWorkingVolumeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MinPoint_ = x.MinPoint_;
        this->MaxPoint_ = x.MaxPoint_;
      }

      return *this;
    }

    EffectiveWorkingVolumeType::
    ~EffectiveWorkingVolumeType ()
    {
    }

    // RotaryTableType
    //

    RotaryTableType::
    RotaryTableType (const LocationOnCMM_type& LocationOnCMM,
                     const AxisDirection_type& AxisDirection,
                     const ZeroIndexDirection_type& ZeroIndexDirection,
                     const TableRadius_type& TableRadius,
                     const TableErrors_type& TableErrors)
    : ::xml_schema::type (),
      LocationOnCMM_ (LocationOnCMM, this),
      AxisDirection_ (AxisDirection, this),
      ZeroIndexDirection_ (ZeroIndexDirection, this),
      TableRadius_ (TableRadius, this),
      TableErrors_ (TableErrors, this)
    {
    }

    RotaryTableType::
    RotaryTableType (::std::auto_ptr< LocationOnCMM_type > LocationOnCMM,
                     ::std::auto_ptr< AxisDirection_type > AxisDirection,
                     ::std::auto_ptr< ZeroIndexDirection_type > ZeroIndexDirection,
                     ::std::auto_ptr< TableRadius_type > TableRadius,
                     ::std::auto_ptr< TableErrors_type > TableErrors)
    : ::xml_schema::type (),
      LocationOnCMM_ (LocationOnCMM, this),
      AxisDirection_ (AxisDirection, this),
      ZeroIndexDirection_ (ZeroIndexDirection, this),
      TableRadius_ (TableRadius, this),
      TableErrors_ (TableErrors, this)
    {
    }

    RotaryTableType::
    RotaryTableType (const RotaryTableType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      LocationOnCMM_ (x.LocationOnCMM_, f, this),
      AxisDirection_ (x.AxisDirection_, f, this),
      ZeroIndexDirection_ (x.ZeroIndexDirection_, f, this),
      TableRadius_ (x.TableRadius_, f, this),
      TableErrors_ (x.TableErrors_, f, this)
    {
    }

    RotaryTableType::
    RotaryTableType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      LocationOnCMM_ (this),
      AxisDirection_ (this),
      ZeroIndexDirection_ (this),
      TableRadius_ (this),
      TableErrors_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void RotaryTableType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // LocationOnCMM
        //
        if (n.name () == "LocationOnCMM" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LocationOnCMM_type > r (
            LocationOnCMM_traits::create (i, f, this));

          if (!LocationOnCMM_.present ())
          {
            this->LocationOnCMM_.set (r);
            continue;
          }
        }

        // AxisDirection
        //
        if (n.name () == "AxisDirection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AxisDirection_type > r (
            AxisDirection_traits::create (i, f, this));

          if (!AxisDirection_.present ())
          {
            this->AxisDirection_.set (r);
            continue;
          }
        }

        // ZeroIndexDirection
        //
        if (n.name () == "ZeroIndexDirection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZeroIndexDirection_type > r (
            ZeroIndexDirection_traits::create (i, f, this));

          if (!ZeroIndexDirection_.present ())
          {
            this->ZeroIndexDirection_.set (r);
            continue;
          }
        }

        // TableRadius
        //
        if (n.name () == "TableRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TableRadius_type > r (
            TableRadius_traits::create (i, f, this));

          if (!TableRadius_.present ())
          {
            this->TableRadius_.set (r);
            continue;
          }
        }

        // TableErrors
        //
        if (n.name () == "TableErrors" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TableErrors_type > r (
            TableErrors_traits::create (i, f, this));

          if (!TableErrors_.present ())
          {
            this->TableErrors_.set (r);
            continue;
          }
        }

        break;
      }

      if (!LocationOnCMM_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "LocationOnCMM",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!AxisDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "AxisDirection",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZeroIndexDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZeroIndexDirection",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!TableRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "TableRadius",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!TableErrors_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "TableErrors",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    RotaryTableType* RotaryTableType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RotaryTableType (*this, f, c);
    }

    RotaryTableType& RotaryTableType::
    operator= (const RotaryTableType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->LocationOnCMM_ = x.LocationOnCMM_;
        this->AxisDirection_ = x.AxisDirection_;
        this->ZeroIndexDirection_ = x.ZeroIndexDirection_;
        this->TableRadius_ = x.TableRadius_;
        this->TableErrors_ = x.TableErrors_;
      }

      return *this;
    }

    RotaryTableType::
    ~RotaryTableType ()
    {
    }

    // TableErrorsType
    //

    TableErrorsType::
    TableErrorsType (const AxialError_type& AxialError,
                     const RadialError_type& RadialError,
                     const TangentialError_type& TangentialError)
    : ::xml_schema::type (),
      AxialError_ (AxialError, this),
      RadialError_ (RadialError, this),
      TangentialError_ (TangentialError, this)
    {
    }

    TableErrorsType::
    TableErrorsType (::std::auto_ptr< AxialError_type > AxialError,
                     ::std::auto_ptr< RadialError_type > RadialError,
                     ::std::auto_ptr< TangentialError_type > TangentialError)
    : ::xml_schema::type (),
      AxialError_ (AxialError, this),
      RadialError_ (RadialError, this),
      TangentialError_ (TangentialError, this)
    {
    }

    TableErrorsType::
    TableErrorsType (const TableErrorsType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AxialError_ (x.AxialError_, f, this),
      RadialError_ (x.RadialError_, f, this),
      TangentialError_ (x.TangentialError_, f, this)
    {
    }

    TableErrorsType::
    TableErrorsType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AxialError_ (this),
      RadialError_ (this),
      TangentialError_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TableErrorsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // AxialError
        //
        if (n.name () == "AxialError" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AxialError_type > r (
            AxialError_traits::create (i, f, this));

          if (!AxialError_.present ())
          {
            this->AxialError_.set (r);
            continue;
          }
        }

        // RadialError
        //
        if (n.name () == "RadialError" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RadialError_type > r (
            RadialError_traits::create (i, f, this));

          if (!RadialError_.present ())
          {
            this->RadialError_.set (r);
            continue;
          }
        }

        // TangentialError
        //
        if (n.name () == "TangentialError" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TangentialError_type > r (
            TangentialError_traits::create (i, f, this));

          if (!TangentialError_.present ())
          {
            this->TangentialError_.set (r);
            continue;
          }
        }

        break;
      }

      if (!AxialError_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "AxialError",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!RadialError_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "RadialError",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!TangentialError_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "TangentialError",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TableErrorsType* TableErrorsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TableErrorsType (*this, f, c);
    }

    TableErrorsType& TableErrorsType::
    operator= (const TableErrorsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->AxialError_ = x.AxialError_;
        this->RadialError_ = x.RadialError_;
        this->TangentialError_ = x.TangentialError_;
      }

      return *this;
    }

    TableErrorsType::
    ~TableErrorsType ()
    {
    }

    // ResolutionType
    //

    ResolutionType::
    ResolutionType ()
    : ::xml_schema::type (),
      CombinedResolution_ (this),
      XYZResolution_ (this)
    {
    }

    ResolutionType::
    ResolutionType (const ResolutionType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CombinedResolution_ (x.CombinedResolution_, f, this),
      XYZResolution_ (x.XYZResolution_, f, this)
    {
    }

    ResolutionType::
    ResolutionType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CombinedResolution_ (this),
      XYZResolution_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ResolutionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CombinedResolution
        //
        if (n.name () == "CombinedResolution" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CombinedResolution_type > r (
            CombinedResolution_traits::create (i, f, this));

          if (!this->CombinedResolution_)
          {
            this->CombinedResolution_.set (r);
            continue;
          }
        }

        // XYZResolution
        //
        if (n.name () == "XYZResolution" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XYZResolution_type > r (
            XYZResolution_traits::create (i, f, this));

          if (!this->XYZResolution_)
          {
            this->XYZResolution_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ResolutionType* ResolutionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ResolutionType (*this, f, c);
    }

    ResolutionType& ResolutionType::
    operator= (const ResolutionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CombinedResolution_ = x.CombinedResolution_;
        this->XYZResolution_ = x.XYZResolution_;
      }

      return *this;
    }

    ResolutionType::
    ~ResolutionType ()
    {
    }

    // XYZResolutionType
    //

    XYZResolutionType::
    XYZResolutionType (const XResolution_type& XResolution,
                       const YResolution_type& YResolution,
                       const ZResolution_type& ZResolution)
    : ::xml_schema::type (),
      XResolution_ (XResolution, this),
      YResolution_ (YResolution, this),
      ZResolution_ (ZResolution, this)
    {
    }

    XYZResolutionType::
    XYZResolutionType (::std::auto_ptr< XResolution_type > XResolution,
                       ::std::auto_ptr< YResolution_type > YResolution,
                       ::std::auto_ptr< ZResolution_type > ZResolution)
    : ::xml_schema::type (),
      XResolution_ (XResolution, this),
      YResolution_ (YResolution, this),
      ZResolution_ (ZResolution, this)
    {
    }

    XYZResolutionType::
    XYZResolutionType (const XYZResolutionType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      XResolution_ (x.XResolution_, f, this),
      YResolution_ (x.YResolution_, f, this),
      ZResolution_ (x.ZResolution_, f, this)
    {
    }

    XYZResolutionType::
    XYZResolutionType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      XResolution_ (this),
      YResolution_ (this),
      ZResolution_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void XYZResolutionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // XResolution
        //
        if (n.name () == "XResolution" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XResolution_type > r (
            XResolution_traits::create (i, f, this));

          if (!XResolution_.present ())
          {
            this->XResolution_.set (r);
            continue;
          }
        }

        // YResolution
        //
        if (n.name () == "YResolution" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YResolution_type > r (
            YResolution_traits::create (i, f, this));

          if (!YResolution_.present ())
          {
            this->YResolution_.set (r);
            continue;
          }
        }

        // ZResolution
        //
        if (n.name () == "ZResolution" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZResolution_type > r (
            ZResolution_traits::create (i, f, this));

          if (!ZResolution_.present ())
          {
            this->ZResolution_.set (r);
            continue;
          }
        }

        break;
      }

      if (!XResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XResolution",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YResolution",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZResolution",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    XYZResolutionType* XYZResolutionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class XYZResolutionType (*this, f, c);
    }

    XYZResolutionType& XYZResolutionType::
    operator= (const XYZResolutionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->XResolution_ = x.XResolution_;
        this->YResolution_ = x.YResolution_;
        this->ZResolution_ = x.ZResolution_;
      }

      return *this;
    }

    XYZResolutionType::
    ~XYZResolutionType ()
    {
    }

    // CMMAccuracyTestBaseType
    //

    CMMAccuracyTestBaseType::
    CMMAccuracyTestBaseType ()
    : ::xml_schema::type ()
    {
    }

    CMMAccuracyTestBaseType::
    CMMAccuracyTestBaseType (const CMMAccuracyTestBaseType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    CMMAccuracyTestBaseType::
    CMMAccuracyTestBaseType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    CMMAccuracyTestBaseType::
    CMMAccuracyTestBaseType (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    CMMAccuracyTestBaseType::
    CMMAccuracyTestBaseType (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    CMMAccuracyTestBaseType* CMMAccuracyTestBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CMMAccuracyTestBaseType (*this, f, c);
    }

    CMMAccuracyTestBaseType::
    ~CMMAccuracyTestBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CMMAccuracyTestBaseType >
    _xsd_CMMAccuracyTestBaseType_type_factory_init (
      "CMMAccuracyTestBaseType",
      "http://qifstandards.org/xsd/qif2");

    // FPSTestType
    //

    FPSTestType::
    FPSTestType (const XLinearity_type& XLinearity,
                 const YLinearity_type& YLinearity,
                 const ZLinearity_type& ZLinearity,
                 const XAxisRoll_type& XAxisRoll,
                 const XAxisPitch_type& XAxisPitch,
                 const XAxisYaw_type& XAxisYaw,
                 const YAxisRoll_type& YAxisRoll,
                 const YAxisPitch_type& YAxisPitch,
                 const YAxisYaw_type& YAxisYaw,
                 const ZAxisRoll_type& ZAxisRoll,
                 const ZAxisPitch_type& ZAxisPitch,
                 const ZAxisYaw_type& ZAxisYaw,
                 const XAxisStraightnessY_type& XAxisStraightnessY,
                 const XAxisStraightnessZ_type& XAxisStraightnessZ,
                 const YAxisStraightnessX_type& YAxisStraightnessX,
                 const YAxisStraightnessZ_type& YAxisStraightnessZ,
                 const ZAxisStraightnessX_type& ZAxisStraightnessX,
                 const ZAxisStraightnessY_type& ZAxisStraightnessY,
                 const XYSquareness_type& XYSquareness,
                 const XZSquareness_type& XZSquareness,
                 const YZSquareness_type& YZSquareness)
    : ::xsd::qif2::CMMAccuracyTestBaseType (),
      XLinearity_ (XLinearity, this),
      YLinearity_ (YLinearity, this),
      ZLinearity_ (ZLinearity, this),
      XAxisRoll_ (XAxisRoll, this),
      XAxisPitch_ (XAxisPitch, this),
      XAxisYaw_ (XAxisYaw, this),
      YAxisRoll_ (YAxisRoll, this),
      YAxisPitch_ (YAxisPitch, this),
      YAxisYaw_ (YAxisYaw, this),
      ZAxisRoll_ (ZAxisRoll, this),
      ZAxisPitch_ (ZAxisPitch, this),
      ZAxisYaw_ (ZAxisYaw, this),
      XAxisStraightnessY_ (XAxisStraightnessY, this),
      XAxisStraightnessZ_ (XAxisStraightnessZ, this),
      YAxisStraightnessX_ (YAxisStraightnessX, this),
      YAxisStraightnessZ_ (YAxisStraightnessZ, this),
      ZAxisStraightnessX_ (ZAxisStraightnessX, this),
      ZAxisStraightnessY_ (ZAxisStraightnessY, this),
      XYSquareness_ (XYSquareness, this),
      XZSquareness_ (XZSquareness, this),
      YZSquareness_ (YZSquareness, this)
    {
    }

    FPSTestType::
    FPSTestType (::std::auto_ptr< XLinearity_type > XLinearity,
                 ::std::auto_ptr< YLinearity_type > YLinearity,
                 ::std::auto_ptr< ZLinearity_type > ZLinearity,
                 ::std::auto_ptr< XAxisRoll_type > XAxisRoll,
                 ::std::auto_ptr< XAxisPitch_type > XAxisPitch,
                 ::std::auto_ptr< XAxisYaw_type > XAxisYaw,
                 ::std::auto_ptr< YAxisRoll_type > YAxisRoll,
                 ::std::auto_ptr< YAxisPitch_type > YAxisPitch,
                 ::std::auto_ptr< YAxisYaw_type > YAxisYaw,
                 ::std::auto_ptr< ZAxisRoll_type > ZAxisRoll,
                 ::std::auto_ptr< ZAxisPitch_type > ZAxisPitch,
                 ::std::auto_ptr< ZAxisYaw_type > ZAxisYaw,
                 ::std::auto_ptr< XAxisStraightnessY_type > XAxisStraightnessY,
                 ::std::auto_ptr< XAxisStraightnessZ_type > XAxisStraightnessZ,
                 ::std::auto_ptr< YAxisStraightnessX_type > YAxisStraightnessX,
                 ::std::auto_ptr< YAxisStraightnessZ_type > YAxisStraightnessZ,
                 ::std::auto_ptr< ZAxisStraightnessX_type > ZAxisStraightnessX,
                 ::std::auto_ptr< ZAxisStraightnessY_type > ZAxisStraightnessY,
                 const XYSquareness_type& XYSquareness,
                 const XZSquareness_type& XZSquareness,
                 const YZSquareness_type& YZSquareness)
    : ::xsd::qif2::CMMAccuracyTestBaseType (),
      XLinearity_ (XLinearity, this),
      YLinearity_ (YLinearity, this),
      ZLinearity_ (ZLinearity, this),
      XAxisRoll_ (XAxisRoll, this),
      XAxisPitch_ (XAxisPitch, this),
      XAxisYaw_ (XAxisYaw, this),
      YAxisRoll_ (YAxisRoll, this),
      YAxisPitch_ (YAxisPitch, this),
      YAxisYaw_ (YAxisYaw, this),
      ZAxisRoll_ (ZAxisRoll, this),
      ZAxisPitch_ (ZAxisPitch, this),
      ZAxisYaw_ (ZAxisYaw, this),
      XAxisStraightnessY_ (XAxisStraightnessY, this),
      XAxisStraightnessZ_ (XAxisStraightnessZ, this),
      YAxisStraightnessX_ (YAxisStraightnessX, this),
      YAxisStraightnessZ_ (YAxisStraightnessZ, this),
      ZAxisStraightnessX_ (ZAxisStraightnessX, this),
      ZAxisStraightnessY_ (ZAxisStraightnessY, this),
      XYSquareness_ (XYSquareness, this),
      XZSquareness_ (XZSquareness, this),
      YZSquareness_ (YZSquareness, this)
    {
    }

    FPSTestType::
    FPSTestType (const FPSTestType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::CMMAccuracyTestBaseType (x, f, c),
      XLinearity_ (x.XLinearity_, f, this),
      YLinearity_ (x.YLinearity_, f, this),
      ZLinearity_ (x.ZLinearity_, f, this),
      XAxisRoll_ (x.XAxisRoll_, f, this),
      XAxisPitch_ (x.XAxisPitch_, f, this),
      XAxisYaw_ (x.XAxisYaw_, f, this),
      YAxisRoll_ (x.YAxisRoll_, f, this),
      YAxisPitch_ (x.YAxisPitch_, f, this),
      YAxisYaw_ (x.YAxisYaw_, f, this),
      ZAxisRoll_ (x.ZAxisRoll_, f, this),
      ZAxisPitch_ (x.ZAxisPitch_, f, this),
      ZAxisYaw_ (x.ZAxisYaw_, f, this),
      XAxisStraightnessY_ (x.XAxisStraightnessY_, f, this),
      XAxisStraightnessZ_ (x.XAxisStraightnessZ_, f, this),
      YAxisStraightnessX_ (x.YAxisStraightnessX_, f, this),
      YAxisStraightnessZ_ (x.YAxisStraightnessZ_, f, this),
      ZAxisStraightnessX_ (x.ZAxisStraightnessX_, f, this),
      ZAxisStraightnessY_ (x.ZAxisStraightnessY_, f, this),
      XYSquareness_ (x.XYSquareness_, f, this),
      XZSquareness_ (x.XZSquareness_, f, this),
      YZSquareness_ (x.YZSquareness_, f, this)
    {
    }

    FPSTestType::
    FPSTestType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::CMMAccuracyTestBaseType (e, f | ::xml_schema::flags::base, c),
      XLinearity_ (this),
      YLinearity_ (this),
      ZLinearity_ (this),
      XAxisRoll_ (this),
      XAxisPitch_ (this),
      XAxisYaw_ (this),
      YAxisRoll_ (this),
      YAxisPitch_ (this),
      YAxisYaw_ (this),
      ZAxisRoll_ (this),
      ZAxisPitch_ (this),
      ZAxisYaw_ (this),
      XAxisStraightnessY_ (this),
      XAxisStraightnessZ_ (this),
      YAxisStraightnessX_ (this),
      YAxisStraightnessZ_ (this),
      ZAxisStraightnessX_ (this),
      ZAxisStraightnessY_ (this),
      XYSquareness_ (this),
      XZSquareness_ (this),
      YZSquareness_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FPSTestType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // XLinearity
        //
        if (n.name () == "XLinearity" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XLinearity_type > r (
            XLinearity_traits::create (i, f, this));

          if (!XLinearity_.present ())
          {
            this->XLinearity_.set (r);
            continue;
          }
        }

        // YLinearity
        //
        if (n.name () == "YLinearity" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YLinearity_type > r (
            YLinearity_traits::create (i, f, this));

          if (!YLinearity_.present ())
          {
            this->YLinearity_.set (r);
            continue;
          }
        }

        // ZLinearity
        //
        if (n.name () == "ZLinearity" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZLinearity_type > r (
            ZLinearity_traits::create (i, f, this));

          if (!ZLinearity_.present ())
          {
            this->ZLinearity_.set (r);
            continue;
          }
        }

        // XAxisRoll
        //
        if (n.name () == "XAxisRoll" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XAxisRoll_type > r (
            XAxisRoll_traits::create (i, f, this));

          if (!XAxisRoll_.present ())
          {
            this->XAxisRoll_.set (r);
            continue;
          }
        }

        // XAxisPitch
        //
        if (n.name () == "XAxisPitch" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XAxisPitch_type > r (
            XAxisPitch_traits::create (i, f, this));

          if (!XAxisPitch_.present ())
          {
            this->XAxisPitch_.set (r);
            continue;
          }
        }

        // XAxisYaw
        //
        if (n.name () == "XAxisYaw" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XAxisYaw_type > r (
            XAxisYaw_traits::create (i, f, this));

          if (!XAxisYaw_.present ())
          {
            this->XAxisYaw_.set (r);
            continue;
          }
        }

        // YAxisRoll
        //
        if (n.name () == "YAxisRoll" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YAxisRoll_type > r (
            YAxisRoll_traits::create (i, f, this));

          if (!YAxisRoll_.present ())
          {
            this->YAxisRoll_.set (r);
            continue;
          }
        }

        // YAxisPitch
        //
        if (n.name () == "YAxisPitch" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YAxisPitch_type > r (
            YAxisPitch_traits::create (i, f, this));

          if (!YAxisPitch_.present ())
          {
            this->YAxisPitch_.set (r);
            continue;
          }
        }

        // YAxisYaw
        //
        if (n.name () == "YAxisYaw" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YAxisYaw_type > r (
            YAxisYaw_traits::create (i, f, this));

          if (!YAxisYaw_.present ())
          {
            this->YAxisYaw_.set (r);
            continue;
          }
        }

        // ZAxisRoll
        //
        if (n.name () == "ZAxisRoll" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZAxisRoll_type > r (
            ZAxisRoll_traits::create (i, f, this));

          if (!ZAxisRoll_.present ())
          {
            this->ZAxisRoll_.set (r);
            continue;
          }
        }

        // ZAxisPitch
        //
        if (n.name () == "ZAxisPitch" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZAxisPitch_type > r (
            ZAxisPitch_traits::create (i, f, this));

          if (!ZAxisPitch_.present ())
          {
            this->ZAxisPitch_.set (r);
            continue;
          }
        }

        // ZAxisYaw
        //
        if (n.name () == "ZAxisYaw" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZAxisYaw_type > r (
            ZAxisYaw_traits::create (i, f, this));

          if (!ZAxisYaw_.present ())
          {
            this->ZAxisYaw_.set (r);
            continue;
          }
        }

        // XAxisStraightnessY
        //
        if (n.name () == "XAxisStraightnessY" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XAxisStraightnessY_type > r (
            XAxisStraightnessY_traits::create (i, f, this));

          if (!XAxisStraightnessY_.present ())
          {
            this->XAxisStraightnessY_.set (r);
            continue;
          }
        }

        // XAxisStraightnessZ
        //
        if (n.name () == "XAxisStraightnessZ" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XAxisStraightnessZ_type > r (
            XAxisStraightnessZ_traits::create (i, f, this));

          if (!XAxisStraightnessZ_.present ())
          {
            this->XAxisStraightnessZ_.set (r);
            continue;
          }
        }

        // YAxisStraightnessX
        //
        if (n.name () == "YAxisStraightnessX" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YAxisStraightnessX_type > r (
            YAxisStraightnessX_traits::create (i, f, this));

          if (!YAxisStraightnessX_.present ())
          {
            this->YAxisStraightnessX_.set (r);
            continue;
          }
        }

        // YAxisStraightnessZ
        //
        if (n.name () == "YAxisStraightnessZ" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YAxisStraightnessZ_type > r (
            YAxisStraightnessZ_traits::create (i, f, this));

          if (!YAxisStraightnessZ_.present ())
          {
            this->YAxisStraightnessZ_.set (r);
            continue;
          }
        }

        // ZAxisStraightnessX
        //
        if (n.name () == "ZAxisStraightnessX" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZAxisStraightnessX_type > r (
            ZAxisStraightnessX_traits::create (i, f, this));

          if (!ZAxisStraightnessX_.present ())
          {
            this->ZAxisStraightnessX_.set (r);
            continue;
          }
        }

        // ZAxisStraightnessY
        //
        if (n.name () == "ZAxisStraightnessY" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZAxisStraightnessY_type > r (
            ZAxisStraightnessY_traits::create (i, f, this));

          if (!ZAxisStraightnessY_.present ())
          {
            this->ZAxisStraightnessY_.set (r);
            continue;
          }
        }

        // XYSquareness
        //
        if (n.name () == "XYSquareness" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!XYSquareness_.present ())
          {
            this->XYSquareness_.set (XYSquareness_traits::create (i, f, this));
            continue;
          }
        }

        // XZSquareness
        //
        if (n.name () == "XZSquareness" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!XZSquareness_.present ())
          {
            this->XZSquareness_.set (XZSquareness_traits::create (i, f, this));
            continue;
          }
        }

        // YZSquareness
        //
        if (n.name () == "YZSquareness" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!YZSquareness_.present ())
          {
            this->YZSquareness_.set (YZSquareness_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!XLinearity_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XLinearity",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YLinearity_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YLinearity",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZLinearity_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZLinearity",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!XAxisRoll_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XAxisRoll",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!XAxisPitch_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XAxisPitch",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!XAxisYaw_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XAxisYaw",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YAxisRoll_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YAxisRoll",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YAxisPitch_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YAxisPitch",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YAxisYaw_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YAxisYaw",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZAxisRoll_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZAxisRoll",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZAxisPitch_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZAxisPitch",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZAxisYaw_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZAxisYaw",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!XAxisStraightnessY_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XAxisStraightnessY",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!XAxisStraightnessZ_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XAxisStraightnessZ",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YAxisStraightnessX_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YAxisStraightnessX",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YAxisStraightnessZ_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YAxisStraightnessZ",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZAxisStraightnessX_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZAxisStraightnessX",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZAxisStraightnessY_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZAxisStraightnessY",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!XYSquareness_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XYSquareness",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!XZSquareness_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XZSquareness",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YZSquareness_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YZSquareness",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    FPSTestType* FPSTestType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FPSTestType (*this, f, c);
    }

    FPSTestType& FPSTestType::
    operator= (const FPSTestType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::CMMAccuracyTestBaseType& > (*this) = x;
        this->XLinearity_ = x.XLinearity_;
        this->YLinearity_ = x.YLinearity_;
        this->ZLinearity_ = x.ZLinearity_;
        this->XAxisRoll_ = x.XAxisRoll_;
        this->XAxisPitch_ = x.XAxisPitch_;
        this->XAxisYaw_ = x.XAxisYaw_;
        this->YAxisRoll_ = x.YAxisRoll_;
        this->YAxisPitch_ = x.YAxisPitch_;
        this->YAxisYaw_ = x.YAxisYaw_;
        this->ZAxisRoll_ = x.ZAxisRoll_;
        this->ZAxisPitch_ = x.ZAxisPitch_;
        this->ZAxisYaw_ = x.ZAxisYaw_;
        this->XAxisStraightnessY_ = x.XAxisStraightnessY_;
        this->XAxisStraightnessZ_ = x.XAxisStraightnessZ_;
        this->YAxisStraightnessX_ = x.YAxisStraightnessX_;
        this->YAxisStraightnessZ_ = x.YAxisStraightnessZ_;
        this->ZAxisStraightnessX_ = x.ZAxisStraightnessX_;
        this->ZAxisStraightnessY_ = x.ZAxisStraightnessY_;
        this->XYSquareness_ = x.XYSquareness_;
        this->XZSquareness_ = x.XZSquareness_;
        this->YZSquareness_ = x.YZSquareness_;
      }

      return *this;
    }

    FPSTestType::
    ~FPSTestType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, FPSTestType >
    _xsd_FPSTestType_type_factory_init (
      "FPSTestType",
      "http://qifstandards.org/xsd/qif2");

    // FunctionDiscreteType
    //

    FunctionDiscreteType::
    FunctionDiscreteType (const DomainValues_type& DomainValues,
                          const RangeValues_type& RangeValues,
                          const N_type& N)
    : ::xml_schema::type (),
      DomainValues_ (DomainValues, this),
      RangeValues_ (RangeValues, this),
      N_ (N, this)
    {
    }

    FunctionDiscreteType::
    FunctionDiscreteType (const FunctionDiscreteType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DomainValues_ (x.DomainValues_, f, this),
      RangeValues_ (x.RangeValues_, f, this),
      N_ (x.N_, f, this)
    {
    }

    FunctionDiscreteType::
    FunctionDiscreteType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DomainValues_ (this),
      RangeValues_ (this),
      N_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FunctionDiscreteType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DomainValues
        //
        if (n.name () == "DomainValues" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DomainValues_type > r (
            DomainValues_traits::create (i, f, this));

          if (!DomainValues_.present ())
          {
            this->DomainValues_.set (r);
            continue;
          }
        }

        // RangeValues
        //
        if (n.name () == "RangeValues" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RangeValues_type > r (
            RangeValues_traits::create (i, f, this));

          if (!RangeValues_.present ())
          {
            this->RangeValues_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DomainValues_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DomainValues",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!RangeValues_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "RangeValues",
          "http://qifstandards.org/xsd/qif2");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          this->N_.set (N_traits::create (i, f, this));
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    FunctionDiscreteType* FunctionDiscreteType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FunctionDiscreteType (*this, f, c);
    }

    FunctionDiscreteType& FunctionDiscreteType::
    operator= (const FunctionDiscreteType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->DomainValues_ = x.DomainValues_;
        this->RangeValues_ = x.RangeValues_;
        this->N_ = x.N_;
      }

      return *this;
    }

    FunctionDiscreteType::
    ~FunctionDiscreteType ()
    {
    }

    // LengthFunctionDiscreteType
    //

    LengthFunctionDiscreteType::
    LengthFunctionDiscreteType (const DomainValues_type& DomainValues,
                                const RangeValues_type& RangeValues,
                                const N_type& N,
                                const DomainLinearUnit_type& DomainLinearUnit,
                                const RangeLinearUnit_type& RangeLinearUnit)
    : ::xsd::qif2::FunctionDiscreteType (DomainValues,
                                         RangeValues,
                                         N),
      DomainLinearUnit_ (DomainLinearUnit, this),
      RangeLinearUnit_ (RangeLinearUnit, this)
    {
    }

    LengthFunctionDiscreteType::
    LengthFunctionDiscreteType (const LengthFunctionDiscreteType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FunctionDiscreteType (x, f, c),
      DomainLinearUnit_ (x.DomainLinearUnit_, f, this),
      RangeLinearUnit_ (x.RangeLinearUnit_, f, this)
    {
    }

    LengthFunctionDiscreteType::
    LengthFunctionDiscreteType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FunctionDiscreteType (e, f | ::xml_schema::flags::base, c),
      DomainLinearUnit_ (this),
      RangeLinearUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LengthFunctionDiscreteType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FunctionDiscreteType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DomainLinearUnit
        //
        if (n.name () == "DomainLinearUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DomainLinearUnit_type > r (
            DomainLinearUnit_traits::create (i, f, this));

          if (!DomainLinearUnit_.present ())
          {
            this->DomainLinearUnit_.set (r);
            continue;
          }
        }

        // RangeLinearUnit
        //
        if (n.name () == "RangeLinearUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RangeLinearUnit_type > r (
            RangeLinearUnit_traits::create (i, f, this));

          if (!RangeLinearUnit_.present ())
          {
            this->RangeLinearUnit_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DomainLinearUnit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DomainLinearUnit",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!RangeLinearUnit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "RangeLinearUnit",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LengthFunctionDiscreteType* LengthFunctionDiscreteType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LengthFunctionDiscreteType (*this, f, c);
    }

    LengthFunctionDiscreteType& LengthFunctionDiscreteType::
    operator= (const LengthFunctionDiscreteType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FunctionDiscreteType& > (*this) = x;
        this->DomainLinearUnit_ = x.DomainLinearUnit_;
        this->RangeLinearUnit_ = x.RangeLinearUnit_;
      }

      return *this;
    }

    LengthFunctionDiscreteType::
    ~LengthFunctionDiscreteType ()
    {
    }

    // AngleFunctionDiscreteType
    //

    AngleFunctionDiscreteType::
    AngleFunctionDiscreteType (const DomainValues_type& DomainValues,
                               const RangeValues_type& RangeValues,
                               const N_type& N,
                               const DomainLinearUnit_type& DomainLinearUnit,
                               const RangeAngularUnit_type& RangeAngularUnit)
    : ::xsd::qif2::FunctionDiscreteType (DomainValues,
                                         RangeValues,
                                         N),
      DomainLinearUnit_ (DomainLinearUnit, this),
      RangeAngularUnit_ (RangeAngularUnit, this)
    {
    }

    AngleFunctionDiscreteType::
    AngleFunctionDiscreteType (const AngleFunctionDiscreteType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FunctionDiscreteType (x, f, c),
      DomainLinearUnit_ (x.DomainLinearUnit_, f, this),
      RangeAngularUnit_ (x.RangeAngularUnit_, f, this)
    {
    }

    AngleFunctionDiscreteType::
    AngleFunctionDiscreteType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FunctionDiscreteType (e, f | ::xml_schema::flags::base, c),
      DomainLinearUnit_ (this),
      RangeAngularUnit_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AngleFunctionDiscreteType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FunctionDiscreteType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DomainLinearUnit
        //
        if (n.name () == "DomainLinearUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DomainLinearUnit_type > r (
            DomainLinearUnit_traits::create (i, f, this));

          if (!DomainLinearUnit_.present ())
          {
            this->DomainLinearUnit_.set (r);
            continue;
          }
        }

        // RangeAngularUnit
        //
        if (n.name () == "RangeAngularUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RangeAngularUnit_type > r (
            RangeAngularUnit_traits::create (i, f, this));

          if (!RangeAngularUnit_.present ())
          {
            this->RangeAngularUnit_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DomainLinearUnit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DomainLinearUnit",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!RangeAngularUnit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "RangeAngularUnit",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    AngleFunctionDiscreteType* AngleFunctionDiscreteType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngleFunctionDiscreteType (*this, f, c);
    }

    AngleFunctionDiscreteType& AngleFunctionDiscreteType::
    operator= (const AngleFunctionDiscreteType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FunctionDiscreteType& > (*this) = x;
        this->DomainLinearUnit_ = x.DomainLinearUnit_;
        this->RangeAngularUnit_ = x.RangeAngularUnit_;
      }

      return *this;
    }

    AngleFunctionDiscreteType::
    ~AngleFunctionDiscreteType ()
    {
    }

    // B89TestType
    //

    B89TestType::
    B89TestType (const XLinearAccuracy_type& XLinearAccuracy,
                 const YLinearAccuracy_type& YLinearAccuracy,
                 const ZLinearAccuracy_type& ZLinearAccuracy,
                 const OffsetVolumetricPerformance_type& OffsetVolumetricPerformance,
                 const VolumetricPerformance_type& VolumetricPerformance,
                 const Repeatability_type& Repeatability)
    : ::xsd::qif2::CMMAccuracyTestBaseType (),
      XLinearAccuracy_ (XLinearAccuracy, this),
      YLinearAccuracy_ (YLinearAccuracy, this),
      ZLinearAccuracy_ (ZLinearAccuracy, this),
      OffsetVolumetricPerformance_ (OffsetVolumetricPerformance, this),
      VolumetricPerformance_ (VolumetricPerformance, this),
      Repeatability_ (Repeatability, this)
    {
    }

    B89TestType::
    B89TestType (::std::auto_ptr< XLinearAccuracy_type > XLinearAccuracy,
                 ::std::auto_ptr< YLinearAccuracy_type > YLinearAccuracy,
                 ::std::auto_ptr< ZLinearAccuracy_type > ZLinearAccuracy,
                 ::std::auto_ptr< OffsetVolumetricPerformance_type > OffsetVolumetricPerformance,
                 ::std::auto_ptr< VolumetricPerformance_type > VolumetricPerformance,
                 ::std::auto_ptr< Repeatability_type > Repeatability)
    : ::xsd::qif2::CMMAccuracyTestBaseType (),
      XLinearAccuracy_ (XLinearAccuracy, this),
      YLinearAccuracy_ (YLinearAccuracy, this),
      ZLinearAccuracy_ (ZLinearAccuracy, this),
      OffsetVolumetricPerformance_ (OffsetVolumetricPerformance, this),
      VolumetricPerformance_ (VolumetricPerformance, this),
      Repeatability_ (Repeatability, this)
    {
    }

    B89TestType::
    B89TestType (const B89TestType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::CMMAccuracyTestBaseType (x, f, c),
      XLinearAccuracy_ (x.XLinearAccuracy_, f, this),
      YLinearAccuracy_ (x.YLinearAccuracy_, f, this),
      ZLinearAccuracy_ (x.ZLinearAccuracy_, f, this),
      OffsetVolumetricPerformance_ (x.OffsetVolumetricPerformance_, f, this),
      VolumetricPerformance_ (x.VolumetricPerformance_, f, this),
      Repeatability_ (x.Repeatability_, f, this)
    {
    }

    B89TestType::
    B89TestType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::CMMAccuracyTestBaseType (e, f | ::xml_schema::flags::base, c),
      XLinearAccuracy_ (this),
      YLinearAccuracy_ (this),
      ZLinearAccuracy_ (this),
      OffsetVolumetricPerformance_ (this),
      VolumetricPerformance_ (this),
      Repeatability_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void B89TestType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // XLinearAccuracy
        //
        if (n.name () == "XLinearAccuracy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XLinearAccuracy_type > r (
            XLinearAccuracy_traits::create (i, f, this));

          if (!XLinearAccuracy_.present ())
          {
            this->XLinearAccuracy_.set (r);
            continue;
          }
        }

        // YLinearAccuracy
        //
        if (n.name () == "YLinearAccuracy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YLinearAccuracy_type > r (
            YLinearAccuracy_traits::create (i, f, this));

          if (!YLinearAccuracy_.present ())
          {
            this->YLinearAccuracy_.set (r);
            continue;
          }
        }

        // ZLinearAccuracy
        //
        if (n.name () == "ZLinearAccuracy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZLinearAccuracy_type > r (
            ZLinearAccuracy_traits::create (i, f, this));

          if (!ZLinearAccuracy_.present ())
          {
            this->ZLinearAccuracy_.set (r);
            continue;
          }
        }

        // OffsetVolumetricPerformance
        //
        if (n.name () == "OffsetVolumetricPerformance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OffsetVolumetricPerformance_type > r (
            OffsetVolumetricPerformance_traits::create (i, f, this));

          if (!OffsetVolumetricPerformance_.present ())
          {
            this->OffsetVolumetricPerformance_.set (r);
            continue;
          }
        }

        // VolumetricPerformance
        //
        if (n.name () == "VolumetricPerformance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< VolumetricPerformance_type > r (
            VolumetricPerformance_traits::create (i, f, this));

          if (!VolumetricPerformance_.present ())
          {
            this->VolumetricPerformance_.set (r);
            continue;
          }
        }

        // Repeatability
        //
        if (n.name () == "Repeatability" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Repeatability_type > r (
            Repeatability_traits::create (i, f, this));

          if (!Repeatability_.present ())
          {
            this->Repeatability_.set (r);
            continue;
          }
        }

        break;
      }

      if (!XLinearAccuracy_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XLinearAccuracy",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YLinearAccuracy_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YLinearAccuracy",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZLinearAccuracy_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZLinearAccuracy",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!OffsetVolumetricPerformance_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "OffsetVolumetricPerformance",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!VolumetricPerformance_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "VolumetricPerformance",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Repeatability_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Repeatability",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    B89TestType* B89TestType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class B89TestType (*this, f, c);
    }

    B89TestType& B89TestType::
    operator= (const B89TestType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::CMMAccuracyTestBaseType& > (*this) = x;
        this->XLinearAccuracy_ = x.XLinearAccuracy_;
        this->YLinearAccuracy_ = x.YLinearAccuracy_;
        this->ZLinearAccuracy_ = x.ZLinearAccuracy_;
        this->OffsetVolumetricPerformance_ = x.OffsetVolumetricPerformance_;
        this->VolumetricPerformance_ = x.VolumetricPerformance_;
        this->Repeatability_ = x.Repeatability_;
      }

      return *this;
    }

    B89TestType::
    ~B89TestType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, B89TestType >
    _xsd_B89TestType_type_factory_init (
      "B89TestType",
      "http://qifstandards.org/xsd/qif2");

    // ISO10360TestType
    //

    ISO10360TestType::
    ISO10360TestType ()
    : ::xsd::qif2::CMMAccuracyTestBaseType (),
      MaxErrorConstant_ (this),
      LinearError_ (this),
      LesserError_ (this)
    {
    }

    ISO10360TestType::
    ISO10360TestType (const ISO10360TestType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::CMMAccuracyTestBaseType (x, f, c),
      MaxErrorConstant_ (x.MaxErrorConstant_, f, this),
      LinearError_ (x.LinearError_, f, this),
      LesserError_ (x.LesserError_, f, this)
    {
    }

    ISO10360TestType::
    ISO10360TestType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::CMMAccuracyTestBaseType (e, f | ::xml_schema::flags::base, c),
      MaxErrorConstant_ (this),
      LinearError_ (this),
      LesserError_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ISO10360TestType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MaxErrorConstant
        //
        if (n.name () == "MaxErrorConstant" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxErrorConstant_type > r (
            MaxErrorConstant_traits::create (i, f, this));

          if (!this->MaxErrorConstant_)
          {
            this->MaxErrorConstant_.set (r);
            continue;
          }
        }

        // LinearError
        //
        if (n.name () == "LinearError" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LinearError_type > r (
            LinearError_traits::create (i, f, this));

          if (!this->LinearError_)
          {
            this->LinearError_.set (r);
            continue;
          }
        }

        // LesserError
        //
        if (n.name () == "LesserError" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LesserError_type > r (
            LesserError_traits::create (i, f, this));

          if (!this->LesserError_)
          {
            this->LesserError_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ISO10360TestType* ISO10360TestType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ISO10360TestType (*this, f, c);
    }

    ISO10360TestType& ISO10360TestType::
    operator= (const ISO10360TestType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::CMMAccuracyTestBaseType& > (*this) = x;
        this->MaxErrorConstant_ = x.MaxErrorConstant_;
        this->LinearError_ = x.LinearError_;
        this->LesserError_ = x.LesserError_;
      }

      return *this;
    }

    ISO10360TestType::
    ~ISO10360TestType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ISO10360TestType >
    _xsd_ISO10360TestType_type_factory_init (
      "ISO10360TestType",
      "http://qifstandards.org/xsd/qif2");

    // LinearErrorType
    //

    LinearErrorType::
    LinearErrorType (const BaseError_type& BaseError,
                     const ErrorRate_type& ErrorRate)
    : ::xml_schema::type (),
      BaseError_ (BaseError, this),
      ErrorRate_ (ErrorRate, this)
    {
    }

    LinearErrorType::
    LinearErrorType (::std::auto_ptr< BaseError_type > BaseError,
                     const ErrorRate_type& ErrorRate)
    : ::xml_schema::type (),
      BaseError_ (BaseError, this),
      ErrorRate_ (ErrorRate, this)
    {
    }

    LinearErrorType::
    LinearErrorType (const LinearErrorType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BaseError_ (x.BaseError_, f, this),
      ErrorRate_ (x.ErrorRate_, f, this)
    {
    }

    LinearErrorType::
    LinearErrorType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BaseError_ (this),
      ErrorRate_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LinearErrorType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseError
        //
        if (n.name () == "BaseError" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseError_type > r (
            BaseError_traits::create (i, f, this));

          if (!BaseError_.present ())
          {
            this->BaseError_.set (r);
            continue;
          }
        }

        // ErrorRate
        //
        if (n.name () == "ErrorRate" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!ErrorRate_.present ())
          {
            this->ErrorRate_.set (ErrorRate_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!BaseError_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseError",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ErrorRate_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ErrorRate",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LinearErrorType* LinearErrorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearErrorType (*this, f, c);
    }

    LinearErrorType& LinearErrorType::
    operator= (const LinearErrorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BaseError_ = x.BaseError_;
        this->ErrorRate_ = x.ErrorRate_;
      }

      return *this;
    }

    LinearErrorType::
    ~LinearErrorType ()
    {
    }

    // LesserErrorType
    //

    LesserErrorType::
    LesserErrorType (const MaxErrorConstant_type& MaxErrorConstant,
                     const LinearError_type& LinearError)
    : ::xml_schema::type (),
      MaxErrorConstant_ (MaxErrorConstant, this),
      LinearError_ (LinearError, this)
    {
    }

    LesserErrorType::
    LesserErrorType (::std::auto_ptr< MaxErrorConstant_type > MaxErrorConstant,
                     ::std::auto_ptr< LinearError_type > LinearError)
    : ::xml_schema::type (),
      MaxErrorConstant_ (MaxErrorConstant, this),
      LinearError_ (LinearError, this)
    {
    }

    LesserErrorType::
    LesserErrorType (const LesserErrorType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxErrorConstant_ (x.MaxErrorConstant_, f, this),
      LinearError_ (x.LinearError_, f, this)
    {
    }

    LesserErrorType::
    LesserErrorType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxErrorConstant_ (this),
      LinearError_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LesserErrorType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MaxErrorConstant
        //
        if (n.name () == "MaxErrorConstant" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxErrorConstant_type > r (
            MaxErrorConstant_traits::create (i, f, this));

          if (!MaxErrorConstant_.present ())
          {
            this->MaxErrorConstant_.set (r);
            continue;
          }
        }

        // LinearError
        //
        if (n.name () == "LinearError" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LinearError_type > r (
            LinearError_traits::create (i, f, this));

          if (!LinearError_.present ())
          {
            this->LinearError_.set (r);
            continue;
          }
        }

        break;
      }

      if (!MaxErrorConstant_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MaxErrorConstant",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!LinearError_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "LinearError",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LesserErrorType* LesserErrorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LesserErrorType (*this, f, c);
    }

    LesserErrorType& LesserErrorType::
    operator= (const LesserErrorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MaxErrorConstant_ = x.MaxErrorConstant_;
        this->LinearError_ = x.LinearError_;
      }

      return *this;
    }

    LesserErrorType::
    ~LesserErrorType ()
    {
    }

    // PointAccuracyTestType
    //

    PointAccuracyTestType::
    PointAccuracyTestType (const Accuracy_type& Accuracy)
    : ::xsd::qif2::CMMAccuracyTestBaseType (),
      Accuracy_ (Accuracy, this)
    {
    }

    PointAccuracyTestType::
    PointAccuracyTestType (::std::auto_ptr< Accuracy_type > Accuracy)
    : ::xsd::qif2::CMMAccuracyTestBaseType (),
      Accuracy_ (Accuracy, this)
    {
    }

    PointAccuracyTestType::
    PointAccuracyTestType (const PointAccuracyTestType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::CMMAccuracyTestBaseType (x, f, c),
      Accuracy_ (x.Accuracy_, f, this)
    {
    }

    PointAccuracyTestType::
    PointAccuracyTestType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::CMMAccuracyTestBaseType (e, f | ::xml_schema::flags::base, c),
      Accuracy_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointAccuracyTestType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Accuracy
        //
        if (n.name () == "Accuracy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Accuracy_type > r (
            Accuracy_traits::create (i, f, this));

          if (!Accuracy_.present ())
          {
            this->Accuracy_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Accuracy_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Accuracy",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointAccuracyTestType* PointAccuracyTestType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointAccuracyTestType (*this, f, c);
    }

    PointAccuracyTestType& PointAccuracyTestType::
    operator= (const PointAccuracyTestType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::CMMAccuracyTestBaseType& > (*this) = x;
        this->Accuracy_ = x.Accuracy_;
      }

      return *this;
    }

    PointAccuracyTestType::
    ~PointAccuracyTestType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PointAccuracyTestType >
    _xsd_PointAccuracyTestType_type_factory_init (
      "PointAccuracyTestType",
      "http://qifstandards.org/xsd/qif2");

    // CMMAccuracyType
    //

    CMMAccuracyType::
    CMMAccuracyType (const MinTemperature_type& MinTemperature,
                     const MaxTemperature_type& MaxTemperature,
                     const CMMAccuracyTest_type& CMMAccuracyTest)
    : ::xsd::qif2::MeasurementDeviceAccuracyBaseType (),
      MinTemperature_ (MinTemperature, this),
      MaxTemperature_ (MaxTemperature, this),
      CMMAccuracyTest_ (CMMAccuracyTest, this)
    {
    }

    CMMAccuracyType::
    CMMAccuracyType (::std::auto_ptr< MinTemperature_type > MinTemperature,
                     ::std::auto_ptr< MaxTemperature_type > MaxTemperature,
                     const CMMAccuracyTest_type& CMMAccuracyTest)
    : ::xsd::qif2::MeasurementDeviceAccuracyBaseType (),
      MinTemperature_ (MinTemperature, this),
      MaxTemperature_ (MaxTemperature, this),
      CMMAccuracyTest_ (CMMAccuracyTest, this)
    {
    }

    CMMAccuracyType::
    CMMAccuracyType (const MinTemperature_type& MinTemperature,
                     const MaxTemperature_type& MaxTemperature,
                     ::std::auto_ptr< CMMAccuracyTest_type > CMMAccuracyTest)
    : ::xsd::qif2::MeasurementDeviceAccuracyBaseType (),
      MinTemperature_ (MinTemperature, this),
      MaxTemperature_ (MaxTemperature, this),
      CMMAccuracyTest_ (CMMAccuracyTest, this)
    {
    }

    CMMAccuracyType::
    CMMAccuracyType (const CMMAccuracyType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementDeviceAccuracyBaseType (x, f, c),
      MinTemperature_ (x.MinTemperature_, f, this),
      MaxTemperature_ (x.MaxTemperature_, f, this),
      CMMAccuracyTest_ (x.CMMAccuracyTest_, f, this)
    {
    }

    CMMAccuracyType::
    CMMAccuracyType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementDeviceAccuracyBaseType (e, f | ::xml_schema::flags::base, c),
      MinTemperature_ (this),
      MaxTemperature_ (this),
      CMMAccuracyTest_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CMMAccuracyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MinTemperature
        //
        if (n.name () == "MinTemperature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinTemperature_type > r (
            MinTemperature_traits::create (i, f, this));

          if (!MinTemperature_.present ())
          {
            this->MinTemperature_.set (r);
            continue;
          }
        }

        // MaxTemperature
        //
        if (n.name () == "MaxTemperature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxTemperature_type > r (
            MaxTemperature_traits::create (i, f, this));

          if (!MaxTemperature_.present ())
          {
            this->MaxTemperature_.set (r);
            continue;
          }
        }

        // CMMAccuracyTest
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "CMMAccuracyTest",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< CMMAccuracyTest_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!CMMAccuracyTest_.present ())
            {
              ::std::auto_ptr< CMMAccuracyTest_type > r (
                dynamic_cast< CMMAccuracyTest_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->CMMAccuracyTest_.set (r);
              continue;
            }
          }
        }

        break;
      }

      if (!MinTemperature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MinTemperature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MaxTemperature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MaxTemperature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!CMMAccuracyTest_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CMMAccuracyTest",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CMMAccuracyType* CMMAccuracyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CMMAccuracyType (*this, f, c);
    }

    CMMAccuracyType& CMMAccuracyType::
    operator= (const CMMAccuracyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::MeasurementDeviceAccuracyBaseType& > (*this) = x;
        this->MinTemperature_ = x.MinTemperature_;
        this->MaxTemperature_ = x.MaxTemperature_;
        this->CMMAccuracyTest_ = x.CMMAccuracyTest_;
      }

      return *this;
    }

    CMMAccuracyType::
    ~CMMAccuracyType ()
    {
    }

    // ComparatorType
    //

    ComparatorType::
    ComparatorType (const Name_type& Name,
                    const id_type& id)
    : ::xsd::qif2::ProbingDeviceType (Name,
                                      id)
    {
    }

    ComparatorType::
    ComparatorType (const ComparatorType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ProbingDeviceType (x, f, c)
    {
    }

    ComparatorType::
    ComparatorType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ProbingDeviceType (e, f, c)
    {
    }

    ComparatorType* ComparatorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ComparatorType (*this, f, c);
    }

    ComparatorType::
    ~ComparatorType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ComparatorType >
    _xsd_ComparatorType_type_factory_init (
      "ComparatorType",
      "http://qifstandards.org/xsd/qif2");

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::CMMType >
    _xsd_CMM_element_factory_init (
      "MeasurementDevice",
      "http://qifstandards.org/xsd/qif2",
      "CMM",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::CaliperType >
    _xsd_Caliper_element_factory_init (
      "MeasurementDevice",
      "http://qifstandards.org/xsd/qif2",
      "Caliper",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::GageDeviceType >
    _xsd_GageDevice_element_factory_init (
      "MeasurementDevice",
      "http://qifstandards.org/xsd/qif2",
      "GageDevice",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ComparatorType >
    _xsd_Comparator_element_factory_init (
      "MeasurementDevice",
      "http://qifstandards.org/xsd/qif2",
      "Comparator",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::FPSTestType >
    _xsd_FPSTest_element_factory_init (
      "CMMAccuracyTest",
      "http://qifstandards.org/xsd/qif2",
      "FPSTest",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::B89TestType >
    _xsd_B89Test_element_factory_init (
      "CMMAccuracyTest",
      "http://qifstandards.org/xsd/qif2",
      "B89Test",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ISO10360TestType >
    _xsd_ISO10360Test_element_factory_init (
      "CMMAccuracyTest",
      "http://qifstandards.org/xsd/qif2",
      "ISO10360Test",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PointAccuracyTestType >
    _xsd_PointAccuracyTest_element_factory_init (
      "CMMAccuracyTest",
      "http://qifstandards.org/xsd/qif2",
      "PointAccuracyTest",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::TouchProbeType >
    _xsd_TouchProbe_element_factory_init (
      "Sensor",
      "http://qifstandards.org/xsd/qif2",
      "TouchProbe",
      "http://qifstandards.org/xsd/qif2");
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif2
  {
    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (const ::std::string& u,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType > (
        ::xsd::qif2::MeasurementResources (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (const ::std::string& u,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType > (
        ::xsd::qif2::MeasurementResources (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (const ::std::string& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType > (
        ::xsd::qif2::MeasurementResources (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::MeasurementResources (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (::std::istream& is,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::MeasurementResources (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::MeasurementResources (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::MeasurementResources (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::MeasurementResources (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (::std::istream& is,
                          const ::std::string& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::MeasurementResources (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (::xercesc::InputSource& i,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType > (
        ::xsd::qif2::MeasurementResources (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (::xercesc::InputSource& i,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType > (
        ::xsd::qif2::MeasurementResources (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (::xercesc::InputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType > (
        ::xsd::qif2::MeasurementResources (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (const ::xercesc::DOMDocument& doc,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType > (
          ::xsd::qif2::MeasurementResources (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "MeasurementResources" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::MeasurementResourcesType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "MeasurementResources",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "MeasurementResources" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::MeasurementResourcesType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "MeasurementResources",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType > (
        ::xsd::qif2::MeasurementDevice (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType > (
        ::xsd::qif2::MeasurementDevice (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType > (
        ::xsd::qif2::MeasurementDevice (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::MeasurementDevice (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::MeasurementDevice (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::MeasurementDevice (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::MeasurementDevice (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::MeasurementDevice (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::MeasurementDevice (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType > (
        ::xsd::qif2::MeasurementDevice (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType > (
        ::xsd::qif2::MeasurementDevice (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType > (
        ::xsd::qif2::MeasurementDevice (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (const ::xercesc::DOMDocument& doc,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType > (
          ::xsd::qif2::MeasurementDevice (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "MeasurementDevice",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::MeasurementDeviceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType > r (
          dynamic_cast< ::xsd::qif2::MeasurementDeviceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "MeasurementDevice",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "MeasurementDevice",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::MeasurementDeviceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType > r (
          dynamic_cast< ::xsd::qif2::MeasurementDeviceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "MeasurementDevice",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::CMMType > (
        ::xsd::qif2::CMM (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::CMMType > (
        ::xsd::qif2::CMM (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::CMMType > (
        ::xsd::qif2::CMM (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CMM (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CMM (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CMM (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CMM (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CMM (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CMM (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::CMMType > (
        ::xsd::qif2::CMM (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::CMMType > (
        ::xsd::qif2::CMM (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::CMMType > (
        ::xsd::qif2::CMM (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::CMMType > (
          ::xsd::qif2::CMM (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "CMM",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::CMMType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::CMMType > r (
          dynamic_cast< ::xsd::qif2::CMMType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CMM",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "CMM",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::CMMType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::CMMType > r (
          dynamic_cast< ::xsd::qif2::CMMType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CMM",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::CaliperType > (
        ::xsd::qif2::Caliper (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::CaliperType > (
        ::xsd::qif2::Caliper (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::CaliperType > (
        ::xsd::qif2::Caliper (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Caliper (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Caliper (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Caliper (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Caliper (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Caliper (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Caliper (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::CaliperType > (
        ::xsd::qif2::Caliper (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::CaliperType > (
        ::xsd::qif2::Caliper (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::CaliperType > (
        ::xsd::qif2::Caliper (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::CaliperType > (
          ::xsd::qif2::Caliper (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Caliper",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::CaliperType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::CaliperType > r (
          dynamic_cast< ::xsd::qif2::CaliperType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Caliper",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Caliper",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::CaliperType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::CaliperType > r (
          dynamic_cast< ::xsd::qif2::CaliperType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Caliper",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::GageDeviceType > (
        ::xsd::qif2::GageDevice (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::GageDeviceType > (
        ::xsd::qif2::GageDevice (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::GageDeviceType > (
        ::xsd::qif2::GageDevice (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GageDevice (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GageDevice (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GageDevice (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GageDevice (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GageDevice (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GageDevice (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::GageDeviceType > (
        ::xsd::qif2::GageDevice (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::GageDeviceType > (
        ::xsd::qif2::GageDevice (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::GageDeviceType > (
        ::xsd::qif2::GageDevice (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::GageDeviceType > (
          ::xsd::qif2::GageDevice (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "GageDevice",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::GageDeviceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::GageDeviceType > r (
          dynamic_cast< ::xsd::qif2::GageDeviceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GageDevice",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "GageDevice",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::GageDeviceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::GageDeviceType > r (
          dynamic_cast< ::xsd::qif2::GageDeviceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GageDevice",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::ComparatorType > (
        ::xsd::qif2::Comparator (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ComparatorType > (
        ::xsd::qif2::Comparator (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ComparatorType > (
        ::xsd::qif2::Comparator (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Comparator (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Comparator (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Comparator (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Comparator (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Comparator (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Comparator (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::ComparatorType > (
        ::xsd::qif2::Comparator (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ComparatorType > (
        ::xsd::qif2::Comparator (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ComparatorType > (
        ::xsd::qif2::Comparator (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::ComparatorType > (
          ::xsd::qif2::Comparator (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Comparator",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::ComparatorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::ComparatorType > r (
          dynamic_cast< ::xsd::qif2::ComparatorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Comparator",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Comparator",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::ComparatorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::ComparatorType > r (
          dynamic_cast< ::xsd::qif2::ComparatorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Comparator",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType > (
        ::xsd::qif2::CMMAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType > (
        ::xsd::qif2::CMMAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType > (
        ::xsd::qif2::CMMAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CMMAccuracyTest (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CMMAccuracyTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CMMAccuracyTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CMMAccuracyTest (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CMMAccuracyTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CMMAccuracyTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType > (
        ::xsd::qif2::CMMAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType > (
        ::xsd::qif2::CMMAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType > (
        ::xsd::qif2::CMMAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (const ::xercesc::DOMDocument& doc,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType > (
          ::xsd::qif2::CMMAccuracyTest (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "CMMAccuracyTest",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::CMMAccuracyTestBaseType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType > r (
          dynamic_cast< ::xsd::qif2::CMMAccuracyTestBaseType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CMMAccuracyTest",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "CMMAccuracyTest",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::CMMAccuracyTestBaseType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType > r (
          dynamic_cast< ::xsd::qif2::CMMAccuracyTestBaseType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CMMAccuracyTest",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::FPSTestType > (
        ::xsd::qif2::FPSTest (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FPSTestType > (
        ::xsd::qif2::FPSTest (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FPSTestType > (
        ::xsd::qif2::FPSTest (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FPSTest (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FPSTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FPSTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FPSTest (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FPSTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FPSTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::FPSTestType > (
        ::xsd::qif2::FPSTest (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FPSTestType > (
        ::xsd::qif2::FPSTest (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::FPSTestType > (
        ::xsd::qif2::FPSTest (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::FPSTestType > (
          ::xsd::qif2::FPSTest (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "FPSTest",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::FPSTestType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::FPSTestType > r (
          dynamic_cast< ::xsd::qif2::FPSTestType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FPSTest",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "FPSTest",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::FPSTestType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::FPSTestType > r (
          dynamic_cast< ::xsd::qif2::FPSTestType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FPSTest",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::B89TestType > (
        ::xsd::qif2::B89Test (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::B89TestType > (
        ::xsd::qif2::B89Test (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::B89TestType > (
        ::xsd::qif2::B89Test (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::B89Test (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::B89Test (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::B89Test (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::B89Test (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::B89Test (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::B89Test (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::B89TestType > (
        ::xsd::qif2::B89Test (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::B89TestType > (
        ::xsd::qif2::B89Test (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::B89TestType > (
        ::xsd::qif2::B89Test (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::B89TestType > (
          ::xsd::qif2::B89Test (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "B89Test",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::B89TestType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::B89TestType > r (
          dynamic_cast< ::xsd::qif2::B89TestType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "B89Test",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "B89Test",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::B89TestType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::B89TestType > r (
          dynamic_cast< ::xsd::qif2::B89TestType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "B89Test",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::ISO10360TestType > (
        ::xsd::qif2::ISO10360Test (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ISO10360TestType > (
        ::xsd::qif2::ISO10360Test (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ISO10360TestType > (
        ::xsd::qif2::ISO10360Test (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ISO10360Test (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ISO10360Test (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ISO10360Test (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ISO10360Test (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ISO10360Test (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ISO10360Test (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::ISO10360TestType > (
        ::xsd::qif2::ISO10360Test (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ISO10360TestType > (
        ::xsd::qif2::ISO10360Test (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::ISO10360TestType > (
        ::xsd::qif2::ISO10360Test (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::ISO10360TestType > (
          ::xsd::qif2::ISO10360Test (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ISO10360Test",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::ISO10360TestType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::ISO10360TestType > r (
          dynamic_cast< ::xsd::qif2::ISO10360TestType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ISO10360Test",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ISO10360Test",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::ISO10360TestType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::ISO10360TestType > r (
          dynamic_cast< ::xsd::qif2::ISO10360TestType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ISO10360Test",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType > (
        ::xsd::qif2::PointAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType > (
        ::xsd::qif2::PointAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType > (
        ::xsd::qif2::PointAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointAccuracyTest (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointAccuracyTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointAccuracyTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointAccuracyTest (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointAccuracyTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointAccuracyTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType > (
        ::xsd::qif2::PointAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType > (
        ::xsd::qif2::PointAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType > (
        ::xsd::qif2::PointAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (const ::xercesc::DOMDocument& doc,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType > (
          ::xsd::qif2::PointAccuracyTest (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "PointAccuracyTest",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::PointAccuracyTestType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType > r (
          dynamic_cast< ::xsd::qif2::PointAccuracyTestType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointAccuracyTest",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "PointAccuracyTest",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::PointAccuracyTestType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType > r (
          dynamic_cast< ::xsd::qif2::PointAccuracyTestType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointAccuracyTest",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::SensorType > (
        ::xsd::qif2::Sensor (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::SensorType > (
        ::xsd::qif2::Sensor (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::SensorType > (
        ::xsd::qif2::Sensor (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Sensor (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Sensor (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Sensor (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Sensor (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Sensor (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Sensor (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::SensorType > (
        ::xsd::qif2::Sensor (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::SensorType > (
        ::xsd::qif2::Sensor (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::SensorType > (
        ::xsd::qif2::Sensor (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::SensorType > (
          ::xsd::qif2::Sensor (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Sensor",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::SensorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::SensorType > r (
          dynamic_cast< ::xsd::qif2::SensorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Sensor",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Sensor",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::SensorType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::SensorType > r (
          dynamic_cast< ::xsd::qif2::SensorType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Sensor",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::TouchProbeType > (
        ::xsd::qif2::TouchProbe (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::TouchProbeType > (
        ::xsd::qif2::TouchProbe (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::TouchProbeType > (
        ::xsd::qif2::TouchProbe (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TouchProbe (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TouchProbe (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TouchProbe (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TouchProbe (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TouchProbe (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TouchProbe (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::xsd::qif2::TouchProbeType > (
        ::xsd::qif2::TouchProbe (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::TouchProbeType > (
        ::xsd::qif2::TouchProbe (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::xsd::qif2::TouchProbeType > (
        ::xsd::qif2::TouchProbe (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (const ::xercesc::DOMDocument& doc,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::xsd::qif2::TouchProbeType > (
          ::xsd::qif2::TouchProbe (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "TouchProbe",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::TouchProbeType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::xsd::qif2::TouchProbeType > r (
          dynamic_cast< ::xsd::qif2::TouchProbeType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "TouchProbe",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "TouchProbe",
          "http://qifstandards.org/xsd/qif2",
          &::xsd::cxx::tree::factory_impl< ::xsd::qif2::TouchProbeType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::xsd::qif2::TouchProbeType > r (
          dynamic_cast< ::xsd::qif2::TouchProbeType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "TouchProbe",
        "http://qifstandards.org/xsd/qif2");
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif2
  {
    void
    MeasurementResources (::std::ostream& o,
                          const ::xsd::qif2::MeasurementResourcesType& s,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::MeasurementResources (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    MeasurementResources (::std::ostream& o,
                          const ::xsd::qif2::MeasurementResourcesType& s,
                          ::xml_schema::error_handler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::MeasurementResources (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    MeasurementResources (::std::ostream& o,
                          const ::xsd::qif2::MeasurementResourcesType& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::MeasurementResources (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    MeasurementResources (::xercesc::XMLFormatTarget& t,
                          const ::xsd::qif2::MeasurementResourcesType& s,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::MeasurementResources (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    MeasurementResources (::xercesc::XMLFormatTarget& t,
                          const ::xsd::qif2::MeasurementResourcesType& s,
                          ::xml_schema::error_handler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::MeasurementResources (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    MeasurementResources (::xercesc::XMLFormatTarget& t,
                          const ::xsd::qif2::MeasurementResourcesType& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::string& e,
                          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::MeasurementResources (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    MeasurementResources (::xercesc::DOMDocument& d,
                          const ::xsd::qif2::MeasurementResourcesType& s,
                          ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "MeasurementResources" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "MeasurementResources",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    MeasurementResources (const ::xsd::qif2::MeasurementResourcesType& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "MeasurementResources",
          "http://qifstandards.org/xsd/qif2",
          m, f));

      ::xsd::qif2::MeasurementResources (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const MeasurementResourcesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Version
      //
      if (i.Version ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Version",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Version ();
      }

      // Carriages
      //
      if (i.Carriages ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Carriages",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Carriages ();
      }

      // Fixtures
      //
      if (i.Fixtures ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Fixtures",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Fixtures ();
      }

      // MeasurementDevices
      //
      if (i.MeasurementDevices ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MeasurementDevices",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MeasurementDevices ();
      }

      // Sensors
      //
      if (i.Sensors ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Sensors",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Sensors ();
      }

      // Tools
      //
      if (i.Tools ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Tools",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Tools ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CarriagesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Carriage
      //
      for (CarriagesType::Carriage_const_iterator
           b (i.Carriage ().begin ()), n (i.Carriage ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Carriage",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FixturesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Fixture
      //
      for (FixturesType::Fixture_const_iterator
           b (i.Fixture ().begin ()), n (i.Fixture ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Fixture",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SensorsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Sensor
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (SensorsType::Sensor_const_iterator
             b (i.Sensor ().begin ()), n (i.Sensor ().end ());
             b != n; ++b)
        {
          if (typeid (SensorsType::Sensor_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Sensor",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "Sensor",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ToolsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Tool
      //
      for (ToolsType::Tool_const_iterator
           b (i.Tool ().begin ()), n (i.Tool ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Tool",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const MeasurementDevicesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MeasurementDevice
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (MeasurementDevicesType::MeasurementDevice_const_iterator
             b (i.MeasurementDevice ().begin ()), n (i.MeasurementDevice ().end ());
             b != n; ++b)
        {
          if (typeid (MeasurementDevicesType::MeasurementDevice_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "MeasurementDevice",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "MeasurementDevice",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const MeasurementResourceBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Name
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Name",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Name ();
      }

      // Description
      //
      if (i.Description ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Description",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Description ();
      }

      // Manufacturer
      //
      if (i.Manufacturer ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Manufacturer",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Manufacturer ();
      }

      // ModelNumber
      //
      if (i.ModelNumber ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ModelNumber",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ModelNumber ();
      }

      // SerialNumber
      //
      if (i.SerialNumber ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SerialNumber",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SerialNumber ();
      }

      // LocationId
      //
      if (i.LocationId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LocationId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LocationId ();
      }

      // Location
      //
      if (i.Location ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Location ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FixtureType& i)
    {
      e << static_cast< const ::xsd::qif2::MeasurementResourceBaseType& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const MeasurementDeviceAccuracyBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr&, const MeasurementDeviceAccuracyBaseType&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const MeasurementDeviceAccuracyBaseType&)
    {
    }

    void
    operator<< (::xercesc::DOMElement& e, const NumericalLengthAccuracyType& i)
    {
      e << static_cast< const ::xsd::qif2::MeasurementDeviceAccuracyBaseType& > (i);

      // AccuracyValue
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AccuracyValue",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.AccuracyValue ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const MeasurementDeviceType& i)
    {
      e << static_cast< const ::xsd::qif2::MeasurementResourceBaseType& > (i);

      // Calibrations
      //
      if (i.Calibrations ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Calibrations",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Calibrations ();
      }

      // InspectionTemperatures
      //
      if (i.InspectionTemperatures ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InspectionTemperatures",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.InspectionTemperatures ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MeasurementDeviceType >
    _xsd_MeasurementDeviceType_type_serializer_init (
      "MeasurementDeviceType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CalibrationMasterType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SerialNumber
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SerialNumber",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SerialNumber ();
      }

      // description
      //
      if (i.description ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "description",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.description ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CalibrationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CalibrationMaster
      //
      if (i.CalibrationMaster ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CalibrationMaster",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CalibrationMaster ();
      }

      // Temperatures
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Temperatures",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Temperatures ();
      }

      // TimeStamp
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TimeStamp",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.TimeStamp ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CalibrationsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Calibration
      //
      for (CalibrationsType::Calibration_const_iterator
           b (i.Calibration ().begin ()), n (i.Calibration ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Calibration",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TemperaturesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Temperature
      //
      for (TemperaturesType::Temperature_const_iterator
           b (i.Temperature ().begin ()), n (i.Temperature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Temperature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TemperatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Attributes",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Attributes ();
      }

      // Temperature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Temperature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Temperature ();
      }

      // TimeStamp
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TimeStamp",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.TimeStamp ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const QualificationsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Qualification
      //
      for (QualificationsType::Qualification_const_iterator
           b (i.Qualification ().begin ()), n (i.Qualification ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Qualification",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const QualificationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Attributes",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Attributes ();
      }

      // Description
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Description",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Description ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SensorType& i)
    {
      e << static_cast< const ::xsd::qif2::MeasurementResourceBaseType& > (i);

      // Qualifications
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Qualifications",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Qualifications ();
      }

      // AAngle
      //
      if (i.AAngle ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AAngle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.AAngle ();
      }

      // BAngle
      //
      if (i.BAngle ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BAngle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BAngle ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SensorType >
    _xsd_SensorType_type_serializer_init (
      "SensorType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const TouchProbeType& i)
    {
      e << static_cast< const ::xsd::qif2::SensorType& > (i);

      // TipDiameter
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TipDiameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.TipDiameter ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TouchProbeType >
    _xsd_TouchProbeType_type_serializer_init (
      "TouchProbeType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ToolType& i)
    {
      e << static_cast< const ::xsd::qif2::MeasurementResourceBaseType& > (i);

      // SensorIds
      //
      if (i.SensorIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SensorIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SensorIds ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CarriageType& i)
    {
      e << static_cast< const ::xsd::qif2::MeasurementResourceBaseType& > (i);

      // ToolIds
      //
      if (i.ToolIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ToolIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ToolIds ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ProbingDeviceType& i)
    {
      e << static_cast< const ::xsd::qif2::MeasurementDeviceType& > (i);

      // WorkingVolume
      //
      if (i.WorkingVolume ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "WorkingVolume",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.WorkingVolume ();
      }

      // EffectiveWorkingVolume
      //
      if (i.EffectiveWorkingVolume ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EffectiveWorkingVolume",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.EffectiveWorkingVolume ();
      }

      // Resolution
      //
      if (i.Resolution ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Resolution",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Resolution ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ProbingDeviceType >
    _xsd_ProbingDeviceType_type_serializer_init (
      "ProbingDeviceType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CMMType& i)
    {
      e << static_cast< const ::xsd::qif2::ProbingDeviceType& > (i);

      // HomeLocation
      //
      if (i.HomeLocation ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "HomeLocation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.HomeLocation ();
      }

      // MachineGeometry
      //
      if (i.MachineGeometry ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MachineGeometry",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MachineGeometry ();
      }

      // AxisOrientation
      //
      if (i.AxisOrientation ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AxisOrientation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.AxisOrientation ();
      }

      // CMMScales
      //
      if (i.CMMScales ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CMMScales",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CMMScales ();
      }

      // MaxWorkpieceHeight
      //
      if (i.MaxWorkpieceHeight ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxWorkpieceHeight",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MaxWorkpieceHeight ();
      }

      // MaxWorkpieceMass
      //
      if (i.MaxWorkpieceMass ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxWorkpieceMass",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MaxWorkpieceMass ();
      }

      // JoystickSpeeds
      //
      if (i.JoystickSpeeds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "JoystickSpeeds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.JoystickSpeeds ();
      }

      // CNCSpeeds
      //
      if (i.CNCSpeeds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CNCSpeeds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CNCSpeeds ();
      }

      // RotaryTable
      //
      if (i.RotaryTable ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RotaryTable",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.RotaryTable ();
      }

      // NominalAccuracy
      //
      if (i.NominalAccuracy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "NominalAccuracy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.NominalAccuracy ();
      }

      // ActualAccuracy
      //
      if (i.ActualAccuracy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ActualAccuracy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ActualAccuracy ();
      }

      // CarriageIds
      //
      if (i.CarriageIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CarriageIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CarriageIds ();
      }

      // ToolIds
      //
      if (i.ToolIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ToolIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ToolIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CMMType >
    _xsd_CMMType_type_serializer_init (
      "CMMType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CMMScalesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // XScale
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "XScale",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.XScale ();
      }

      // YScale
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "YScale",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.YScale ();
      }

      // ZScale
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ZScale",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ZScale ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CMMScaleType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ScaleMaterial
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ScaleMaterial",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ScaleMaterial ();
      }

      // ScaleCoefficientOfExpansion
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ScaleCoefficientOfExpansion",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << ::xml_schema::as_decimal(i.ScaleCoefficientOfExpansion ());
      }

      // ScaleCoefficientOfExpansionUncertainty
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ScaleCoefficientOfExpansionUncertainty",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << ::xml_schema::as_decimal(i.ScaleCoefficientOfExpansionUncertainty ());
      }

      // TypeOfScale
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TypeOfScale",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.TypeOfScale ();
      }

      // ScaleResolution
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ScaleResolution",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ScaleResolution ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CMMSpeedsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MaxXTraverseSpeed
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxXTraverseSpeed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.MaxXTraverseSpeed ();
      }

      // MaxYTraverseSpeed
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxYTraverseSpeed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.MaxYTraverseSpeed ();
      }

      // MaxZTraverseSpeed
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxZTraverseSpeed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.MaxZTraverseSpeed ();
      }

      // MaxXProbingSpeed
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxXProbingSpeed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.MaxXProbingSpeed ();
      }

      // MaxYProbingSpeed
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxYProbingSpeed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.MaxYProbingSpeed ();
      }

      // MaxZProbingSpeed
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxZProbingSpeed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.MaxZProbingSpeed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const GageDeviceType& i)
    {
      e << static_cast< const ::xsd::qif2::MeasurementDeviceType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GageDeviceType >
    _xsd_GageDeviceType_type_serializer_init (
      "GageDeviceType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ManualDeviceType& i)
    {
      e << static_cast< const ::xsd::qif2::MeasurementDeviceType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ManualDeviceType >
    _xsd_ManualDeviceType_type_serializer_init (
      "ManualDeviceType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CaliperType& i)
    {
      e << static_cast< const ::xsd::qif2::ManualDeviceType& > (i);

      // Resolution
      //
      if (i.Resolution ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Resolution",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Resolution ();
      }

      // Accuracy
      //
      if (i.Accuracy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Accuracy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Accuracy ();
      }

      // MinMeasurement
      //
      if (i.MinMeasurement ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinMeasurement",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MinMeasurement ();
      }

      // MaxMeasurement
      //
      if (i.MaxMeasurement ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxMeasurement",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MaxMeasurement ();
      }

      // CanMeasureInnerD
      //
      if (i.CanMeasureInnerD ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CanMeasureInnerD",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CanMeasureInnerD ();
      }

      // CanMeasureOuterD
      //
      if (i.CanMeasureOuterD ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CanMeasureOuterD",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CanMeasureOuterD ();
      }

      // CanMeasureDepth
      //
      if (i.CanMeasureDepth ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CanMeasureDepth",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CanMeasureDepth ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CaliperType >
    _xsd_CaliperType_type_serializer_init (
      "CaliperType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CMMDirectionEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const CMMDirectionEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const CMMDirectionEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const CMMGeometryType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CMMGeometryEnum
      //
      if (i.CMMGeometryEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CMMGeometryEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CMMGeometryEnum ();
      }

      // OtherCMMGeometry
      //
      if (i.OtherCMMGeometry ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherCMMGeometry",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.OtherCMMGeometry ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CMMGeometryEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const CMMGeometryEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const CMMGeometryEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const CMMAxisDirectionsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // XAxisDirection
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "XAxisDirection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.XAxisDirection ();
      }

      // YAxisDirection
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "YAxisDirection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.YAxisDirection ();
      }

      // ZAxisDirection
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ZAxisDirection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ZAxisDirection ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const WorkingVolumeType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // XAxisLength
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "XAxisLength",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.XAxisLength ();
      }

      // YAxisLength
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "YAxisLength",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.YAxisLength ();
      }

      // ZAxisLength
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ZAxisLength",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ZAxisLength ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EffectiveWorkingVolumeType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MinPoint
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinPoint",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.MinPoint ();
      }

      // MaxPoint
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxPoint",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.MaxPoint ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const RotaryTableType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // LocationOnCMM
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LocationOnCMM",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.LocationOnCMM ();
      }

      // AxisDirection
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AxisDirection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.AxisDirection ();
      }

      // ZeroIndexDirection
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ZeroIndexDirection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ZeroIndexDirection ();
      }

      // TableRadius
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TableRadius",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.TableRadius ();
      }

      // TableErrors
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TableErrors",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.TableErrors ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TableErrorsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // AxialError
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AxialError",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.AxialError ();
      }

      // RadialError
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RadialError",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.RadialError ();
      }

      // TangentialError
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TangentialError",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.TangentialError ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ResolutionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CombinedResolution
      //
      if (i.CombinedResolution ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CombinedResolution",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CombinedResolution ();
      }

      // XYZResolution
      //
      if (i.XYZResolution ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "XYZResolution",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.XYZResolution ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const XYZResolutionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // XResolution
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "XResolution",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.XResolution ();
      }

      // YResolution
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "YResolution",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.YResolution ();
      }

      // ZResolution
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ZResolution",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ZResolution ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CMMAccuracyTestBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr&, const CMMAccuracyTestBaseType&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const CMMAccuracyTestBaseType&)
    {
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CMMAccuracyTestBaseType >
    _xsd_CMMAccuracyTestBaseType_type_serializer_init (
      "CMMAccuracyTestBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const FPSTestType& i)
    {
      e << static_cast< const ::xsd::qif2::CMMAccuracyTestBaseType& > (i);

      // XLinearity
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "XLinearity",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.XLinearity ();
      }

      // YLinearity
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "YLinearity",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.YLinearity ();
      }

      // ZLinearity
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ZLinearity",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ZLinearity ();
      }

      // XAxisRoll
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "XAxisRoll",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.XAxisRoll ();
      }

      // XAxisPitch
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "XAxisPitch",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.XAxisPitch ();
      }

      // XAxisYaw
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "XAxisYaw",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.XAxisYaw ();
      }

      // YAxisRoll
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "YAxisRoll",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.YAxisRoll ();
      }

      // YAxisPitch
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "YAxisPitch",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.YAxisPitch ();
      }

      // YAxisYaw
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "YAxisYaw",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.YAxisYaw ();
      }

      // ZAxisRoll
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ZAxisRoll",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ZAxisRoll ();
      }

      // ZAxisPitch
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ZAxisPitch",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ZAxisPitch ();
      }

      // ZAxisYaw
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ZAxisYaw",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ZAxisYaw ();
      }

      // XAxisStraightnessY
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "XAxisStraightnessY",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.XAxisStraightnessY ();
      }

      // XAxisStraightnessZ
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "XAxisStraightnessZ",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.XAxisStraightnessZ ();
      }

      // YAxisStraightnessX
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "YAxisStraightnessX",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.YAxisStraightnessX ();
      }

      // YAxisStraightnessZ
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "YAxisStraightnessZ",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.YAxisStraightnessZ ();
      }

      // ZAxisStraightnessX
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ZAxisStraightnessX",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ZAxisStraightnessX ();
      }

      // ZAxisStraightnessY
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ZAxisStraightnessY",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ZAxisStraightnessY ();
      }

      // XYSquareness
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "XYSquareness",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << ::xml_schema::as_double(i.XYSquareness ());
      }

      // XZSquareness
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "XZSquareness",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << ::xml_schema::as_double(i.XZSquareness ());
      }

      // YZSquareness
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "YZSquareness",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << ::xml_schema::as_double(i.YZSquareness ());
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FPSTestType >
    _xsd_FPSTestType_type_serializer_init (
      "FPSTestType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const FunctionDiscreteType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DomainValues
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DomainValues",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DomainValues ();
      }

      // RangeValues
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RangeValues",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.RangeValues ();
      }

      // N
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "N",
            e));

        a << i.N ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LengthFunctionDiscreteType& i)
    {
      e << static_cast< const ::xsd::qif2::FunctionDiscreteType& > (i);

      // DomainLinearUnit
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DomainLinearUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DomainLinearUnit ();
      }

      // RangeLinearUnit
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RangeLinearUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.RangeLinearUnit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const AngleFunctionDiscreteType& i)
    {
      e << static_cast< const ::xsd::qif2::FunctionDiscreteType& > (i);

      // DomainLinearUnit
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DomainLinearUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DomainLinearUnit ();
      }

      // RangeAngularUnit
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RangeAngularUnit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.RangeAngularUnit ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const B89TestType& i)
    {
      e << static_cast< const ::xsd::qif2::CMMAccuracyTestBaseType& > (i);

      // XLinearAccuracy
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "XLinearAccuracy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.XLinearAccuracy ();
      }

      // YLinearAccuracy
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "YLinearAccuracy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.YLinearAccuracy ();
      }

      // ZLinearAccuracy
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ZLinearAccuracy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ZLinearAccuracy ();
      }

      // OffsetVolumetricPerformance
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OffsetVolumetricPerformance",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.OffsetVolumetricPerformance ();
      }

      // VolumetricPerformance
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "VolumetricPerformance",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.VolumetricPerformance ();
      }

      // Repeatability
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Repeatability",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Repeatability ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, B89TestType >
    _xsd_B89TestType_type_serializer_init (
      "B89TestType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ISO10360TestType& i)
    {
      e << static_cast< const ::xsd::qif2::CMMAccuracyTestBaseType& > (i);

      // MaxErrorConstant
      //
      if (i.MaxErrorConstant ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxErrorConstant",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MaxErrorConstant ();
      }

      // LinearError
      //
      if (i.LinearError ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LinearError",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LinearError ();
      }

      // LesserError
      //
      if (i.LesserError ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LesserError",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LesserError ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ISO10360TestType >
    _xsd_ISO10360TestType_type_serializer_init (
      "ISO10360TestType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const LinearErrorType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BaseError
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseError",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseError ();
      }

      // ErrorRate
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ErrorRate",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << ::xml_schema::as_decimal(i.ErrorRate ());
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LesserErrorType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MaxErrorConstant
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxErrorConstant",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.MaxErrorConstant ();
      }

      // LinearError
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LinearError",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.LinearError ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointAccuracyTestType& i)
    {
      e << static_cast< const ::xsd::qif2::CMMAccuracyTestBaseType& > (i);

      // Accuracy
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Accuracy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Accuracy ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PointAccuracyTestType >
    _xsd_PointAccuracyTestType_type_serializer_init (
      "PointAccuracyTestType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CMMAccuracyType& i)
    {
      e << static_cast< const ::xsd::qif2::MeasurementDeviceAccuracyBaseType& > (i);

      // MinTemperature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinTemperature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.MinTemperature ();
      }

      // MaxTemperature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxTemperature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.MaxTemperature ();
      }

      // CMMAccuracyTest
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const CMMAccuracyType::CMMAccuracyTest_type& x (i.CMMAccuracyTest ());
        if (typeid (CMMAccuracyType::CMMAccuracyTest_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "CMMAccuracyTest",
              "http://qifstandards.org/xsd/qif2",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "CMMAccuracyTest",
            "http://qifstandards.org/xsd/qif2",
            true, true, e, x);
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ComparatorType& i)
    {
      e << static_cast< const ::xsd::qif2::ProbingDeviceType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ComparatorType >
    _xsd_ComparatorType_type_serializer_init (
      "ComparatorType",
      "http://qifstandards.org/xsd/qif2");


    void
    MeasurementDevice (::std::ostream& o,
                       const ::xsd::qif2::MeasurementDeviceType& s,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::MeasurementDevice (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    MeasurementDevice (::std::ostream& o,
                       const ::xsd::qif2::MeasurementDeviceType& s,
                       ::xml_schema::error_handler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::MeasurementDevice (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    MeasurementDevice (::std::ostream& o,
                       const ::xsd::qif2::MeasurementDeviceType& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::MeasurementDevice (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    MeasurementDevice (::xercesc::XMLFormatTarget& t,
                       const ::xsd::qif2::MeasurementDeviceType& s,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::MeasurementDevice (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    MeasurementDevice (::xercesc::XMLFormatTarget& t,
                       const ::xsd::qif2::MeasurementDeviceType& s,
                       ::xml_schema::error_handler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::MeasurementDevice (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    MeasurementDevice (::xercesc::XMLFormatTarget& t,
                       const ::xsd::qif2::MeasurementDeviceType& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::MeasurementDevice (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    MeasurementDevice (::xercesc::DOMDocument& d,
                       const ::xsd::qif2::MeasurementDeviceType& s,
                       ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::MeasurementDeviceType) == typeid (s))
      {
        if (n.name () == "MeasurementDevice" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "MeasurementDevice",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "MeasurementDevice",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    MeasurementDevice (const ::xsd::qif2::MeasurementDeviceType& s,
                       const ::xml_schema::namespace_infomap& m,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::MeasurementDeviceType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "MeasurementDevice",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "MeasurementDevice",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::MeasurementDevice (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::CMMType >
    _xsd_CMM_element_serializer_init (
      "MeasurementDevice",
      "http://qifstandards.org/xsd/qif2",
      "CMM",
      "http://qifstandards.org/xsd/qif2");


    void
    CMM (::std::ostream& o,
         const ::xsd::qif2::CMMType& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::CMM (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    CMM (::std::ostream& o,
         const ::xsd::qif2::CMMType& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::CMM (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    CMM (::std::ostream& o,
         const ::xsd::qif2::CMMType& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::CMM (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    CMM (::xercesc::XMLFormatTarget& t,
         const ::xsd::qif2::CMMType& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::CMM (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    CMM (::xercesc::XMLFormatTarget& t,
         const ::xsd::qif2::CMMType& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::CMM (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    CMM (::xercesc::XMLFormatTarget& t,
         const ::xsd::qif2::CMMType& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::CMM (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    CMM (::xercesc::DOMDocument& d,
         const ::xsd::qif2::CMMType& s,
         ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::CMMType) == typeid (s))
      {
        if (n.name () == "CMM" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "CMM",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "CMM",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    CMM (const ::xsd::qif2::CMMType& s,
         const ::xml_schema::namespace_infomap& m,
         ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::CMMType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "CMM",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "CMM",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::CMM (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::CaliperType >
    _xsd_Caliper_element_serializer_init (
      "MeasurementDevice",
      "http://qifstandards.org/xsd/qif2",
      "Caliper",
      "http://qifstandards.org/xsd/qif2");


    void
    Caliper (::std::ostream& o,
             const ::xsd::qif2::CaliperType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Caliper (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Caliper (::std::ostream& o,
             const ::xsd::qif2::CaliperType& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Caliper (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Caliper (::std::ostream& o,
             const ::xsd::qif2::CaliperType& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Caliper (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Caliper (::xercesc::XMLFormatTarget& t,
             const ::xsd::qif2::CaliperType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Caliper (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Caliper (::xercesc::XMLFormatTarget& t,
             const ::xsd::qif2::CaliperType& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Caliper (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Caliper (::xercesc::XMLFormatTarget& t,
             const ::xsd::qif2::CaliperType& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Caliper (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Caliper (::xercesc::DOMDocument& d,
             const ::xsd::qif2::CaliperType& s,
             ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::CaliperType) == typeid (s))
      {
        if (n.name () == "Caliper" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Caliper",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Caliper",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Caliper (const ::xsd::qif2::CaliperType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::CaliperType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Caliper",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Caliper",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::Caliper (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::GageDeviceType >
    _xsd_GageDevice_element_serializer_init (
      "MeasurementDevice",
      "http://qifstandards.org/xsd/qif2",
      "GageDevice",
      "http://qifstandards.org/xsd/qif2");


    void
    GageDevice (::std::ostream& o,
                const ::xsd::qif2::GageDeviceType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::GageDevice (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    GageDevice (::std::ostream& o,
                const ::xsd::qif2::GageDeviceType& s,
                ::xml_schema::error_handler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::GageDevice (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    GageDevice (::std::ostream& o,
                const ::xsd::qif2::GageDeviceType& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::GageDevice (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    GageDevice (::xercesc::XMLFormatTarget& t,
                const ::xsd::qif2::GageDeviceType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::GageDevice (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    GageDevice (::xercesc::XMLFormatTarget& t,
                const ::xsd::qif2::GageDeviceType& s,
                ::xml_schema::error_handler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::GageDevice (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    GageDevice (::xercesc::XMLFormatTarget& t,
                const ::xsd::qif2::GageDeviceType& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::GageDevice (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    GageDevice (::xercesc::DOMDocument& d,
                const ::xsd::qif2::GageDeviceType& s,
                ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::GageDeviceType) == typeid (s))
      {
        if (n.name () == "GageDevice" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "GageDevice",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "GageDevice",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    GageDevice (const ::xsd::qif2::GageDeviceType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::GageDeviceType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "GageDevice",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "GageDevice",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::GageDevice (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ComparatorType >
    _xsd_Comparator_element_serializer_init (
      "MeasurementDevice",
      "http://qifstandards.org/xsd/qif2",
      "Comparator",
      "http://qifstandards.org/xsd/qif2");


    void
    Comparator (::std::ostream& o,
                const ::xsd::qif2::ComparatorType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Comparator (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Comparator (::std::ostream& o,
                const ::xsd::qif2::ComparatorType& s,
                ::xml_schema::error_handler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Comparator (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Comparator (::std::ostream& o,
                const ::xsd::qif2::ComparatorType& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Comparator (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Comparator (::xercesc::XMLFormatTarget& t,
                const ::xsd::qif2::ComparatorType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Comparator (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Comparator (::xercesc::XMLFormatTarget& t,
                const ::xsd::qif2::ComparatorType& s,
                ::xml_schema::error_handler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Comparator (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Comparator (::xercesc::XMLFormatTarget& t,
                const ::xsd::qif2::ComparatorType& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Comparator (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Comparator (::xercesc::DOMDocument& d,
                const ::xsd::qif2::ComparatorType& s,
                ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::ComparatorType) == typeid (s))
      {
        if (n.name () == "Comparator" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Comparator",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Comparator",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Comparator (const ::xsd::qif2::ComparatorType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::ComparatorType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Comparator",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Comparator",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::Comparator (*d, s, f);
      return d;
    }

    void
    CMMAccuracyTest (::std::ostream& o,
                     const ::xsd::qif2::CMMAccuracyTestBaseType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::CMMAccuracyTest (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    CMMAccuracyTest (::std::ostream& o,
                     const ::xsd::qif2::CMMAccuracyTestBaseType& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::CMMAccuracyTest (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    CMMAccuracyTest (::std::ostream& o,
                     const ::xsd::qif2::CMMAccuracyTestBaseType& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::CMMAccuracyTest (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    CMMAccuracyTest (::xercesc::XMLFormatTarget& t,
                     const ::xsd::qif2::CMMAccuracyTestBaseType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::CMMAccuracyTest (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    CMMAccuracyTest (::xercesc::XMLFormatTarget& t,
                     const ::xsd::qif2::CMMAccuracyTestBaseType& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::CMMAccuracyTest (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    CMMAccuracyTest (::xercesc::XMLFormatTarget& t,
                     const ::xsd::qif2::CMMAccuracyTestBaseType& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::string& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::CMMAccuracyTest (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    CMMAccuracyTest (::xercesc::DOMDocument& d,
                     const ::xsd::qif2::CMMAccuracyTestBaseType& s,
                     ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::CMMAccuracyTestBaseType) == typeid (s))
      {
        if (n.name () == "CMMAccuracyTest" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "CMMAccuracyTest",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "CMMAccuracyTest",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    CMMAccuracyTest (const ::xsd::qif2::CMMAccuracyTestBaseType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::CMMAccuracyTestBaseType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "CMMAccuracyTest",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "CMMAccuracyTest",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::CMMAccuracyTest (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::FPSTestType >
    _xsd_FPSTest_element_serializer_init (
      "CMMAccuracyTest",
      "http://qifstandards.org/xsd/qif2",
      "FPSTest",
      "http://qifstandards.org/xsd/qif2");


    void
    FPSTest (::std::ostream& o,
             const ::xsd::qif2::FPSTestType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FPSTest (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    FPSTest (::std::ostream& o,
             const ::xsd::qif2::FPSTestType& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FPSTest (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    FPSTest (::std::ostream& o,
             const ::xsd::qif2::FPSTestType& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FPSTest (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    FPSTest (::xercesc::XMLFormatTarget& t,
             const ::xsd::qif2::FPSTestType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FPSTest (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    FPSTest (::xercesc::XMLFormatTarget& t,
             const ::xsd::qif2::FPSTestType& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FPSTest (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    FPSTest (::xercesc::XMLFormatTarget& t,
             const ::xsd::qif2::FPSTestType& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::FPSTest (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    FPSTest (::xercesc::DOMDocument& d,
             const ::xsd::qif2::FPSTestType& s,
             ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::FPSTestType) == typeid (s))
      {
        if (n.name () == "FPSTest" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "FPSTest",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "FPSTest",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    FPSTest (const ::xsd::qif2::FPSTestType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::FPSTestType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "FPSTest",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "FPSTest",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::FPSTest (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::B89TestType >
    _xsd_B89Test_element_serializer_init (
      "CMMAccuracyTest",
      "http://qifstandards.org/xsd/qif2",
      "B89Test",
      "http://qifstandards.org/xsd/qif2");


    void
    B89Test (::std::ostream& o,
             const ::xsd::qif2::B89TestType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::B89Test (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    B89Test (::std::ostream& o,
             const ::xsd::qif2::B89TestType& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::B89Test (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    B89Test (::std::ostream& o,
             const ::xsd::qif2::B89TestType& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::B89Test (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    B89Test (::xercesc::XMLFormatTarget& t,
             const ::xsd::qif2::B89TestType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::B89Test (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    B89Test (::xercesc::XMLFormatTarget& t,
             const ::xsd::qif2::B89TestType& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::B89Test (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    B89Test (::xercesc::XMLFormatTarget& t,
             const ::xsd::qif2::B89TestType& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::B89Test (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    B89Test (::xercesc::DOMDocument& d,
             const ::xsd::qif2::B89TestType& s,
             ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::B89TestType) == typeid (s))
      {
        if (n.name () == "B89Test" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "B89Test",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "B89Test",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    B89Test (const ::xsd::qif2::B89TestType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::B89TestType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "B89Test",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "B89Test",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::B89Test (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ISO10360TestType >
    _xsd_ISO10360Test_element_serializer_init (
      "CMMAccuracyTest",
      "http://qifstandards.org/xsd/qif2",
      "ISO10360Test",
      "http://qifstandards.org/xsd/qif2");


    void
    ISO10360Test (::std::ostream& o,
                  const ::xsd::qif2::ISO10360TestType& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ISO10360Test (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ISO10360Test (::std::ostream& o,
                  const ::xsd::qif2::ISO10360TestType& s,
                  ::xml_schema::error_handler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ISO10360Test (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ISO10360Test (::std::ostream& o,
                  const ::xsd::qif2::ISO10360TestType& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ISO10360Test (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ISO10360Test (::xercesc::XMLFormatTarget& t,
                  const ::xsd::qif2::ISO10360TestType& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ISO10360Test (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    ISO10360Test (::xercesc::XMLFormatTarget& t,
                  const ::xsd::qif2::ISO10360TestType& s,
                  ::xml_schema::error_handler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ISO10360Test (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ISO10360Test (::xercesc::XMLFormatTarget& t,
                  const ::xsd::qif2::ISO10360TestType& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::ISO10360Test (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    ISO10360Test (::xercesc::DOMDocument& d,
                  const ::xsd::qif2::ISO10360TestType& s,
                  ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::ISO10360TestType) == typeid (s))
      {
        if (n.name () == "ISO10360Test" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "ISO10360Test",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ISO10360Test",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    ISO10360Test (const ::xsd::qif2::ISO10360TestType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::ISO10360TestType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "ISO10360Test",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "ISO10360Test",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::ISO10360Test (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PointAccuracyTestType >
    _xsd_PointAccuracyTest_element_serializer_init (
      "CMMAccuracyTest",
      "http://qifstandards.org/xsd/qif2",
      "PointAccuracyTest",
      "http://qifstandards.org/xsd/qif2");


    void
    PointAccuracyTest (::std::ostream& o,
                       const ::xsd::qif2::PointAccuracyTestType& s,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::PointAccuracyTest (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    PointAccuracyTest (::std::ostream& o,
                       const ::xsd::qif2::PointAccuracyTestType& s,
                       ::xml_schema::error_handler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::PointAccuracyTest (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    PointAccuracyTest (::std::ostream& o,
                       const ::xsd::qif2::PointAccuracyTestType& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::PointAccuracyTest (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    PointAccuracyTest (::xercesc::XMLFormatTarget& t,
                       const ::xsd::qif2::PointAccuracyTestType& s,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::PointAccuracyTest (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    PointAccuracyTest (::xercesc::XMLFormatTarget& t,
                       const ::xsd::qif2::PointAccuracyTestType& s,
                       ::xml_schema::error_handler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::PointAccuracyTest (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    PointAccuracyTest (::xercesc::XMLFormatTarget& t,
                       const ::xsd::qif2::PointAccuracyTestType& s,
                       ::xercesc::DOMErrorHandler& h,
                       const ::xml_schema::namespace_infomap& m,
                       const ::std::string& e,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::PointAccuracyTest (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    PointAccuracyTest (::xercesc::DOMDocument& d,
                       const ::xsd::qif2::PointAccuracyTestType& s,
                       ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::PointAccuracyTestType) == typeid (s))
      {
        if (n.name () == "PointAccuracyTest" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "PointAccuracyTest",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "PointAccuracyTest",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    PointAccuracyTest (const ::xsd::qif2::PointAccuracyTestType& s,
                       const ::xml_schema::namespace_infomap& m,
                       ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::PointAccuracyTestType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "PointAccuracyTest",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "PointAccuracyTest",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::PointAccuracyTest (*d, s, f);
      return d;
    }

    void
    Sensor (::std::ostream& o,
            const ::xsd::qif2::SensorType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Sensor (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Sensor (::std::ostream& o,
            const ::xsd::qif2::SensorType& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Sensor (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Sensor (::std::ostream& o,
            const ::xsd::qif2::SensorType& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Sensor (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Sensor (::xercesc::XMLFormatTarget& t,
            const ::xsd::qif2::SensorType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Sensor (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    Sensor (::xercesc::XMLFormatTarget& t,
            const ::xsd::qif2::SensorType& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Sensor (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Sensor (::xercesc::XMLFormatTarget& t,
            const ::xsd::qif2::SensorType& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::Sensor (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    Sensor (::xercesc::DOMDocument& d,
            const ::xsd::qif2::SensorType& s,
            ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::SensorType) == typeid (s))
      {
        if (n.name () == "Sensor" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "Sensor",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Sensor",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Sensor (const ::xsd::qif2::SensorType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::SensorType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "Sensor",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "Sensor",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::Sensor (*d, s, f);
      return d;
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::TouchProbeType >
    _xsd_TouchProbe_element_serializer_init (
      "Sensor",
      "http://qifstandards.org/xsd/qif2",
      "TouchProbe",
      "http://qifstandards.org/xsd/qif2");


    void
    TouchProbe (::std::ostream& o,
                const ::xsd::qif2::TouchProbeType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::TouchProbe (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    TouchProbe (::std::ostream& o,
                const ::xsd::qif2::TouchProbeType& s,
                ::xml_schema::error_handler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::TouchProbe (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    TouchProbe (::std::ostream& o,
                const ::xsd::qif2::TouchProbeType& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::TouchProbe (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    TouchProbe (::xercesc::XMLFormatTarget& t,
                const ::xsd::qif2::TouchProbeType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::TouchProbe (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    TouchProbe (::xercesc::XMLFormatTarget& t,
                const ::xsd::qif2::TouchProbeType& s,
                ::xml_schema::error_handler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::TouchProbe (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    TouchProbe (::xercesc::XMLFormatTarget& t,
                const ::xsd::qif2::TouchProbeType& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::qif2::TouchProbe (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    TouchProbe (::xercesc::DOMDocument& d,
                const ::xsd::qif2::TouchProbeType& s,
                ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (typeid (::xsd::qif2::TouchProbeType) == typeid (s))
      {
        if (n.name () == "TouchProbe" &&
            n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < char > (
            n.name (),
            n.namespace_ (),
            "TouchProbe",
            "http://qifstandards.org/xsd/qif2");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "TouchProbe",
          "http://qifstandards.org/xsd/qif2",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    TouchProbe (const ::xsd::qif2::TouchProbeType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::xsd::qif2::TouchProbeType) == typeid (s))
      {
        d = ::xsd::cxx::xml::dom::serialize< char > (
          "TouchProbe",
          "http://qifstandards.org/xsd/qif2",
          m, f);
      }
      else
      {
        d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
          "TouchProbe",
          "http://qifstandards.org/xsd/qif2",
          m, s, f);
      }

      ::xsd::qif2::TouchProbe (*d, s, f);
      return d;
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

