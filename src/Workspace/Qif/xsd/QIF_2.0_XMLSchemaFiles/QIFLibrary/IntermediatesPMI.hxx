// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef INTERMEDIATES_PMI_HXX
#define INTERMEDIATES_PMI_HXX

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< char > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< char > not_derived;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace xsd
{
  namespace qif2
  {
    class FormalStandardEnumType;
    class FormalStandardType;
    class SequencedDatumType;
    class CompoundDatumType;
    class DatumWithPrecedenceType;
    class DatumType;
    class DatumTranslationType;
    class DatumFeatureBaseType;
    class ActualDatumFeatureType;
    class NominalDatumFeatureType;
    class DatumFeatureSimulatorModifierType;
    class DatumReferenceFrameType;
    class DegreeOfFreedomEnumType;
    class ISODegreeOfFreedomEnumType;
    class IntersectionPlaneEnumType;
    class IntersectionPlaneType;
    class ModifyingPlaneEnumType;
    class DirectionFeatureType;
    class CollectionPlaneType;
    class OrientationPlaneType;
    class ReducedDatumEnumType;
    class DegreesOfFreedomType;
    class DiameterModifierEnumType;
    class SectionModifierEnumType;
    class PointWithNormalBaseType;
    class ActualPointWithNormalBaseType;
    class MeasurePointNominalType;
    class MeasurePointActualType;
    class MovableDatumTargetDirectionType;
    class TargetPointActualType;
    class TargetPointNominalType;
    class TransformListType;
    class TransformInstanceType;
    class LinearCoordinateDirectionEnumType;
    class AngularCoordinateDirectionEnumType;
    class SubstituteFeatureAlgorithmBaseType;
    class FeatureOfSizeSubstituteFeatureAlgorithmEnumType;
    class FeatureOfSizeSubstituteFeatureAlgorithmType;
    class NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType;
    class NonFeatureOfSizeSubstituteFeatureAlgorithmType;
    class CurveSubstituteFeatureAlgorithmEnumType;
    class CurveSubstituteFeatureAlgorithmType;
    class SurfaceSubstituteFeatureAlgorithmEnumType;
    class SurfaceSubstituteFeatureAlgorithmType;
    class MaterialModifierEnumType;
    class PrecedenceEnumType;
    class PrecedenceType;
    class ReferencedComponentEnumType;
    class RetrievalMethodEnumType;
    class MeasurementDirectiveEnumType;
    class MeasurementDirectiveType;
    class DistanceBetweenAnalysisModeEnumType;
    class AngleBetweenAnalysisModeEnumType;
    class BaseFeatureType;
    class SequencedBaseFeatureType;
    class DirectionalOffsetType;
    class AlignmentFeatureType;
    class AlignmentOperationBaseType;
    class PrimaryAlignmentOperationType;
    class SecondaryAlignmentOperationType;
    class ActualOriginOffsetType;
    class ActualOffsetAlignmentOperationType;
    class NominalOffsetAlignmentOperationType;
    class NominalRotationAlignmentOperationType;
    class DatumPrecedenceAlignmentOperationType;
    class BestFitAlignmentOperationType;
    class MachineCoordinateSystemOperationType;
    class AlignmentOperationsType;
    class CoordinateSystemListType;
    class CoordinateSystemType;
    class CoordinateSystemActualTransformType;
    class CoordinateSystemActualTransformsType;
    class ThreadSpecificationDetailedBaseType;
    class SingleLeadThreadSpecificationType;
    class MultiLeadThreadSpecificationType;
    class ThreadSpecificationType;
    class TextThreadSpecificationType;
    class ThreadSpecificationsType;
    class ToleranceZonePerUnitAreaType;
    class ToleranceZonePerUnitLengthType;
    class ToleranceZonePerUnitAngleType;
    class ToleranceZonePerUnitPolarAreaType;
    class CompoundFeatureGeometryEnumType;
    class DatumReferenceFramesType;
    class EventBaseType;
    class NotableEventType;
    class NotableEventsType;
    class NotedEventType;
    class NotedEventsType;
    class InspectionStatusEnumType;
    class InspectionStatusType;
    class EntityExternalType;
    class EntitiesExternalType;
    class ZoneDataType;
    class LinearToleranceType;
    class LinearToleranceDefinitionType;
    class AngularToleranceType;
    class AngularToleranceDefinitionType;
    class TemperatureToleranceType;
    class AreaToleranceType;
    class ForceToleranceType;
    class MassToleranceType;
    class PressureToleranceType;
    class SpeedToleranceType;
    class TimeToleranceType;
    class DimensionModifierEnumType;
    class NonToleranceEnumType;
    class CommonFileSpecEnumType;
    class FileSpecType;
    class ExternalFileReferenceType;
    class DatumTargetDefinitionsType;
    class DatumDefinitionType;
    class DatumDefinitionsType;
    class DatumTargetDefinitionBaseType;
    class DatumTargetPointDefinitionType;
    class DatumTargetLineDefinitionType;
    class DatumTargetCircularAreaDefinitionType;
    class DatumTargetCircularLineDefinitionType;
    class DatumTargetCylindricalAreaDefinitionType;
    class DatumTargetRectangularAreaDefinitionType;
    class DatumTargetSphereDefinitionType;
    class DatumTargetIrregularAreaDefinitionType;
    class EmployeeType;
    class FileType;
    class SoftwareType;
    class OrganizationType;
    class PhysicalAddressType;
    class AddressDescriptionEnumType;
    class AddressDescriptionType;
    class LocationType;
    class CustomerOrganizationType;
    class VersionHistoryType;
    class VersionBaseType;
    class VersionType;
    class VersionReferenceType;
    class SignOffsType;
  }
}


#include <memory>    // ::std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "../QIFLibrary/PrimitivesPMI.hxx"

namespace xsd
{
  namespace qif2
  {
    class FormalStandardEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        ANSI,
        ASME_Y14_5_1982,
        ASME_Y14_5_1994,
        ASME_Y14_5_2009,
        ISO1101_1983,
        ISO1101_2004,
        ISO1101_2012,
        BS_8888_2004,
        JIS,
        DIN,
        COMPANY
      };

      FormalStandardEnumType (value v);

      FormalStandardEnumType (const char* v);

      FormalStandardEnumType (const ::std::string& v);

      FormalStandardEnumType (const ::xml_schema::nmtoken& v);

      FormalStandardEnumType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      FormalStandardEnumType (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      FormalStandardEnumType (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      FormalStandardEnumType (const FormalStandardEnumType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual FormalStandardEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FormalStandardEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_FormalStandardEnumType_convert ();
      }

      protected:
      value
      _xsd_FormalStandardEnumType_convert () const;

      public:
      static const char* const _xsd_FormalStandardEnumType_literals_[11];
      static const value _xsd_FormalStandardEnumType_indexes_[11];
    };

    class FormalStandardType: public ::xml_schema::type
    {
      public:
      // FormalStandardEnum
      //
      typedef ::xsd::qif2::FormalStandardEnumType FormalStandardEnum_type;
      typedef ::xsd::cxx::tree::optional< FormalStandardEnum_type > FormalStandardEnum_optional;
      typedef ::xsd::cxx::tree::traits< FormalStandardEnum_type, char > FormalStandardEnum_traits;

      const FormalStandardEnum_optional&
      FormalStandardEnum () const;

      FormalStandardEnum_optional&
      FormalStandardEnum ();

      void
      FormalStandardEnum (const FormalStandardEnum_type& x);

      void
      FormalStandardEnum (const FormalStandardEnum_optional& x);

      void
      FormalStandardEnum (::std::auto_ptr< FormalStandardEnum_type > p);

      // OtherFormalStandard
      //
      typedef ::xml_schema::string OtherFormalStandard_type;
      typedef ::xsd::cxx::tree::optional< OtherFormalStandard_type > OtherFormalStandard_optional;
      typedef ::xsd::cxx::tree::traits< OtherFormalStandard_type, char > OtherFormalStandard_traits;

      const OtherFormalStandard_optional&
      OtherFormalStandard () const;

      OtherFormalStandard_optional&
      OtherFormalStandard ();

      void
      OtherFormalStandard (const OtherFormalStandard_type& x);

      void
      OtherFormalStandard (const OtherFormalStandard_optional& x);

      void
      OtherFormalStandard (::std::auto_ptr< OtherFormalStandard_type > p);

      // Constructors.
      //
      FormalStandardType ();

      FormalStandardType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      FormalStandardType (const FormalStandardType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual FormalStandardType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FormalStandardType&
      operator= (const FormalStandardType& x);

      virtual 
      ~FormalStandardType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      FormalStandardEnum_optional FormalStandardEnum_;
      OtherFormalStandard_optional OtherFormalStandard_;
    };

    class SequencedDatumType: public ::xml_schema::type
    {
      public:
      // SimpleDatum
      //
      typedef ::xsd::qif2::DatumType SimpleDatum_type;
      typedef ::xsd::cxx::tree::optional< SimpleDatum_type > SimpleDatum_optional;
      typedef ::xsd::cxx::tree::traits< SimpleDatum_type, char > SimpleDatum_traits;

      const SimpleDatum_optional&
      SimpleDatum () const;

      SimpleDatum_optional&
      SimpleDatum ();

      void
      SimpleDatum (const SimpleDatum_type& x);

      void
      SimpleDatum (const SimpleDatum_optional& x);

      void
      SimpleDatum (::std::auto_ptr< SimpleDatum_type > p);

      // CompoundDatum
      //
      typedef ::xsd::qif2::CompoundDatumType CompoundDatum_type;
      typedef ::xsd::cxx::tree::optional< CompoundDatum_type > CompoundDatum_optional;
      typedef ::xsd::cxx::tree::traits< CompoundDatum_type, char > CompoundDatum_traits;

      const CompoundDatum_optional&
      CompoundDatum () const;

      CompoundDatum_optional&
      CompoundDatum ();

      void
      CompoundDatum (const CompoundDatum_type& x);

      void
      CompoundDatum (const CompoundDatum_optional& x);

      void
      CompoundDatum (::std::auto_ptr< CompoundDatum_type > p);

      // SequenceNumber
      //
      typedef ::xml_schema::positive_integer SequenceNumber_type;
      typedef ::xsd::cxx::tree::traits< SequenceNumber_type, char > SequenceNumber_traits;

      const SequenceNumber_type&
      SequenceNumber () const;

      SequenceNumber_type&
      SequenceNumber ();

      void
      SequenceNumber (const SequenceNumber_type& x);

      // Constructors.
      //
      SequencedDatumType (const SequenceNumber_type&);

      SequencedDatumType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      SequencedDatumType (const SequencedDatumType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual SequencedDatumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SequencedDatumType&
      operator= (const SequencedDatumType& x);

      virtual 
      ~SequencedDatumType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      SimpleDatum_optional SimpleDatum_;
      CompoundDatum_optional CompoundDatum_;
      ::xsd::cxx::tree::one< SequenceNumber_type > SequenceNumber_;
    };

    class CompoundDatumType: public ::xml_schema::type
    {
      public:
      // Datum
      //
      typedef ::xsd::qif2::SequencedDatumType Datum_type;
      typedef ::xsd::cxx::tree::sequence< Datum_type > Datum_sequence;
      typedef Datum_sequence::iterator Datum_iterator;
      typedef Datum_sequence::const_iterator Datum_const_iterator;
      typedef ::xsd::cxx::tree::traits< Datum_type, char > Datum_traits;

      const Datum_sequence&
      Datum () const;

      Datum_sequence&
      Datum ();

      void
      Datum (const Datum_sequence& s);

      // ReducedDatum
      //
      typedef ::xsd::qif2::ReducedDatumEnumType ReducedDatum_type;
      typedef ::xsd::cxx::tree::optional< ReducedDatum_type > ReducedDatum_optional;
      typedef ::xsd::cxx::tree::traits< ReducedDatum_type, char > ReducedDatum_traits;

      const ReducedDatum_optional&
      ReducedDatum () const;

      ReducedDatum_optional&
      ReducedDatum ();

      void
      ReducedDatum (const ReducedDatum_type& x);

      void
      ReducedDatum (const ReducedDatum_optional& x);

      void
      ReducedDatum (::std::auto_ptr< ReducedDatum_type > p);

      // Constructors.
      //
      CompoundDatumType ();

      CompoundDatumType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      CompoundDatumType (const CompoundDatumType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual CompoundDatumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CompoundDatumType&
      operator= (const CompoundDatumType& x);

      virtual 
      ~CompoundDatumType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Datum_sequence Datum_;
      ReducedDatum_optional ReducedDatum_;
    };

    class DatumWithPrecedenceType: public ::xml_schema::type
    {
      public:
      // SimpleDatum
      //
      typedef ::xsd::qif2::DatumType SimpleDatum_type;
      typedef ::xsd::cxx::tree::optional< SimpleDatum_type > SimpleDatum_optional;
      typedef ::xsd::cxx::tree::traits< SimpleDatum_type, char > SimpleDatum_traits;

      const SimpleDatum_optional&
      SimpleDatum () const;

      SimpleDatum_optional&
      SimpleDatum ();

      void
      SimpleDatum (const SimpleDatum_type& x);

      void
      SimpleDatum (const SimpleDatum_optional& x);

      void
      SimpleDatum (::std::auto_ptr< SimpleDatum_type > p);

      // NominalDatumFeature
      //
      typedef ::xsd::qif2::NominalDatumFeatureType NominalDatumFeature_type;
      typedef ::xsd::cxx::tree::optional< NominalDatumFeature_type > NominalDatumFeature_optional;
      typedef ::xsd::cxx::tree::traits< NominalDatumFeature_type, char > NominalDatumFeature_traits;

      const NominalDatumFeature_optional&
      NominalDatumFeature () const;

      NominalDatumFeature_optional&
      NominalDatumFeature ();

      void
      NominalDatumFeature (const NominalDatumFeature_type& x);

      void
      NominalDatumFeature (const NominalDatumFeature_optional& x);

      void
      NominalDatumFeature (::std::auto_ptr< NominalDatumFeature_type > p);

      // ActualDatumFeature
      //
      typedef ::xsd::qif2::ActualDatumFeatureType ActualDatumFeature_type;
      typedef ::xsd::cxx::tree::optional< ActualDatumFeature_type > ActualDatumFeature_optional;
      typedef ::xsd::cxx::tree::traits< ActualDatumFeature_type, char > ActualDatumFeature_traits;

      const ActualDatumFeature_optional&
      ActualDatumFeature () const;

      ActualDatumFeature_optional&
      ActualDatumFeature ();

      void
      ActualDatumFeature (const ActualDatumFeature_type& x);

      void
      ActualDatumFeature (const ActualDatumFeature_optional& x);

      void
      ActualDatumFeature (::std::auto_ptr< ActualDatumFeature_type > p);

      // CompoundDatum
      //
      typedef ::xsd::qif2::CompoundDatumType CompoundDatum_type;
      typedef ::xsd::cxx::tree::optional< CompoundDatum_type > CompoundDatum_optional;
      typedef ::xsd::cxx::tree::traits< CompoundDatum_type, char > CompoundDatum_traits;

      const CompoundDatum_optional&
      CompoundDatum () const;

      CompoundDatum_optional&
      CompoundDatum ();

      void
      CompoundDatum (const CompoundDatum_type& x);

      void
      CompoundDatum (const CompoundDatum_optional& x);

      void
      CompoundDatum (::std::auto_ptr< CompoundDatum_type > p);

      // Precedence
      //
      typedef ::xsd::qif2::PrecedenceType Precedence_type;
      typedef ::xsd::cxx::tree::traits< Precedence_type, char > Precedence_traits;

      const Precedence_type&
      Precedence () const;

      Precedence_type&
      Precedence ();

      void
      Precedence (const Precedence_type& x);

      void
      Precedence (::std::auto_ptr< Precedence_type > p);

      // Constructors.
      //
      DatumWithPrecedenceType (const Precedence_type&);

      DatumWithPrecedenceType (::std::auto_ptr< Precedence_type >);

      DatumWithPrecedenceType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      DatumWithPrecedenceType (const DatumWithPrecedenceType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual DatumWithPrecedenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumWithPrecedenceType&
      operator= (const DatumWithPrecedenceType& x);

      virtual 
      ~DatumWithPrecedenceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      SimpleDatum_optional SimpleDatum_;
      NominalDatumFeature_optional NominalDatumFeature_;
      ActualDatumFeature_optional ActualDatumFeature_;
      CompoundDatum_optional CompoundDatum_;
      ::xsd::cxx::tree::one< Precedence_type > Precedence_;
    };

    class DatumType: public ::xml_schema::type
    {
      public:
      // DatumDefinitionId
      //
      typedef ::xsd::qif2::QIFReferenceFullType DatumDefinitionId_type;
      typedef ::xsd::cxx::tree::traits< DatumDefinitionId_type, char > DatumDefinitionId_traits;

      const DatumDefinitionId_type&
      DatumDefinitionId () const;

      DatumDefinitionId_type&
      DatumDefinitionId ();

      void
      DatumDefinitionId (const DatumDefinitionId_type& x);

      void
      DatumDefinitionId (::std::auto_ptr< DatumDefinitionId_type > p);

      // MaterialModifier
      //
      typedef ::xsd::qif2::MaterialModifierEnumType MaterialModifier_type;
      typedef ::xsd::cxx::tree::traits< MaterialModifier_type, char > MaterialModifier_traits;

      const MaterialModifier_type&
      MaterialModifier () const;

      MaterialModifier_type&
      MaterialModifier ();

      void
      MaterialModifier (const MaterialModifier_type& x);

      void
      MaterialModifier (::std::auto_ptr< MaterialModifier_type > p);

      // ReferencedComponent
      //
      typedef ::xsd::qif2::ReferencedComponentEnumType ReferencedComponent_type;
      typedef ::xsd::cxx::tree::traits< ReferencedComponent_type, char > ReferencedComponent_traits;

      const ReferencedComponent_type&
      ReferencedComponent () const;

      ReferencedComponent_type&
      ReferencedComponent ();

      void
      ReferencedComponent (const ReferencedComponent_type& x);

      void
      ReferencedComponent (::std::auto_ptr< ReferencedComponent_type > p);

      // DatumFeatureSimulatorModifier
      //
      typedef ::xsd::qif2::DatumFeatureSimulatorModifierType DatumFeatureSimulatorModifier_type;
      typedef ::xsd::cxx::tree::optional< DatumFeatureSimulatorModifier_type > DatumFeatureSimulatorModifier_optional;
      typedef ::xsd::cxx::tree::traits< DatumFeatureSimulatorModifier_type, char > DatumFeatureSimulatorModifier_traits;

      const DatumFeatureSimulatorModifier_optional&
      DatumFeatureSimulatorModifier () const;

      DatumFeatureSimulatorModifier_optional&
      DatumFeatureSimulatorModifier ();

      void
      DatumFeatureSimulatorModifier (const DatumFeatureSimulatorModifier_type& x);

      void
      DatumFeatureSimulatorModifier (const DatumFeatureSimulatorModifier_optional& x);

      void
      DatumFeatureSimulatorModifier (::std::auto_ptr< DatumFeatureSimulatorModifier_type > p);

      // DatumTranslation
      //
      typedef ::xsd::qif2::DatumTranslationType DatumTranslation_type;
      typedef ::xsd::cxx::tree::optional< DatumTranslation_type > DatumTranslation_optional;
      typedef ::xsd::cxx::tree::traits< DatumTranslation_type, char > DatumTranslation_traits;

      const DatumTranslation_optional&
      DatumTranslation () const;

      DatumTranslation_optional&
      DatumTranslation ();

      void
      DatumTranslation (const DatumTranslation_type& x);

      void
      DatumTranslation (const DatumTranslation_optional& x);

      void
      DatumTranslation (::std::auto_ptr< DatumTranslation_type > p);

      // DegreesOfFreedom
      //
      typedef ::xsd::qif2::DegreesOfFreedomType DegreesOfFreedom_type;
      typedef ::xsd::cxx::tree::optional< DegreesOfFreedom_type > DegreesOfFreedom_optional;
      typedef ::xsd::cxx::tree::traits< DegreesOfFreedom_type, char > DegreesOfFreedom_traits;

      const DegreesOfFreedom_optional&
      DegreesOfFreedom () const;

      DegreesOfFreedom_optional&
      DegreesOfFreedom ();

      void
      DegreesOfFreedom (const DegreesOfFreedom_type& x);

      void
      DegreesOfFreedom (const DegreesOfFreedom_optional& x);

      void
      DegreesOfFreedom (::std::auto_ptr< DegreesOfFreedom_type > p);

      // ProjectedDatum
      //
      typedef ::xsd::qif2::LinearValueType ProjectedDatum_type;
      typedef ::xsd::cxx::tree::optional< ProjectedDatum_type > ProjectedDatum_optional;
      typedef ::xsd::cxx::tree::traits< ProjectedDatum_type, char > ProjectedDatum_traits;

      const ProjectedDatum_optional&
      ProjectedDatum () const;

      ProjectedDatum_optional&
      ProjectedDatum ();

      void
      ProjectedDatum (const ProjectedDatum_type& x);

      void
      ProjectedDatum (const ProjectedDatum_optional& x);

      void
      ProjectedDatum (::std::auto_ptr< ProjectedDatum_type > p);

      // DiameterModifier
      //
      typedef ::xsd::qif2::DiameterModifierEnumType DiameterModifier_type;
      typedef ::xsd::cxx::tree::optional< DiameterModifier_type > DiameterModifier_optional;
      typedef ::xsd::cxx::tree::traits< DiameterModifier_type, char > DiameterModifier_traits;

      const DiameterModifier_optional&
      DiameterModifier () const;

      DiameterModifier_optional&
      DiameterModifier ();

      void
      DiameterModifier (const DiameterModifier_type& x);

      void
      DiameterModifier (const DiameterModifier_optional& x);

      void
      DiameterModifier (::std::auto_ptr< DiameterModifier_type > p);

      // SectionModifier
      //
      typedef ::xsd::qif2::SectionModifierEnumType SectionModifier_type;
      typedef ::xsd::cxx::tree::optional< SectionModifier_type > SectionModifier_optional;
      typedef ::xsd::cxx::tree::traits< SectionModifier_type, char > SectionModifier_traits;

      const SectionModifier_optional&
      SectionModifier () const;

      SectionModifier_optional&
      SectionModifier ();

      void
      SectionModifier (const SectionModifier_type& x);

      void
      SectionModifier (const SectionModifier_optional& x);

      void
      SectionModifier (::std::auto_ptr< SectionModifier_type > p);

      // ContactingFeature
      //
      typedef ::xml_schema::boolean ContactingFeature_type;
      typedef ::xsd::cxx::tree::optional< ContactingFeature_type > ContactingFeature_optional;
      typedef ::xsd::cxx::tree::traits< ContactingFeature_type, char > ContactingFeature_traits;

      const ContactingFeature_optional&
      ContactingFeature () const;

      ContactingFeature_optional&
      ContactingFeature ();

      void
      ContactingFeature (const ContactingFeature_type& x);

      void
      ContactingFeature (const ContactingFeature_optional& x);

      // DistanceVariable
      //
      typedef ::xml_schema::boolean DistanceVariable_type;
      typedef ::xsd::cxx::tree::optional< DistanceVariable_type > DistanceVariable_optional;
      typedef ::xsd::cxx::tree::traits< DistanceVariable_type, char > DistanceVariable_traits;

      const DistanceVariable_optional&
      DistanceVariable () const;

      DistanceVariable_optional&
      DistanceVariable ();

      void
      DistanceVariable (const DistanceVariable_type& x);

      void
      DistanceVariable (const DistanceVariable_optional& x);

      // DatumFixed
      //
      typedef ::xml_schema::boolean DatumFixed_type;
      typedef ::xsd::cxx::tree::optional< DatumFixed_type > DatumFixed_optional;
      typedef ::xsd::cxx::tree::traits< DatumFixed_type, char > DatumFixed_traits;

      const DatumFixed_optional&
      DatumFixed () const;

      DatumFixed_optional&
      DatumFixed ();

      void
      DatumFixed (const DatumFixed_type& x);

      void
      DatumFixed (const DatumFixed_optional& x);

      // ReducedDatum
      //
      typedef ::xsd::qif2::ReducedDatumEnumType ReducedDatum_type;
      typedef ::xsd::cxx::tree::optional< ReducedDatum_type > ReducedDatum_optional;
      typedef ::xsd::cxx::tree::traits< ReducedDatum_type, char > ReducedDatum_traits;

      const ReducedDatum_optional&
      ReducedDatum () const;

      ReducedDatum_optional&
      ReducedDatum ();

      void
      ReducedDatum (const ReducedDatum_type& x);

      void
      ReducedDatum (const ReducedDatum_optional& x);

      void
      ReducedDatum (::std::auto_ptr< ReducedDatum_type > p);

      // ConstrainOrientation
      //
      typedef ::xml_schema::boolean ConstrainOrientation_type;
      typedef ::xsd::cxx::tree::optional< ConstrainOrientation_type > ConstrainOrientation_optional;
      typedef ::xsd::cxx::tree::traits< ConstrainOrientation_type, char > ConstrainOrientation_traits;

      const ConstrainOrientation_optional&
      ConstrainOrientation () const;

      ConstrainOrientation_optional&
      ConstrainOrientation ();

      void
      ConstrainOrientation (const ConstrainOrientation_type& x);

      void
      ConstrainOrientation (const ConstrainOrientation_optional& x);

      // ConstrainSubsequent
      //
      typedef ::xml_schema::boolean ConstrainSubsequent_type;
      typedef ::xsd::cxx::tree::optional< ConstrainSubsequent_type > ConstrainSubsequent_optional;
      typedef ::xsd::cxx::tree::traits< ConstrainSubsequent_type, char > ConstrainSubsequent_traits;

      const ConstrainSubsequent_optional&
      ConstrainSubsequent () const;

      ConstrainSubsequent_optional&
      ConstrainSubsequent ();

      void
      ConstrainSubsequent (const ConstrainSubsequent_type& x);

      void
      ConstrainSubsequent (const ConstrainSubsequent_optional& x);

      // Constructors.
      //
      DatumType (const DatumDefinitionId_type&,
                 const MaterialModifier_type&,
                 const ReferencedComponent_type&);

      DatumType (::std::auto_ptr< DatumDefinitionId_type >,
                 const MaterialModifier_type&,
                 const ReferencedComponent_type&);

      DatumType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      DatumType (const DatumType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual DatumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumType&
      operator= (const DatumType& x);

      virtual 
      ~DatumType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DatumDefinitionId_type > DatumDefinitionId_;
      ::xsd::cxx::tree::one< MaterialModifier_type > MaterialModifier_;
      ::xsd::cxx::tree::one< ReferencedComponent_type > ReferencedComponent_;
      DatumFeatureSimulatorModifier_optional DatumFeatureSimulatorModifier_;
      DatumTranslation_optional DatumTranslation_;
      DegreesOfFreedom_optional DegreesOfFreedom_;
      ProjectedDatum_optional ProjectedDatum_;
      DiameterModifier_optional DiameterModifier_;
      SectionModifier_optional SectionModifier_;
      ContactingFeature_optional ContactingFeature_;
      DistanceVariable_optional DistanceVariable_;
      DatumFixed_optional DatumFixed_;
      ReducedDatum_optional ReducedDatum_;
      ConstrainOrientation_optional ConstrainOrientation_;
      ConstrainSubsequent_optional ConstrainSubsequent_;
    };

    class DatumTranslationType: public ::xml_schema::type
    {
      public:
      // DatumTranslationAllowed
      //
      typedef ::xml_schema::boolean DatumTranslationAllowed_type;
      typedef ::xsd::cxx::tree::traits< DatumTranslationAllowed_type, char > DatumTranslationAllowed_traits;

      const DatumTranslationAllowed_type&
      DatumTranslationAllowed () const;

      DatumTranslationAllowed_type&
      DatumTranslationAllowed ();

      void
      DatumTranslationAllowed (const DatumTranslationAllowed_type& x);

      // Constructors.
      //
      DatumTranslationType (const DatumTranslationAllowed_type&);

      DatumTranslationType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      DatumTranslationType (const DatumTranslationType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual DatumTranslationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumTranslationType&
      operator= (const DatumTranslationType& x);

      virtual 
      ~DatumTranslationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DatumTranslationAllowed_type > DatumTranslationAllowed_;
    };

    class DatumFeatureBaseType: public ::xml_schema::type
    {
      public:
      // FeatureItemId
      //
      typedef ::xsd::qif2::QIFReferenceFullType FeatureItemId_type;
      typedef ::xsd::cxx::tree::traits< FeatureItemId_type, char > FeatureItemId_traits;

      const FeatureItemId_type&
      FeatureItemId () const;

      FeatureItemId_type&
      FeatureItemId ();

      void
      FeatureItemId (const FeatureItemId_type& x);

      void
      FeatureItemId (::std::auto_ptr< FeatureItemId_type > p);

      // Constructors.
      //
      DatumFeatureBaseType (const FeatureItemId_type&);

      DatumFeatureBaseType (::std::auto_ptr< FeatureItemId_type >);

      DatumFeatureBaseType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      DatumFeatureBaseType (const DatumFeatureBaseType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual DatumFeatureBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumFeatureBaseType&
      operator= (const DatumFeatureBaseType& x);

      virtual 
      ~DatumFeatureBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< FeatureItemId_type > FeatureItemId_;
    };

    class ActualDatumFeatureType: public ::xsd::qif2::DatumFeatureBaseType
    {
      public:
      // MaterialModifier
      //
      typedef ::xsd::qif2::MaterialModifierEnumType MaterialModifier_type;
      typedef ::xsd::cxx::tree::traits< MaterialModifier_type, char > MaterialModifier_traits;

      const MaterialModifier_type&
      MaterialModifier () const;

      MaterialModifier_type&
      MaterialModifier ();

      void
      MaterialModifier (const MaterialModifier_type& x);

      void
      MaterialModifier (::std::auto_ptr< MaterialModifier_type > p);

      // Constructors.
      //
      ActualDatumFeatureType (const FeatureItemId_type&,
                              const MaterialModifier_type&);

      ActualDatumFeatureType (::std::auto_ptr< FeatureItemId_type >,
                              const MaterialModifier_type&);

      ActualDatumFeatureType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      ActualDatumFeatureType (const ActualDatumFeatureType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual ActualDatumFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ActualDatumFeatureType&
      operator= (const ActualDatumFeatureType& x);

      virtual 
      ~ActualDatumFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< MaterialModifier_type > MaterialModifier_;
    };

    class NominalDatumFeatureType: public ::xsd::qif2::DatumFeatureBaseType
    {
      public:
      // Constructors.
      //
      NominalDatumFeatureType (const FeatureItemId_type&);

      NominalDatumFeatureType (::std::auto_ptr< FeatureItemId_type >);

      NominalDatumFeatureType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      NominalDatumFeatureType (const NominalDatumFeatureType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual NominalDatumFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~NominalDatumFeatureType ();
    };

    class DatumFeatureSimulatorModifierType: public ::xml_schema::type
    {
      public:
      // LinearSize
      //
      typedef ::xsd::qif2::LinearValueType LinearSize_type;
      typedef ::xsd::cxx::tree::optional< LinearSize_type > LinearSize_optional;
      typedef ::xsd::cxx::tree::traits< LinearSize_type, char > LinearSize_traits;

      const LinearSize_optional&
      LinearSize () const;

      LinearSize_optional&
      LinearSize ();

      void
      LinearSize (const LinearSize_type& x);

      void
      LinearSize (const LinearSize_optional& x);

      void
      LinearSize (::std::auto_ptr< LinearSize_type > p);

      // DiametricalSize
      //
      typedef ::xsd::qif2::LinearValueType DiametricalSize_type;
      typedef ::xsd::cxx::tree::optional< DiametricalSize_type > DiametricalSize_optional;
      typedef ::xsd::cxx::tree::traits< DiametricalSize_type, char > DiametricalSize_traits;

      const DiametricalSize_optional&
      DiametricalSize () const;

      DiametricalSize_optional&
      DiametricalSize ();

      void
      DiametricalSize (const DiametricalSize_type& x);

      void
      DiametricalSize (const DiametricalSize_optional& x);

      void
      DiametricalSize (::std::auto_ptr< DiametricalSize_type > p);

      // BasicSize
      //
      typedef ::xml_schema::token BasicSize_type;
      typedef ::xsd::cxx::tree::optional< BasicSize_type > BasicSize_optional;
      typedef ::xsd::cxx::tree::traits< BasicSize_type, char > BasicSize_traits;

      const BasicSize_optional&
      BasicSize () const;

      BasicSize_optional&
      BasicSize ();

      void
      BasicSize (const BasicSize_type& x);

      void
      BasicSize (const BasicSize_optional& x);

      void
      BasicSize (::std::auto_ptr< BasicSize_type > p);

      static const BasicSize_type&
      BasicSize_default_value ();

      // Constructors.
      //
      DatumFeatureSimulatorModifierType ();

      DatumFeatureSimulatorModifierType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      DatumFeatureSimulatorModifierType (const DatumFeatureSimulatorModifierType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual DatumFeatureSimulatorModifierType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumFeatureSimulatorModifierType&
      operator= (const DatumFeatureSimulatorModifierType& x);

      virtual 
      ~DatumFeatureSimulatorModifierType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      LinearSize_optional LinearSize_;
      DiametricalSize_optional DiametricalSize_;
      BasicSize_optional BasicSize_;
      static const BasicSize_type BasicSize_default_value_;
    };

    class DatumReferenceFrameType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif2::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, char > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::auto_ptr< Attributes_type > p);

      // Datum
      //
      typedef ::xsd::qif2::DatumWithPrecedenceType Datum_type;
      typedef ::xsd::cxx::tree::sequence< Datum_type > Datum_sequence;
      typedef Datum_sequence::iterator Datum_iterator;
      typedef Datum_sequence::const_iterator Datum_const_iterator;
      typedef ::xsd::cxx::tree::traits< Datum_type, char > Datum_traits;

      const Datum_sequence&
      Datum () const;

      Datum_sequence&
      Datum ();

      void
      Datum (const Datum_sequence& s);

      // Name
      //
      typedef ::xml_schema::token Name_type;
      typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
      typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

      const Name_optional&
      Name () const;

      Name_optional&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (const Name_optional& x);

      void
      Name (::std::auto_ptr< Name_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, char > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::auto_ptr< Description_type > p);

      // CoordinateSystemId
      //
      typedef ::xsd::qif2::QIFReferenceFullType CoordinateSystemId_type;
      typedef ::xsd::cxx::tree::optional< CoordinateSystemId_type > CoordinateSystemId_optional;
      typedef ::xsd::cxx::tree::traits< CoordinateSystemId_type, char > CoordinateSystemId_traits;

      const CoordinateSystemId_optional&
      CoordinateSystemId () const;

      CoordinateSystemId_optional&
      CoordinateSystemId ();

      void
      CoordinateSystemId (const CoordinateSystemId_type& x);

      void
      CoordinateSystemId (const CoordinateSystemId_optional& x);

      void
      CoordinateSystemId (::std::auto_ptr< CoordinateSystemId_type > p);

      // id
      //
      typedef ::xsd::qif2::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::auto_ptr< id_type > p);

      // Constructors.
      //
      DatumReferenceFrameType (const id_type&);

      DatumReferenceFrameType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      DatumReferenceFrameType (const DatumReferenceFrameType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual DatumReferenceFrameType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumReferenceFrameType&
      operator= (const DatumReferenceFrameType& x);

      virtual 
      ~DatumReferenceFrameType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      Datum_sequence Datum_;
      Name_optional Name_;
      Description_optional Description_;
      CoordinateSystemId_optional CoordinateSystemId_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class DegreeOfFreedomEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        U,
        V,
        W,
        X,
        Y,
        Z
      };

      DegreeOfFreedomEnumType (value v);

      DegreeOfFreedomEnumType (const char* v);

      DegreeOfFreedomEnumType (const ::std::string& v);

      DegreeOfFreedomEnumType (const ::xml_schema::nmtoken& v);

      DegreeOfFreedomEnumType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      DegreeOfFreedomEnumType (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      DegreeOfFreedomEnumType (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      DegreeOfFreedomEnumType (const DegreeOfFreedomEnumType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual DegreeOfFreedomEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DegreeOfFreedomEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_DegreeOfFreedomEnumType_convert ();
      }

      protected:
      value
      _xsd_DegreeOfFreedomEnumType_convert () const;

      public:
      static const char* const _xsd_DegreeOfFreedomEnumType_literals_[6];
      static const value _xsd_DegreeOfFreedomEnumType_indexes_[6];
    };

    class ISODegreeOfFreedomEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        Rx,
        Ry,
        Rz,
        Tx,
        Ty,
        Tz
      };

      ISODegreeOfFreedomEnumType (value v);

      ISODegreeOfFreedomEnumType (const char* v);

      ISODegreeOfFreedomEnumType (const ::std::string& v);

      ISODegreeOfFreedomEnumType (const ::xml_schema::nmtoken& v);

      ISODegreeOfFreedomEnumType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ISODegreeOfFreedomEnumType (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ISODegreeOfFreedomEnumType (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ISODegreeOfFreedomEnumType (const ISODegreeOfFreedomEnumType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual ISODegreeOfFreedomEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ISODegreeOfFreedomEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ISODegreeOfFreedomEnumType_convert ();
      }

      protected:
      value
      _xsd_ISODegreeOfFreedomEnumType_convert () const;

      public:
      static const char* const _xsd_ISODegreeOfFreedomEnumType_literals_[6];
      static const value _xsd_ISODegreeOfFreedomEnumType_indexes_[6];
    };

    class IntersectionPlaneEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        PARALLEL,
        PERPENDICULAR,
        INCLUDING
      };

      IntersectionPlaneEnumType (value v);

      IntersectionPlaneEnumType (const char* v);

      IntersectionPlaneEnumType (const ::std::string& v);

      IntersectionPlaneEnumType (const ::xml_schema::nmtoken& v);

      IntersectionPlaneEnumType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      IntersectionPlaneEnumType (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      IntersectionPlaneEnumType (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      IntersectionPlaneEnumType (const IntersectionPlaneEnumType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual IntersectionPlaneEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IntersectionPlaneEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_IntersectionPlaneEnumType_convert ();
      }

      protected:
      value
      _xsd_IntersectionPlaneEnumType_convert () const;

      public:
      static const char* const _xsd_IntersectionPlaneEnumType_literals_[3];
      static const value _xsd_IntersectionPlaneEnumType_indexes_[3];
    };

    class IntersectionPlaneType: public ::xml_schema::type
    {
      public:
      // IntersectionPlaneEnum
      //
      typedef ::xsd::qif2::IntersectionPlaneEnumType IntersectionPlaneEnum_type;
      typedef ::xsd::cxx::tree::traits< IntersectionPlaneEnum_type, char > IntersectionPlaneEnum_traits;

      const IntersectionPlaneEnum_type&
      IntersectionPlaneEnum () const;

      IntersectionPlaneEnum_type&
      IntersectionPlaneEnum ();

      void
      IntersectionPlaneEnum (const IntersectionPlaneEnum_type& x);

      void
      IntersectionPlaneEnum (::std::auto_ptr< IntersectionPlaneEnum_type > p);

      // DatumDefinitionId
      //
      typedef ::xsd::qif2::QIFReferenceFullType DatumDefinitionId_type;
      typedef ::xsd::cxx::tree::traits< DatumDefinitionId_type, char > DatumDefinitionId_traits;

      const DatumDefinitionId_type&
      DatumDefinitionId () const;

      DatumDefinitionId_type&
      DatumDefinitionId ();

      void
      DatumDefinitionId (const DatumDefinitionId_type& x);

      void
      DatumDefinitionId (::std::auto_ptr< DatumDefinitionId_type > p);

      // Constructors.
      //
      IntersectionPlaneType (const IntersectionPlaneEnum_type&,
                             const DatumDefinitionId_type&);

      IntersectionPlaneType (const IntersectionPlaneEnum_type&,
                             ::std::auto_ptr< DatumDefinitionId_type >);

      IntersectionPlaneType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      IntersectionPlaneType (const IntersectionPlaneType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual IntersectionPlaneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IntersectionPlaneType&
      operator= (const IntersectionPlaneType& x);

      virtual 
      ~IntersectionPlaneType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< IntersectionPlaneEnum_type > IntersectionPlaneEnum_;
      ::xsd::cxx::tree::one< DatumDefinitionId_type > DatumDefinitionId_;
    };

    class ModifyingPlaneEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        PARALLEL,
        PERPENDICULAR,
        INCLINED
      };

      ModifyingPlaneEnumType (value v);

      ModifyingPlaneEnumType (const char* v);

      ModifyingPlaneEnumType (const ::std::string& v);

      ModifyingPlaneEnumType (const ::xml_schema::nmtoken& v);

      ModifyingPlaneEnumType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      ModifyingPlaneEnumType (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      ModifyingPlaneEnumType (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      ModifyingPlaneEnumType (const ModifyingPlaneEnumType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual ModifyingPlaneEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ModifyingPlaneEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ModifyingPlaneEnumType_convert ();
      }

      protected:
      value
      _xsd_ModifyingPlaneEnumType_convert () const;

      public:
      static const char* const _xsd_ModifyingPlaneEnumType_literals_[3];
      static const value _xsd_ModifyingPlaneEnumType_indexes_[3];
    };

    class DirectionFeatureType: public ::xml_schema::type
    {
      public:
      // DirectionFeatureEnum
      //
      typedef ::xsd::qif2::ModifyingPlaneEnumType DirectionFeatureEnum_type;
      typedef ::xsd::cxx::tree::traits< DirectionFeatureEnum_type, char > DirectionFeatureEnum_traits;

      const DirectionFeatureEnum_type&
      DirectionFeatureEnum () const;

      DirectionFeatureEnum_type&
      DirectionFeatureEnum ();

      void
      DirectionFeatureEnum (const DirectionFeatureEnum_type& x);

      void
      DirectionFeatureEnum (::std::auto_ptr< DirectionFeatureEnum_type > p);

      // DatumDefinitionId
      //
      typedef ::xsd::qif2::QIFReferenceFullType DatumDefinitionId_type;
      typedef ::xsd::cxx::tree::traits< DatumDefinitionId_type, char > DatumDefinitionId_traits;

      const DatumDefinitionId_type&
      DatumDefinitionId () const;

      DatumDefinitionId_type&
      DatumDefinitionId ();

      void
      DatumDefinitionId (const DatumDefinitionId_type& x);

      void
      DatumDefinitionId (::std::auto_ptr< DatumDefinitionId_type > p);

      // Constructors.
      //
      DirectionFeatureType (const DirectionFeatureEnum_type&,
                            const DatumDefinitionId_type&);

      DirectionFeatureType (const DirectionFeatureEnum_type&,
                            ::std::auto_ptr< DatumDefinitionId_type >);

      DirectionFeatureType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      DirectionFeatureType (const DirectionFeatureType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual DirectionFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DirectionFeatureType&
      operator= (const DirectionFeatureType& x);

      virtual 
      ~DirectionFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DirectionFeatureEnum_type > DirectionFeatureEnum_;
      ::xsd::cxx::tree::one< DatumDefinitionId_type > DatumDefinitionId_;
    };

    class CollectionPlaneType: public ::xml_schema::type
    {
      public:
      // CollectionPlaneEnum
      //
      typedef ::xsd::qif2::ModifyingPlaneEnumType CollectionPlaneEnum_type;
      typedef ::xsd::cxx::tree::traits< CollectionPlaneEnum_type, char > CollectionPlaneEnum_traits;

      const CollectionPlaneEnum_type&
      CollectionPlaneEnum () const;

      CollectionPlaneEnum_type&
      CollectionPlaneEnum ();

      void
      CollectionPlaneEnum (const CollectionPlaneEnum_type& x);

      void
      CollectionPlaneEnum (::std::auto_ptr< CollectionPlaneEnum_type > p);

      // DatumDefinitionId
      //
      typedef ::xsd::qif2::QIFReferenceFullType DatumDefinitionId_type;
      typedef ::xsd::cxx::tree::traits< DatumDefinitionId_type, char > DatumDefinitionId_traits;

      const DatumDefinitionId_type&
      DatumDefinitionId () const;

      DatumDefinitionId_type&
      DatumDefinitionId ();

      void
      DatumDefinitionId (const DatumDefinitionId_type& x);

      void
      DatumDefinitionId (::std::auto_ptr< DatumDefinitionId_type > p);

      // Constructors.
      //
      CollectionPlaneType (const CollectionPlaneEnum_type&,
                           const DatumDefinitionId_type&);

      CollectionPlaneType (const CollectionPlaneEnum_type&,
                           ::std::auto_ptr< DatumDefinitionId_type >);

      CollectionPlaneType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      CollectionPlaneType (const CollectionPlaneType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual CollectionPlaneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CollectionPlaneType&
      operator= (const CollectionPlaneType& x);

      virtual 
      ~CollectionPlaneType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CollectionPlaneEnum_type > CollectionPlaneEnum_;
      ::xsd::cxx::tree::one< DatumDefinitionId_type > DatumDefinitionId_;
    };

    class OrientationPlaneType: public ::xml_schema::type
    {
      public:
      // OrientationPlaneEnum
      //
      typedef ::xsd::qif2::ModifyingPlaneEnumType OrientationPlaneEnum_type;
      typedef ::xsd::cxx::tree::traits< OrientationPlaneEnum_type, char > OrientationPlaneEnum_traits;

      const OrientationPlaneEnum_type&
      OrientationPlaneEnum () const;

      OrientationPlaneEnum_type&
      OrientationPlaneEnum ();

      void
      OrientationPlaneEnum (const OrientationPlaneEnum_type& x);

      void
      OrientationPlaneEnum (::std::auto_ptr< OrientationPlaneEnum_type > p);

      // DatumDefinitionId
      //
      typedef ::xsd::qif2::QIFReferenceFullType DatumDefinitionId_type;
      typedef ::xsd::cxx::tree::traits< DatumDefinitionId_type, char > DatumDefinitionId_traits;

      const DatumDefinitionId_type&
      DatumDefinitionId () const;

      DatumDefinitionId_type&
      DatumDefinitionId ();

      void
      DatumDefinitionId (const DatumDefinitionId_type& x);

      void
      DatumDefinitionId (::std::auto_ptr< DatumDefinitionId_type > p);

      // Constructors.
      //
      OrientationPlaneType (const OrientationPlaneEnum_type&,
                            const DatumDefinitionId_type&);

      OrientationPlaneType (const OrientationPlaneEnum_type&,
                            ::std::auto_ptr< DatumDefinitionId_type >);

      OrientationPlaneType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      OrientationPlaneType (const OrientationPlaneType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual OrientationPlaneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OrientationPlaneType&
      operator= (const OrientationPlaneType& x);

      virtual 
      ~OrientationPlaneType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< OrientationPlaneEnum_type > OrientationPlaneEnum_;
      ::xsd::cxx::tree::one< DatumDefinitionId_type > DatumDefinitionId_;
    };

    class ReducedDatumEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        PT,
        SL,
        PL
      };

      ReducedDatumEnumType (value v);

      ReducedDatumEnumType (const char* v);

      ReducedDatumEnumType (const ::std::string& v);

      ReducedDatumEnumType (const ::xml_schema::nmtoken& v);

      ReducedDatumEnumType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ReducedDatumEnumType (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ReducedDatumEnumType (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ReducedDatumEnumType (const ReducedDatumEnumType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual ReducedDatumEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ReducedDatumEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ReducedDatumEnumType_convert ();
      }

      protected:
      value
      _xsd_ReducedDatumEnumType_convert () const;

      public:
      static const char* const _xsd_ReducedDatumEnumType_literals_[3];
      static const value _xsd_ReducedDatumEnumType_indexes_[3];
    };

    class DegreesOfFreedomType: public ::xml_schema::type
    {
      public:
      // DegreeOfFreedom
      //
      typedef ::xsd::qif2::DegreeOfFreedomEnumType DegreeOfFreedom_type;
      typedef ::xsd::cxx::tree::sequence< DegreeOfFreedom_type > DegreeOfFreedom_sequence;
      typedef DegreeOfFreedom_sequence::iterator DegreeOfFreedom_iterator;
      typedef DegreeOfFreedom_sequence::const_iterator DegreeOfFreedom_const_iterator;
      typedef ::xsd::cxx::tree::traits< DegreeOfFreedom_type, char > DegreeOfFreedom_traits;

      const DegreeOfFreedom_sequence&
      DegreeOfFreedom () const;

      DegreeOfFreedom_sequence&
      DegreeOfFreedom ();

      void
      DegreeOfFreedom (const DegreeOfFreedom_sequence& s);

      // ISODegreeOfFreedom
      //
      typedef ::xsd::qif2::ISODegreeOfFreedomEnumType ISODegreeOfFreedom_type;
      typedef ::xsd::cxx::tree::sequence< ISODegreeOfFreedom_type > ISODegreeOfFreedom_sequence;
      typedef ISODegreeOfFreedom_sequence::iterator ISODegreeOfFreedom_iterator;
      typedef ISODegreeOfFreedom_sequence::const_iterator ISODegreeOfFreedom_const_iterator;
      typedef ::xsd::cxx::tree::traits< ISODegreeOfFreedom_type, char > ISODegreeOfFreedom_traits;

      const ISODegreeOfFreedom_sequence&
      ISODegreeOfFreedom () const;

      ISODegreeOfFreedom_sequence&
      ISODegreeOfFreedom ();

      void
      ISODegreeOfFreedom (const ISODegreeOfFreedom_sequence& s);

      // Constructors.
      //
      DegreesOfFreedomType ();

      DegreesOfFreedomType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      DegreesOfFreedomType (const DegreesOfFreedomType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual DegreesOfFreedomType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DegreesOfFreedomType&
      operator= (const DegreesOfFreedomType& x);

      virtual 
      ~DegreesOfFreedomType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      DegreeOfFreedom_sequence DegreeOfFreedom_;
      ISODegreeOfFreedom_sequence ISODegreeOfFreedom_;
    };

    class DiameterModifierEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        PD,
        MD,
        LD
      };

      DiameterModifierEnumType (value v);

      DiameterModifierEnumType (const char* v);

      DiameterModifierEnumType (const ::std::string& v);

      DiameterModifierEnumType (const ::xml_schema::nmtoken& v);

      DiameterModifierEnumType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      DiameterModifierEnumType (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      DiameterModifierEnumType (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      DiameterModifierEnumType (const DiameterModifierEnumType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual DiameterModifierEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DiameterModifierEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_DiameterModifierEnumType_convert ();
      }

      protected:
      value
      _xsd_DiameterModifierEnumType_convert () const;

      public:
      static const char* const _xsd_DiameterModifierEnumType_literals_[3];
      static const value _xsd_DiameterModifierEnumType_indexes_[3];
    };

    class SectionModifierEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        ACS,
        ALS
      };

      SectionModifierEnumType (value v);

      SectionModifierEnumType (const char* v);

      SectionModifierEnumType (const ::std::string& v);

      SectionModifierEnumType (const ::xml_schema::nmtoken& v);

      SectionModifierEnumType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      SectionModifierEnumType (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      SectionModifierEnumType (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      SectionModifierEnumType (const SectionModifierEnumType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual SectionModifierEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SectionModifierEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_SectionModifierEnumType_convert ();
      }

      protected:
      value
      _xsd_SectionModifierEnumType_convert () const;

      public:
      static const char* const _xsd_SectionModifierEnumType_literals_[2];
      static const value _xsd_SectionModifierEnumType_indexes_[2];
    };

    class PointWithNormalBaseType: public ::xml_schema::type
    {
      public:
      // Point
      //
      typedef ::xsd::qif2::PointType Point_type;
      typedef ::xsd::cxx::tree::traits< Point_type, char > Point_traits;

      const Point_type&
      Point () const;

      Point_type&
      Point ();

      void
      Point (const Point_type& x);

      void
      Point (::std::auto_ptr< Point_type > p);

      // Normal
      //
      typedef ::xsd::qif2::UnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::optional< Normal_type > Normal_optional;
      typedef ::xsd::cxx::tree::traits< Normal_type, char > Normal_traits;

      const Normal_optional&
      Normal () const;

      Normal_optional&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (const Normal_optional& x);

      void
      Normal (::std::auto_ptr< Normal_type > p);

      // id
      //
      typedef ::xsd::qif2::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::auto_ptr< id_type > p);

      // Constructors.
      //
      PointWithNormalBaseType (const Point_type&,
                               const id_type&);

      PointWithNormalBaseType (::std::auto_ptr< Point_type >,
                               const id_type&);

      PointWithNormalBaseType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      PointWithNormalBaseType (const PointWithNormalBaseType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual PointWithNormalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointWithNormalBaseType&
      operator= (const PointWithNormalBaseType& x);

      virtual 
      ~PointWithNormalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Point_type > Point_;
      Normal_optional Normal_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class ActualPointWithNormalBaseType: public ::xml_schema::type
    {
      public:
      // Point
      //
      typedef ::xsd::qif2::ActualPointType Point_type;
      typedef ::xsd::cxx::tree::traits< Point_type, char > Point_traits;

      const Point_type&
      Point () const;

      Point_type&
      Point ();

      void
      Point (const Point_type& x);

      void
      Point (::std::auto_ptr< Point_type > p);

      // Normal
      //
      typedef ::xsd::qif2::ActualUnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::optional< Normal_type > Normal_optional;
      typedef ::xsd::cxx::tree::traits< Normal_type, char > Normal_traits;

      const Normal_optional&
      Normal () const;

      Normal_optional&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (const Normal_optional& x);

      void
      Normal (::std::auto_ptr< Normal_type > p);

      // id
      //
      typedef ::xsd::qif2::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::auto_ptr< id_type > p);

      // Constructors.
      //
      ActualPointWithNormalBaseType (const Point_type&,
                                     const id_type&);

      ActualPointWithNormalBaseType (::std::auto_ptr< Point_type >,
                                     const id_type&);

      ActualPointWithNormalBaseType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      ActualPointWithNormalBaseType (const ActualPointWithNormalBaseType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual ActualPointWithNormalBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ActualPointWithNormalBaseType&
      operator= (const ActualPointWithNormalBaseType& x);

      virtual 
      ~ActualPointWithNormalBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Point_type > Point_;
      Normal_optional Normal_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class MeasurePointNominalType: public ::xsd::qif2::PointWithNormalBaseType
    {
      public:
      // MeasurementDeviceId
      //
      typedef ::xsd::qif2::QIFReferenceFullType MeasurementDeviceId_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDeviceId_type > MeasurementDeviceId_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDeviceId_type, char > MeasurementDeviceId_traits;

      const MeasurementDeviceId_optional&
      MeasurementDeviceId () const;

      MeasurementDeviceId_optional&
      MeasurementDeviceId ();

      void
      MeasurementDeviceId (const MeasurementDeviceId_type& x);

      void
      MeasurementDeviceId (const MeasurementDeviceId_optional& x);

      void
      MeasurementDeviceId (::std::auto_ptr< MeasurementDeviceId_type > p);

      // SensorId
      //
      typedef ::xsd::qif2::QIFReferenceFullType SensorId_type;
      typedef ::xsd::cxx::tree::optional< SensorId_type > SensorId_optional;
      typedef ::xsd::cxx::tree::traits< SensorId_type, char > SensorId_traits;

      const SensorId_optional&
      SensorId () const;

      SensorId_optional&
      SensorId ();

      void
      SensorId (const SensorId_type& x);

      void
      SensorId (const SensorId_optional& x);

      void
      SensorId (::std::auto_ptr< SensorId_type > p);

      // Constructors.
      //
      MeasurePointNominalType (const Point_type&,
                               const id_type&);

      MeasurePointNominalType (::std::auto_ptr< Point_type >,
                               const id_type&);

      MeasurePointNominalType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      MeasurePointNominalType (const MeasurePointNominalType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual MeasurePointNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasurePointNominalType&
      operator= (const MeasurePointNominalType& x);

      virtual 
      ~MeasurePointNominalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      MeasurementDeviceId_optional MeasurementDeviceId_;
      SensorId_optional SensorId_;
    };

    class MeasurePointActualType: public ::xsd::qif2::ActualPointWithNormalBaseType
    {
      public:
      // Compensated
      //
      typedef ::xml_schema::boolean Compensated_type;
      typedef ::xsd::cxx::tree::traits< Compensated_type, char > Compensated_traits;

      const Compensated_type&
      Compensated () const;

      Compensated_type&
      Compensated ();

      void
      Compensated (const Compensated_type& x);

      // ProbeRadius
      //
      typedef ::xsd::qif2::ActualLinearValueType ProbeRadius_type;
      typedef ::xsd::cxx::tree::optional< ProbeRadius_type > ProbeRadius_optional;
      typedef ::xsd::cxx::tree::traits< ProbeRadius_type, char > ProbeRadius_traits;

      const ProbeRadius_optional&
      ProbeRadius () const;

      ProbeRadius_optional&
      ProbeRadius ();

      void
      ProbeRadius (const ProbeRadius_type& x);

      void
      ProbeRadius (const ProbeRadius_optional& x);

      void
      ProbeRadius (::std::auto_ptr< ProbeRadius_type > p);

      // MeasurementDeviceId
      //
      typedef ::xsd::qif2::QIFReferenceFullType MeasurementDeviceId_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDeviceId_type > MeasurementDeviceId_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDeviceId_type, char > MeasurementDeviceId_traits;

      const MeasurementDeviceId_optional&
      MeasurementDeviceId () const;

      MeasurementDeviceId_optional&
      MeasurementDeviceId ();

      void
      MeasurementDeviceId (const MeasurementDeviceId_type& x);

      void
      MeasurementDeviceId (const MeasurementDeviceId_optional& x);

      void
      MeasurementDeviceId (::std::auto_ptr< MeasurementDeviceId_type > p);

      // SensorId
      //
      typedef ::xsd::qif2::QIFReferenceFullType SensorId_type;
      typedef ::xsd::cxx::tree::optional< SensorId_type > SensorId_optional;
      typedef ::xsd::cxx::tree::traits< SensorId_type, char > SensorId_traits;

      const SensorId_optional&
      SensorId () const;

      SensorId_optional&
      SensorId ();

      void
      SensorId (const SensorId_type& x);

      void
      SensorId (const SensorId_optional& x);

      void
      SensorId (::std::auto_ptr< SensorId_type > p);

      // MeasurePointNominalId
      //
      typedef ::xsd::qif2::QIFReferenceFullType MeasurePointNominalId_type;
      typedef ::xsd::cxx::tree::optional< MeasurePointNominalId_type > MeasurePointNominalId_optional;
      typedef ::xsd::cxx::tree::traits< MeasurePointNominalId_type, char > MeasurePointNominalId_traits;

      const MeasurePointNominalId_optional&
      MeasurePointNominalId () const;

      MeasurePointNominalId_optional&
      MeasurePointNominalId ();

      void
      MeasurePointNominalId (const MeasurePointNominalId_type& x);

      void
      MeasurePointNominalId (const MeasurePointNominalId_optional& x);

      void
      MeasurePointNominalId (::std::auto_ptr< MeasurePointNominalId_type > p);

      // Constructors.
      //
      MeasurePointActualType (const Point_type&,
                              const id_type&,
                              const Compensated_type&);

      MeasurePointActualType (::std::auto_ptr< Point_type >,
                              const id_type&,
                              const Compensated_type&);

      MeasurePointActualType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      MeasurePointActualType (const MeasurePointActualType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual MeasurePointActualType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasurePointActualType&
      operator= (const MeasurePointActualType& x);

      virtual 
      ~MeasurePointActualType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Compensated_type > Compensated_;
      ProbeRadius_optional ProbeRadius_;
      MeasurementDeviceId_optional MeasurementDeviceId_;
      SensorId_optional SensorId_;
      MeasurePointNominalId_optional MeasurePointNominalId_;
    };

    class MovableDatumTargetDirectionType: public ::xml_schema::type
    {
      public:
      // DatumTargetTranslationDirection
      //
      typedef ::xsd::qif2::UnitVectorType DatumTargetTranslationDirection_type;
      typedef ::xsd::cxx::tree::traits< DatumTargetTranslationDirection_type, char > DatumTargetTranslationDirection_traits;

      const DatumTargetTranslationDirection_type&
      DatumTargetTranslationDirection () const;

      DatumTargetTranslationDirection_type&
      DatumTargetTranslationDirection ();

      void
      DatumTargetTranslationDirection (const DatumTargetTranslationDirection_type& x);

      void
      DatumTargetTranslationDirection (::std::auto_ptr< DatumTargetTranslationDirection_type > p);

      // Constructors.
      //
      MovableDatumTargetDirectionType (const DatumTargetTranslationDirection_type&);

      MovableDatumTargetDirectionType (::std::auto_ptr< DatumTargetTranslationDirection_type >);

      MovableDatumTargetDirectionType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      MovableDatumTargetDirectionType (const MovableDatumTargetDirectionType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual MovableDatumTargetDirectionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MovableDatumTargetDirectionType&
      operator= (const MovableDatumTargetDirectionType& x);

      virtual 
      ~MovableDatumTargetDirectionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DatumTargetTranslationDirection_type > DatumTargetTranslationDirection_;
    };

    class TargetPointActualType: public ::xsd::qif2::ActualPointWithNormalBaseType
    {
      public:
      // Constructors.
      //
      TargetPointActualType (const Point_type&,
                             const id_type&);

      TargetPointActualType (::std::auto_ptr< Point_type >,
                             const id_type&);

      TargetPointActualType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      TargetPointActualType (const TargetPointActualType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual TargetPointActualType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~TargetPointActualType ();
    };

    class TargetPointNominalType: public ::xsd::qif2::PointWithNormalBaseType
    {
      public:
      // Constructors.
      //
      TargetPointNominalType (const Point_type&,
                              const id_type&);

      TargetPointNominalType (::std::auto_ptr< Point_type >,
                              const id_type&);

      TargetPointNominalType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      TargetPointNominalType (const TargetPointNominalType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual TargetPointNominalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~TargetPointNominalType ();
    };

    class TransformListType: public ::xml_schema::type
    {
      public:
      // Transform
      //
      typedef ::xsd::qif2::TransformInstanceType Transform_type;
      typedef ::xsd::cxx::tree::sequence< Transform_type > Transform_sequence;
      typedef Transform_sequence::iterator Transform_iterator;
      typedef Transform_sequence::const_iterator Transform_const_iterator;
      typedef ::xsd::cxx::tree::traits< Transform_type, char > Transform_traits;

      const Transform_sequence&
      Transform () const;

      Transform_sequence&
      Transform ();

      void
      Transform (const Transform_sequence& s);

      // N
      //
      typedef ::xsd::qif2::NaturalType N_type;
      typedef ::xsd::cxx::tree::traits< N_type, char > N_traits;

      const N_type&
      N () const;

      N_type&
      N ();

      void
      N (const N_type& x);

      void
      N (::std::auto_ptr< N_type > p);

      // Constructors.
      //
      TransformListType (const N_type&);

      TransformListType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      TransformListType (const TransformListType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual TransformListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TransformListType&
      operator= (const TransformListType& x);

      virtual 
      ~TransformListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Transform_sequence Transform_;
      ::xsd::cxx::tree::one< N_type > N_;
    };

    class TransformInstanceType: public ::xsd::qif2::TransformMatrixType
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif2::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, char > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::auto_ptr< Attributes_type > p);

      // Name
      //
      typedef ::xml_schema::token Name_type;
      typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
      typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

      const Name_optional&
      Name () const;

      Name_optional&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (const Name_optional& x);

      void
      Name (::std::auto_ptr< Name_type > p);

      // id
      //
      typedef ::xsd::qif2::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::auto_ptr< id_type > p);

      // Constructors.
      //
      TransformInstanceType (const id_type&);

      TransformInstanceType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      TransformInstanceType (const TransformInstanceType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual TransformInstanceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TransformInstanceType&
      operator= (const TransformInstanceType& x);

      virtual 
      ~TransformInstanceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      Name_optional Name_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class LinearCoordinateDirectionEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        XAXIS,
        YAXIS,
        ZAXIS,
        RADIAL
      };

      LinearCoordinateDirectionEnumType (value v);

      LinearCoordinateDirectionEnumType (const char* v);

      LinearCoordinateDirectionEnumType (const ::std::string& v);

      LinearCoordinateDirectionEnumType (const ::xml_schema::nmtoken& v);

      LinearCoordinateDirectionEnumType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      LinearCoordinateDirectionEnumType (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      LinearCoordinateDirectionEnumType (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      LinearCoordinateDirectionEnumType (const LinearCoordinateDirectionEnumType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual LinearCoordinateDirectionEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearCoordinateDirectionEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_LinearCoordinateDirectionEnumType_convert ();
      }

      protected:
      value
      _xsd_LinearCoordinateDirectionEnumType_convert () const;

      public:
      static const char* const _xsd_LinearCoordinateDirectionEnumType_literals_[4];
      static const value _xsd_LinearCoordinateDirectionEnumType_indexes_[4];
    };

    class AngularCoordinateDirectionEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        ANGULAR,
        AZIMUTH,
        POLAR
      };

      AngularCoordinateDirectionEnumType (value v);

      AngularCoordinateDirectionEnumType (const char* v);

      AngularCoordinateDirectionEnumType (const ::std::string& v);

      AngularCoordinateDirectionEnumType (const ::xml_schema::nmtoken& v);

      AngularCoordinateDirectionEnumType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      AngularCoordinateDirectionEnumType (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      AngularCoordinateDirectionEnumType (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      AngularCoordinateDirectionEnumType (const AngularCoordinateDirectionEnumType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual AngularCoordinateDirectionEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngularCoordinateDirectionEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_AngularCoordinateDirectionEnumType_convert ();
      }

      protected:
      value
      _xsd_AngularCoordinateDirectionEnumType_convert () const;

      public:
      static const char* const _xsd_AngularCoordinateDirectionEnumType_literals_[3];
      static const value _xsd_AngularCoordinateDirectionEnumType_indexes_[3];
    };

    class SubstituteFeatureAlgorithmBaseType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      SubstituteFeatureAlgorithmBaseType ();

      SubstituteFeatureAlgorithmBaseType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      SubstituteFeatureAlgorithmBaseType (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      SubstituteFeatureAlgorithmBaseType (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      SubstituteFeatureAlgorithmBaseType (const SubstituteFeatureAlgorithmBaseType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual SubstituteFeatureAlgorithmBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~SubstituteFeatureAlgorithmBaseType ();
    };

    class FeatureOfSizeSubstituteFeatureAlgorithmEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        LEASTSQUARES,
        MINMAX,
        MINCIRCUMSCRIBED,
        MAXINSCRIBED,
        UNDEFINED
      };

      FeatureOfSizeSubstituteFeatureAlgorithmEnumType (value v);

      FeatureOfSizeSubstituteFeatureAlgorithmEnumType (const char* v);

      FeatureOfSizeSubstituteFeatureAlgorithmEnumType (const ::std::string& v);

      FeatureOfSizeSubstituteFeatureAlgorithmEnumType (const ::xml_schema::nmtoken& v);

      FeatureOfSizeSubstituteFeatureAlgorithmEnumType (const ::xercesc::DOMElement& e,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      FeatureOfSizeSubstituteFeatureAlgorithmEnumType (const ::xercesc::DOMAttr& a,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      FeatureOfSizeSubstituteFeatureAlgorithmEnumType (const ::std::string& s,
                                                       const ::xercesc::DOMElement* e,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      FeatureOfSizeSubstituteFeatureAlgorithmEnumType (const FeatureOfSizeSubstituteFeatureAlgorithmEnumType& x,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

      virtual FeatureOfSizeSubstituteFeatureAlgorithmEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FeatureOfSizeSubstituteFeatureAlgorithmEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_FeatureOfSizeSubstituteFeatureAlgorithmEnumType_convert ();
      }

      protected:
      value
      _xsd_FeatureOfSizeSubstituteFeatureAlgorithmEnumType_convert () const;

      public:
      static const char* const _xsd_FeatureOfSizeSubstituteFeatureAlgorithmEnumType_literals_[5];
      static const value _xsd_FeatureOfSizeSubstituteFeatureAlgorithmEnumType_indexes_[5];
    };

    class FeatureOfSizeSubstituteFeatureAlgorithmType: public ::xsd::qif2::SubstituteFeatureAlgorithmBaseType
    {
      public:
      // FeatureOfSizeSubstituteFeatureAlgorithmEnum
      //
      typedef ::xsd::qif2::FeatureOfSizeSubstituteFeatureAlgorithmEnumType FeatureOfSizeSubstituteFeatureAlgorithmEnum_type;
      typedef ::xsd::cxx::tree::optional< FeatureOfSizeSubstituteFeatureAlgorithmEnum_type > FeatureOfSizeSubstituteFeatureAlgorithmEnum_optional;
      typedef ::xsd::cxx::tree::traits< FeatureOfSizeSubstituteFeatureAlgorithmEnum_type, char > FeatureOfSizeSubstituteFeatureAlgorithmEnum_traits;

      const FeatureOfSizeSubstituteFeatureAlgorithmEnum_optional&
      FeatureOfSizeSubstituteFeatureAlgorithmEnum () const;

      FeatureOfSizeSubstituteFeatureAlgorithmEnum_optional&
      FeatureOfSizeSubstituteFeatureAlgorithmEnum ();

      void
      FeatureOfSizeSubstituteFeatureAlgorithmEnum (const FeatureOfSizeSubstituteFeatureAlgorithmEnum_type& x);

      void
      FeatureOfSizeSubstituteFeatureAlgorithmEnum (const FeatureOfSizeSubstituteFeatureAlgorithmEnum_optional& x);

      void
      FeatureOfSizeSubstituteFeatureAlgorithmEnum (::std::auto_ptr< FeatureOfSizeSubstituteFeatureAlgorithmEnum_type > p);

      // OtherFeatureOfSizeSubstituteFeatureAlgorithm
      //
      typedef ::xml_schema::string OtherFeatureOfSizeSubstituteFeatureAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< OtherFeatureOfSizeSubstituteFeatureAlgorithm_type > OtherFeatureOfSizeSubstituteFeatureAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< OtherFeatureOfSizeSubstituteFeatureAlgorithm_type, char > OtherFeatureOfSizeSubstituteFeatureAlgorithm_traits;

      const OtherFeatureOfSizeSubstituteFeatureAlgorithm_optional&
      OtherFeatureOfSizeSubstituteFeatureAlgorithm () const;

      OtherFeatureOfSizeSubstituteFeatureAlgorithm_optional&
      OtherFeatureOfSizeSubstituteFeatureAlgorithm ();

      void
      OtherFeatureOfSizeSubstituteFeatureAlgorithm (const OtherFeatureOfSizeSubstituteFeatureAlgorithm_type& x);

      void
      OtherFeatureOfSizeSubstituteFeatureAlgorithm (const OtherFeatureOfSizeSubstituteFeatureAlgorithm_optional& x);

      void
      OtherFeatureOfSizeSubstituteFeatureAlgorithm (::std::auto_ptr< OtherFeatureOfSizeSubstituteFeatureAlgorithm_type > p);

      // Constructors.
      //
      FeatureOfSizeSubstituteFeatureAlgorithmType ();

      FeatureOfSizeSubstituteFeatureAlgorithmType (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      FeatureOfSizeSubstituteFeatureAlgorithmType (const FeatureOfSizeSubstituteFeatureAlgorithmType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual FeatureOfSizeSubstituteFeatureAlgorithmType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FeatureOfSizeSubstituteFeatureAlgorithmType&
      operator= (const FeatureOfSizeSubstituteFeatureAlgorithmType& x);

      virtual 
      ~FeatureOfSizeSubstituteFeatureAlgorithmType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      FeatureOfSizeSubstituteFeatureAlgorithmEnum_optional FeatureOfSizeSubstituteFeatureAlgorithmEnum_;
      OtherFeatureOfSizeSubstituteFeatureAlgorithm_optional OtherFeatureOfSizeSubstituteFeatureAlgorithm_;
    };

    class NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        LEASTSQUARES,
        MINMAX,
        UNDEFINED
      };

      NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType (value v);

      NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType (const char* v);

      NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType (const ::std::string& v);

      NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType (const ::xml_schema::nmtoken& v);

      NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType (const ::xercesc::DOMElement& e,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

      NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType (const ::xercesc::DOMAttr& a,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

      NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType (const ::std::string& s,
                                                          const ::xercesc::DOMElement* e,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

      NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType (const NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType& x,
                                                          ::xml_schema::flags f = 0,
                                                          ::xml_schema::container* c = 0);

      virtual NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType_convert ();
      }

      protected:
      value
      _xsd_NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType_convert () const;

      public:
      static const char* const _xsd_NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType_literals_[3];
      static const value _xsd_NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType_indexes_[3];
    };

    class NonFeatureOfSizeSubstituteFeatureAlgorithmType: public ::xsd::qif2::SubstituteFeatureAlgorithmBaseType
    {
      public:
      // NonFeatureOfSizeSubstituteFeatureAlgorithmEnum
      //
      typedef ::xsd::qif2::NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_type;
      typedef ::xsd::cxx::tree::optional< NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_type > NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_optional;
      typedef ::xsd::cxx::tree::traits< NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_type, char > NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_traits;

      const NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_optional&
      NonFeatureOfSizeSubstituteFeatureAlgorithmEnum () const;

      NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_optional&
      NonFeatureOfSizeSubstituteFeatureAlgorithmEnum ();

      void
      NonFeatureOfSizeSubstituteFeatureAlgorithmEnum (const NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_type& x);

      void
      NonFeatureOfSizeSubstituteFeatureAlgorithmEnum (const NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_optional& x);

      void
      NonFeatureOfSizeSubstituteFeatureAlgorithmEnum (::std::auto_ptr< NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_type > p);

      // OtherNonFeatureOfSizeSubstituteFeatureAlgorithm
      //
      typedef ::xml_schema::string OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_type > OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_type, char > OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_traits;

      const OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_optional&
      OtherNonFeatureOfSizeSubstituteFeatureAlgorithm () const;

      OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_optional&
      OtherNonFeatureOfSizeSubstituteFeatureAlgorithm ();

      void
      OtherNonFeatureOfSizeSubstituteFeatureAlgorithm (const OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_type& x);

      void
      OtherNonFeatureOfSizeSubstituteFeatureAlgorithm (const OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_optional& x);

      void
      OtherNonFeatureOfSizeSubstituteFeatureAlgorithm (::std::auto_ptr< OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_type > p);

      // Constructors.
      //
      NonFeatureOfSizeSubstituteFeatureAlgorithmType ();

      NonFeatureOfSizeSubstituteFeatureAlgorithmType (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

      NonFeatureOfSizeSubstituteFeatureAlgorithmType (const NonFeatureOfSizeSubstituteFeatureAlgorithmType& x,
                                                      ::xml_schema::flags f = 0,
                                                      ::xml_schema::container* c = 0);

      virtual NonFeatureOfSizeSubstituteFeatureAlgorithmType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NonFeatureOfSizeSubstituteFeatureAlgorithmType&
      operator= (const NonFeatureOfSizeSubstituteFeatureAlgorithmType& x);

      virtual 
      ~NonFeatureOfSizeSubstituteFeatureAlgorithmType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_optional NonFeatureOfSizeSubstituteFeatureAlgorithmEnum_;
      OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_optional OtherNonFeatureOfSizeSubstituteFeatureAlgorithm_;
    };

    class CurveSubstituteFeatureAlgorithmEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        LEASTSQUARES,
        BSPLINE,
        MINMAX,
        UNDEFINED
      };

      CurveSubstituteFeatureAlgorithmEnumType (value v);

      CurveSubstituteFeatureAlgorithmEnumType (const char* v);

      CurveSubstituteFeatureAlgorithmEnumType (const ::std::string& v);

      CurveSubstituteFeatureAlgorithmEnumType (const ::xml_schema::nmtoken& v);

      CurveSubstituteFeatureAlgorithmEnumType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      CurveSubstituteFeatureAlgorithmEnumType (const ::xercesc::DOMAttr& a,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      CurveSubstituteFeatureAlgorithmEnumType (const ::std::string& s,
                                               const ::xercesc::DOMElement* e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      CurveSubstituteFeatureAlgorithmEnumType (const CurveSubstituteFeatureAlgorithmEnumType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual CurveSubstituteFeatureAlgorithmEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CurveSubstituteFeatureAlgorithmEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_CurveSubstituteFeatureAlgorithmEnumType_convert ();
      }

      protected:
      value
      _xsd_CurveSubstituteFeatureAlgorithmEnumType_convert () const;

      public:
      static const char* const _xsd_CurveSubstituteFeatureAlgorithmEnumType_literals_[4];
      static const value _xsd_CurveSubstituteFeatureAlgorithmEnumType_indexes_[4];
    };

    class CurveSubstituteFeatureAlgorithmType: public ::xsd::qif2::SubstituteFeatureAlgorithmBaseType
    {
      public:
      // CurveSubstituteFeatureAlgorithmEnum
      //
      typedef ::xsd::qif2::CurveSubstituteFeatureAlgorithmEnumType CurveSubstituteFeatureAlgorithmEnum_type;
      typedef ::xsd::cxx::tree::optional< CurveSubstituteFeatureAlgorithmEnum_type > CurveSubstituteFeatureAlgorithmEnum_optional;
      typedef ::xsd::cxx::tree::traits< CurveSubstituteFeatureAlgorithmEnum_type, char > CurveSubstituteFeatureAlgorithmEnum_traits;

      const CurveSubstituteFeatureAlgorithmEnum_optional&
      CurveSubstituteFeatureAlgorithmEnum () const;

      CurveSubstituteFeatureAlgorithmEnum_optional&
      CurveSubstituteFeatureAlgorithmEnum ();

      void
      CurveSubstituteFeatureAlgorithmEnum (const CurveSubstituteFeatureAlgorithmEnum_type& x);

      void
      CurveSubstituteFeatureAlgorithmEnum (const CurveSubstituteFeatureAlgorithmEnum_optional& x);

      void
      CurveSubstituteFeatureAlgorithmEnum (::std::auto_ptr< CurveSubstituteFeatureAlgorithmEnum_type > p);

      // OtherCurveSubstituteFeatureAlgorithm
      //
      typedef ::xml_schema::string OtherCurveSubstituteFeatureAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< OtherCurveSubstituteFeatureAlgorithm_type > OtherCurveSubstituteFeatureAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< OtherCurveSubstituteFeatureAlgorithm_type, char > OtherCurveSubstituteFeatureAlgorithm_traits;

      const OtherCurveSubstituteFeatureAlgorithm_optional&
      OtherCurveSubstituteFeatureAlgorithm () const;

      OtherCurveSubstituteFeatureAlgorithm_optional&
      OtherCurveSubstituteFeatureAlgorithm ();

      void
      OtherCurveSubstituteFeatureAlgorithm (const OtherCurveSubstituteFeatureAlgorithm_type& x);

      void
      OtherCurveSubstituteFeatureAlgorithm (const OtherCurveSubstituteFeatureAlgorithm_optional& x);

      void
      OtherCurveSubstituteFeatureAlgorithm (::std::auto_ptr< OtherCurveSubstituteFeatureAlgorithm_type > p);

      // Constructors.
      //
      CurveSubstituteFeatureAlgorithmType ();

      CurveSubstituteFeatureAlgorithmType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      CurveSubstituteFeatureAlgorithmType (const CurveSubstituteFeatureAlgorithmType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual CurveSubstituteFeatureAlgorithmType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CurveSubstituteFeatureAlgorithmType&
      operator= (const CurveSubstituteFeatureAlgorithmType& x);

      virtual 
      ~CurveSubstituteFeatureAlgorithmType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      CurveSubstituteFeatureAlgorithmEnum_optional CurveSubstituteFeatureAlgorithmEnum_;
      OtherCurveSubstituteFeatureAlgorithm_optional OtherCurveSubstituteFeatureAlgorithm_;
    };

    class SurfaceSubstituteFeatureAlgorithmEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        LEASTSQUARES,
        BEZIER,
        NURBS,
        MINMAX,
        UNDEFINED
      };

      SurfaceSubstituteFeatureAlgorithmEnumType (value v);

      SurfaceSubstituteFeatureAlgorithmEnumType (const char* v);

      SurfaceSubstituteFeatureAlgorithmEnumType (const ::std::string& v);

      SurfaceSubstituteFeatureAlgorithmEnumType (const ::xml_schema::nmtoken& v);

      SurfaceSubstituteFeatureAlgorithmEnumType (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      SurfaceSubstituteFeatureAlgorithmEnumType (const ::xercesc::DOMAttr& a,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      SurfaceSubstituteFeatureAlgorithmEnumType (const ::std::string& s,
                                                 const ::xercesc::DOMElement* e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      SurfaceSubstituteFeatureAlgorithmEnumType (const SurfaceSubstituteFeatureAlgorithmEnumType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual SurfaceSubstituteFeatureAlgorithmEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceSubstituteFeatureAlgorithmEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_SurfaceSubstituteFeatureAlgorithmEnumType_convert ();
      }

      protected:
      value
      _xsd_SurfaceSubstituteFeatureAlgorithmEnumType_convert () const;

      public:
      static const char* const _xsd_SurfaceSubstituteFeatureAlgorithmEnumType_literals_[5];
      static const value _xsd_SurfaceSubstituteFeatureAlgorithmEnumType_indexes_[5];
    };

    class SurfaceSubstituteFeatureAlgorithmType: public ::xsd::qif2::SubstituteFeatureAlgorithmBaseType
    {
      public:
      // SurfaceSubstituteFeatureAlgorithmEnum
      //
      typedef ::xsd::qif2::SurfaceSubstituteFeatureAlgorithmEnumType SurfaceSubstituteFeatureAlgorithmEnum_type;
      typedef ::xsd::cxx::tree::optional< SurfaceSubstituteFeatureAlgorithmEnum_type > SurfaceSubstituteFeatureAlgorithmEnum_optional;
      typedef ::xsd::cxx::tree::traits< SurfaceSubstituteFeatureAlgorithmEnum_type, char > SurfaceSubstituteFeatureAlgorithmEnum_traits;

      const SurfaceSubstituteFeatureAlgorithmEnum_optional&
      SurfaceSubstituteFeatureAlgorithmEnum () const;

      SurfaceSubstituteFeatureAlgorithmEnum_optional&
      SurfaceSubstituteFeatureAlgorithmEnum ();

      void
      SurfaceSubstituteFeatureAlgorithmEnum (const SurfaceSubstituteFeatureAlgorithmEnum_type& x);

      void
      SurfaceSubstituteFeatureAlgorithmEnum (const SurfaceSubstituteFeatureAlgorithmEnum_optional& x);

      void
      SurfaceSubstituteFeatureAlgorithmEnum (::std::auto_ptr< SurfaceSubstituteFeatureAlgorithmEnum_type > p);

      // OtherSurfaceSubstituteFeatureAlgorithm
      //
      typedef ::xml_schema::string OtherSurfaceSubstituteFeatureAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< OtherSurfaceSubstituteFeatureAlgorithm_type > OtherSurfaceSubstituteFeatureAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< OtherSurfaceSubstituteFeatureAlgorithm_type, char > OtherSurfaceSubstituteFeatureAlgorithm_traits;

      const OtherSurfaceSubstituteFeatureAlgorithm_optional&
      OtherSurfaceSubstituteFeatureAlgorithm () const;

      OtherSurfaceSubstituteFeatureAlgorithm_optional&
      OtherSurfaceSubstituteFeatureAlgorithm ();

      void
      OtherSurfaceSubstituteFeatureAlgorithm (const OtherSurfaceSubstituteFeatureAlgorithm_type& x);

      void
      OtherSurfaceSubstituteFeatureAlgorithm (const OtherSurfaceSubstituteFeatureAlgorithm_optional& x);

      void
      OtherSurfaceSubstituteFeatureAlgorithm (::std::auto_ptr< OtherSurfaceSubstituteFeatureAlgorithm_type > p);

      // Constructors.
      //
      SurfaceSubstituteFeatureAlgorithmType ();

      SurfaceSubstituteFeatureAlgorithmType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      SurfaceSubstituteFeatureAlgorithmType (const SurfaceSubstituteFeatureAlgorithmType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual SurfaceSubstituteFeatureAlgorithmType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceSubstituteFeatureAlgorithmType&
      operator= (const SurfaceSubstituteFeatureAlgorithmType& x);

      virtual 
      ~SurfaceSubstituteFeatureAlgorithmType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      SurfaceSubstituteFeatureAlgorithmEnum_optional SurfaceSubstituteFeatureAlgorithmEnum_;
      OtherSurfaceSubstituteFeatureAlgorithm_optional OtherSurfaceSubstituteFeatureAlgorithm_;
    };

    class MaterialModifierEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        REGARDLESS,
        LEAST,
        MAXIMUM,
        NONE
      };

      MaterialModifierEnumType (value v);

      MaterialModifierEnumType (const char* v);

      MaterialModifierEnumType (const ::std::string& v);

      MaterialModifierEnumType (const ::xml_schema::nmtoken& v);

      MaterialModifierEnumType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      MaterialModifierEnumType (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      MaterialModifierEnumType (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      MaterialModifierEnumType (const MaterialModifierEnumType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual MaterialModifierEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MaterialModifierEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_MaterialModifierEnumType_convert ();
      }

      protected:
      value
      _xsd_MaterialModifierEnumType_convert () const;

      public:
      static const char* const _xsd_MaterialModifierEnumType_literals_[4];
      static const value _xsd_MaterialModifierEnumType_indexes_[4];
    };

    class PrecedenceEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        PRIMARY,
        SECONDARY,
        TERTIARY,
        QUATERNARY,
        QUINARY,
        SENARY
      };

      PrecedenceEnumType (value v);

      PrecedenceEnumType (const char* v);

      PrecedenceEnumType (const ::std::string& v);

      PrecedenceEnumType (const ::xml_schema::nmtoken& v);

      PrecedenceEnumType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      PrecedenceEnumType (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      PrecedenceEnumType (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      PrecedenceEnumType (const PrecedenceEnumType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual PrecedenceEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PrecedenceEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_PrecedenceEnumType_convert ();
      }

      protected:
      value
      _xsd_PrecedenceEnumType_convert () const;

      public:
      static const char* const _xsd_PrecedenceEnumType_literals_[6];
      static const value _xsd_PrecedenceEnumType_indexes_[6];
    };

    class PrecedenceType: public ::xml_schema::type
    {
      public:
      // PrecedenceEnum
      //
      typedef ::xsd::qif2::PrecedenceEnumType PrecedenceEnum_type;
      typedef ::xsd::cxx::tree::optional< PrecedenceEnum_type > PrecedenceEnum_optional;
      typedef ::xsd::cxx::tree::traits< PrecedenceEnum_type, char > PrecedenceEnum_traits;

      const PrecedenceEnum_optional&
      PrecedenceEnum () const;

      PrecedenceEnum_optional&
      PrecedenceEnum ();

      void
      PrecedenceEnum (const PrecedenceEnum_type& x);

      void
      PrecedenceEnum (const PrecedenceEnum_optional& x);

      void
      PrecedenceEnum (::std::auto_ptr< PrecedenceEnum_type > p);

      // OtherPrecedence
      //
      typedef ::xml_schema::string OtherPrecedence_type;
      typedef ::xsd::cxx::tree::optional< OtherPrecedence_type > OtherPrecedence_optional;
      typedef ::xsd::cxx::tree::traits< OtherPrecedence_type, char > OtherPrecedence_traits;

      const OtherPrecedence_optional&
      OtherPrecedence () const;

      OtherPrecedence_optional&
      OtherPrecedence ();

      void
      OtherPrecedence (const OtherPrecedence_type& x);

      void
      OtherPrecedence (const OtherPrecedence_optional& x);

      void
      OtherPrecedence (::std::auto_ptr< OtherPrecedence_type > p);

      // Constructors.
      //
      PrecedenceType ();

      PrecedenceType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      PrecedenceType (const PrecedenceType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual PrecedenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PrecedenceType&
      operator= (const PrecedenceType& x);

      virtual 
      ~PrecedenceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      PrecedenceEnum_optional PrecedenceEnum_;
      OtherPrecedence_optional OtherPrecedence_;
    };

    class ReferencedComponentEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        NOMINAL,
        ACTUAL
      };

      ReferencedComponentEnumType (value v);

      ReferencedComponentEnumType (const char* v);

      ReferencedComponentEnumType (const ::std::string& v);

      ReferencedComponentEnumType (const ::xml_schema::nmtoken& v);

      ReferencedComponentEnumType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ReferencedComponentEnumType (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ReferencedComponentEnumType (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ReferencedComponentEnumType (const ReferencedComponentEnumType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual ReferencedComponentEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ReferencedComponentEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ReferencedComponentEnumType_convert ();
      }

      protected:
      value
      _xsd_ReferencedComponentEnumType_convert () const;

      public:
      static const char* const _xsd_ReferencedComponentEnumType_literals_[2];
      static const value _xsd_ReferencedComponentEnumType_indexes_[2];
    };

    class RetrievalMethodEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        AVERAGE,
        MAXEXTREME,
        MINEXTREME,
        CLOSEST1D,
        CLOSEST2D,
        CLOSEST3D
      };

      RetrievalMethodEnumType (value v);

      RetrievalMethodEnumType (const char* v);

      RetrievalMethodEnumType (const ::std::string& v);

      RetrievalMethodEnumType (const ::xml_schema::nmtoken& v);

      RetrievalMethodEnumType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      RetrievalMethodEnumType (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      RetrievalMethodEnumType (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      RetrievalMethodEnumType (const RetrievalMethodEnumType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual RetrievalMethodEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RetrievalMethodEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_RetrievalMethodEnumType_convert ();
      }

      protected:
      value
      _xsd_RetrievalMethodEnumType_convert () const;

      public:
      static const char* const _xsd_RetrievalMethodEnumType_literals_[6];
      static const value _xsd_RetrievalMethodEnumType_indexes_[6];
    };

    class MeasurementDirectiveEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        MINIMUM,
        MAXIMUM,
        AVERAGE,
        UNDEFINED
      };

      MeasurementDirectiveEnumType (value v);

      MeasurementDirectiveEnumType (const char* v);

      MeasurementDirectiveEnumType (const ::std::string& v);

      MeasurementDirectiveEnumType (const ::xml_schema::nmtoken& v);

      MeasurementDirectiveEnumType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      MeasurementDirectiveEnumType (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      MeasurementDirectiveEnumType (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      MeasurementDirectiveEnumType (const MeasurementDirectiveEnumType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual MeasurementDirectiveEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasurementDirectiveEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_MeasurementDirectiveEnumType_convert ();
      }

      protected:
      value
      _xsd_MeasurementDirectiveEnumType_convert () const;

      public:
      static const char* const _xsd_MeasurementDirectiveEnumType_literals_[4];
      static const value _xsd_MeasurementDirectiveEnumType_indexes_[4];
    };

    class MeasurementDirectiveType: public ::xml_schema::type
    {
      public:
      // MeasurementDirectiveEnum
      //
      typedef ::xsd::qif2::MeasurementDirectiveEnumType MeasurementDirectiveEnum_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDirectiveEnum_type > MeasurementDirectiveEnum_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDirectiveEnum_type, char > MeasurementDirectiveEnum_traits;

      const MeasurementDirectiveEnum_optional&
      MeasurementDirectiveEnum () const;

      MeasurementDirectiveEnum_optional&
      MeasurementDirectiveEnum ();

      void
      MeasurementDirectiveEnum (const MeasurementDirectiveEnum_type& x);

      void
      MeasurementDirectiveEnum (const MeasurementDirectiveEnum_optional& x);

      void
      MeasurementDirectiveEnum (::std::auto_ptr< MeasurementDirectiveEnum_type > p);

      // OtherMeasurementDirective
      //
      typedef ::xml_schema::string OtherMeasurementDirective_type;
      typedef ::xsd::cxx::tree::optional< OtherMeasurementDirective_type > OtherMeasurementDirective_optional;
      typedef ::xsd::cxx::tree::traits< OtherMeasurementDirective_type, char > OtherMeasurementDirective_traits;

      const OtherMeasurementDirective_optional&
      OtherMeasurementDirective () const;

      OtherMeasurementDirective_optional&
      OtherMeasurementDirective ();

      void
      OtherMeasurementDirective (const OtherMeasurementDirective_type& x);

      void
      OtherMeasurementDirective (const OtherMeasurementDirective_optional& x);

      void
      OtherMeasurementDirective (::std::auto_ptr< OtherMeasurementDirective_type > p);

      // Constructors.
      //
      MeasurementDirectiveType ();

      MeasurementDirectiveType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      MeasurementDirectiveType (const MeasurementDirectiveType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual MeasurementDirectiveType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasurementDirectiveType&
      operator= (const MeasurementDirectiveType& x);

      virtual 
      ~MeasurementDirectiveType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      MeasurementDirectiveEnum_optional MeasurementDirectiveEnum_;
      OtherMeasurementDirective_optional OtherMeasurementDirective_;
    };

    class DistanceBetweenAnalysisModeEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        ONEDIMENSIONAL,
        TWODIMENSIONAL,
        THREEDIMENSIONAL
      };

      DistanceBetweenAnalysisModeEnumType (value v);

      DistanceBetweenAnalysisModeEnumType (const char* v);

      DistanceBetweenAnalysisModeEnumType (const ::std::string& v);

      DistanceBetweenAnalysisModeEnumType (const ::xml_schema::nmtoken& v);

      DistanceBetweenAnalysisModeEnumType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      DistanceBetweenAnalysisModeEnumType (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      DistanceBetweenAnalysisModeEnumType (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      DistanceBetweenAnalysisModeEnumType (const DistanceBetweenAnalysisModeEnumType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual DistanceBetweenAnalysisModeEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DistanceBetweenAnalysisModeEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_DistanceBetweenAnalysisModeEnumType_convert ();
      }

      protected:
      value
      _xsd_DistanceBetweenAnalysisModeEnumType_convert () const;

      public:
      static const char* const _xsd_DistanceBetweenAnalysisModeEnumType_literals_[3];
      static const value _xsd_DistanceBetweenAnalysisModeEnumType_indexes_[3];
    };

    class AngleBetweenAnalysisModeEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        TWODIMENSIONAL,
        THREEDIMENSIONAL
      };

      AngleBetweenAnalysisModeEnumType (value v);

      AngleBetweenAnalysisModeEnumType (const char* v);

      AngleBetweenAnalysisModeEnumType (const ::std::string& v);

      AngleBetweenAnalysisModeEnumType (const ::xml_schema::nmtoken& v);

      AngleBetweenAnalysisModeEnumType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      AngleBetweenAnalysisModeEnumType (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      AngleBetweenAnalysisModeEnumType (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      AngleBetweenAnalysisModeEnumType (const AngleBetweenAnalysisModeEnumType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual AngleBetweenAnalysisModeEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngleBetweenAnalysisModeEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_AngleBetweenAnalysisModeEnumType_convert ();
      }

      protected:
      value
      _xsd_AngleBetweenAnalysisModeEnumType_convert () const;

      public:
      static const char* const _xsd_AngleBetweenAnalysisModeEnumType_literals_[2];
      static const value _xsd_AngleBetweenAnalysisModeEnumType_indexes_[2];
    };

    class BaseFeatureType: public ::xml_schema::type
    {
      public:
      // ReferencedComponent
      //
      typedef ::xsd::qif2::ReferencedComponentEnumType ReferencedComponent_type;
      typedef ::xsd::cxx::tree::traits< ReferencedComponent_type, char > ReferencedComponent_traits;

      const ReferencedComponent_type&
      ReferencedComponent () const;

      ReferencedComponent_type&
      ReferencedComponent ();

      void
      ReferencedComponent (const ReferencedComponent_type& x);

      void
      ReferencedComponent (::std::auto_ptr< ReferencedComponent_type > p);

      // FeatureItemId
      //
      typedef ::xsd::qif2::QIFReferenceFullType FeatureItemId_type;
      typedef ::xsd::cxx::tree::traits< FeatureItemId_type, char > FeatureItemId_traits;

      const FeatureItemId_type&
      FeatureItemId () const;

      FeatureItemId_type&
      FeatureItemId ();

      void
      FeatureItemId (const FeatureItemId_type& x);

      void
      FeatureItemId (::std::auto_ptr< FeatureItemId_type > p);

      // Constructors.
      //
      BaseFeatureType (const ReferencedComponent_type&,
                       const FeatureItemId_type&);

      BaseFeatureType (const ReferencedComponent_type&,
                       ::std::auto_ptr< FeatureItemId_type >);

      BaseFeatureType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      BaseFeatureType (const BaseFeatureType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual BaseFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BaseFeatureType&
      operator= (const BaseFeatureType& x);

      virtual 
      ~BaseFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ReferencedComponent_type > ReferencedComponent_;
      ::xsd::cxx::tree::one< FeatureItemId_type > FeatureItemId_;
    };

    class SequencedBaseFeatureType: public ::xsd::qif2::BaseFeatureType
    {
      public:
      // SequenceNumber
      //
      typedef ::xml_schema::positive_integer SequenceNumber_type;
      typedef ::xsd::cxx::tree::traits< SequenceNumber_type, char > SequenceNumber_traits;

      const SequenceNumber_type&
      SequenceNumber () const;

      SequenceNumber_type&
      SequenceNumber ();

      void
      SequenceNumber (const SequenceNumber_type& x);

      // Constructors.
      //
      SequencedBaseFeatureType (const ReferencedComponent_type&,
                                const FeatureItemId_type&,
                                const SequenceNumber_type&);

      SequencedBaseFeatureType (const ReferencedComponent_type&,
                                ::std::auto_ptr< FeatureItemId_type >,
                                const SequenceNumber_type&);

      SequencedBaseFeatureType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      SequencedBaseFeatureType (const SequencedBaseFeatureType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual SequencedBaseFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SequencedBaseFeatureType&
      operator= (const SequencedBaseFeatureType& x);

      virtual 
      ~SequencedBaseFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SequenceNumber_type > SequenceNumber_;
    };

    class DirectionalOffsetType: public ::xml_schema::type
    {
      public:
      // Offset
      //
      typedef ::xsd::qif2::LinearValueType Offset_type;
      typedef ::xsd::cxx::tree::traits< Offset_type, char > Offset_traits;

      const Offset_type&
      Offset () const;

      Offset_type&
      Offset ();

      void
      Offset (const Offset_type& x);

      void
      Offset (::std::auto_ptr< Offset_type > p);

      // NominalDirection
      //
      typedef ::xsd::qif2::UnitVectorType NominalDirection_type;
      typedef ::xsd::cxx::tree::optional< NominalDirection_type > NominalDirection_optional;
      typedef ::xsd::cxx::tree::traits< NominalDirection_type, char > NominalDirection_traits;

      const NominalDirection_optional&
      NominalDirection () const;

      NominalDirection_optional&
      NominalDirection ();

      void
      NominalDirection (const NominalDirection_type& x);

      void
      NominalDirection (const NominalDirection_optional& x);

      void
      NominalDirection (::std::auto_ptr< NominalDirection_type > p);

      // FeatureDirection
      //
      typedef ::xsd::qif2::BaseFeatureType FeatureDirection_type;
      typedef ::xsd::cxx::tree::optional< FeatureDirection_type > FeatureDirection_optional;
      typedef ::xsd::cxx::tree::traits< FeatureDirection_type, char > FeatureDirection_traits;

      const FeatureDirection_optional&
      FeatureDirection () const;

      FeatureDirection_optional&
      FeatureDirection ();

      void
      FeatureDirection (const FeatureDirection_type& x);

      void
      FeatureDirection (const FeatureDirection_optional& x);

      void
      FeatureDirection (::std::auto_ptr< FeatureDirection_type > p);

      // Constructors.
      //
      DirectionalOffsetType (const Offset_type&);

      DirectionalOffsetType (::std::auto_ptr< Offset_type >);

      DirectionalOffsetType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      DirectionalOffsetType (const DirectionalOffsetType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual DirectionalOffsetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DirectionalOffsetType&
      operator= (const DirectionalOffsetType& x);

      virtual 
      ~DirectionalOffsetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Offset_type > Offset_;
      NominalDirection_optional NominalDirection_;
      FeatureDirection_optional FeatureDirection_;
    };

    class AlignmentFeatureType: public ::xml_schema::type
    {
      public:
      // DatumDefinitionId
      //
      typedef ::xsd::qif2::QIFReferenceFullType DatumDefinitionId_type;
      typedef ::xsd::cxx::tree::optional< DatumDefinitionId_type > DatumDefinitionId_optional;
      typedef ::xsd::cxx::tree::traits< DatumDefinitionId_type, char > DatumDefinitionId_traits;

      const DatumDefinitionId_optional&
      DatumDefinitionId () const;

      DatumDefinitionId_optional&
      DatumDefinitionId ();

      void
      DatumDefinitionId (const DatumDefinitionId_type& x);

      void
      DatumDefinitionId (const DatumDefinitionId_optional& x);

      void
      DatumDefinitionId (::std::auto_ptr< DatumDefinitionId_type > p);

      // BaseFeature
      //
      typedef ::xsd::qif2::BaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::optional< BaseFeature_type > BaseFeature_optional;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, char > BaseFeature_traits;

      const BaseFeature_optional&
      BaseFeature () const;

      BaseFeature_optional&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_type& x);

      void
      BaseFeature (const BaseFeature_optional& x);

      void
      BaseFeature (::std::auto_ptr< BaseFeature_type > p);

      // Constructors.
      //
      AlignmentFeatureType ();

      AlignmentFeatureType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      AlignmentFeatureType (const AlignmentFeatureType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual AlignmentFeatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AlignmentFeatureType&
      operator= (const AlignmentFeatureType& x);

      virtual 
      ~AlignmentFeatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      DatumDefinitionId_optional DatumDefinitionId_;
      BaseFeature_optional BaseFeature_;
    };

    class AlignmentOperationBaseType: public ::xml_schema::type
    {
      public:
      // SequenceNumber
      //
      typedef ::xml_schema::positive_integer SequenceNumber_type;
      typedef ::xsd::cxx::tree::traits< SequenceNumber_type, char > SequenceNumber_traits;

      const SequenceNumber_type&
      SequenceNumber () const;

      SequenceNumber_type&
      SequenceNumber ();

      void
      SequenceNumber (const SequenceNumber_type& x);

      // Constructors.
      //
      AlignmentOperationBaseType (const SequenceNumber_type&);

      AlignmentOperationBaseType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      AlignmentOperationBaseType (const AlignmentOperationBaseType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual AlignmentOperationBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AlignmentOperationBaseType&
      operator= (const AlignmentOperationBaseType& x);

      virtual 
      ~AlignmentOperationBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SequenceNumber_type > SequenceNumber_;
    };

    class PrimaryAlignmentOperationType: public ::xsd::qif2::AlignmentOperationBaseType
    {
      public:
      // PrimaryEntity
      //
      typedef ::xsd::qif2::AlignmentFeatureType PrimaryEntity_type;
      typedef ::xsd::cxx::tree::traits< PrimaryEntity_type, char > PrimaryEntity_traits;

      const PrimaryEntity_type&
      PrimaryEntity () const;

      PrimaryEntity_type&
      PrimaryEntity ();

      void
      PrimaryEntity (const PrimaryEntity_type& x);

      void
      PrimaryEntity (::std::auto_ptr< PrimaryEntity_type > p);

      // PrimaryAxis
      //
      typedef ::xsd::qif2::UnitVectorType PrimaryAxis_type;
      typedef ::xsd::cxx::tree::traits< PrimaryAxis_type, char > PrimaryAxis_traits;

      const PrimaryAxis_type&
      PrimaryAxis () const;

      PrimaryAxis_type&
      PrimaryAxis ();

      void
      PrimaryAxis (const PrimaryAxis_type& x);

      void
      PrimaryAxis (::std::auto_ptr< PrimaryAxis_type > p);

      // Constructors.
      //
      PrimaryAlignmentOperationType (const SequenceNumber_type&,
                                     const PrimaryEntity_type&,
                                     const PrimaryAxis_type&);

      PrimaryAlignmentOperationType (const SequenceNumber_type&,
                                     ::std::auto_ptr< PrimaryEntity_type >,
                                     ::std::auto_ptr< PrimaryAxis_type >);

      PrimaryAlignmentOperationType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      PrimaryAlignmentOperationType (const PrimaryAlignmentOperationType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual PrimaryAlignmentOperationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PrimaryAlignmentOperationType&
      operator= (const PrimaryAlignmentOperationType& x);

      virtual 
      ~PrimaryAlignmentOperationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< PrimaryEntity_type > PrimaryEntity_;
      ::xsd::cxx::tree::one< PrimaryAxis_type > PrimaryAxis_;
    };

    class SecondaryAlignmentOperationType: public ::xsd::qif2::AlignmentOperationBaseType
    {
      public:
      // SecondaryEntity
      //
      typedef ::xsd::qif2::AlignmentFeatureType SecondaryEntity_type;
      typedef ::xsd::cxx::tree::traits< SecondaryEntity_type, char > SecondaryEntity_traits;

      const SecondaryEntity_type&
      SecondaryEntity () const;

      SecondaryEntity_type&
      SecondaryEntity ();

      void
      SecondaryEntity (const SecondaryEntity_type& x);

      void
      SecondaryEntity (::std::auto_ptr< SecondaryEntity_type > p);

      // SecondaryAxis
      //
      typedef ::xsd::qif2::UnitVectorType SecondaryAxis_type;
      typedef ::xsd::cxx::tree::traits< SecondaryAxis_type, char > SecondaryAxis_traits;

      const SecondaryAxis_type&
      SecondaryAxis () const;

      SecondaryAxis_type&
      SecondaryAxis ();

      void
      SecondaryAxis (const SecondaryAxis_type& x);

      void
      SecondaryAxis (::std::auto_ptr< SecondaryAxis_type > p);

      // RotationAxis
      //
      typedef ::xsd::qif2::UnitVectorType RotationAxis_type;
      typedef ::xsd::cxx::tree::optional< RotationAxis_type > RotationAxis_optional;
      typedef ::xsd::cxx::tree::traits< RotationAxis_type, char > RotationAxis_traits;

      const RotationAxis_optional&
      RotationAxis () const;

      RotationAxis_optional&
      RotationAxis ();

      void
      RotationAxis (const RotationAxis_type& x);

      void
      RotationAxis (const RotationAxis_optional& x);

      void
      RotationAxis (::std::auto_ptr< RotationAxis_type > p);

      // Constructors.
      //
      SecondaryAlignmentOperationType (const SequenceNumber_type&,
                                       const SecondaryEntity_type&,
                                       const SecondaryAxis_type&);

      SecondaryAlignmentOperationType (const SequenceNumber_type&,
                                       ::std::auto_ptr< SecondaryEntity_type >,
                                       ::std::auto_ptr< SecondaryAxis_type >);

      SecondaryAlignmentOperationType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      SecondaryAlignmentOperationType (const SecondaryAlignmentOperationType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual SecondaryAlignmentOperationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SecondaryAlignmentOperationType&
      operator= (const SecondaryAlignmentOperationType& x);

      virtual 
      ~SecondaryAlignmentOperationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SecondaryEntity_type > SecondaryEntity_;
      ::xsd::cxx::tree::one< SecondaryAxis_type > SecondaryAxis_;
      RotationAxis_optional RotationAxis_;
    };

    class ActualOriginOffsetType: public ::xml_schema::type
    {
      public:
      // OriginEntity
      //
      typedef ::xsd::qif2::AlignmentFeatureType OriginEntity_type;
      typedef ::xsd::cxx::tree::traits< OriginEntity_type, char > OriginEntity_traits;

      const OriginEntity_type&
      OriginEntity () const;

      OriginEntity_type&
      OriginEntity ();

      void
      OriginEntity (const OriginEntity_type& x);

      void
      OriginEntity (::std::auto_ptr< OriginEntity_type > p);

      // OriginDirection
      //
      typedef ::xsd::qif2::UnitVectorType OriginDirection_type;
      typedef ::xsd::cxx::tree::traits< OriginDirection_type, char > OriginDirection_traits;

      const OriginDirection_type&
      OriginDirection () const;

      OriginDirection_type&
      OriginDirection ();

      void
      OriginDirection (const OriginDirection_type& x);

      void
      OriginDirection (::std::auto_ptr< OriginDirection_type > p);

      // Constructors.
      //
      ActualOriginOffsetType (const OriginEntity_type&,
                              const OriginDirection_type&);

      ActualOriginOffsetType (::std::auto_ptr< OriginEntity_type >,
                              ::std::auto_ptr< OriginDirection_type >);

      ActualOriginOffsetType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      ActualOriginOffsetType (const ActualOriginOffsetType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual ActualOriginOffsetType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ActualOriginOffsetType&
      operator= (const ActualOriginOffsetType& x);

      virtual 
      ~ActualOriginOffsetType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< OriginEntity_type > OriginEntity_;
      ::xsd::cxx::tree::one< OriginDirection_type > OriginDirection_;
    };

    class ActualOffsetAlignmentOperationType: public ::xsd::qif2::AlignmentOperationBaseType
    {
      public:
      // Origin
      //
      typedef ::xsd::qif2::ActualOriginOffsetType Origin_type;
      typedef ::xsd::cxx::tree::sequence< Origin_type > Origin_sequence;
      typedef Origin_sequence::iterator Origin_iterator;
      typedef Origin_sequence::const_iterator Origin_const_iterator;
      typedef ::xsd::cxx::tree::traits< Origin_type, char > Origin_traits;

      const Origin_sequence&
      Origin () const;

      Origin_sequence&
      Origin ();

      void
      Origin (const Origin_sequence& s);

      // Constructors.
      //
      ActualOffsetAlignmentOperationType (const SequenceNumber_type&);

      ActualOffsetAlignmentOperationType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      ActualOffsetAlignmentOperationType (const ActualOffsetAlignmentOperationType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual ActualOffsetAlignmentOperationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ActualOffsetAlignmentOperationType&
      operator= (const ActualOffsetAlignmentOperationType& x);

      virtual 
      ~ActualOffsetAlignmentOperationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Origin_sequence Origin_;
    };

    class NominalOffsetAlignmentOperationType: public ::xsd::qif2::AlignmentOperationBaseType
    {
      public:
      // Offset
      //
      typedef ::xsd::qif2::VectorType Offset_type;
      typedef ::xsd::cxx::tree::traits< Offset_type, char > Offset_traits;

      const Offset_type&
      Offset () const;

      Offset_type&
      Offset ();

      void
      Offset (const Offset_type& x);

      void
      Offset (::std::auto_ptr< Offset_type > p);

      // Constructors.
      //
      NominalOffsetAlignmentOperationType (const SequenceNumber_type&,
                                           const Offset_type&);

      NominalOffsetAlignmentOperationType (const SequenceNumber_type&,
                                           ::std::auto_ptr< Offset_type >);

      NominalOffsetAlignmentOperationType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      NominalOffsetAlignmentOperationType (const NominalOffsetAlignmentOperationType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual NominalOffsetAlignmentOperationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NominalOffsetAlignmentOperationType&
      operator= (const NominalOffsetAlignmentOperationType& x);

      virtual 
      ~NominalOffsetAlignmentOperationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Offset_type > Offset_;
    };

    class NominalRotationAlignmentOperationType: public ::xsd::qif2::AlignmentOperationBaseType
    {
      public:
      // RotationAxis
      //
      typedef ::xsd::qif2::UnitVectorType RotationAxis_type;
      typedef ::xsd::cxx::tree::traits< RotationAxis_type, char > RotationAxis_traits;

      const RotationAxis_type&
      RotationAxis () const;

      RotationAxis_type&
      RotationAxis ();

      void
      RotationAxis (const RotationAxis_type& x);

      void
      RotationAxis (::std::auto_ptr< RotationAxis_type > p);

      // Angle
      //
      typedef ::xsd::qif2::AngularValueType Angle_type;
      typedef ::xsd::cxx::tree::traits< Angle_type, char > Angle_traits;

      const Angle_type&
      Angle () const;

      Angle_type&
      Angle ();

      void
      Angle (const Angle_type& x);

      void
      Angle (::std::auto_ptr< Angle_type > p);

      // Constructors.
      //
      NominalRotationAlignmentOperationType (const SequenceNumber_type&,
                                             const RotationAxis_type&,
                                             const Angle_type&);

      NominalRotationAlignmentOperationType (const SequenceNumber_type&,
                                             ::std::auto_ptr< RotationAxis_type >,
                                             ::std::auto_ptr< Angle_type >);

      NominalRotationAlignmentOperationType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      NominalRotationAlignmentOperationType (const NominalRotationAlignmentOperationType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual NominalRotationAlignmentOperationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NominalRotationAlignmentOperationType&
      operator= (const NominalRotationAlignmentOperationType& x);

      virtual 
      ~NominalRotationAlignmentOperationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< RotationAxis_type > RotationAxis_;
      ::xsd::cxx::tree::one< Angle_type > Angle_;
    };

    class DatumPrecedenceAlignmentOperationType: public ::xsd::qif2::AlignmentOperationBaseType
    {
      public:
      // DatumReferenceFrameId
      //
      typedef ::xsd::qif2::QIFReferenceFullType DatumReferenceFrameId_type;
      typedef ::xsd::cxx::tree::traits< DatumReferenceFrameId_type, char > DatumReferenceFrameId_traits;

      const DatumReferenceFrameId_type&
      DatumReferenceFrameId () const;

      DatumReferenceFrameId_type&
      DatumReferenceFrameId ();

      void
      DatumReferenceFrameId (const DatumReferenceFrameId_type& x);

      void
      DatumReferenceFrameId (::std::auto_ptr< DatumReferenceFrameId_type > p);

      // PrimaryAxis
      //
      typedef ::xsd::qif2::UnitVectorType PrimaryAxis_type;
      typedef ::xsd::cxx::tree::traits< PrimaryAxis_type, char > PrimaryAxis_traits;

      const PrimaryAxis_type&
      PrimaryAxis () const;

      PrimaryAxis_type&
      PrimaryAxis ();

      void
      PrimaryAxis (const PrimaryAxis_type& x);

      void
      PrimaryAxis (::std::auto_ptr< PrimaryAxis_type > p);

      // SecondaryAxis
      //
      typedef ::xsd::qif2::UnitVectorType SecondaryAxis_type;
      typedef ::xsd::cxx::tree::optional< SecondaryAxis_type > SecondaryAxis_optional;
      typedef ::xsd::cxx::tree::traits< SecondaryAxis_type, char > SecondaryAxis_traits;

      const SecondaryAxis_optional&
      SecondaryAxis () const;

      SecondaryAxis_optional&
      SecondaryAxis ();

      void
      SecondaryAxis (const SecondaryAxis_type& x);

      void
      SecondaryAxis (const SecondaryAxis_optional& x);

      void
      SecondaryAxis (::std::auto_ptr< SecondaryAxis_type > p);

      // Constructors.
      //
      DatumPrecedenceAlignmentOperationType (const SequenceNumber_type&,
                                             const DatumReferenceFrameId_type&,
                                             const PrimaryAxis_type&);

      DatumPrecedenceAlignmentOperationType (const SequenceNumber_type&,
                                             ::std::auto_ptr< DatumReferenceFrameId_type >,
                                             ::std::auto_ptr< PrimaryAxis_type >);

      DatumPrecedenceAlignmentOperationType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      DatumPrecedenceAlignmentOperationType (const DatumPrecedenceAlignmentOperationType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual DatumPrecedenceAlignmentOperationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumPrecedenceAlignmentOperationType&
      operator= (const DatumPrecedenceAlignmentOperationType& x);

      virtual 
      ~DatumPrecedenceAlignmentOperationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DatumReferenceFrameId_type > DatumReferenceFrameId_;
      ::xsd::cxx::tree::one< PrimaryAxis_type > PrimaryAxis_;
      SecondaryAxis_optional SecondaryAxis_;
    };

    class BestFitAlignmentOperationType: public ::xsd::qif2::AlignmentOperationBaseType
    {
      public:
      // DegreesOfFreedom
      //
      typedef ::xsd::qif2::DegreesOfFreedomType DegreesOfFreedom_type;
      typedef ::xsd::cxx::tree::traits< DegreesOfFreedom_type, char > DegreesOfFreedom_traits;

      const DegreesOfFreedom_type&
      DegreesOfFreedom () const;

      DegreesOfFreedom_type&
      DegreesOfFreedom ();

      void
      DegreesOfFreedom (const DegreesOfFreedom_type& x);

      void
      DegreesOfFreedom (::std::auto_ptr< DegreesOfFreedom_type > p);

      // BaseFeature
      //
      typedef ::xsd::qif2::SequencedBaseFeatureType BaseFeature_type;
      typedef ::xsd::cxx::tree::sequence< BaseFeature_type > BaseFeature_sequence;
      typedef BaseFeature_sequence::iterator BaseFeature_iterator;
      typedef BaseFeature_sequence::const_iterator BaseFeature_const_iterator;
      typedef ::xsd::cxx::tree::traits< BaseFeature_type, char > BaseFeature_traits;

      const BaseFeature_sequence&
      BaseFeature () const;

      BaseFeature_sequence&
      BaseFeature ();

      void
      BaseFeature (const BaseFeature_sequence& s);

      // Constructors.
      //
      BestFitAlignmentOperationType (const SequenceNumber_type&,
                                     const DegreesOfFreedom_type&);

      BestFitAlignmentOperationType (const SequenceNumber_type&,
                                     ::std::auto_ptr< DegreesOfFreedom_type >);

      BestFitAlignmentOperationType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      BestFitAlignmentOperationType (const BestFitAlignmentOperationType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual BestFitAlignmentOperationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BestFitAlignmentOperationType&
      operator= (const BestFitAlignmentOperationType& x);

      virtual 
      ~BestFitAlignmentOperationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DegreesOfFreedom_type > DegreesOfFreedom_;
      BaseFeature_sequence BaseFeature_;
    };

    class MachineCoordinateSystemOperationType: public ::xsd::qif2::AlignmentOperationBaseType
    {
      public:
      // Constructors.
      //
      MachineCoordinateSystemOperationType (const SequenceNumber_type&);

      MachineCoordinateSystemOperationType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      MachineCoordinateSystemOperationType (const MachineCoordinateSystemOperationType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual MachineCoordinateSystemOperationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~MachineCoordinateSystemOperationType ();
    };

    class AlignmentOperationsType: public ::xml_schema::type
    {
      public:
      // AlignmentOperation
      //
      typedef ::xsd::qif2::AlignmentOperationBaseType AlignmentOperation_type;
      typedef ::xsd::cxx::tree::sequence< AlignmentOperation_type > AlignmentOperation_sequence;
      typedef AlignmentOperation_sequence::iterator AlignmentOperation_iterator;
      typedef AlignmentOperation_sequence::const_iterator AlignmentOperation_const_iterator;
      typedef ::xsd::cxx::tree::traits< AlignmentOperation_type, char > AlignmentOperation_traits;

      const AlignmentOperation_sequence&
      AlignmentOperation () const;

      AlignmentOperation_sequence&
      AlignmentOperation ();

      void
      AlignmentOperation (const AlignmentOperation_sequence& s);

      // BaseCoordinateSystemId
      //
      typedef ::xsd::qif2::QIFReferenceFullType BaseCoordinateSystemId_type;
      typedef ::xsd::cxx::tree::optional< BaseCoordinateSystemId_type > BaseCoordinateSystemId_optional;
      typedef ::xsd::cxx::tree::traits< BaseCoordinateSystemId_type, char > BaseCoordinateSystemId_traits;

      const BaseCoordinateSystemId_optional&
      BaseCoordinateSystemId () const;

      BaseCoordinateSystemId_optional&
      BaseCoordinateSystemId ();

      void
      BaseCoordinateSystemId (const BaseCoordinateSystemId_type& x);

      void
      BaseCoordinateSystemId (const BaseCoordinateSystemId_optional& x);

      void
      BaseCoordinateSystemId (::std::auto_ptr< BaseCoordinateSystemId_type > p);

      // Constructors.
      //
      AlignmentOperationsType ();

      AlignmentOperationsType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      AlignmentOperationsType (const AlignmentOperationsType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual AlignmentOperationsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AlignmentOperationsType&
      operator= (const AlignmentOperationsType& x);

      virtual 
      ~AlignmentOperationsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      AlignmentOperation_sequence AlignmentOperation_;
      BaseCoordinateSystemId_optional BaseCoordinateSystemId_;
    };

    class CoordinateSystemListType: public ::xml_schema::type
    {
      public:
      // CoordinateSystem
      //
      typedef ::xsd::qif2::CoordinateSystemType CoordinateSystem_type;
      typedef ::xsd::cxx::tree::sequence< CoordinateSystem_type > CoordinateSystem_sequence;
      typedef CoordinateSystem_sequence::iterator CoordinateSystem_iterator;
      typedef CoordinateSystem_sequence::const_iterator CoordinateSystem_const_iterator;
      typedef ::xsd::cxx::tree::traits< CoordinateSystem_type, char > CoordinateSystem_traits;

      const CoordinateSystem_sequence&
      CoordinateSystem () const;

      CoordinateSystem_sequence&
      CoordinateSystem ();

      void
      CoordinateSystem (const CoordinateSystem_sequence& s);

      // CommonCoordinateSystemId
      //
      typedef ::xsd::qif2::QIFReferenceFullType CommonCoordinateSystemId_type;
      typedef ::xsd::cxx::tree::optional< CommonCoordinateSystemId_type > CommonCoordinateSystemId_optional;
      typedef ::xsd::cxx::tree::traits< CommonCoordinateSystemId_type, char > CommonCoordinateSystemId_traits;

      const CommonCoordinateSystemId_optional&
      CommonCoordinateSystemId () const;

      CommonCoordinateSystemId_optional&
      CommonCoordinateSystemId ();

      void
      CommonCoordinateSystemId (const CommonCoordinateSystemId_type& x);

      void
      CommonCoordinateSystemId (const CommonCoordinateSystemId_optional& x);

      void
      CommonCoordinateSystemId (::std::auto_ptr< CommonCoordinateSystemId_type > p);

      // MachineCoordinateSystemId
      //
      typedef ::xsd::qif2::QIFReferenceFullType MachineCoordinateSystemId_type;
      typedef ::xsd::cxx::tree::optional< MachineCoordinateSystemId_type > MachineCoordinateSystemId_optional;
      typedef ::xsd::cxx::tree::traits< MachineCoordinateSystemId_type, char > MachineCoordinateSystemId_traits;

      const MachineCoordinateSystemId_optional&
      MachineCoordinateSystemId () const;

      MachineCoordinateSystemId_optional&
      MachineCoordinateSystemId ();

      void
      MachineCoordinateSystemId (const MachineCoordinateSystemId_type& x);

      void
      MachineCoordinateSystemId (const MachineCoordinateSystemId_optional& x);

      void
      MachineCoordinateSystemId (::std::auto_ptr< MachineCoordinateSystemId_type > p);

      // Constructors.
      //
      CoordinateSystemListType ();

      CoordinateSystemListType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      CoordinateSystemListType (const CoordinateSystemListType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual CoordinateSystemListType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CoordinateSystemListType&
      operator= (const CoordinateSystemListType& x);

      virtual 
      ~CoordinateSystemListType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      CoordinateSystem_sequence CoordinateSystem_;
      CommonCoordinateSystemId_optional CommonCoordinateSystemId_;
      MachineCoordinateSystemId_optional MachineCoordinateSystemId_;
    };

    class CoordinateSystemType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif2::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, char > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::auto_ptr< Attributes_type > p);

      // Name
      //
      typedef ::xml_schema::token Name_type;
      typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
      typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

      const Name_optional&
      Name () const;

      Name_optional&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (const Name_optional& x);

      void
      Name (::std::auto_ptr< Name_type > p);

      // NominalTransform
      //
      typedef ::xsd::qif2::TransformMatrixType NominalTransform_type;
      typedef ::xsd::cxx::tree::optional< NominalTransform_type > NominalTransform_optional;
      typedef ::xsd::cxx::tree::traits< NominalTransform_type, char > NominalTransform_traits;

      const NominalTransform_optional&
      NominalTransform () const;

      NominalTransform_optional&
      NominalTransform ();

      void
      NominalTransform (const NominalTransform_type& x);

      void
      NominalTransform (const NominalTransform_optional& x);

      void
      NominalTransform (::std::auto_ptr< NominalTransform_type > p);

      // InternalCADCoordinateSystemId
      //
      typedef ::xsd::qif2::QIFReferenceFullType InternalCADCoordinateSystemId_type;
      typedef ::xsd::cxx::tree::optional< InternalCADCoordinateSystemId_type > InternalCADCoordinateSystemId_optional;
      typedef ::xsd::cxx::tree::traits< InternalCADCoordinateSystemId_type, char > InternalCADCoordinateSystemId_traits;

      const InternalCADCoordinateSystemId_optional&
      InternalCADCoordinateSystemId () const;

      InternalCADCoordinateSystemId_optional&
      InternalCADCoordinateSystemId ();

      void
      InternalCADCoordinateSystemId (const InternalCADCoordinateSystemId_type& x);

      void
      InternalCADCoordinateSystemId (const InternalCADCoordinateSystemId_optional& x);

      void
      InternalCADCoordinateSystemId (::std::auto_ptr< InternalCADCoordinateSystemId_type > p);

      // ExternalCADCoordinateSystemId
      //
      typedef ::xsd::qif2::QIFReferenceFullType ExternalCADCoordinateSystemId_type;
      typedef ::xsd::cxx::tree::optional< ExternalCADCoordinateSystemId_type > ExternalCADCoordinateSystemId_optional;
      typedef ::xsd::cxx::tree::traits< ExternalCADCoordinateSystemId_type, char > ExternalCADCoordinateSystemId_traits;

      const ExternalCADCoordinateSystemId_optional&
      ExternalCADCoordinateSystemId () const;

      ExternalCADCoordinateSystemId_optional&
      ExternalCADCoordinateSystemId ();

      void
      ExternalCADCoordinateSystemId (const ExternalCADCoordinateSystemId_type& x);

      void
      ExternalCADCoordinateSystemId (const ExternalCADCoordinateSystemId_optional& x);

      void
      ExternalCADCoordinateSystemId (::std::auto_ptr< ExternalCADCoordinateSystemId_type > p);

      // AlignmentOperations
      //
      typedef ::xsd::qif2::AlignmentOperationsType AlignmentOperations_type;
      typedef ::xsd::cxx::tree::optional< AlignmentOperations_type > AlignmentOperations_optional;
      typedef ::xsd::cxx::tree::traits< AlignmentOperations_type, char > AlignmentOperations_traits;

      const AlignmentOperations_optional&
      AlignmentOperations () const;

      AlignmentOperations_optional&
      AlignmentOperations ();

      void
      AlignmentOperations (const AlignmentOperations_type& x);

      void
      AlignmentOperations (const AlignmentOperations_optional& x);

      void
      AlignmentOperations (::std::auto_ptr< AlignmentOperations_type > p);

      // SequenceNumber
      //
      typedef ::xml_schema::positive_integer SequenceNumber_type;
      typedef ::xsd::cxx::tree::optional< SequenceNumber_type > SequenceNumber_optional;
      typedef ::xsd::cxx::tree::traits< SequenceNumber_type, char > SequenceNumber_traits;

      const SequenceNumber_optional&
      SequenceNumber () const;

      SequenceNumber_optional&
      SequenceNumber ();

      void
      SequenceNumber (const SequenceNumber_type& x);

      void
      SequenceNumber (const SequenceNumber_optional& x);

      // id
      //
      typedef ::xsd::qif2::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::auto_ptr< id_type > p);

      // Constructors.
      //
      CoordinateSystemType (const id_type&);

      CoordinateSystemType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      CoordinateSystemType (const CoordinateSystemType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual CoordinateSystemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CoordinateSystemType&
      operator= (const CoordinateSystemType& x);

      virtual 
      ~CoordinateSystemType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      Name_optional Name_;
      NominalTransform_optional NominalTransform_;
      InternalCADCoordinateSystemId_optional InternalCADCoordinateSystemId_;
      ExternalCADCoordinateSystemId_optional ExternalCADCoordinateSystemId_;
      AlignmentOperations_optional AlignmentOperations_;
      SequenceNumber_optional SequenceNumber_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class CoordinateSystemActualTransformType: public ::xml_schema::type
    {
      public:
      // ActualTransform
      //
      typedef ::xsd::qif2::TransformMatrixType ActualTransform_type;
      typedef ::xsd::cxx::tree::traits< ActualTransform_type, char > ActualTransform_traits;

      const ActualTransform_type&
      ActualTransform () const;

      ActualTransform_type&
      ActualTransform ();

      void
      ActualTransform (const ActualTransform_type& x);

      void
      ActualTransform (::std::auto_ptr< ActualTransform_type > p);

      // CoordinateSystemId
      //
      typedef ::xsd::qif2::QIFReferenceFullType CoordinateSystemId_type;
      typedef ::xsd::cxx::tree::traits< CoordinateSystemId_type, char > CoordinateSystemId_traits;

      const CoordinateSystemId_type&
      CoordinateSystemId () const;

      CoordinateSystemId_type&
      CoordinateSystemId ();

      void
      CoordinateSystemId (const CoordinateSystemId_type& x);

      void
      CoordinateSystemId (::std::auto_ptr< CoordinateSystemId_type > p);

      // Constructors.
      //
      CoordinateSystemActualTransformType (const ActualTransform_type&,
                                           const CoordinateSystemId_type&);

      CoordinateSystemActualTransformType (::std::auto_ptr< ActualTransform_type >,
                                           ::std::auto_ptr< CoordinateSystemId_type >);

      CoordinateSystemActualTransformType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      CoordinateSystemActualTransformType (const CoordinateSystemActualTransformType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual CoordinateSystemActualTransformType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CoordinateSystemActualTransformType&
      operator= (const CoordinateSystemActualTransformType& x);

      virtual 
      ~CoordinateSystemActualTransformType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ActualTransform_type > ActualTransform_;
      ::xsd::cxx::tree::one< CoordinateSystemId_type > CoordinateSystemId_;
    };

    class CoordinateSystemActualTransformsType: public ::xml_schema::type
    {
      public:
      // Transform
      //
      typedef ::xsd::qif2::CoordinateSystemActualTransformType Transform_type;
      typedef ::xsd::cxx::tree::sequence< Transform_type > Transform_sequence;
      typedef Transform_sequence::iterator Transform_iterator;
      typedef Transform_sequence::const_iterator Transform_const_iterator;
      typedef ::xsd::cxx::tree::traits< Transform_type, char > Transform_traits;

      const Transform_sequence&
      Transform () const;

      Transform_sequence&
      Transform ();

      void
      Transform (const Transform_sequence& s);

      // Constructors.
      //
      CoordinateSystemActualTransformsType ();

      CoordinateSystemActualTransformsType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      CoordinateSystemActualTransformsType (const CoordinateSystemActualTransformsType& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

      virtual CoordinateSystemActualTransformsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CoordinateSystemActualTransformsType&
      operator= (const CoordinateSystemActualTransformsType& x);

      virtual 
      ~CoordinateSystemActualTransformsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Transform_sequence Transform_;
    };

    class ThreadSpecificationDetailedBaseType: public ::xml_schema::type
    {
      public:
      // Diameter
      //
      typedef ::xsd::qif2::LinearValueType Diameter_type;
      typedef ::xsd::cxx::tree::traits< Diameter_type, char > Diameter_traits;

      const Diameter_type&
      Diameter () const;

      Diameter_type&
      Diameter ();

      void
      Diameter (const Diameter_type& x);

      void
      Diameter (::std::auto_ptr< Diameter_type > p);

      // ThreadSeries
      //
      typedef ::xsd::qif2::ThreadSeriesType ThreadSeries_type;
      typedef ::xsd::cxx::tree::traits< ThreadSeries_type, char > ThreadSeries_traits;

      const ThreadSeries_type&
      ThreadSeries () const;

      ThreadSeries_type&
      ThreadSeries ();

      void
      ThreadSeries (const ThreadSeries_type& x);

      void
      ThreadSeries (::std::auto_ptr< ThreadSeries_type > p);

      // ThreadToleranceClass
      //
      typedef ::xsd::qif2::ThreadClassType ThreadToleranceClass_type;
      typedef ::xsd::cxx::tree::traits< ThreadToleranceClass_type, char > ThreadToleranceClass_traits;

      const ThreadToleranceClass_type&
      ThreadToleranceClass () const;

      ThreadToleranceClass_type&
      ThreadToleranceClass ();

      void
      ThreadToleranceClass (const ThreadToleranceClass_type& x);

      void
      ThreadToleranceClass (::std::auto_ptr< ThreadToleranceClass_type > p);

      // CrestDiameterToleranceClass
      //
      typedef ::xsd::qif2::ThreadClassType CrestDiameterToleranceClass_type;
      typedef ::xsd::cxx::tree::optional< CrestDiameterToleranceClass_type > CrestDiameterToleranceClass_optional;
      typedef ::xsd::cxx::tree::traits< CrestDiameterToleranceClass_type, char > CrestDiameterToleranceClass_traits;

      const CrestDiameterToleranceClass_optional&
      CrestDiameterToleranceClass () const;

      CrestDiameterToleranceClass_optional&
      CrestDiameterToleranceClass ();

      void
      CrestDiameterToleranceClass (const CrestDiameterToleranceClass_type& x);

      void
      CrestDiameterToleranceClass (const CrestDiameterToleranceClass_optional& x);

      void
      CrestDiameterToleranceClass (::std::auto_ptr< CrestDiameterToleranceClass_type > p);

      // LeftHanded
      //
      typedef ::xml_schema::boolean LeftHanded_type;
      typedef ::xsd::cxx::tree::optional< LeftHanded_type > LeftHanded_optional;
      typedef ::xsd::cxx::tree::traits< LeftHanded_type, char > LeftHanded_traits;

      const LeftHanded_optional&
      LeftHanded () const;

      LeftHanded_optional&
      LeftHanded ();

      void
      LeftHanded (const LeftHanded_type& x);

      void
      LeftHanded (const LeftHanded_optional& x);

      // ModifiedThread
      //
      typedef ::xml_schema::boolean ModifiedThread_type;
      typedef ::xsd::cxx::tree::optional< ModifiedThread_type > ModifiedThread_optional;
      typedef ::xsd::cxx::tree::traits< ModifiedThread_type, char > ModifiedThread_traits;

      const ModifiedThread_optional&
      ModifiedThread () const;

      ModifiedThread_optional&
      ModifiedThread ();

      void
      ModifiedThread (const ModifiedThread_type& x);

      void
      ModifiedThread (const ModifiedThread_optional& x);

      // ThreadLengthEngagement
      //
      typedef ::xsd::qif2::LinearValueType ThreadLengthEngagement_type;
      typedef ::xsd::cxx::tree::optional< ThreadLengthEngagement_type > ThreadLengthEngagement_optional;
      typedef ::xsd::cxx::tree::traits< ThreadLengthEngagement_type, char > ThreadLengthEngagement_traits;

      const ThreadLengthEngagement_optional&
      ThreadLengthEngagement () const;

      ThreadLengthEngagement_optional&
      ThreadLengthEngagement ();

      void
      ThreadLengthEngagement (const ThreadLengthEngagement_type& x);

      void
      ThreadLengthEngagement (const ThreadLengthEngagement_optional& x);

      void
      ThreadLengthEngagement (::std::auto_ptr< ThreadLengthEngagement_type > p);

      // id
      //
      typedef ::xsd::qif2::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::auto_ptr< id_type > p);

      // Constructors.
      //
      ThreadSpecificationDetailedBaseType (const Diameter_type&,
                                           const ThreadSeries_type&,
                                           const ThreadToleranceClass_type&,
                                           const id_type&);

      ThreadSpecificationDetailedBaseType (::std::auto_ptr< Diameter_type >,
                                           ::std::auto_ptr< ThreadSeries_type >,
                                           ::std::auto_ptr< ThreadToleranceClass_type >,
                                           const id_type&);

      ThreadSpecificationDetailedBaseType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      ThreadSpecificationDetailedBaseType (const ThreadSpecificationDetailedBaseType& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual ThreadSpecificationDetailedBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThreadSpecificationDetailedBaseType&
      operator= (const ThreadSpecificationDetailedBaseType& x);

      virtual 
      ~ThreadSpecificationDetailedBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Diameter_type > Diameter_;
      ::xsd::cxx::tree::one< ThreadSeries_type > ThreadSeries_;
      ::xsd::cxx::tree::one< ThreadToleranceClass_type > ThreadToleranceClass_;
      CrestDiameterToleranceClass_optional CrestDiameterToleranceClass_;
      LeftHanded_optional LeftHanded_;
      ModifiedThread_optional ModifiedThread_;
      ThreadLengthEngagement_optional ThreadLengthEngagement_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class SingleLeadThreadSpecificationType: public ::xsd::qif2::ThreadSpecificationDetailedBaseType
    {
      public:
      // ThreadDensity
      //
      typedef ::xsd::qif2::LinearValueType ThreadDensity_type;
      typedef ::xsd::cxx::tree::traits< ThreadDensity_type, char > ThreadDensity_traits;

      const ThreadDensity_type&
      ThreadDensity () const;

      ThreadDensity_type&
      ThreadDensity ();

      void
      ThreadDensity (const ThreadDensity_type& x);

      void
      ThreadDensity (::std::auto_ptr< ThreadDensity_type > p);

      // Constructors.
      //
      SingleLeadThreadSpecificationType (const Diameter_type&,
                                         const ThreadSeries_type&,
                                         const ThreadToleranceClass_type&,
                                         const id_type&,
                                         const ThreadDensity_type&);

      SingleLeadThreadSpecificationType (::std::auto_ptr< Diameter_type >,
                                         ::std::auto_ptr< ThreadSeries_type >,
                                         ::std::auto_ptr< ThreadToleranceClass_type >,
                                         const id_type&,
                                         ::std::auto_ptr< ThreadDensity_type >);

      SingleLeadThreadSpecificationType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      SingleLeadThreadSpecificationType (const SingleLeadThreadSpecificationType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual SingleLeadThreadSpecificationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SingleLeadThreadSpecificationType&
      operator= (const SingleLeadThreadSpecificationType& x);

      virtual 
      ~SingleLeadThreadSpecificationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ThreadDensity_type > ThreadDensity_;
    };

    class MultiLeadThreadSpecificationType: public ::xsd::qif2::ThreadSpecificationDetailedBaseType
    {
      public:
      // ThreadPitch
      //
      typedef ::xsd::qif2::LinearValueType ThreadPitch_type;
      typedef ::xsd::cxx::tree::traits< ThreadPitch_type, char > ThreadPitch_traits;

      const ThreadPitch_type&
      ThreadPitch () const;

      ThreadPitch_type&
      ThreadPitch ();

      void
      ThreadPitch (const ThreadPitch_type& x);

      void
      ThreadPitch (::std::auto_ptr< ThreadPitch_type > p);

      // ThreadLeadDistance
      //
      typedef ::xsd::qif2::LinearValueType ThreadLeadDistance_type;
      typedef ::xsd::cxx::tree::traits< ThreadLeadDistance_type, char > ThreadLeadDistance_traits;

      const ThreadLeadDistance_type&
      ThreadLeadDistance () const;

      ThreadLeadDistance_type&
      ThreadLeadDistance ();

      void
      ThreadLeadDistance (const ThreadLeadDistance_type& x);

      void
      ThreadLeadDistance (::std::auto_ptr< ThreadLeadDistance_type > p);

      // ThreadLeadStarts
      //
      typedef ::xml_schema::positive_integer ThreadLeadStarts_type;
      typedef ::xsd::cxx::tree::traits< ThreadLeadStarts_type, char > ThreadLeadStarts_traits;

      const ThreadLeadStarts_type&
      ThreadLeadStarts () const;

      ThreadLeadStarts_type&
      ThreadLeadStarts ();

      void
      ThreadLeadStarts (const ThreadLeadStarts_type& x);

      // Constructors.
      //
      MultiLeadThreadSpecificationType (const Diameter_type&,
                                        const ThreadSeries_type&,
                                        const ThreadToleranceClass_type&,
                                        const id_type&,
                                        const ThreadPitch_type&,
                                        const ThreadLeadDistance_type&,
                                        const ThreadLeadStarts_type&);

      MultiLeadThreadSpecificationType (::std::auto_ptr< Diameter_type >,
                                        ::std::auto_ptr< ThreadSeries_type >,
                                        ::std::auto_ptr< ThreadToleranceClass_type >,
                                        const id_type&,
                                        ::std::auto_ptr< ThreadPitch_type >,
                                        ::std::auto_ptr< ThreadLeadDistance_type >,
                                        const ThreadLeadStarts_type&);

      MultiLeadThreadSpecificationType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      MultiLeadThreadSpecificationType (const MultiLeadThreadSpecificationType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual MultiLeadThreadSpecificationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MultiLeadThreadSpecificationType&
      operator= (const MultiLeadThreadSpecificationType& x);

      virtual 
      ~MultiLeadThreadSpecificationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ThreadPitch_type > ThreadPitch_;
      ::xsd::cxx::tree::one< ThreadLeadDistance_type > ThreadLeadDistance_;
      ::xsd::cxx::tree::one< ThreadLeadStarts_type > ThreadLeadStarts_;
    };

    class ThreadSpecificationType: public ::xml_schema::type
    {
      public:
      // SingleLeadSpecification
      //
      typedef ::xsd::qif2::SingleLeadThreadSpecificationType SingleLeadSpecification_type;
      typedef ::xsd::cxx::tree::optional< SingleLeadSpecification_type > SingleLeadSpecification_optional;
      typedef ::xsd::cxx::tree::traits< SingleLeadSpecification_type, char > SingleLeadSpecification_traits;

      const SingleLeadSpecification_optional&
      SingleLeadSpecification () const;

      SingleLeadSpecification_optional&
      SingleLeadSpecification ();

      void
      SingleLeadSpecification (const SingleLeadSpecification_type& x);

      void
      SingleLeadSpecification (const SingleLeadSpecification_optional& x);

      void
      SingleLeadSpecification (::std::auto_ptr< SingleLeadSpecification_type > p);

      // MultiLeadSpecification
      //
      typedef ::xsd::qif2::MultiLeadThreadSpecificationType MultiLeadSpecification_type;
      typedef ::xsd::cxx::tree::optional< MultiLeadSpecification_type > MultiLeadSpecification_optional;
      typedef ::xsd::cxx::tree::traits< MultiLeadSpecification_type, char > MultiLeadSpecification_traits;

      const MultiLeadSpecification_optional&
      MultiLeadSpecification () const;

      MultiLeadSpecification_optional&
      MultiLeadSpecification ();

      void
      MultiLeadSpecification (const MultiLeadSpecification_type& x);

      void
      MultiLeadSpecification (const MultiLeadSpecification_optional& x);

      void
      MultiLeadSpecification (::std::auto_ptr< MultiLeadSpecification_type > p);

      // TextThreadSpecification
      //
      typedef ::xsd::qif2::TextThreadSpecificationType TextThreadSpecification_type;
      typedef ::xsd::cxx::tree::optional< TextThreadSpecification_type > TextThreadSpecification_optional;
      typedef ::xsd::cxx::tree::traits< TextThreadSpecification_type, char > TextThreadSpecification_traits;

      const TextThreadSpecification_optional&
      TextThreadSpecification () const;

      TextThreadSpecification_optional&
      TextThreadSpecification ();

      void
      TextThreadSpecification (const TextThreadSpecification_type& x);

      void
      TextThreadSpecification (const TextThreadSpecification_optional& x);

      void
      TextThreadSpecification (::std::auto_ptr< TextThreadSpecification_type > p);

      // Constructors.
      //
      ThreadSpecificationType ();

      ThreadSpecificationType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      ThreadSpecificationType (const ThreadSpecificationType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual ThreadSpecificationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThreadSpecificationType&
      operator= (const ThreadSpecificationType& x);

      virtual 
      ~ThreadSpecificationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      SingleLeadSpecification_optional SingleLeadSpecification_;
      MultiLeadSpecification_optional MultiLeadSpecification_;
      TextThreadSpecification_optional TextThreadSpecification_;
    };

    class TextThreadSpecificationType: public ::xml_schema::type
    {
      public:
      // TextSpecification
      //
      typedef ::xml_schema::string TextSpecification_type;
      typedef ::xsd::cxx::tree::traits< TextSpecification_type, char > TextSpecification_traits;

      const TextSpecification_type&
      TextSpecification () const;

      TextSpecification_type&
      TextSpecification ();

      void
      TextSpecification (const TextSpecification_type& x);

      void
      TextSpecification (::std::auto_ptr< TextSpecification_type > p);

      // id
      //
      typedef ::xsd::qif2::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::auto_ptr< id_type > p);

      // Constructors.
      //
      TextThreadSpecificationType (const TextSpecification_type&,
                                   const id_type&);

      TextThreadSpecificationType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      TextThreadSpecificationType (const TextThreadSpecificationType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual TextThreadSpecificationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TextThreadSpecificationType&
      operator= (const TextThreadSpecificationType& x);

      virtual 
      ~TextThreadSpecificationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< TextSpecification_type > TextSpecification_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class ThreadSpecificationsType: public ::xml_schema::type
    {
      public:
      // ThreadSpecification
      //
      typedef ::xsd::qif2::ThreadSpecificationType ThreadSpecification_type;
      typedef ::xsd::cxx::tree::sequence< ThreadSpecification_type > ThreadSpecification_sequence;
      typedef ThreadSpecification_sequence::iterator ThreadSpecification_iterator;
      typedef ThreadSpecification_sequence::const_iterator ThreadSpecification_const_iterator;
      typedef ::xsd::cxx::tree::traits< ThreadSpecification_type, char > ThreadSpecification_traits;

      const ThreadSpecification_sequence&
      ThreadSpecification () const;

      ThreadSpecification_sequence&
      ThreadSpecification ();

      void
      ThreadSpecification (const ThreadSpecification_sequence& s);

      // Constructors.
      //
      ThreadSpecificationsType ();

      ThreadSpecificationsType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      ThreadSpecificationsType (const ThreadSpecificationsType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual ThreadSpecificationsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThreadSpecificationsType&
      operator= (const ThreadSpecificationsType& x);

      virtual 
      ~ThreadSpecificationsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThreadSpecification_sequence ThreadSpecification_;
    };

    class ToleranceZonePerUnitAreaType: public ::xml_schema::type
    {
      public:
      // ToleranceValuePerUnit
      //
      typedef ::xsd::qif2::LinearValueType ToleranceValuePerUnit_type;
      typedef ::xsd::cxx::tree::traits< ToleranceValuePerUnit_type, char > ToleranceValuePerUnit_traits;

      const ToleranceValuePerUnit_type&
      ToleranceValuePerUnit () const;

      ToleranceValuePerUnit_type&
      ToleranceValuePerUnit ();

      void
      ToleranceValuePerUnit (const ToleranceValuePerUnit_type& x);

      void
      ToleranceValuePerUnit (::std::auto_ptr< ToleranceValuePerUnit_type > p);

      // RectangularUnitArea
      //
      typedef ::xsd::qif2::RectangularUnitAreaType RectangularUnitArea_type;
      typedef ::xsd::cxx::tree::optional< RectangularUnitArea_type > RectangularUnitArea_optional;
      typedef ::xsd::cxx::tree::traits< RectangularUnitArea_type, char > RectangularUnitArea_traits;

      const RectangularUnitArea_optional&
      RectangularUnitArea () const;

      RectangularUnitArea_optional&
      RectangularUnitArea ();

      void
      RectangularUnitArea (const RectangularUnitArea_type& x);

      void
      RectangularUnitArea (const RectangularUnitArea_optional& x);

      void
      RectangularUnitArea (::std::auto_ptr< RectangularUnitArea_type > p);

      // CircularUnitArea
      //
      typedef ::xsd::qif2::CircularUnitAreaType CircularUnitArea_type;
      typedef ::xsd::cxx::tree::optional< CircularUnitArea_type > CircularUnitArea_optional;
      typedef ::xsd::cxx::tree::traits< CircularUnitArea_type, char > CircularUnitArea_traits;

      const CircularUnitArea_optional&
      CircularUnitArea () const;

      CircularUnitArea_optional&
      CircularUnitArea ();

      void
      CircularUnitArea (const CircularUnitArea_type& x);

      void
      CircularUnitArea (const CircularUnitArea_optional& x);

      void
      CircularUnitArea (::std::auto_ptr< CircularUnitArea_type > p);

      // Constructors.
      //
      ToleranceZonePerUnitAreaType (const ToleranceValuePerUnit_type&);

      ToleranceZonePerUnitAreaType (::std::auto_ptr< ToleranceValuePerUnit_type >);

      ToleranceZonePerUnitAreaType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      ToleranceZonePerUnitAreaType (const ToleranceZonePerUnitAreaType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual ToleranceZonePerUnitAreaType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToleranceZonePerUnitAreaType&
      operator= (const ToleranceZonePerUnitAreaType& x);

      virtual 
      ~ToleranceZonePerUnitAreaType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ToleranceValuePerUnit_type > ToleranceValuePerUnit_;
      RectangularUnitArea_optional RectangularUnitArea_;
      CircularUnitArea_optional CircularUnitArea_;
    };

    class ToleranceZonePerUnitLengthType: public ::xml_schema::type
    {
      public:
      // ToleranceValuePerUnit
      //
      typedef ::xsd::qif2::LinearValueType ToleranceValuePerUnit_type;
      typedef ::xsd::cxx::tree::traits< ToleranceValuePerUnit_type, char > ToleranceValuePerUnit_traits;

      const ToleranceValuePerUnit_type&
      ToleranceValuePerUnit () const;

      ToleranceValuePerUnit_type&
      ToleranceValuePerUnit ();

      void
      ToleranceValuePerUnit (const ToleranceValuePerUnit_type& x);

      void
      ToleranceValuePerUnit (::std::auto_ptr< ToleranceValuePerUnit_type > p);

      // UnitLength
      //
      typedef ::xsd::qif2::LinearValueType UnitLength_type;
      typedef ::xsd::cxx::tree::traits< UnitLength_type, char > UnitLength_traits;

      const UnitLength_type&
      UnitLength () const;

      UnitLength_type&
      UnitLength ();

      void
      UnitLength (const UnitLength_type& x);

      void
      UnitLength (::std::auto_ptr< UnitLength_type > p);

      // Constructors.
      //
      ToleranceZonePerUnitLengthType (const ToleranceValuePerUnit_type&,
                                      const UnitLength_type&);

      ToleranceZonePerUnitLengthType (::std::auto_ptr< ToleranceValuePerUnit_type >,
                                      ::std::auto_ptr< UnitLength_type >);

      ToleranceZonePerUnitLengthType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      ToleranceZonePerUnitLengthType (const ToleranceZonePerUnitLengthType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual ToleranceZonePerUnitLengthType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToleranceZonePerUnitLengthType&
      operator= (const ToleranceZonePerUnitLengthType& x);

      virtual 
      ~ToleranceZonePerUnitLengthType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ToleranceValuePerUnit_type > ToleranceValuePerUnit_;
      ::xsd::cxx::tree::one< UnitLength_type > UnitLength_;
    };

    class ToleranceZonePerUnitAngleType: public ::xml_schema::type
    {
      public:
      // ToleranceValuePerUnit
      //
      typedef ::xsd::qif2::LinearValueType ToleranceValuePerUnit_type;
      typedef ::xsd::cxx::tree::traits< ToleranceValuePerUnit_type, char > ToleranceValuePerUnit_traits;

      const ToleranceValuePerUnit_type&
      ToleranceValuePerUnit () const;

      ToleranceValuePerUnit_type&
      ToleranceValuePerUnit ();

      void
      ToleranceValuePerUnit (const ToleranceValuePerUnit_type& x);

      void
      ToleranceValuePerUnit (::std::auto_ptr< ToleranceValuePerUnit_type > p);

      // UnitAngle
      //
      typedef ::xsd::qif2::AngularValueType UnitAngle_type;
      typedef ::xsd::cxx::tree::traits< UnitAngle_type, char > UnitAngle_traits;

      const UnitAngle_type&
      UnitAngle () const;

      UnitAngle_type&
      UnitAngle ();

      void
      UnitAngle (const UnitAngle_type& x);

      void
      UnitAngle (::std::auto_ptr< UnitAngle_type > p);

      // Constructors.
      //
      ToleranceZonePerUnitAngleType (const ToleranceValuePerUnit_type&,
                                     const UnitAngle_type&);

      ToleranceZonePerUnitAngleType (::std::auto_ptr< ToleranceValuePerUnit_type >,
                                     ::std::auto_ptr< UnitAngle_type >);

      ToleranceZonePerUnitAngleType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      ToleranceZonePerUnitAngleType (const ToleranceZonePerUnitAngleType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual ToleranceZonePerUnitAngleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToleranceZonePerUnitAngleType&
      operator= (const ToleranceZonePerUnitAngleType& x);

      virtual 
      ~ToleranceZonePerUnitAngleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ToleranceValuePerUnit_type > ToleranceValuePerUnit_;
      ::xsd::cxx::tree::one< UnitAngle_type > UnitAngle_;
    };

    class ToleranceZonePerUnitPolarAreaType: public ::xml_schema::type
    {
      public:
      // ToleranceValuePerUnit
      //
      typedef ::xsd::qif2::LinearValueType ToleranceValuePerUnit_type;
      typedef ::xsd::cxx::tree::traits< ToleranceValuePerUnit_type, char > ToleranceValuePerUnit_traits;

      const ToleranceValuePerUnit_type&
      ToleranceValuePerUnit () const;

      ToleranceValuePerUnit_type&
      ToleranceValuePerUnit ();

      void
      ToleranceValuePerUnit (const ToleranceValuePerUnit_type& x);

      void
      ToleranceValuePerUnit (::std::auto_ptr< ToleranceValuePerUnit_type > p);

      // UnitAngle
      //
      typedef ::xsd::qif2::AngularValueType UnitAngle_type;
      typedef ::xsd::cxx::tree::traits< UnitAngle_type, char > UnitAngle_traits;

      const UnitAngle_type&
      UnitAngle () const;

      UnitAngle_type&
      UnitAngle ();

      void
      UnitAngle (const UnitAngle_type& x);

      void
      UnitAngle (::std::auto_ptr< UnitAngle_type > p);

      // UnitLength
      //
      typedef ::xsd::qif2::LinearValueType UnitLength_type;
      typedef ::xsd::cxx::tree::traits< UnitLength_type, char > UnitLength_traits;

      const UnitLength_type&
      UnitLength () const;

      UnitLength_type&
      UnitLength ();

      void
      UnitLength (const UnitLength_type& x);

      void
      UnitLength (::std::auto_ptr< UnitLength_type > p);

      // Constructors.
      //
      ToleranceZonePerUnitPolarAreaType (const ToleranceValuePerUnit_type&,
                                         const UnitAngle_type&,
                                         const UnitLength_type&);

      ToleranceZonePerUnitPolarAreaType (::std::auto_ptr< ToleranceValuePerUnit_type >,
                                         ::std::auto_ptr< UnitAngle_type >,
                                         ::std::auto_ptr< UnitLength_type >);

      ToleranceZonePerUnitPolarAreaType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      ToleranceZonePerUnitPolarAreaType (const ToleranceZonePerUnitPolarAreaType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual ToleranceZonePerUnitPolarAreaType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToleranceZonePerUnitPolarAreaType&
      operator= (const ToleranceZonePerUnitPolarAreaType& x);

      virtual 
      ~ToleranceZonePerUnitPolarAreaType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ToleranceValuePerUnit_type > ToleranceValuePerUnit_;
      ::xsd::cxx::tree::one< UnitAngle_type > UnitAngle_;
      ::xsd::cxx::tree::one< UnitLength_type > UnitLength_;
    };

    class CompoundFeatureGeometryEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        COAXIAL,
        COPLANAR,
        COCENTERED
      };

      CompoundFeatureGeometryEnumType (value v);

      CompoundFeatureGeometryEnumType (const char* v);

      CompoundFeatureGeometryEnumType (const ::std::string& v);

      CompoundFeatureGeometryEnumType (const ::xml_schema::nmtoken& v);

      CompoundFeatureGeometryEnumType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      CompoundFeatureGeometryEnumType (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      CompoundFeatureGeometryEnumType (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      CompoundFeatureGeometryEnumType (const CompoundFeatureGeometryEnumType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual CompoundFeatureGeometryEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CompoundFeatureGeometryEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_CompoundFeatureGeometryEnumType_convert ();
      }

      protected:
      value
      _xsd_CompoundFeatureGeometryEnumType_convert () const;

      public:
      static const char* const _xsd_CompoundFeatureGeometryEnumType_literals_[3];
      static const value _xsd_CompoundFeatureGeometryEnumType_indexes_[3];
    };

    class DatumReferenceFramesType: public ::xml_schema::type
    {
      public:
      // DatumReferenceFrame
      //
      typedef ::xsd::qif2::DatumReferenceFrameType DatumReferenceFrame_type;
      typedef ::xsd::cxx::tree::sequence< DatumReferenceFrame_type > DatumReferenceFrame_sequence;
      typedef DatumReferenceFrame_sequence::iterator DatumReferenceFrame_iterator;
      typedef DatumReferenceFrame_sequence::const_iterator DatumReferenceFrame_const_iterator;
      typedef ::xsd::cxx::tree::traits< DatumReferenceFrame_type, char > DatumReferenceFrame_traits;

      const DatumReferenceFrame_sequence&
      DatumReferenceFrame () const;

      DatumReferenceFrame_sequence&
      DatumReferenceFrame ();

      void
      DatumReferenceFrame (const DatumReferenceFrame_sequence& s);

      // Constructors.
      //
      DatumReferenceFramesType ();

      DatumReferenceFramesType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      DatumReferenceFramesType (const DatumReferenceFramesType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual DatumReferenceFramesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumReferenceFramesType&
      operator= (const DatumReferenceFramesType& x);

      virtual 
      ~DatumReferenceFramesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      DatumReferenceFrame_sequence DatumReferenceFrame_;
    };

    class EventBaseType: public ::xml_schema::type
    {
      public:
      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::traits< Description_type, char > Description_traits;

      const Description_type&
      Description () const;

      Description_type&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (::std::auto_ptr< Description_type > p);

      // id
      //
      typedef ::xsd::qif2::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::auto_ptr< id_type > p);

      // Constructors.
      //
      EventBaseType (const Description_type&,
                     const id_type&);

      EventBaseType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      EventBaseType (const EventBaseType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual EventBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EventBaseType&
      operator= (const EventBaseType& x);

      virtual 
      ~EventBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Description_type > Description_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class NotableEventType: public ::xsd::qif2::EventBaseType
    {
      public:
      // Active
      //
      typedef ::xml_schema::boolean Active_type;
      typedef ::xsd::cxx::tree::traits< Active_type, char > Active_traits;

      const Active_type&
      Active () const;

      Active_type&
      Active ();

      void
      Active (const Active_type& x);

      // Constructors.
      //
      NotableEventType (const Description_type&,
                        const id_type&,
                        const Active_type&);

      NotableEventType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      NotableEventType (const NotableEventType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual NotableEventType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NotableEventType&
      operator= (const NotableEventType& x);

      virtual 
      ~NotableEventType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Active_type > Active_;
    };

    class NotableEventsType: public ::xml_schema::type
    {
      public:
      // NotableEvent
      //
      typedef ::xsd::qif2::NotableEventType NotableEvent_type;
      typedef ::xsd::cxx::tree::sequence< NotableEvent_type > NotableEvent_sequence;
      typedef NotableEvent_sequence::iterator NotableEvent_iterator;
      typedef NotableEvent_sequence::const_iterator NotableEvent_const_iterator;
      typedef ::xsd::cxx::tree::traits< NotableEvent_type, char > NotableEvent_traits;

      const NotableEvent_sequence&
      NotableEvent () const;

      NotableEvent_sequence&
      NotableEvent ();

      void
      NotableEvent (const NotableEvent_sequence& s);

      // Constructors.
      //
      NotableEventsType ();

      NotableEventsType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      NotableEventsType (const NotableEventsType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual NotableEventsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NotableEventsType&
      operator= (const NotableEventsType& x);

      virtual 
      ~NotableEventsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      NotableEvent_sequence NotableEvent_;
    };

    class NotedEventType: public ::xsd::qif2::EventBaseType
    {
      public:
      // SequenceNumber
      //
      typedef ::xml_schema::positive_integer SequenceNumber_type;
      typedef ::xsd::cxx::tree::traits< SequenceNumber_type, char > SequenceNumber_traits;

      const SequenceNumber_type&
      SequenceNumber () const;

      SequenceNumber_type&
      SequenceNumber ();

      void
      SequenceNumber (const SequenceNumber_type& x);

      // TimeOccurred
      //
      typedef ::xml_schema::date_time TimeOccurred_type;
      typedef ::xsd::cxx::tree::optional< TimeOccurred_type > TimeOccurred_optional;
      typedef ::xsd::cxx::tree::traits< TimeOccurred_type, char > TimeOccurred_traits;

      const TimeOccurred_optional&
      TimeOccurred () const;

      TimeOccurred_optional&
      TimeOccurred ();

      void
      TimeOccurred (const TimeOccurred_type& x);

      void
      TimeOccurred (const TimeOccurred_optional& x);

      void
      TimeOccurred (::std::auto_ptr< TimeOccurred_type > p);

      // NotableEventId
      //
      typedef ::xsd::qif2::QIFReferenceFullType NotableEventId_type;
      typedef ::xsd::cxx::tree::optional< NotableEventId_type > NotableEventId_optional;
      typedef ::xsd::cxx::tree::traits< NotableEventId_type, char > NotableEventId_traits;

      const NotableEventId_optional&
      NotableEventId () const;

      NotableEventId_optional&
      NotableEventId ();

      void
      NotableEventId (const NotableEventId_type& x);

      void
      NotableEventId (const NotableEventId_optional& x);

      void
      NotableEventId (::std::auto_ptr< NotableEventId_type > p);

      // Constructors.
      //
      NotedEventType (const Description_type&,
                      const id_type&,
                      const SequenceNumber_type&);

      NotedEventType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      NotedEventType (const NotedEventType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual NotedEventType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NotedEventType&
      operator= (const NotedEventType& x);

      virtual 
      ~NotedEventType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SequenceNumber_type > SequenceNumber_;
      TimeOccurred_optional TimeOccurred_;
      NotableEventId_optional NotableEventId_;
    };

    class NotedEventsType: public ::xml_schema::type
    {
      public:
      // NotedEvent
      //
      typedef ::xsd::qif2::NotedEventType NotedEvent_type;
      typedef ::xsd::cxx::tree::sequence< NotedEvent_type > NotedEvent_sequence;
      typedef NotedEvent_sequence::iterator NotedEvent_iterator;
      typedef NotedEvent_sequence::const_iterator NotedEvent_const_iterator;
      typedef ::xsd::cxx::tree::traits< NotedEvent_type, char > NotedEvent_traits;

      const NotedEvent_sequence&
      NotedEvent () const;

      NotedEvent_sequence&
      NotedEvent ();

      void
      NotedEvent (const NotedEvent_sequence& s);

      // Constructors.
      //
      NotedEventsType ();

      NotedEventsType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      NotedEventsType (const NotedEventsType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual NotedEventsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NotedEventsType&
      operator= (const NotedEventsType& x);

      virtual 
      ~NotedEventsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      NotedEvent_sequence NotedEvent_;
    };

    class InspectionStatusEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        PASS,
        FAIL,
        REWORK,
        SYSERROR,
        UNKNOWN,
        NOT_CALCULATED,
        NOT_MEASURED,
        UNDEFINED
      };

      InspectionStatusEnumType (value v);

      InspectionStatusEnumType (const char* v);

      InspectionStatusEnumType (const ::std::string& v);

      InspectionStatusEnumType (const ::xml_schema::nmtoken& v);

      InspectionStatusEnumType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      InspectionStatusEnumType (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      InspectionStatusEnumType (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      InspectionStatusEnumType (const InspectionStatusEnumType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual InspectionStatusEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      InspectionStatusEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_InspectionStatusEnumType_convert ();
      }

      protected:
      value
      _xsd_InspectionStatusEnumType_convert () const;

      public:
      static const char* const _xsd_InspectionStatusEnumType_literals_[8];
      static const value _xsd_InspectionStatusEnumType_indexes_[8];
    };

    class InspectionStatusType: public ::xml_schema::type
    {
      public:
      // InspectionStatusEnum
      //
      typedef ::xsd::qif2::InspectionStatusEnumType InspectionStatusEnum_type;
      typedef ::xsd::cxx::tree::optional< InspectionStatusEnum_type > InspectionStatusEnum_optional;
      typedef ::xsd::cxx::tree::traits< InspectionStatusEnum_type, char > InspectionStatusEnum_traits;

      const InspectionStatusEnum_optional&
      InspectionStatusEnum () const;

      InspectionStatusEnum_optional&
      InspectionStatusEnum ();

      void
      InspectionStatusEnum (const InspectionStatusEnum_type& x);

      void
      InspectionStatusEnum (const InspectionStatusEnum_optional& x);

      void
      InspectionStatusEnum (::std::auto_ptr< InspectionStatusEnum_type > p);

      // OtherInspectionStatus
      //
      typedef ::xml_schema::string OtherInspectionStatus_type;
      typedef ::xsd::cxx::tree::optional< OtherInspectionStatus_type > OtherInspectionStatus_optional;
      typedef ::xsd::cxx::tree::traits< OtherInspectionStatus_type, char > OtherInspectionStatus_traits;

      const OtherInspectionStatus_optional&
      OtherInspectionStatus () const;

      OtherInspectionStatus_optional&
      OtherInspectionStatus ();

      void
      OtherInspectionStatus (const OtherInspectionStatus_type& x);

      void
      OtherInspectionStatus (const OtherInspectionStatus_optional& x);

      void
      OtherInspectionStatus (::std::auto_ptr< OtherInspectionStatus_type > p);

      // Constructors.
      //
      InspectionStatusType ();

      InspectionStatusType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      InspectionStatusType (const InspectionStatusType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual InspectionStatusType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      InspectionStatusType&
      operator= (const InspectionStatusType& x);

      virtual 
      ~InspectionStatusType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      InspectionStatusEnum_optional InspectionStatusEnum_;
      OtherInspectionStatus_optional OtherInspectionStatus_;
    };

    class EntityExternalType: public ::xml_schema::type
    {
      public:
      // EntityId
      //
      typedef ::xml_schema::token EntityId_type;
      typedef ::xsd::cxx::tree::traits< EntityId_type, char > EntityId_traits;

      const EntityId_type&
      EntityId () const;

      EntityId_type&
      EntityId ();

      void
      EntityId (const EntityId_type& x);

      void
      EntityId (::std::auto_ptr< EntityId_type > p);

      // Name
      //
      typedef ::xml_schema::token Name_type;
      typedef ::xsd::cxx::tree::optional< Name_type > Name_optional;
      typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

      const Name_optional&
      Name () const;

      Name_optional&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (const Name_optional& x);

      void
      Name (::std::auto_ptr< Name_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, char > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::auto_ptr< Description_type > p);

      // id
      //
      typedef ::xsd::qif2::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::auto_ptr< id_type > p);

      // Constructors.
      //
      EntityExternalType (const EntityId_type&,
                          const id_type&);

      EntityExternalType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      EntityExternalType (const EntityExternalType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual EntityExternalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EntityExternalType&
      operator= (const EntityExternalType& x);

      virtual 
      ~EntityExternalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< EntityId_type > EntityId_;
      Name_optional Name_;
      Description_optional Description_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class EntitiesExternalType: public ::xml_schema::type
    {
      public:
      // Entity
      //
      typedef ::xsd::qif2::EntityExternalType Entity_type;
      typedef ::xsd::cxx::tree::sequence< Entity_type > Entity_sequence;
      typedef Entity_sequence::iterator Entity_iterator;
      typedef Entity_sequence::const_iterator Entity_const_iterator;
      typedef ::xsd::cxx::tree::traits< Entity_type, char > Entity_traits;

      const Entity_sequence&
      Entity () const;

      Entity_sequence&
      Entity ();

      void
      Entity (const Entity_sequence& s);

      // Constructors.
      //
      EntitiesExternalType ();

      EntitiesExternalType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      EntitiesExternalType (const EntitiesExternalType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual EntitiesExternalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EntitiesExternalType&
      operator= (const EntitiesExternalType& x);

      virtual 
      ~EntitiesExternalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Entity_sequence Entity_;
    };

    class ZoneDataType: public ::xml_schema::type
    {
      public:
      // FeatureItemId
      //
      typedef ::xsd::qif2::QIFReferenceFullType FeatureItemId_type;
      typedef ::xsd::cxx::tree::traits< FeatureItemId_type, char > FeatureItemId_traits;

      const FeatureItemId_type&
      FeatureItemId () const;

      FeatureItemId_type&
      FeatureItemId ();

      void
      FeatureItemId (const FeatureItemId_type& x);

      void
      FeatureItemId (::std::auto_ptr< FeatureItemId_type > p);

      // Bonus
      //
      typedef ::xsd::qif2::LinearValueType Bonus_type;
      typedef ::xsd::cxx::tree::traits< Bonus_type, char > Bonus_traits;

      const Bonus_type&
      Bonus () const;

      Bonus_type&
      Bonus ();

      void
      Bonus (const Bonus_type& x);

      void
      Bonus (::std::auto_ptr< Bonus_type > p);

      // ReferenceLength
      //
      typedef ::xsd::qif2::LinearValueType ReferenceLength_type;
      typedef ::xsd::cxx::tree::traits< ReferenceLength_type, char > ReferenceLength_traits;

      const ReferenceLength_type&
      ReferenceLength () const;

      ReferenceLength_type&
      ReferenceLength ();

      void
      ReferenceLength (const ReferenceLength_type& x);

      void
      ReferenceLength (::std::auto_ptr< ReferenceLength_type > p);

      // Constructors.
      //
      ZoneDataType (const FeatureItemId_type&,
                    const Bonus_type&,
                    const ReferenceLength_type&);

      ZoneDataType (::std::auto_ptr< FeatureItemId_type >,
                    ::std::auto_ptr< Bonus_type >,
                    ::std::auto_ptr< ReferenceLength_type >);

      ZoneDataType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      ZoneDataType (const ZoneDataType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual ZoneDataType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ZoneDataType&
      operator= (const ZoneDataType& x);

      virtual 
      ~ZoneDataType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< FeatureItemId_type > FeatureItemId_;
      ::xsd::cxx::tree::one< Bonus_type > Bonus_;
      ::xsd::cxx::tree::one< ReferenceLength_type > ReferenceLength_;
    };

    class LinearToleranceType: public ::xml_schema::type
    {
      public:
      // MaxValue
      //
      typedef ::xsd::qif2::LinearValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, char > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::auto_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif2::LinearValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, char > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::auto_ptr< MinValue_type > p);

      // DefinitionId
      //
      typedef ::xsd::qif2::QIFReferenceFullType DefinitionId_type;
      typedef ::xsd::cxx::tree::optional< DefinitionId_type > DefinitionId_optional;
      typedef ::xsd::cxx::tree::traits< DefinitionId_type, char > DefinitionId_traits;

      const DefinitionId_optional&
      DefinitionId () const;

      DefinitionId_optional&
      DefinitionId ();

      void
      DefinitionId (const DefinitionId_type& x);

      void
      DefinitionId (const DefinitionId_optional& x);

      void
      DefinitionId (::std::auto_ptr< DefinitionId_type > p);

      // DefinedAsLimit
      //
      typedef ::xml_schema::boolean DefinedAsLimit_type;
      typedef ::xsd::cxx::tree::traits< DefinedAsLimit_type, char > DefinedAsLimit_traits;

      const DefinedAsLimit_type&
      DefinedAsLimit () const;

      DefinedAsLimit_type&
      DefinedAsLimit ();

      void
      DefinedAsLimit (const DefinedAsLimit_type& x);

      // Constructors.
      //
      LinearToleranceType (const DefinedAsLimit_type&);

      LinearToleranceType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      LinearToleranceType (const LinearToleranceType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual LinearToleranceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearToleranceType&
      operator= (const LinearToleranceType& x);

      virtual 
      ~LinearToleranceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
      DefinitionId_optional DefinitionId_;
      ::xsd::cxx::tree::one< DefinedAsLimit_type > DefinedAsLimit_;
    };

    class LinearToleranceDefinitionType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif2::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, char > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::auto_ptr< Attributes_type > p);

      // MaxValue
      //
      typedef ::xsd::qif2::LinearValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, char > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::auto_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif2::LinearValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, char > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::auto_ptr< MinValue_type > p);

      // id
      //
      typedef ::xsd::qif2::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::auto_ptr< id_type > p);

      // Constructors.
      //
      LinearToleranceDefinitionType (const id_type&);

      LinearToleranceDefinitionType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      LinearToleranceDefinitionType (const LinearToleranceDefinitionType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual LinearToleranceDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearToleranceDefinitionType&
      operator= (const LinearToleranceDefinitionType& x);

      virtual 
      ~LinearToleranceDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class AngularToleranceType: public ::xml_schema::type
    {
      public:
      // MaxValue
      //
      typedef ::xsd::qif2::AngularValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, char > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::auto_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif2::AngularValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, char > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::auto_ptr< MinValue_type > p);

      // DefinitionId
      //
      typedef ::xsd::qif2::QIFReferenceFullType DefinitionId_type;
      typedef ::xsd::cxx::tree::optional< DefinitionId_type > DefinitionId_optional;
      typedef ::xsd::cxx::tree::traits< DefinitionId_type, char > DefinitionId_traits;

      const DefinitionId_optional&
      DefinitionId () const;

      DefinitionId_optional&
      DefinitionId ();

      void
      DefinitionId (const DefinitionId_type& x);

      void
      DefinitionId (const DefinitionId_optional& x);

      void
      DefinitionId (::std::auto_ptr< DefinitionId_type > p);

      // DefinedAsLimit
      //
      typedef ::xml_schema::boolean DefinedAsLimit_type;
      typedef ::xsd::cxx::tree::traits< DefinedAsLimit_type, char > DefinedAsLimit_traits;

      const DefinedAsLimit_type&
      DefinedAsLimit () const;

      DefinedAsLimit_type&
      DefinedAsLimit ();

      void
      DefinedAsLimit (const DefinedAsLimit_type& x);

      // Constructors.
      //
      AngularToleranceType (const DefinedAsLimit_type&);

      AngularToleranceType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      AngularToleranceType (const AngularToleranceType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual AngularToleranceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngularToleranceType&
      operator= (const AngularToleranceType& x);

      virtual 
      ~AngularToleranceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
      DefinitionId_optional DefinitionId_;
      ::xsd::cxx::tree::one< DefinedAsLimit_type > DefinedAsLimit_;
    };

    class AngularToleranceDefinitionType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif2::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, char > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::auto_ptr< Attributes_type > p);

      // MaxValue
      //
      typedef ::xsd::qif2::AngularValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, char > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::auto_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif2::AngularValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, char > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::auto_ptr< MinValue_type > p);

      // id
      //
      typedef ::xsd::qif2::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::auto_ptr< id_type > p);

      // Constructors.
      //
      AngularToleranceDefinitionType (const id_type&);

      AngularToleranceDefinitionType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      AngularToleranceDefinitionType (const AngularToleranceDefinitionType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual AngularToleranceDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngularToleranceDefinitionType&
      operator= (const AngularToleranceDefinitionType& x);

      virtual 
      ~AngularToleranceDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class TemperatureToleranceType: public ::xml_schema::type
    {
      public:
      // MaxValue
      //
      typedef ::xsd::qif2::TemperatureValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, char > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::auto_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif2::TemperatureValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, char > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::auto_ptr< MinValue_type > p);

      // DefinedAsLimit
      //
      typedef ::xml_schema::boolean DefinedAsLimit_type;
      typedef ::xsd::cxx::tree::traits< DefinedAsLimit_type, char > DefinedAsLimit_traits;

      const DefinedAsLimit_type&
      DefinedAsLimit () const;

      DefinedAsLimit_type&
      DefinedAsLimit ();

      void
      DefinedAsLimit (const DefinedAsLimit_type& x);

      // Constructors.
      //
      TemperatureToleranceType (const DefinedAsLimit_type&);

      TemperatureToleranceType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      TemperatureToleranceType (const TemperatureToleranceType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual TemperatureToleranceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TemperatureToleranceType&
      operator= (const TemperatureToleranceType& x);

      virtual 
      ~TemperatureToleranceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
      ::xsd::cxx::tree::one< DefinedAsLimit_type > DefinedAsLimit_;
    };

    class AreaToleranceType: public ::xml_schema::type
    {
      public:
      // MaxValue
      //
      typedef ::xsd::qif2::AreaValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, char > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::auto_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif2::AreaValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, char > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::auto_ptr< MinValue_type > p);

      // DefinedAsLimit
      //
      typedef ::xml_schema::boolean DefinedAsLimit_type;
      typedef ::xsd::cxx::tree::traits< DefinedAsLimit_type, char > DefinedAsLimit_traits;

      const DefinedAsLimit_type&
      DefinedAsLimit () const;

      DefinedAsLimit_type&
      DefinedAsLimit ();

      void
      DefinedAsLimit (const DefinedAsLimit_type& x);

      // Constructors.
      //
      AreaToleranceType (const DefinedAsLimit_type&);

      AreaToleranceType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      AreaToleranceType (const AreaToleranceType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual AreaToleranceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AreaToleranceType&
      operator= (const AreaToleranceType& x);

      virtual 
      ~AreaToleranceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
      ::xsd::cxx::tree::one< DefinedAsLimit_type > DefinedAsLimit_;
    };

    class ForceToleranceType: public ::xml_schema::type
    {
      public:
      // MaxValue
      //
      typedef ::xsd::qif2::ForceValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, char > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::auto_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif2::ForceValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, char > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::auto_ptr< MinValue_type > p);

      // DefinedAsLimit
      //
      typedef ::xml_schema::boolean DefinedAsLimit_type;
      typedef ::xsd::cxx::tree::traits< DefinedAsLimit_type, char > DefinedAsLimit_traits;

      const DefinedAsLimit_type&
      DefinedAsLimit () const;

      DefinedAsLimit_type&
      DefinedAsLimit ();

      void
      DefinedAsLimit (const DefinedAsLimit_type& x);

      // Constructors.
      //
      ForceToleranceType (const DefinedAsLimit_type&);

      ForceToleranceType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ForceToleranceType (const ForceToleranceType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual ForceToleranceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ForceToleranceType&
      operator= (const ForceToleranceType& x);

      virtual 
      ~ForceToleranceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
      ::xsd::cxx::tree::one< DefinedAsLimit_type > DefinedAsLimit_;
    };

    class MassToleranceType: public ::xml_schema::type
    {
      public:
      // MaxValue
      //
      typedef ::xsd::qif2::MassValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, char > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::auto_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif2::MassValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, char > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::auto_ptr< MinValue_type > p);

      // DefinedAsLimit
      //
      typedef ::xml_schema::boolean DefinedAsLimit_type;
      typedef ::xsd::cxx::tree::traits< DefinedAsLimit_type, char > DefinedAsLimit_traits;

      const DefinedAsLimit_type&
      DefinedAsLimit () const;

      DefinedAsLimit_type&
      DefinedAsLimit ();

      void
      DefinedAsLimit (const DefinedAsLimit_type& x);

      // Constructors.
      //
      MassToleranceType (const DefinedAsLimit_type&);

      MassToleranceType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      MassToleranceType (const MassToleranceType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual MassToleranceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MassToleranceType&
      operator= (const MassToleranceType& x);

      virtual 
      ~MassToleranceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
      ::xsd::cxx::tree::one< DefinedAsLimit_type > DefinedAsLimit_;
    };

    class PressureToleranceType: public ::xml_schema::type
    {
      public:
      // MaxValue
      //
      typedef ::xsd::qif2::PressureValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, char > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::auto_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif2::PressureValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, char > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::auto_ptr< MinValue_type > p);

      // DefinedAsLimit
      //
      typedef ::xml_schema::boolean DefinedAsLimit_type;
      typedef ::xsd::cxx::tree::traits< DefinedAsLimit_type, char > DefinedAsLimit_traits;

      const DefinedAsLimit_type&
      DefinedAsLimit () const;

      DefinedAsLimit_type&
      DefinedAsLimit ();

      void
      DefinedAsLimit (const DefinedAsLimit_type& x);

      // Constructors.
      //
      PressureToleranceType (const DefinedAsLimit_type&);

      PressureToleranceType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      PressureToleranceType (const PressureToleranceType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual PressureToleranceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PressureToleranceType&
      operator= (const PressureToleranceType& x);

      virtual 
      ~PressureToleranceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
      ::xsd::cxx::tree::one< DefinedAsLimit_type > DefinedAsLimit_;
    };

    class SpeedToleranceType: public ::xml_schema::type
    {
      public:
      // MaxValue
      //
      typedef ::xsd::qif2::SpeedValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, char > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::auto_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif2::SpeedValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, char > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::auto_ptr< MinValue_type > p);

      // DefinedAsLimit
      //
      typedef ::xml_schema::boolean DefinedAsLimit_type;
      typedef ::xsd::cxx::tree::traits< DefinedAsLimit_type, char > DefinedAsLimit_traits;

      const DefinedAsLimit_type&
      DefinedAsLimit () const;

      DefinedAsLimit_type&
      DefinedAsLimit ();

      void
      DefinedAsLimit (const DefinedAsLimit_type& x);

      // Constructors.
      //
      SpeedToleranceType (const DefinedAsLimit_type&);

      SpeedToleranceType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      SpeedToleranceType (const SpeedToleranceType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual SpeedToleranceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SpeedToleranceType&
      operator= (const SpeedToleranceType& x);

      virtual 
      ~SpeedToleranceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
      ::xsd::cxx::tree::one< DefinedAsLimit_type > DefinedAsLimit_;
    };

    class TimeToleranceType: public ::xml_schema::type
    {
      public:
      // MaxValue
      //
      typedef ::xsd::qif2::TimeValueType MaxValue_type;
      typedef ::xsd::cxx::tree::optional< MaxValue_type > MaxValue_optional;
      typedef ::xsd::cxx::tree::traits< MaxValue_type, char > MaxValue_traits;

      const MaxValue_optional&
      MaxValue () const;

      MaxValue_optional&
      MaxValue ();

      void
      MaxValue (const MaxValue_type& x);

      void
      MaxValue (const MaxValue_optional& x);

      void
      MaxValue (::std::auto_ptr< MaxValue_type > p);

      // MinValue
      //
      typedef ::xsd::qif2::TimeValueType MinValue_type;
      typedef ::xsd::cxx::tree::optional< MinValue_type > MinValue_optional;
      typedef ::xsd::cxx::tree::traits< MinValue_type, char > MinValue_traits;

      const MinValue_optional&
      MinValue () const;

      MinValue_optional&
      MinValue ();

      void
      MinValue (const MinValue_type& x);

      void
      MinValue (const MinValue_optional& x);

      void
      MinValue (::std::auto_ptr< MinValue_type > p);

      // DefinedAsLimit
      //
      typedef ::xml_schema::boolean DefinedAsLimit_type;
      typedef ::xsd::cxx::tree::traits< DefinedAsLimit_type, char > DefinedAsLimit_traits;

      const DefinedAsLimit_type&
      DefinedAsLimit () const;

      DefinedAsLimit_type&
      DefinedAsLimit ();

      void
      DefinedAsLimit (const DefinedAsLimit_type& x);

      // Constructors.
      //
      TimeToleranceType (const DefinedAsLimit_type&);

      TimeToleranceType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      TimeToleranceType (const TimeToleranceType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual TimeToleranceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TimeToleranceType&
      operator= (const TimeToleranceType& x);

      virtual 
      ~TimeToleranceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      MaxValue_optional MaxValue_;
      MinValue_optional MinValue_;
      ::xsd::cxx::tree::one< DefinedAsLimit_type > DefinedAsLimit_;
    };

    class DimensionModifierEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        BASIC,
        SET,
        REFERENCE
      };

      DimensionModifierEnumType (value v);

      DimensionModifierEnumType (const char* v);

      DimensionModifierEnumType (const ::std::string& v);

      DimensionModifierEnumType (const ::xml_schema::nmtoken& v);

      DimensionModifierEnumType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      DimensionModifierEnumType (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      DimensionModifierEnumType (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      DimensionModifierEnumType (const DimensionModifierEnumType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual DimensionModifierEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DimensionModifierEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_DimensionModifierEnumType_convert ();
      }

      protected:
      value
      _xsd_DimensionModifierEnumType_convert () const;

      public:
      static const char* const _xsd_DimensionModifierEnumType_literals_[3];
      static const value _xsd_DimensionModifierEnumType_indexes_[3];
    };

    class NonToleranceEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        MEASURED,
        SET
      };

      NonToleranceEnumType (value v);

      NonToleranceEnumType (const char* v);

      NonToleranceEnumType (const ::std::string& v);

      NonToleranceEnumType (const ::xml_schema::nmtoken& v);

      NonToleranceEnumType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      NonToleranceEnumType (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      NonToleranceEnumType (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      NonToleranceEnumType (const NonToleranceEnumType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual NonToleranceEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NonToleranceEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_NonToleranceEnumType_convert ();
      }

      protected:
      value
      _xsd_NonToleranceEnumType_convert () const;

      public:
      static const char* const _xsd_NonToleranceEnumType_literals_[2];
      static const value _xsd_NonToleranceEnumType_indexes_[2];
    };

    class CommonFileSpecEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        AVI,
        BMP,
        DOC,
        DOCX,
        DXF,
        DTD,
        GIF,
        GZIP,
        HTML,
        IGES,
        JPEG,
        JPG,
        MOV,
        MPEG,
        MPG,
        PDF,
        PNG,
        PPM,
        PPT,
        PRT,
        RAR,
        RTF,
        STL,
        STEP,
        STP,
        TAR,
        TIF,
        TIFF,
        TXT,
        WMV,
        XLS,
        XLSX,
        XML,
        XSD,
        X_T,
        ZIP
      };

      CommonFileSpecEnumType (value v);

      CommonFileSpecEnumType (const char* v);

      CommonFileSpecEnumType (const ::std::string& v);

      CommonFileSpecEnumType (const ::xml_schema::nmtoken& v);

      CommonFileSpecEnumType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      CommonFileSpecEnumType (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      CommonFileSpecEnumType (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      CommonFileSpecEnumType (const CommonFileSpecEnumType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual CommonFileSpecEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CommonFileSpecEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_CommonFileSpecEnumType_convert ();
      }

      protected:
      value
      _xsd_CommonFileSpecEnumType_convert () const;

      public:
      static const char* const _xsd_CommonFileSpecEnumType_literals_[36];
      static const value _xsd_CommonFileSpecEnumType_indexes_[36];
    };

    class FileSpecType: public ::xml_schema::type
    {
      public:
      // CommonFileSpecEnum
      //
      typedef ::xsd::qif2::CommonFileSpecEnumType CommonFileSpecEnum_type;
      typedef ::xsd::cxx::tree::optional< CommonFileSpecEnum_type > CommonFileSpecEnum_optional;
      typedef ::xsd::cxx::tree::traits< CommonFileSpecEnum_type, char > CommonFileSpecEnum_traits;

      const CommonFileSpecEnum_optional&
      CommonFileSpecEnum () const;

      CommonFileSpecEnum_optional&
      CommonFileSpecEnum ();

      void
      CommonFileSpecEnum (const CommonFileSpecEnum_type& x);

      void
      CommonFileSpecEnum (const CommonFileSpecEnum_optional& x);

      void
      CommonFileSpecEnum (::std::auto_ptr< CommonFileSpecEnum_type > p);

      // OtherFileSpec
      //
      typedef ::xml_schema::string OtherFileSpec_type;
      typedef ::xsd::cxx::tree::optional< OtherFileSpec_type > OtherFileSpec_optional;
      typedef ::xsd::cxx::tree::traits< OtherFileSpec_type, char > OtherFileSpec_traits;

      const OtherFileSpec_optional&
      OtherFileSpec () const;

      OtherFileSpec_optional&
      OtherFileSpec ();

      void
      OtherFileSpec (const OtherFileSpec_type& x);

      void
      OtherFileSpec (const OtherFileSpec_optional& x);

      void
      OtherFileSpec (::std::auto_ptr< OtherFileSpec_type > p);

      // Constructors.
      //
      FileSpecType ();

      FileSpecType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      FileSpecType (const FileSpecType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual FileSpecType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FileSpecType&
      operator= (const FileSpecType& x);

      virtual 
      ~FileSpecType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      CommonFileSpecEnum_optional CommonFileSpecEnum_;
      OtherFileSpec_optional OtherFileSpec_;
    };

    class ExternalFileReferenceType: public ::xml_schema::type
    {
      public:
      // URI
      //
      typedef ::xml_schema::uri URI_type;
      typedef ::xsd::cxx::tree::traits< URI_type, char > URI_traits;

      const URI_type&
      URI () const;

      URI_type&
      URI ();

      void
      URI (const URI_type& x);

      void
      URI (::std::auto_ptr< URI_type > p);

      // FileSpec
      //
      typedef ::xsd::qif2::FileSpecType FileSpec_type;
      typedef ::xsd::cxx::tree::traits< FileSpec_type, char > FileSpec_traits;

      const FileSpec_type&
      FileSpec () const;

      FileSpec_type&
      FileSpec ();

      void
      FileSpec (const FileSpec_type& x);

      void
      FileSpec (::std::auto_ptr< FileSpec_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::traits< Description_type, char > Description_traits;

      const Description_type&
      Description () const;

      Description_type&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (::std::auto_ptr< Description_type > p);

      // Constructors.
      //
      ExternalFileReferenceType (const URI_type&,
                                 const FileSpec_type&,
                                 const Description_type&);

      ExternalFileReferenceType (const URI_type&,
                                 ::std::auto_ptr< FileSpec_type >,
                                 const Description_type&);

      ExternalFileReferenceType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      ExternalFileReferenceType (const ExternalFileReferenceType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual ExternalFileReferenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExternalFileReferenceType&
      operator= (const ExternalFileReferenceType& x);

      virtual 
      ~ExternalFileReferenceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< URI_type > URI_;
      ::xsd::cxx::tree::one< FileSpec_type > FileSpec_;
      ::xsd::cxx::tree::one< Description_type > Description_;
    };

    class DatumTargetDefinitionsType: public ::xml_schema::type
    {
      public:
      // DatumTarget
      //
      typedef ::xsd::qif2::DatumTargetDefinitionBaseType DatumTarget_type;
      typedef ::xsd::cxx::tree::sequence< DatumTarget_type > DatumTarget_sequence;
      typedef DatumTarget_sequence::iterator DatumTarget_iterator;
      typedef DatumTarget_sequence::const_iterator DatumTarget_const_iterator;
      typedef ::xsd::cxx::tree::traits< DatumTarget_type, char > DatumTarget_traits;

      const DatumTarget_sequence&
      DatumTarget () const;

      DatumTarget_sequence&
      DatumTarget ();

      void
      DatumTarget (const DatumTarget_sequence& s);

      // N
      //
      typedef ::xsd::qif2::NaturalType N_type;
      typedef ::xsd::cxx::tree::traits< N_type, char > N_traits;

      const N_type&
      N () const;

      N_type&
      N ();

      void
      N (const N_type& x);

      void
      N (::std::auto_ptr< N_type > p);

      // Constructors.
      //
      DatumTargetDefinitionsType (const N_type&);

      DatumTargetDefinitionsType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      DatumTargetDefinitionsType (const DatumTargetDefinitionsType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual DatumTargetDefinitionsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumTargetDefinitionsType&
      operator= (const DatumTargetDefinitionsType& x);

      virtual 
      ~DatumTargetDefinitionsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      DatumTarget_sequence DatumTarget_;
      ::xsd::cxx::tree::one< N_type > N_;
    };

    class DatumDefinitionType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif2::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, char > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::auto_ptr< Attributes_type > p);

      // DatumLabel
      //
      typedef ::xml_schema::nmtoken DatumLabel_type;
      typedef ::xsd::cxx::tree::traits< DatumLabel_type, char > DatumLabel_traits;

      const DatumLabel_type&
      DatumLabel () const;

      DatumLabel_type&
      DatumLabel ();

      void
      DatumLabel (const DatumLabel_type& x);

      void
      DatumLabel (::std::auto_ptr< DatumLabel_type > p);

      // DatumTargetIds
      //
      typedef ::xsd::qif2::ArrayReferenceFullType DatumTargetIds_type;
      typedef ::xsd::cxx::tree::optional< DatumTargetIds_type > DatumTargetIds_optional;
      typedef ::xsd::cxx::tree::traits< DatumTargetIds_type, char > DatumTargetIds_traits;

      const DatumTargetIds_optional&
      DatumTargetIds () const;

      DatumTargetIds_optional&
      DatumTargetIds ();

      void
      DatumTargetIds (const DatumTargetIds_type& x);

      void
      DatumTargetIds (const DatumTargetIds_optional& x);

      void
      DatumTargetIds (::std::auto_ptr< DatumTargetIds_type > p);

      // FeatureNominalIds
      //
      typedef ::xsd::qif2::ArrayReferenceFullType FeatureNominalIds_type;
      typedef ::xsd::cxx::tree::optional< FeatureNominalIds_type > FeatureNominalIds_optional;
      typedef ::xsd::cxx::tree::traits< FeatureNominalIds_type, char > FeatureNominalIds_traits;

      const FeatureNominalIds_optional&
      FeatureNominalIds () const;

      FeatureNominalIds_optional&
      FeatureNominalIds ();

      void
      FeatureNominalIds (const FeatureNominalIds_type& x);

      void
      FeatureNominalIds (const FeatureNominalIds_optional& x);

      void
      FeatureNominalIds (::std::auto_ptr< FeatureNominalIds_type > p);

      // id
      //
      typedef ::xsd::qif2::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::auto_ptr< id_type > p);

      // Constructors.
      //
      DatumDefinitionType (const DatumLabel_type&,
                           const id_type&);

      DatumDefinitionType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      DatumDefinitionType (const DatumDefinitionType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual DatumDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumDefinitionType&
      operator= (const DatumDefinitionType& x);

      virtual 
      ~DatumDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      ::xsd::cxx::tree::one< DatumLabel_type > DatumLabel_;
      DatumTargetIds_optional DatumTargetIds_;
      FeatureNominalIds_optional FeatureNominalIds_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class DatumDefinitionsType: public ::xml_schema::type
    {
      public:
      // DatumDefinition
      //
      typedef ::xsd::qif2::DatumDefinitionType DatumDefinition_type;
      typedef ::xsd::cxx::tree::sequence< DatumDefinition_type > DatumDefinition_sequence;
      typedef DatumDefinition_sequence::iterator DatumDefinition_iterator;
      typedef DatumDefinition_sequence::const_iterator DatumDefinition_const_iterator;
      typedef ::xsd::cxx::tree::traits< DatumDefinition_type, char > DatumDefinition_traits;

      const DatumDefinition_sequence&
      DatumDefinition () const;

      DatumDefinition_sequence&
      DatumDefinition ();

      void
      DatumDefinition (const DatumDefinition_sequence& s);

      // Constructors.
      //
      DatumDefinitionsType ();

      DatumDefinitionsType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      DatumDefinitionsType (const DatumDefinitionsType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual DatumDefinitionsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumDefinitionsType&
      operator= (const DatumDefinitionsType& x);

      virtual 
      ~DatumDefinitionsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      DatumDefinition_sequence DatumDefinition_;
    };

    class DatumTargetDefinitionBaseType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif2::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, char > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::auto_ptr< Attributes_type > p);

      // DatumTargetLabel
      //
      typedef ::xml_schema::token DatumTargetLabel_type;
      typedef ::xsd::cxx::tree::traits< DatumTargetLabel_type, char > DatumTargetLabel_traits;

      const DatumTargetLabel_type&
      DatumTargetLabel () const;

      DatumTargetLabel_type&
      DatumTargetLabel ();

      void
      DatumTargetLabel (const DatumTargetLabel_type& x);

      void
      DatumTargetLabel (::std::auto_ptr< DatumTargetLabel_type > p);

      // FeatureNominalId
      //
      typedef ::xsd::qif2::QIFReferenceFullType FeatureNominalId_type;
      typedef ::xsd::cxx::tree::optional< FeatureNominalId_type > FeatureNominalId_optional;
      typedef ::xsd::cxx::tree::traits< FeatureNominalId_type, char > FeatureNominalId_traits;

      const FeatureNominalId_optional&
      FeatureNominalId () const;

      FeatureNominalId_optional&
      FeatureNominalId ();

      void
      FeatureNominalId (const FeatureNominalId_type& x);

      void
      FeatureNominalId (const FeatureNominalId_optional& x);

      void
      FeatureNominalId (::std::auto_ptr< FeatureNominalId_type > p);

      // MovableDatumTarget
      //
      typedef ::xsd::qif2::MovableDatumTargetDirectionType MovableDatumTarget_type;
      typedef ::xsd::cxx::tree::optional< MovableDatumTarget_type > MovableDatumTarget_optional;
      typedef ::xsd::cxx::tree::traits< MovableDatumTarget_type, char > MovableDatumTarget_traits;

      const MovableDatumTarget_optional&
      MovableDatumTarget () const;

      MovableDatumTarget_optional&
      MovableDatumTarget ();

      void
      MovableDatumTarget (const MovableDatumTarget_type& x);

      void
      MovableDatumTarget (const MovableDatumTarget_optional& x);

      void
      MovableDatumTarget (::std::auto_ptr< MovableDatumTarget_type > p);

      // id
      //
      typedef ::xsd::qif2::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::auto_ptr< id_type > p);

      // Constructors.
      //
      DatumTargetDefinitionBaseType (const DatumTargetLabel_type&,
                                     const id_type&);

      DatumTargetDefinitionBaseType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      DatumTargetDefinitionBaseType (const DatumTargetDefinitionBaseType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual DatumTargetDefinitionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumTargetDefinitionBaseType&
      operator= (const DatumTargetDefinitionBaseType& x);

      virtual 
      ~DatumTargetDefinitionBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      ::xsd::cxx::tree::one< DatumTargetLabel_type > DatumTargetLabel_;
      FeatureNominalId_optional FeatureNominalId_;
      MovableDatumTarget_optional MovableDatumTarget_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class DatumTargetPointDefinitionType: public ::xsd::qif2::DatumTargetDefinitionBaseType
    {
      public:
      // Point
      //
      typedef ::xsd::qif2::PointType Point_type;
      typedef ::xsd::cxx::tree::traits< Point_type, char > Point_traits;

      const Point_type&
      Point () const;

      Point_type&
      Point ();

      void
      Point (const Point_type& x);

      void
      Point (::std::auto_ptr< Point_type > p);

      // Constructors.
      //
      DatumTargetPointDefinitionType (const DatumTargetLabel_type&,
                                      const id_type&,
                                      const Point_type&);

      DatumTargetPointDefinitionType (const DatumTargetLabel_type&,
                                      const id_type&,
                                      ::std::auto_ptr< Point_type >);

      DatumTargetPointDefinitionType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      DatumTargetPointDefinitionType (const DatumTargetPointDefinitionType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual DatumTargetPointDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumTargetPointDefinitionType&
      operator= (const DatumTargetPointDefinitionType& x);

      virtual 
      ~DatumTargetPointDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Point_type > Point_;
    };

    class DatumTargetLineDefinitionType: public ::xsd::qif2::DatumTargetDefinitionBaseType
    {
      public:
      // Line
      //
      typedef ::xsd::qif2::LineSegmentType Line_type;
      typedef ::xsd::cxx::tree::traits< Line_type, char > Line_traits;

      const Line_type&
      Line () const;

      Line_type&
      Line ();

      void
      Line (const Line_type& x);

      void
      Line (::std::auto_ptr< Line_type > p);

      // Constructors.
      //
      DatumTargetLineDefinitionType (const DatumTargetLabel_type&,
                                     const id_type&,
                                     const Line_type&);

      DatumTargetLineDefinitionType (const DatumTargetLabel_type&,
                                     const id_type&,
                                     ::std::auto_ptr< Line_type >);

      DatumTargetLineDefinitionType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      DatumTargetLineDefinitionType (const DatumTargetLineDefinitionType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual DatumTargetLineDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumTargetLineDefinitionType&
      operator= (const DatumTargetLineDefinitionType& x);

      virtual 
      ~DatumTargetLineDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Line_type > Line_;
    };

    class DatumTargetCircularAreaDefinitionType: public ::xsd::qif2::DatumTargetDefinitionBaseType
    {
      public:
      // Circle
      //
      typedef ::xsd::qif2::CircleType Circle_type;
      typedef ::xsd::cxx::tree::traits< Circle_type, char > Circle_traits;

      const Circle_type&
      Circle () const;

      Circle_type&
      Circle ();

      void
      Circle (const Circle_type& x);

      void
      Circle (::std::auto_ptr< Circle_type > p);

      // Constructors.
      //
      DatumTargetCircularAreaDefinitionType (const DatumTargetLabel_type&,
                                             const id_type&,
                                             const Circle_type&);

      DatumTargetCircularAreaDefinitionType (const DatumTargetLabel_type&,
                                             const id_type&,
                                             ::std::auto_ptr< Circle_type >);

      DatumTargetCircularAreaDefinitionType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      DatumTargetCircularAreaDefinitionType (const DatumTargetCircularAreaDefinitionType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual DatumTargetCircularAreaDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumTargetCircularAreaDefinitionType&
      operator= (const DatumTargetCircularAreaDefinitionType& x);

      virtual 
      ~DatumTargetCircularAreaDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Circle_type > Circle_;
    };

    class DatumTargetCircularLineDefinitionType: public ::xsd::qif2::DatumTargetDefinitionBaseType
    {
      public:
      // Circle
      //
      typedef ::xsd::qif2::CircleType Circle_type;
      typedef ::xsd::cxx::tree::traits< Circle_type, char > Circle_traits;

      const Circle_type&
      Circle () const;

      Circle_type&
      Circle ();

      void
      Circle (const Circle_type& x);

      void
      Circle (::std::auto_ptr< Circle_type > p);

      // Constructors.
      //
      DatumTargetCircularLineDefinitionType (const DatumTargetLabel_type&,
                                             const id_type&,
                                             const Circle_type&);

      DatumTargetCircularLineDefinitionType (const DatumTargetLabel_type&,
                                             const id_type&,
                                             ::std::auto_ptr< Circle_type >);

      DatumTargetCircularLineDefinitionType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      DatumTargetCircularLineDefinitionType (const DatumTargetCircularLineDefinitionType& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

      virtual DatumTargetCircularLineDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumTargetCircularLineDefinitionType&
      operator= (const DatumTargetCircularLineDefinitionType& x);

      virtual 
      ~DatumTargetCircularLineDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Circle_type > Circle_;
    };

    class DatumTargetCylindricalAreaDefinitionType: public ::xsd::qif2::DatumTargetDefinitionBaseType
    {
      public:
      // Cylinder
      //
      typedef ::xsd::qif2::CylinderType Cylinder_type;
      typedef ::xsd::cxx::tree::traits< Cylinder_type, char > Cylinder_traits;

      const Cylinder_type&
      Cylinder () const;

      Cylinder_type&
      Cylinder ();

      void
      Cylinder (const Cylinder_type& x);

      void
      Cylinder (::std::auto_ptr< Cylinder_type > p);

      // Constructors.
      //
      DatumTargetCylindricalAreaDefinitionType (const DatumTargetLabel_type&,
                                                const id_type&,
                                                const Cylinder_type&);

      DatumTargetCylindricalAreaDefinitionType (const DatumTargetLabel_type&,
                                                const id_type&,
                                                ::std::auto_ptr< Cylinder_type >);

      DatumTargetCylindricalAreaDefinitionType (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      DatumTargetCylindricalAreaDefinitionType (const DatumTargetCylindricalAreaDefinitionType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual DatumTargetCylindricalAreaDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumTargetCylindricalAreaDefinitionType&
      operator= (const DatumTargetCylindricalAreaDefinitionType& x);

      virtual 
      ~DatumTargetCylindricalAreaDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Cylinder_type > Cylinder_;
    };

    class DatumTargetRectangularAreaDefinitionType: public ::xsd::qif2::DatumTargetDefinitionBaseType
    {
      public:
      // Rectangle
      //
      typedef ::xsd::qif2::RectangleType Rectangle_type;
      typedef ::xsd::cxx::tree::traits< Rectangle_type, char > Rectangle_traits;

      const Rectangle_type&
      Rectangle () const;

      Rectangle_type&
      Rectangle ();

      void
      Rectangle (const Rectangle_type& x);

      void
      Rectangle (::std::auto_ptr< Rectangle_type > p);

      // Constructors.
      //
      DatumTargetRectangularAreaDefinitionType (const DatumTargetLabel_type&,
                                                const id_type&,
                                                const Rectangle_type&);

      DatumTargetRectangularAreaDefinitionType (const DatumTargetLabel_type&,
                                                const id_type&,
                                                ::std::auto_ptr< Rectangle_type >);

      DatumTargetRectangularAreaDefinitionType (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      DatumTargetRectangularAreaDefinitionType (const DatumTargetRectangularAreaDefinitionType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual DatumTargetRectangularAreaDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumTargetRectangularAreaDefinitionType&
      operator= (const DatumTargetRectangularAreaDefinitionType& x);

      virtual 
      ~DatumTargetRectangularAreaDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Rectangle_type > Rectangle_;
    };

    class DatumTargetSphereDefinitionType: public ::xsd::qif2::DatumTargetDefinitionBaseType
    {
      public:
      // Sphere
      //
      typedef ::xsd::qif2::SphereType Sphere_type;
      typedef ::xsd::cxx::tree::traits< Sphere_type, char > Sphere_traits;

      const Sphere_type&
      Sphere () const;

      Sphere_type&
      Sphere ();

      void
      Sphere (const Sphere_type& x);

      void
      Sphere (::std::auto_ptr< Sphere_type > p);

      // Constructors.
      //
      DatumTargetSphereDefinitionType (const DatumTargetLabel_type&,
                                       const id_type&,
                                       const Sphere_type&);

      DatumTargetSphereDefinitionType (const DatumTargetLabel_type&,
                                       const id_type&,
                                       ::std::auto_ptr< Sphere_type >);

      DatumTargetSphereDefinitionType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      DatumTargetSphereDefinitionType (const DatumTargetSphereDefinitionType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual DatumTargetSphereDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumTargetSphereDefinitionType&
      operator= (const DatumTargetSphereDefinitionType& x);

      virtual 
      ~DatumTargetSphereDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Sphere_type > Sphere_;
    };

    class DatumTargetIrregularAreaDefinitionType: public ::xsd::qif2::DatumTargetDefinitionBaseType
    {
      public:
      // Boundary
      //
      typedef ::xsd::qif2::PolyLineType Boundary_type;
      typedef ::xsd::cxx::tree::traits< Boundary_type, char > Boundary_traits;

      const Boundary_type&
      Boundary () const;

      Boundary_type&
      Boundary ();

      void
      Boundary (const Boundary_type& x);

      void
      Boundary (::std::auto_ptr< Boundary_type > p);

      // Constructors.
      //
      DatumTargetIrregularAreaDefinitionType (const DatumTargetLabel_type&,
                                              const id_type&,
                                              const Boundary_type&);

      DatumTargetIrregularAreaDefinitionType (const DatumTargetLabel_type&,
                                              const id_type&,
                                              ::std::auto_ptr< Boundary_type >);

      DatumTargetIrregularAreaDefinitionType (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      DatumTargetIrregularAreaDefinitionType (const DatumTargetIrregularAreaDefinitionType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual DatumTargetIrregularAreaDefinitionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DatumTargetIrregularAreaDefinitionType&
      operator= (const DatumTargetIrregularAreaDefinitionType& x);

      virtual 
      ~DatumTargetIrregularAreaDefinitionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Boundary_type > Boundary_;
    };

    class EmployeeType: public ::xml_schema::type
    {
      public:
      // Name
      //
      typedef ::xml_schema::token Name_type;
      typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

      const Name_type&
      Name () const;

      Name_type&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (::std::auto_ptr< Name_type > p);

      // EmployeeId
      //
      typedef ::xml_schema::token EmployeeId_type;
      typedef ::xsd::cxx::tree::optional< EmployeeId_type > EmployeeId_optional;
      typedef ::xsd::cxx::tree::traits< EmployeeId_type, char > EmployeeId_traits;

      const EmployeeId_optional&
      EmployeeId () const;

      EmployeeId_optional&
      EmployeeId ();

      void
      EmployeeId (const EmployeeId_type& x);

      void
      EmployeeId (const EmployeeId_optional& x);

      void
      EmployeeId (::std::auto_ptr< EmployeeId_type > p);

      // Shift
      //
      typedef ::xml_schema::token Shift_type;
      typedef ::xsd::cxx::tree::optional< Shift_type > Shift_optional;
      typedef ::xsd::cxx::tree::traits< Shift_type, char > Shift_traits;

      const Shift_optional&
      Shift () const;

      Shift_optional&
      Shift ();

      void
      Shift (const Shift_type& x);

      void
      Shift (const Shift_optional& x);

      void
      Shift (::std::auto_ptr< Shift_type > p);

      // Constructors.
      //
      EmployeeType (const Name_type&);

      EmployeeType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      EmployeeType (const EmployeeType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual EmployeeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EmployeeType&
      operator= (const EmployeeType& x);

      virtual 
      ~EmployeeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Name_type > Name_;
      EmployeeId_optional EmployeeId_;
      Shift_optional Shift_;
    };

    class FileType: public ::xml_schema::type
    {
      public:
      // Name
      //
      typedef ::xml_schema::token Name_type;
      typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

      const Name_type&
      Name () const;

      Name_type&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (::std::auto_ptr< Name_type > p);

      // Version
      //
      typedef ::xml_schema::token Version_type;
      typedef ::xsd::cxx::tree::optional< Version_type > Version_optional;
      typedef ::xsd::cxx::tree::traits< Version_type, char > Version_traits;

      const Version_optional&
      Version () const;

      Version_optional&
      Version ();

      void
      Version (const Version_type& x);

      void
      Version (const Version_optional& x);

      void
      Version (::std::auto_ptr< Version_type > p);

      // Format
      //
      typedef ::xsd::qif2::DigitalModelFormatType Format_type;
      typedef ::xsd::cxx::tree::optional< Format_type > Format_optional;
      typedef ::xsd::cxx::tree::traits< Format_type, char > Format_traits;

      const Format_optional&
      Format () const;

      Format_optional&
      Format ();

      void
      Format (const Format_type& x);

      void
      Format (const Format_optional& x);

      void
      Format (::std::auto_ptr< Format_type > p);

      // Constructors.
      //
      FileType (const Name_type&);

      FileType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      FileType (const FileType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual FileType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FileType&
      operator= (const FileType& x);

      virtual 
      ~FileType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Name_type > Name_;
      Version_optional Version_;
      Format_optional Format_;
    };

    class SoftwareType: public ::xml_schema::type
    {
      public:
      // VendorName
      //
      typedef ::xml_schema::token VendorName_type;
      typedef ::xsd::cxx::tree::traits< VendorName_type, char > VendorName_traits;

      const VendorName_type&
      VendorName () const;

      VendorName_type&
      VendorName ();

      void
      VendorName (const VendorName_type& x);

      void
      VendorName (::std::auto_ptr< VendorName_type > p);

      // ApplicationName
      //
      typedef ::xml_schema::token ApplicationName_type;
      typedef ::xsd::cxx::tree::traits< ApplicationName_type, char > ApplicationName_traits;

      const ApplicationName_type&
      ApplicationName () const;

      ApplicationName_type&
      ApplicationName ();

      void
      ApplicationName (const ApplicationName_type& x);

      void
      ApplicationName (::std::auto_ptr< ApplicationName_type > p);

      // Version
      //
      typedef ::xml_schema::token Version_type;
      typedef ::xsd::cxx::tree::optional< Version_type > Version_optional;
      typedef ::xsd::cxx::tree::traits< Version_type, char > Version_traits;

      const Version_optional&
      Version () const;

      Version_optional&
      Version ();

      void
      Version (const Version_type& x);

      void
      Version (const Version_optional& x);

      void
      Version (::std::auto_ptr< Version_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, char > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::auto_ptr< Description_type > p);

      // Constructors.
      //
      SoftwareType (const VendorName_type&,
                    const ApplicationName_type&);

      SoftwareType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      SoftwareType (const SoftwareType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual SoftwareType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SoftwareType&
      operator= (const SoftwareType& x);

      virtual 
      ~SoftwareType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< VendorName_type > VendorName_;
      ::xsd::cxx::tree::one< ApplicationName_type > ApplicationName_;
      Version_optional Version_;
      Description_optional Description_;
    };

    class OrganizationType: public ::xml_schema::type
    {
      public:
      // Name
      //
      typedef ::xml_schema::token Name_type;
      typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

      const Name_type&
      Name () const;

      Name_type&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (::std::auto_ptr< Name_type > p);

      // Address
      //
      typedef ::xsd::qif2::PhysicalAddressType Address_type;
      typedef ::xsd::cxx::tree::optional< Address_type > Address_optional;
      typedef ::xsd::cxx::tree::traits< Address_type, char > Address_traits;

      const Address_optional&
      Address () const;

      Address_optional&
      Address ();

      void
      Address (const Address_type& x);

      void
      Address (const Address_optional& x);

      void
      Address (::std::auto_ptr< Address_type > p);

      // Constructors.
      //
      OrganizationType (const Name_type&);

      OrganizationType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      OrganizationType (const OrganizationType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual OrganizationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OrganizationType&
      operator= (const OrganizationType& x);

      virtual 
      ~OrganizationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Name_type > Name_;
      Address_optional Address_;
    };

    class PhysicalAddressType: public ::xml_schema::type
    {
      public:
      // Description
      //
      typedef ::xsd::qif2::AddressDescriptionType Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, char > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::auto_ptr< Description_type > p);

      // InternalLocation
      //
      typedef ::xml_schema::token InternalLocation_type;
      typedef ::xsd::cxx::tree::optional< InternalLocation_type > InternalLocation_optional;
      typedef ::xsd::cxx::tree::traits< InternalLocation_type, char > InternalLocation_traits;

      const InternalLocation_optional&
      InternalLocation () const;

      InternalLocation_optional&
      InternalLocation ();

      void
      InternalLocation (const InternalLocation_type& x);

      void
      InternalLocation (const InternalLocation_optional& x);

      void
      InternalLocation (::std::auto_ptr< InternalLocation_type > p);

      // StreetNumber
      //
      typedef ::xml_schema::token StreetNumber_type;
      typedef ::xsd::cxx::tree::optional< StreetNumber_type > StreetNumber_optional;
      typedef ::xsd::cxx::tree::traits< StreetNumber_type, char > StreetNumber_traits;

      const StreetNumber_optional&
      StreetNumber () const;

      StreetNumber_optional&
      StreetNumber ();

      void
      StreetNumber (const StreetNumber_type& x);

      void
      StreetNumber (const StreetNumber_optional& x);

      void
      StreetNumber (::std::auto_ptr< StreetNumber_type > p);

      // Street
      //
      typedef ::xml_schema::token Street_type;
      typedef ::xsd::cxx::tree::optional< Street_type > Street_optional;
      typedef ::xsd::cxx::tree::traits< Street_type, char > Street_traits;

      const Street_optional&
      Street () const;

      Street_optional&
      Street ();

      void
      Street (const Street_type& x);

      void
      Street (const Street_optional& x);

      void
      Street (::std::auto_ptr< Street_type > p);

      // PostalBox
      //
      typedef ::xml_schema::token PostalBox_type;
      typedef ::xsd::cxx::tree::optional< PostalBox_type > PostalBox_optional;
      typedef ::xsd::cxx::tree::traits< PostalBox_type, char > PostalBox_traits;

      const PostalBox_optional&
      PostalBox () const;

      PostalBox_optional&
      PostalBox ();

      void
      PostalBox (const PostalBox_type& x);

      void
      PostalBox (const PostalBox_optional& x);

      void
      PostalBox (::std::auto_ptr< PostalBox_type > p);

      // Town
      //
      typedef ::xml_schema::token Town_type;
      typedef ::xsd::cxx::tree::optional< Town_type > Town_optional;
      typedef ::xsd::cxx::tree::traits< Town_type, char > Town_traits;

      const Town_optional&
      Town () const;

      Town_optional&
      Town ();

      void
      Town (const Town_type& x);

      void
      Town (const Town_optional& x);

      void
      Town (::std::auto_ptr< Town_type > p);

      // Region
      //
      typedef ::xml_schema::token Region_type;
      typedef ::xsd::cxx::tree::optional< Region_type > Region_optional;
      typedef ::xsd::cxx::tree::traits< Region_type, char > Region_traits;

      const Region_optional&
      Region () const;

      Region_optional&
      Region ();

      void
      Region (const Region_type& x);

      void
      Region (const Region_optional& x);

      void
      Region (::std::auto_ptr< Region_type > p);

      // PostalCode
      //
      typedef ::xml_schema::token PostalCode_type;
      typedef ::xsd::cxx::tree::optional< PostalCode_type > PostalCode_optional;
      typedef ::xsd::cxx::tree::traits< PostalCode_type, char > PostalCode_traits;

      const PostalCode_optional&
      PostalCode () const;

      PostalCode_optional&
      PostalCode ();

      void
      PostalCode (const PostalCode_type& x);

      void
      PostalCode (const PostalCode_optional& x);

      void
      PostalCode (::std::auto_ptr< PostalCode_type > p);

      // Country
      //
      typedef ::xml_schema::token Country_type;
      typedef ::xsd::cxx::tree::optional< Country_type > Country_optional;
      typedef ::xsd::cxx::tree::traits< Country_type, char > Country_traits;

      const Country_optional&
      Country () const;

      Country_optional&
      Country ();

      void
      Country (const Country_type& x);

      void
      Country (const Country_optional& x);

      void
      Country (::std::auto_ptr< Country_type > p);

      // FacsimileNumber
      //
      typedef ::xml_schema::token FacsimileNumber_type;
      typedef ::xsd::cxx::tree::optional< FacsimileNumber_type > FacsimileNumber_optional;
      typedef ::xsd::cxx::tree::traits< FacsimileNumber_type, char > FacsimileNumber_traits;

      const FacsimileNumber_optional&
      FacsimileNumber () const;

      FacsimileNumber_optional&
      FacsimileNumber ();

      void
      FacsimileNumber (const FacsimileNumber_type& x);

      void
      FacsimileNumber (const FacsimileNumber_optional& x);

      void
      FacsimileNumber (::std::auto_ptr< FacsimileNumber_type > p);

      // TelephoneNumber
      //
      typedef ::xml_schema::token TelephoneNumber_type;
      typedef ::xsd::cxx::tree::optional< TelephoneNumber_type > TelephoneNumber_optional;
      typedef ::xsd::cxx::tree::traits< TelephoneNumber_type, char > TelephoneNumber_traits;

      const TelephoneNumber_optional&
      TelephoneNumber () const;

      TelephoneNumber_optional&
      TelephoneNumber ();

      void
      TelephoneNumber (const TelephoneNumber_type& x);

      void
      TelephoneNumber (const TelephoneNumber_optional& x);

      void
      TelephoneNumber (::std::auto_ptr< TelephoneNumber_type > p);

      // ElectronicMailAddress
      //
      typedef ::xml_schema::token ElectronicMailAddress_type;
      typedef ::xsd::cxx::tree::optional< ElectronicMailAddress_type > ElectronicMailAddress_optional;
      typedef ::xsd::cxx::tree::traits< ElectronicMailAddress_type, char > ElectronicMailAddress_traits;

      const ElectronicMailAddress_optional&
      ElectronicMailAddress () const;

      ElectronicMailAddress_optional&
      ElectronicMailAddress ();

      void
      ElectronicMailAddress (const ElectronicMailAddress_type& x);

      void
      ElectronicMailAddress (const ElectronicMailAddress_optional& x);

      void
      ElectronicMailAddress (::std::auto_ptr< ElectronicMailAddress_type > p);

      // TelexNumber
      //
      typedef ::xml_schema::token TelexNumber_type;
      typedef ::xsd::cxx::tree::optional< TelexNumber_type > TelexNumber_optional;
      typedef ::xsd::cxx::tree::traits< TelexNumber_type, char > TelexNumber_traits;

      const TelexNumber_optional&
      TelexNumber () const;

      TelexNumber_optional&
      TelexNumber ();

      void
      TelexNumber (const TelexNumber_type& x);

      void
      TelexNumber (const TelexNumber_optional& x);

      void
      TelexNumber (::std::auto_ptr< TelexNumber_type > p);

      // Constructors.
      //
      PhysicalAddressType ();

      PhysicalAddressType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      PhysicalAddressType (const PhysicalAddressType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual PhysicalAddressType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PhysicalAddressType&
      operator= (const PhysicalAddressType& x);

      virtual 
      ~PhysicalAddressType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Description_optional Description_;
      InternalLocation_optional InternalLocation_;
      StreetNumber_optional StreetNumber_;
      Street_optional Street_;
      PostalBox_optional PostalBox_;
      Town_optional Town_;
      Region_optional Region_;
      PostalCode_optional PostalCode_;
      Country_optional Country_;
      FacsimileNumber_optional FacsimileNumber_;
      TelephoneNumber_optional TelephoneNumber_;
      ElectronicMailAddress_optional ElectronicMailAddress_;
      TelexNumber_optional TelexNumber_;
    };

    class AddressDescriptionEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        DELIVERY,
        POSTAL,
        VISITOR,
        NOTDEFINED
      };

      AddressDescriptionEnumType (value v);

      AddressDescriptionEnumType (const char* v);

      AddressDescriptionEnumType (const ::std::string& v);

      AddressDescriptionEnumType (const ::xml_schema::nmtoken& v);

      AddressDescriptionEnumType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      AddressDescriptionEnumType (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      AddressDescriptionEnumType (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      AddressDescriptionEnumType (const AddressDescriptionEnumType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual AddressDescriptionEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AddressDescriptionEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_AddressDescriptionEnumType_convert ();
      }

      protected:
      value
      _xsd_AddressDescriptionEnumType_convert () const;

      public:
      static const char* const _xsd_AddressDescriptionEnumType_literals_[4];
      static const value _xsd_AddressDescriptionEnumType_indexes_[4];
    };

    class AddressDescriptionType: public ::xml_schema::type
    {
      public:
      // AddressDescriptionEnum
      //
      typedef ::xsd::qif2::AddressDescriptionEnumType AddressDescriptionEnum_type;
      typedef ::xsd::cxx::tree::optional< AddressDescriptionEnum_type > AddressDescriptionEnum_optional;
      typedef ::xsd::cxx::tree::traits< AddressDescriptionEnum_type, char > AddressDescriptionEnum_traits;

      const AddressDescriptionEnum_optional&
      AddressDescriptionEnum () const;

      AddressDescriptionEnum_optional&
      AddressDescriptionEnum ();

      void
      AddressDescriptionEnum (const AddressDescriptionEnum_type& x);

      void
      AddressDescriptionEnum (const AddressDescriptionEnum_optional& x);

      void
      AddressDescriptionEnum (::std::auto_ptr< AddressDescriptionEnum_type > p);

      // OtherAddressDescription
      //
      typedef ::xml_schema::string OtherAddressDescription_type;
      typedef ::xsd::cxx::tree::optional< OtherAddressDescription_type > OtherAddressDescription_optional;
      typedef ::xsd::cxx::tree::traits< OtherAddressDescription_type, char > OtherAddressDescription_traits;

      const OtherAddressDescription_optional&
      OtherAddressDescription () const;

      OtherAddressDescription_optional&
      OtherAddressDescription ();

      void
      OtherAddressDescription (const OtherAddressDescription_type& x);

      void
      OtherAddressDescription (const OtherAddressDescription_optional& x);

      void
      OtherAddressDescription (::std::auto_ptr< OtherAddressDescription_type > p);

      // Constructors.
      //
      AddressDescriptionType ();

      AddressDescriptionType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      AddressDescriptionType (const AddressDescriptionType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual AddressDescriptionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AddressDescriptionType&
      operator= (const AddressDescriptionType& x);

      virtual 
      ~AddressDescriptionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      AddressDescriptionEnum_optional AddressDescriptionEnum_;
      OtherAddressDescription_optional OtherAddressDescription_;
    };

    class LocationType: public ::xml_schema::type
    {
      public:
      // LocationDescription
      //
      typedef ::xml_schema::string LocationDescription_type;
      typedef ::xsd::cxx::tree::traits< LocationDescription_type, char > LocationDescription_traits;

      const LocationDescription_type&
      LocationDescription () const;

      LocationDescription_type&
      LocationDescription ();

      void
      LocationDescription (const LocationDescription_type& x);

      void
      LocationDescription (::std::auto_ptr< LocationDescription_type > p);

      // Address
      //
      typedef ::xsd::qif2::PhysicalAddressType Address_type;
      typedef ::xsd::cxx::tree::optional< Address_type > Address_optional;
      typedef ::xsd::cxx::tree::traits< Address_type, char > Address_traits;

      const Address_optional&
      Address () const;

      Address_optional&
      Address ();

      void
      Address (const Address_type& x);

      void
      Address (const Address_optional& x);

      void
      Address (::std::auto_ptr< Address_type > p);

      // id
      //
      typedef ::xsd::qif2::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::auto_ptr< id_type > p);

      // Constructors.
      //
      LocationType (const LocationDescription_type&,
                    const id_type&);

      LocationType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      LocationType (const LocationType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual LocationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LocationType&
      operator= (const LocationType& x);

      virtual 
      ~LocationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< LocationDescription_type > LocationDescription_;
      Address_optional Address_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class CustomerOrganizationType: public ::xsd::qif2::OrganizationType
    {
      public:
      // CustomerNumber
      //
      typedef ::xml_schema::token CustomerNumber_type;
      typedef ::xsd::cxx::tree::traits< CustomerNumber_type, char > CustomerNumber_traits;

      const CustomerNumber_type&
      CustomerNumber () const;

      CustomerNumber_type&
      CustomerNumber ();

      void
      CustomerNumber (const CustomerNumber_type& x);

      void
      CustomerNumber (::std::auto_ptr< CustomerNumber_type > p);

      // Constructors.
      //
      CustomerOrganizationType (const Name_type&,
                                const CustomerNumber_type&);

      CustomerOrganizationType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      CustomerOrganizationType (const CustomerOrganizationType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual CustomerOrganizationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CustomerOrganizationType&
      operator= (const CustomerOrganizationType& x);

      virtual 
      ~CustomerOrganizationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CustomerNumber_type > CustomerNumber_;
    };

    class VersionHistoryType: public ::xml_schema::type
    {
      public:
      // EarlierVersion
      //
      typedef ::xsd::qif2::VersionReferenceType EarlierVersion_type;
      typedef ::xsd::cxx::tree::sequence< EarlierVersion_type > EarlierVersion_sequence;
      typedef EarlierVersion_sequence::iterator EarlierVersion_iterator;
      typedef EarlierVersion_sequence::const_iterator EarlierVersion_const_iterator;
      typedef ::xsd::cxx::tree::traits< EarlierVersion_type, char > EarlierVersion_traits;

      const EarlierVersion_sequence&
      EarlierVersion () const;

      EarlierVersion_sequence&
      EarlierVersion ();

      void
      EarlierVersion (const EarlierVersion_sequence& s);

      // Constructors.
      //
      VersionHistoryType ();

      VersionHistoryType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      VersionHistoryType (const VersionHistoryType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual VersionHistoryType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      VersionHistoryType&
      operator= (const VersionHistoryType& x);

      virtual 
      ~VersionHistoryType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      EarlierVersion_sequence EarlierVersion_;
    };

    class VersionBaseType: public ::xml_schema::type
    {
      public:
      // TimeCreated
      //
      typedef ::xml_schema::date_time TimeCreated_type;
      typedef ::xsd::cxx::tree::optional< TimeCreated_type > TimeCreated_optional;
      typedef ::xsd::cxx::tree::traits< TimeCreated_type, char > TimeCreated_traits;

      const TimeCreated_optional&
      TimeCreated () const;

      TimeCreated_optional&
      TimeCreated ();

      void
      TimeCreated (const TimeCreated_type& x);

      void
      TimeCreated (const TimeCreated_optional& x);

      void
      TimeCreated (::std::auto_ptr< TimeCreated_type > p);

      // SignOffs
      //
      typedef ::xsd::qif2::SignOffsType SignOffs_type;
      typedef ::xsd::cxx::tree::optional< SignOffs_type > SignOffs_optional;
      typedef ::xsd::cxx::tree::traits< SignOffs_type, char > SignOffs_traits;

      const SignOffs_optional&
      SignOffs () const;

      SignOffs_optional&
      SignOffs ();

      void
      SignOffs (const SignOffs_type& x);

      void
      SignOffs (const SignOffs_optional& x);

      void
      SignOffs (::std::auto_ptr< SignOffs_type > p);

      // Constructors.
      //
      VersionBaseType ();

      VersionBaseType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      VersionBaseType (const VersionBaseType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual VersionBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      VersionBaseType&
      operator= (const VersionBaseType& x);

      virtual 
      ~VersionBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      TimeCreated_optional TimeCreated_;
      SignOffs_optional SignOffs_;
    };

    class VersionType: public ::xsd::qif2::VersionBaseType
    {
      public:
      // ThisInstanceQPId
      //
      typedef ::xsd::qif2::QPIdType ThisInstanceQPId_type;
      typedef ::xsd::cxx::tree::optional< ThisInstanceQPId_type > ThisInstanceQPId_optional;
      typedef ::xsd::cxx::tree::traits< ThisInstanceQPId_type, char > ThisInstanceQPId_traits;

      const ThisInstanceQPId_optional&
      ThisInstanceQPId () const;

      ThisInstanceQPId_optional&
      ThisInstanceQPId ();

      void
      ThisInstanceQPId (const ThisInstanceQPId_type& x);

      void
      ThisInstanceQPId (const ThisInstanceQPId_optional& x);

      void
      ThisInstanceQPId (::std::auto_ptr< ThisInstanceQPId_type > p);

      // Constructors.
      //
      VersionType ();

      VersionType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      VersionType (const VersionType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual VersionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      VersionType&
      operator= (const VersionType& x);

      virtual 
      ~VersionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThisInstanceQPId_optional ThisInstanceQPId_;
    };

    class VersionReferenceType: public ::xsd::qif2::VersionBaseType
    {
      public:
      // QPIdReference
      //
      typedef ::xsd::qif2::QPIdReferenceType QPIdReference_type;
      typedef ::xsd::cxx::tree::optional< QPIdReference_type > QPIdReference_optional;
      typedef ::xsd::cxx::tree::traits< QPIdReference_type, char > QPIdReference_traits;

      const QPIdReference_optional&
      QPIdReference () const;

      QPIdReference_optional&
      QPIdReference ();

      void
      QPIdReference (const QPIdReference_type& x);

      void
      QPIdReference (const QPIdReference_optional& x);

      void
      QPIdReference (::std::auto_ptr< QPIdReference_type > p);

      // Constructors.
      //
      VersionReferenceType ();

      VersionReferenceType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      VersionReferenceType (const VersionReferenceType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual VersionReferenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      VersionReferenceType&
      operator= (const VersionReferenceType& x);

      virtual 
      ~VersionReferenceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      QPIdReference_optional QPIdReference_;
    };

    class SignOffsType: public ::xml_schema::type
    {
      public:
      // Employee
      //
      typedef ::xsd::qif2::EmployeeType Employee_type;
      typedef ::xsd::cxx::tree::sequence< Employee_type > Employee_sequence;
      typedef Employee_sequence::iterator Employee_iterator;
      typedef Employee_sequence::const_iterator Employee_const_iterator;
      typedef ::xsd::cxx::tree::traits< Employee_type, char > Employee_traits;

      const Employee_sequence&
      Employee () const;

      Employee_sequence&
      Employee ();

      void
      Employee (const Employee_sequence& s);

      // Constructors.
      //
      SignOffsType ();

      SignOffsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      SignOffsType (const SignOffsType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual SignOffsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SignOffsType&
      operator= (const SignOffsType& x);

      virtual 
      ~SignOffsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Employee_sequence Employee_;
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace xsd
{
  namespace qif2
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace xsd
{
  namespace qif2
  {
    void
    operator<< (::xercesc::DOMElement&, const FormalStandardEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const FormalStandardEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const FormalStandardEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const FormalStandardType&);

    void
    operator<< (::xercesc::DOMElement&, const SequencedDatumType&);

    void
    operator<< (::xercesc::DOMElement&, const CompoundDatumType&);

    void
    operator<< (::xercesc::DOMElement&, const DatumWithPrecedenceType&);

    void
    operator<< (::xercesc::DOMElement&, const DatumType&);

    void
    operator<< (::xercesc::DOMElement&, const DatumTranslationType&);

    void
    operator<< (::xercesc::DOMElement&, const DatumFeatureBaseType&);

    void
    operator<< (::xercesc::DOMElement&, const ActualDatumFeatureType&);

    void
    operator<< (::xercesc::DOMElement&, const NominalDatumFeatureType&);

    void
    operator<< (::xercesc::DOMElement&, const DatumFeatureSimulatorModifierType&);

    void
    operator<< (::xercesc::DOMElement&, const DatumReferenceFrameType&);

    void
    operator<< (::xercesc::DOMElement&, const DegreeOfFreedomEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const DegreeOfFreedomEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const DegreeOfFreedomEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const ISODegreeOfFreedomEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const ISODegreeOfFreedomEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const ISODegreeOfFreedomEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const IntersectionPlaneEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const IntersectionPlaneEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const IntersectionPlaneEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const IntersectionPlaneType&);

    void
    operator<< (::xercesc::DOMElement&, const ModifyingPlaneEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const ModifyingPlaneEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const ModifyingPlaneEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const DirectionFeatureType&);

    void
    operator<< (::xercesc::DOMElement&, const CollectionPlaneType&);

    void
    operator<< (::xercesc::DOMElement&, const OrientationPlaneType&);

    void
    operator<< (::xercesc::DOMElement&, const ReducedDatumEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const ReducedDatumEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const ReducedDatumEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const DegreesOfFreedomType&);

    void
    operator<< (::xercesc::DOMElement&, const DiameterModifierEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const DiameterModifierEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const DiameterModifierEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const SectionModifierEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const SectionModifierEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const SectionModifierEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const PointWithNormalBaseType&);

    void
    operator<< (::xercesc::DOMElement&, const ActualPointWithNormalBaseType&);

    void
    operator<< (::xercesc::DOMElement&, const MeasurePointNominalType&);

    void
    operator<< (::xercesc::DOMElement&, const MeasurePointActualType&);

    void
    operator<< (::xercesc::DOMElement&, const MovableDatumTargetDirectionType&);

    void
    operator<< (::xercesc::DOMElement&, const TargetPointActualType&);

    void
    operator<< (::xercesc::DOMElement&, const TargetPointNominalType&);

    void
    operator<< (::xercesc::DOMElement&, const TransformListType&);

    void
    operator<< (::xercesc::DOMElement&, const TransformInstanceType&);

    void
    operator<< (::xercesc::DOMElement&, const LinearCoordinateDirectionEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const LinearCoordinateDirectionEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const LinearCoordinateDirectionEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const AngularCoordinateDirectionEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const AngularCoordinateDirectionEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const AngularCoordinateDirectionEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const SubstituteFeatureAlgorithmBaseType&);

    void
    operator<< (::xercesc::DOMAttr&, const SubstituteFeatureAlgorithmBaseType&);

    void
    operator<< (::xml_schema::list_stream&,
                const SubstituteFeatureAlgorithmBaseType&);

    void
    operator<< (::xercesc::DOMElement&, const FeatureOfSizeSubstituteFeatureAlgorithmEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const FeatureOfSizeSubstituteFeatureAlgorithmEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const FeatureOfSizeSubstituteFeatureAlgorithmEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const FeatureOfSizeSubstituteFeatureAlgorithmType&);

    void
    operator<< (::xercesc::DOMElement&, const NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const NonFeatureOfSizeSubstituteFeatureAlgorithmEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const NonFeatureOfSizeSubstituteFeatureAlgorithmType&);

    void
    operator<< (::xercesc::DOMElement&, const CurveSubstituteFeatureAlgorithmEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const CurveSubstituteFeatureAlgorithmEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const CurveSubstituteFeatureAlgorithmEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const CurveSubstituteFeatureAlgorithmType&);

    void
    operator<< (::xercesc::DOMElement&, const SurfaceSubstituteFeatureAlgorithmEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const SurfaceSubstituteFeatureAlgorithmEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const SurfaceSubstituteFeatureAlgorithmEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const SurfaceSubstituteFeatureAlgorithmType&);

    void
    operator<< (::xercesc::DOMElement&, const MaterialModifierEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const MaterialModifierEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const MaterialModifierEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const PrecedenceEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const PrecedenceEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const PrecedenceEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const PrecedenceType&);

    void
    operator<< (::xercesc::DOMElement&, const ReferencedComponentEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const ReferencedComponentEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const ReferencedComponentEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const RetrievalMethodEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const RetrievalMethodEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const RetrievalMethodEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const MeasurementDirectiveEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const MeasurementDirectiveEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const MeasurementDirectiveEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const MeasurementDirectiveType&);

    void
    operator<< (::xercesc::DOMElement&, const DistanceBetweenAnalysisModeEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const DistanceBetweenAnalysisModeEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const DistanceBetweenAnalysisModeEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const AngleBetweenAnalysisModeEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const AngleBetweenAnalysisModeEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const AngleBetweenAnalysisModeEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const BaseFeatureType&);

    void
    operator<< (::xercesc::DOMElement&, const SequencedBaseFeatureType&);

    void
    operator<< (::xercesc::DOMElement&, const DirectionalOffsetType&);

    void
    operator<< (::xercesc::DOMElement&, const AlignmentFeatureType&);

    void
    operator<< (::xercesc::DOMElement&, const AlignmentOperationBaseType&);

    void
    operator<< (::xercesc::DOMElement&, const PrimaryAlignmentOperationType&);

    void
    operator<< (::xercesc::DOMElement&, const SecondaryAlignmentOperationType&);

    void
    operator<< (::xercesc::DOMElement&, const ActualOriginOffsetType&);

    void
    operator<< (::xercesc::DOMElement&, const ActualOffsetAlignmentOperationType&);

    void
    operator<< (::xercesc::DOMElement&, const NominalOffsetAlignmentOperationType&);

    void
    operator<< (::xercesc::DOMElement&, const NominalRotationAlignmentOperationType&);

    void
    operator<< (::xercesc::DOMElement&, const DatumPrecedenceAlignmentOperationType&);

    void
    operator<< (::xercesc::DOMElement&, const BestFitAlignmentOperationType&);

    void
    operator<< (::xercesc::DOMElement&, const MachineCoordinateSystemOperationType&);

    void
    operator<< (::xercesc::DOMElement&, const AlignmentOperationsType&);

    void
    operator<< (::xercesc::DOMElement&, const CoordinateSystemListType&);

    void
    operator<< (::xercesc::DOMElement&, const CoordinateSystemType&);

    void
    operator<< (::xercesc::DOMElement&, const CoordinateSystemActualTransformType&);

    void
    operator<< (::xercesc::DOMElement&, const CoordinateSystemActualTransformsType&);

    void
    operator<< (::xercesc::DOMElement&, const ThreadSpecificationDetailedBaseType&);

    void
    operator<< (::xercesc::DOMElement&, const SingleLeadThreadSpecificationType&);

    void
    operator<< (::xercesc::DOMElement&, const MultiLeadThreadSpecificationType&);

    void
    operator<< (::xercesc::DOMElement&, const ThreadSpecificationType&);

    void
    operator<< (::xercesc::DOMElement&, const TextThreadSpecificationType&);

    void
    operator<< (::xercesc::DOMElement&, const ThreadSpecificationsType&);

    void
    operator<< (::xercesc::DOMElement&, const ToleranceZonePerUnitAreaType&);

    void
    operator<< (::xercesc::DOMElement&, const ToleranceZonePerUnitLengthType&);

    void
    operator<< (::xercesc::DOMElement&, const ToleranceZonePerUnitAngleType&);

    void
    operator<< (::xercesc::DOMElement&, const ToleranceZonePerUnitPolarAreaType&);

    void
    operator<< (::xercesc::DOMElement&, const CompoundFeatureGeometryEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const CompoundFeatureGeometryEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const CompoundFeatureGeometryEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const DatumReferenceFramesType&);

    void
    operator<< (::xercesc::DOMElement&, const EventBaseType&);

    void
    operator<< (::xercesc::DOMElement&, const NotableEventType&);

    void
    operator<< (::xercesc::DOMElement&, const NotableEventsType&);

    void
    operator<< (::xercesc::DOMElement&, const NotedEventType&);

    void
    operator<< (::xercesc::DOMElement&, const NotedEventsType&);

    void
    operator<< (::xercesc::DOMElement&, const InspectionStatusEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const InspectionStatusEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const InspectionStatusEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const InspectionStatusType&);

    void
    operator<< (::xercesc::DOMElement&, const EntityExternalType&);

    void
    operator<< (::xercesc::DOMElement&, const EntitiesExternalType&);

    void
    operator<< (::xercesc::DOMElement&, const ZoneDataType&);

    void
    operator<< (::xercesc::DOMElement&, const LinearToleranceType&);

    void
    operator<< (::xercesc::DOMElement&, const LinearToleranceDefinitionType&);

    void
    operator<< (::xercesc::DOMElement&, const AngularToleranceType&);

    void
    operator<< (::xercesc::DOMElement&, const AngularToleranceDefinitionType&);

    void
    operator<< (::xercesc::DOMElement&, const TemperatureToleranceType&);

    void
    operator<< (::xercesc::DOMElement&, const AreaToleranceType&);

    void
    operator<< (::xercesc::DOMElement&, const ForceToleranceType&);

    void
    operator<< (::xercesc::DOMElement&, const MassToleranceType&);

    void
    operator<< (::xercesc::DOMElement&, const PressureToleranceType&);

    void
    operator<< (::xercesc::DOMElement&, const SpeedToleranceType&);

    void
    operator<< (::xercesc::DOMElement&, const TimeToleranceType&);

    void
    operator<< (::xercesc::DOMElement&, const DimensionModifierEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const DimensionModifierEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const DimensionModifierEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const NonToleranceEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const NonToleranceEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const NonToleranceEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const CommonFileSpecEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const CommonFileSpecEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const CommonFileSpecEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const FileSpecType&);

    void
    operator<< (::xercesc::DOMElement&, const ExternalFileReferenceType&);

    void
    operator<< (::xercesc::DOMElement&, const DatumTargetDefinitionsType&);

    void
    operator<< (::xercesc::DOMElement&, const DatumDefinitionType&);

    void
    operator<< (::xercesc::DOMElement&, const DatumDefinitionsType&);

    void
    operator<< (::xercesc::DOMElement&, const DatumTargetDefinitionBaseType&);

    void
    operator<< (::xercesc::DOMElement&, const DatumTargetPointDefinitionType&);

    void
    operator<< (::xercesc::DOMElement&, const DatumTargetLineDefinitionType&);

    void
    operator<< (::xercesc::DOMElement&, const DatumTargetCircularAreaDefinitionType&);

    void
    operator<< (::xercesc::DOMElement&, const DatumTargetCircularLineDefinitionType&);

    void
    operator<< (::xercesc::DOMElement&, const DatumTargetCylindricalAreaDefinitionType&);

    void
    operator<< (::xercesc::DOMElement&, const DatumTargetRectangularAreaDefinitionType&);

    void
    operator<< (::xercesc::DOMElement&, const DatumTargetSphereDefinitionType&);

    void
    operator<< (::xercesc::DOMElement&, const DatumTargetIrregularAreaDefinitionType&);

    void
    operator<< (::xercesc::DOMElement&, const EmployeeType&);

    void
    operator<< (::xercesc::DOMElement&, const FileType&);

    void
    operator<< (::xercesc::DOMElement&, const SoftwareType&);

    void
    operator<< (::xercesc::DOMElement&, const OrganizationType&);

    void
    operator<< (::xercesc::DOMElement&, const PhysicalAddressType&);

    void
    operator<< (::xercesc::DOMElement&, const AddressDescriptionEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const AddressDescriptionEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const AddressDescriptionEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const AddressDescriptionType&);

    void
    operator<< (::xercesc::DOMElement&, const LocationType&);

    void
    operator<< (::xercesc::DOMElement&, const CustomerOrganizationType&);

    void
    operator<< (::xercesc::DOMElement&, const VersionHistoryType&);

    void
    operator<< (::xercesc::DOMElement&, const VersionBaseType&);

    void
    operator<< (::xercesc::DOMElement&, const VersionType&);

    void
    operator<< (::xercesc::DOMElement&, const VersionReferenceType&);

    void
    operator<< (::xercesc::DOMElement&, const SignOffsType&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // INTERMEDIATES_PMI_HXX
