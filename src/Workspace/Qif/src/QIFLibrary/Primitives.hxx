// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef PRIMITIVES_HXX
#define PRIMITIVES_HXX

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< char > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< char > not_derived;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace xsd
{
  namespace qif2
  {
    class BinaryDataType;
    class ListIntType;
    class I2Type;
    class ListDoubleType;
    class D3Type;
    class D2Type;
    class DoublePositiveType;
    class Point2dSimpleType;
    class UnitVector2dSimpleType;
    class ParameterRangeType;
    class PointSimpleType;
    class VectorSimpleType;
    class UnitVectorSimpleType;
    class ValidityEnumType;
    class PointType;
    class ActualPointType;
    class VectorType;
    class UnitVectorType;
    class ActualUnitVectorType;
    class ArrayPoint2dType;
    class ArrayPointType;
    class ArrayUnitVectorType;
    class PolyLineType;
    class PlaneType;
    class ActualPlaneType;
    class PlaneXType;
    class AxisType;
    class ActualAxisType;
    class TransformRotationType;
    class CoordinateSystemCoreType;
    class TransformMatrixType;
    class LineSegmentType;
    class LineSegment2dType;
    class LatitudeLongitudeSweepType;
    class OrientedLatitudeLongitudeSweepType;
    class SweepType;
    class AngleRangeType;
    class QIFIdType;
    class QIFReferenceType;
    class QIFReferenceFullType;
    class ElementReferenceType;
    class ElementReferenceFullType;
    class D4Type;
    class NaturalType;
    class ListNaturalType;
    class ArrayNaturalType;
    class ArrayReferenceType;
    class ArrayReferenceFullType;
    class ListBoolType;
    class ListUnsignedByteType;
    class QPIdType;
    class QPIdReferenceType;
    class QPIdFullReferenceType;
    class ArrayUnsignedByteType;
    class ArrayIntType;
    class ArrayI2Type;
    class ArrayI3Type;
    class ArrayDoubleType;
    class ArrayBinaryType;
    class AttributesType;
    class AttributeBaseType;
    class AttributeBoolType;
    class AttributeStrType;
    class AttributeQPIdType;
    class AttributeI1Type;
    class AttributeI2Type;
    class AttributeD1Type;
    class AttributeD3Type;
    class AttributeUserType;
    class UserDataXMLType;
  }
}


#include <memory>    // ::std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "../QIFLibrary/Units.hxx"

namespace xsd
{
  namespace qif2
  {
    class BinaryDataType: public ::xml_schema::base64_binary
    {
      public:
      // N
      //
      typedef ::xml_schema::unsigned_int N_type;
      typedef ::xsd::cxx::tree::traits< N_type, char > N_traits;

      const N_type&
      N () const;

      N_type&
      N ();

      void
      N (const N_type& x);

      // Constructors.
      //
      BinaryDataType (const N_type&);

      BinaryDataType (const ::xml_schema::base64_binary&,
                      const N_type&);

      BinaryDataType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      BinaryDataType (const BinaryDataType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual BinaryDataType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BinaryDataType&
      operator= (const BinaryDataType& x);

      virtual 
      ~BinaryDataType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< N_type > N_;
    };

    class ListIntType: public ::xml_schema::simple_type,
      public ::xsd::cxx::tree::list< ::xml_schema::integer, char >
    {
      public:
      ListIntType ();

      ListIntType (size_type n, const ::xml_schema::integer& x);

      template < typename I >
      ListIntType (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::xml_schema::integer, char > (begin, end, this)
      {
      }

      ListIntType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      ListIntType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      ListIntType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      ListIntType (const ListIntType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual ListIntType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ListIntType ();
    };

    class I2Type: public ::xsd::qif2::ListIntType
    {
      public:
      // Constructors.
      //
      I2Type ();

      I2Type (const ::xsd::qif2::ListIntType&);

      I2Type (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      I2Type (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      I2Type (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      I2Type (const I2Type& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      virtual I2Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~I2Type ();
    };

    class ListDoubleType: public ::xml_schema::simple_type,
      public ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ >
    {
      public:
      ListDoubleType ();

      ListDoubleType (size_type n, const ::xml_schema::double_& x);

      template < typename I >
      ListDoubleType (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (begin, end, this)
      {
      }

      ListDoubleType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ListDoubleType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ListDoubleType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ListDoubleType (const ListDoubleType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual ListDoubleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ListDoubleType ();
    };

    class D3Type: public ::xsd::qif2::ListDoubleType
    {
      public:
      // Constructors.
      //
      D3Type ();

      D3Type (const ::xsd::qif2::ListDoubleType&);

      D3Type (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      D3Type (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      D3Type (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      D3Type (const D3Type& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      virtual D3Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~D3Type ();
    };

    class D2Type: public ::xsd::qif2::ListDoubleType
    {
      public:
      // Constructors.
      //
      D2Type ();

      D2Type (const ::xsd::qif2::ListDoubleType&);

      D2Type (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      D2Type (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      D2Type (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      D2Type (const D2Type& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      virtual D2Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~D2Type ();
    };

    class DoublePositiveType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
    {
      public:
      // Constructors.
      //
      DoublePositiveType (const ::xml_schema::double_&);

      DoublePositiveType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      DoublePositiveType (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      DoublePositiveType (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      DoublePositiveType (const DoublePositiveType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual DoublePositiveType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~DoublePositiveType ();
    };

    class Point2dSimpleType: public ::xsd::qif2::ListDoubleType
    {
      public:
      // Constructors.
      //
      Point2dSimpleType ();

      Point2dSimpleType (const ::xsd::qif2::ListDoubleType&);

      Point2dSimpleType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      Point2dSimpleType (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      Point2dSimpleType (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      Point2dSimpleType (const Point2dSimpleType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual Point2dSimpleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~Point2dSimpleType ();
    };

    class UnitVector2dSimpleType: public ::xsd::qif2::ListDoubleType
    {
      public:
      // Constructors.
      //
      UnitVector2dSimpleType ();

      UnitVector2dSimpleType (const ::xsd::qif2::ListDoubleType&);

      UnitVector2dSimpleType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      UnitVector2dSimpleType (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      UnitVector2dSimpleType (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      UnitVector2dSimpleType (const UnitVector2dSimpleType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual UnitVector2dSimpleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~UnitVector2dSimpleType ();
    };

    class ParameterRangeType: public ::xsd::qif2::ListDoubleType
    {
      public:
      // Constructors.
      //
      ParameterRangeType ();

      ParameterRangeType (const ::xsd::qif2::ListDoubleType&);

      ParameterRangeType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ParameterRangeType (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ParameterRangeType (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ParameterRangeType (const ParameterRangeType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual ParameterRangeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ParameterRangeType ();
    };

    class PointSimpleType: public ::xsd::qif2::ListDoubleType
    {
      public:
      // Constructors.
      //
      PointSimpleType ();

      PointSimpleType (const ::xsd::qif2::ListDoubleType&);

      PointSimpleType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      PointSimpleType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      PointSimpleType (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      PointSimpleType (const PointSimpleType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual PointSimpleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~PointSimpleType ();
    };

    class VectorSimpleType: public ::xsd::qif2::ListDoubleType
    {
      public:
      // Constructors.
      //
      VectorSimpleType ();

      VectorSimpleType (const ::xsd::qif2::ListDoubleType&);

      VectorSimpleType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      VectorSimpleType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      VectorSimpleType (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      VectorSimpleType (const VectorSimpleType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual VectorSimpleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~VectorSimpleType ();
    };

    class UnitVectorSimpleType: public ::xsd::qif2::ListDoubleType
    {
      public:
      // Constructors.
      //
      UnitVectorSimpleType ();

      UnitVectorSimpleType (const ::xsd::qif2::ListDoubleType&);

      UnitVectorSimpleType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      UnitVectorSimpleType (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      UnitVectorSimpleType (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      UnitVectorSimpleType (const UnitVectorSimpleType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual UnitVectorSimpleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~UnitVectorSimpleType ();
    };

    class ValidityEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        REPORTED,
        DUMMY,
        MOOT,
        DERIVED,
        SET
      };

      ValidityEnumType (value v);

      ValidityEnumType (const char* v);

      ValidityEnumType (const ::std::string& v);

      ValidityEnumType (const ::xml_schema::nmtoken& v);

      ValidityEnumType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ValidityEnumType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ValidityEnumType (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ValidityEnumType (const ValidityEnumType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual ValidityEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ValidityEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ValidityEnumType_convert ();
      }

      protected:
      value
      _xsd_ValidityEnumType_convert () const;

      public:
      static const char* const _xsd_ValidityEnumType_literals_[5];
      static const value _xsd_ValidityEnumType_indexes_[5];
    };

    class PointType: public ::xsd::qif2::PointSimpleType
    {
      public:
      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, char > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::auto_ptr< linearUnit_type > p);

      // decimalPlaces
      //
      typedef ::xml_schema::non_negative_integer decimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< decimalPlaces_type > decimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< decimalPlaces_type, char > decimalPlaces_traits;

      const decimalPlaces_optional&
      decimalPlaces () const;

      decimalPlaces_optional&
      decimalPlaces ();

      void
      decimalPlaces (const decimalPlaces_type& x);

      void
      decimalPlaces (const decimalPlaces_optional& x);

      // significantFigures
      //
      typedef ::xml_schema::non_negative_integer significantFigures_type;
      typedef ::xsd::cxx::tree::optional< significantFigures_type > significantFigures_optional;
      typedef ::xsd::cxx::tree::traits< significantFigures_type, char > significantFigures_traits;

      const significantFigures_optional&
      significantFigures () const;

      significantFigures_optional&
      significantFigures ();

      void
      significantFigures (const significantFigures_type& x);

      void
      significantFigures (const significantFigures_optional& x);

      // validity
      //
      typedef ::xsd::qif2::ValidityEnumType validity_type;
      typedef ::xsd::cxx::tree::optional< validity_type > validity_optional;
      typedef ::xsd::cxx::tree::traits< validity_type, char > validity_traits;

      const validity_optional&
      validity () const;

      validity_optional&
      validity ();

      void
      validity (const validity_type& x);

      void
      validity (const validity_optional& x);

      void
      validity (::std::auto_ptr< validity_type > p);

      // xDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer xDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< xDecimalPlaces_type > xDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< xDecimalPlaces_type, char > xDecimalPlaces_traits;

      const xDecimalPlaces_optional&
      xDecimalPlaces () const;

      xDecimalPlaces_optional&
      xDecimalPlaces ();

      void
      xDecimalPlaces (const xDecimalPlaces_type& x);

      void
      xDecimalPlaces (const xDecimalPlaces_optional& x);

      // xSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer xSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< xSignificantFigures_type > xSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< xSignificantFigures_type, char > xSignificantFigures_traits;

      const xSignificantFigures_optional&
      xSignificantFigures () const;

      xSignificantFigures_optional&
      xSignificantFigures ();

      void
      xSignificantFigures (const xSignificantFigures_type& x);

      void
      xSignificantFigures (const xSignificantFigures_optional& x);

      // xValidity
      //
      typedef ::xsd::qif2::ValidityEnumType xValidity_type;
      typedef ::xsd::cxx::tree::optional< xValidity_type > xValidity_optional;
      typedef ::xsd::cxx::tree::traits< xValidity_type, char > xValidity_traits;

      const xValidity_optional&
      xValidity () const;

      xValidity_optional&
      xValidity ();

      void
      xValidity (const xValidity_type& x);

      void
      xValidity (const xValidity_optional& x);

      void
      xValidity (::std::auto_ptr< xValidity_type > p);

      // yDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer yDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< yDecimalPlaces_type > yDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< yDecimalPlaces_type, char > yDecimalPlaces_traits;

      const yDecimalPlaces_optional&
      yDecimalPlaces () const;

      yDecimalPlaces_optional&
      yDecimalPlaces ();

      void
      yDecimalPlaces (const yDecimalPlaces_type& x);

      void
      yDecimalPlaces (const yDecimalPlaces_optional& x);

      // ySignificantFigures
      //
      typedef ::xml_schema::non_negative_integer ySignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< ySignificantFigures_type > ySignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< ySignificantFigures_type, char > ySignificantFigures_traits;

      const ySignificantFigures_optional&
      ySignificantFigures () const;

      ySignificantFigures_optional&
      ySignificantFigures ();

      void
      ySignificantFigures (const ySignificantFigures_type& x);

      void
      ySignificantFigures (const ySignificantFigures_optional& x);

      // yValidity
      //
      typedef ::xsd::qif2::ValidityEnumType yValidity_type;
      typedef ::xsd::cxx::tree::optional< yValidity_type > yValidity_optional;
      typedef ::xsd::cxx::tree::traits< yValidity_type, char > yValidity_traits;

      const yValidity_optional&
      yValidity () const;

      yValidity_optional&
      yValidity ();

      void
      yValidity (const yValidity_type& x);

      void
      yValidity (const yValidity_optional& x);

      void
      yValidity (::std::auto_ptr< yValidity_type > p);

      // zDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer zDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< zDecimalPlaces_type > zDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< zDecimalPlaces_type, char > zDecimalPlaces_traits;

      const zDecimalPlaces_optional&
      zDecimalPlaces () const;

      zDecimalPlaces_optional&
      zDecimalPlaces ();

      void
      zDecimalPlaces (const zDecimalPlaces_type& x);

      void
      zDecimalPlaces (const zDecimalPlaces_optional& x);

      // zSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer zSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< zSignificantFigures_type > zSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< zSignificantFigures_type, char > zSignificantFigures_traits;

      const zSignificantFigures_optional&
      zSignificantFigures () const;

      zSignificantFigures_optional&
      zSignificantFigures ();

      void
      zSignificantFigures (const zSignificantFigures_type& x);

      void
      zSignificantFigures (const zSignificantFigures_optional& x);

      // zValidity
      //
      typedef ::xsd::qif2::ValidityEnumType zValidity_type;
      typedef ::xsd::cxx::tree::optional< zValidity_type > zValidity_optional;
      typedef ::xsd::cxx::tree::traits< zValidity_type, char > zValidity_traits;

      const zValidity_optional&
      zValidity () const;

      zValidity_optional&
      zValidity ();

      void
      zValidity (const zValidity_type& x);

      void
      zValidity (const zValidity_optional& x);

      void
      zValidity (::std::auto_ptr< zValidity_type > p);

      // Constructors.
      //
      PointType ();

      PointType (const ::xsd::qif2::ListDoubleType&);

      PointType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      PointType (const PointType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual PointType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointType&
      operator= (const PointType& x);

      virtual 
      ~PointType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      linearUnit_optional linearUnit_;
      decimalPlaces_optional decimalPlaces_;
      significantFigures_optional significantFigures_;
      validity_optional validity_;
      xDecimalPlaces_optional xDecimalPlaces_;
      xSignificantFigures_optional xSignificantFigures_;
      xValidity_optional xValidity_;
      yDecimalPlaces_optional yDecimalPlaces_;
      ySignificantFigures_optional ySignificantFigures_;
      yValidity_optional yValidity_;
      zDecimalPlaces_optional zDecimalPlaces_;
      zSignificantFigures_optional zSignificantFigures_;
      zValidity_optional zValidity_;
    };

    class ActualPointType: public ::xsd::qif2::PointType
    {
      public:
      // combinedUncertainty
      //
      typedef ::xml_schema::decimal combinedUncertainty_type;
      typedef ::xsd::cxx::tree::optional< combinedUncertainty_type > combinedUncertainty_optional;
      typedef ::xsd::cxx::tree::traits< combinedUncertainty_type, char, ::xsd::cxx::tree::schema_type::decimal > combinedUncertainty_traits;

      const combinedUncertainty_optional&
      combinedUncertainty () const;

      combinedUncertainty_optional&
      combinedUncertainty ();

      void
      combinedUncertainty (const combinedUncertainty_type& x);

      void
      combinedUncertainty (const combinedUncertainty_optional& x);

      // meanError
      //
      typedef ::xml_schema::decimal meanError_type;
      typedef ::xsd::cxx::tree::optional< meanError_type > meanError_optional;
      typedef ::xsd::cxx::tree::traits< meanError_type, char, ::xsd::cxx::tree::schema_type::decimal > meanError_traits;

      const meanError_optional&
      meanError () const;

      meanError_optional&
      meanError ();

      void
      meanError (const meanError_type& x);

      void
      meanError (const meanError_optional& x);

      // xCombinedUncertainty
      //
      typedef ::xml_schema::decimal xCombinedUncertainty_type;
      typedef ::xsd::cxx::tree::optional< xCombinedUncertainty_type > xCombinedUncertainty_optional;
      typedef ::xsd::cxx::tree::traits< xCombinedUncertainty_type, char, ::xsd::cxx::tree::schema_type::decimal > xCombinedUncertainty_traits;

      const xCombinedUncertainty_optional&
      xCombinedUncertainty () const;

      xCombinedUncertainty_optional&
      xCombinedUncertainty ();

      void
      xCombinedUncertainty (const xCombinedUncertainty_type& x);

      void
      xCombinedUncertainty (const xCombinedUncertainty_optional& x);

      // xMeanError
      //
      typedef ::xml_schema::decimal xMeanError_type;
      typedef ::xsd::cxx::tree::optional< xMeanError_type > xMeanError_optional;
      typedef ::xsd::cxx::tree::traits< xMeanError_type, char, ::xsd::cxx::tree::schema_type::decimal > xMeanError_traits;

      const xMeanError_optional&
      xMeanError () const;

      xMeanError_optional&
      xMeanError ();

      void
      xMeanError (const xMeanError_type& x);

      void
      xMeanError (const xMeanError_optional& x);

      // yCombinedUncertainty
      //
      typedef ::xml_schema::decimal yCombinedUncertainty_type;
      typedef ::xsd::cxx::tree::optional< yCombinedUncertainty_type > yCombinedUncertainty_optional;
      typedef ::xsd::cxx::tree::traits< yCombinedUncertainty_type, char, ::xsd::cxx::tree::schema_type::decimal > yCombinedUncertainty_traits;

      const yCombinedUncertainty_optional&
      yCombinedUncertainty () const;

      yCombinedUncertainty_optional&
      yCombinedUncertainty ();

      void
      yCombinedUncertainty (const yCombinedUncertainty_type& x);

      void
      yCombinedUncertainty (const yCombinedUncertainty_optional& x);

      // yMeanError
      //
      typedef ::xml_schema::decimal yMeanError_type;
      typedef ::xsd::cxx::tree::optional< yMeanError_type > yMeanError_optional;
      typedef ::xsd::cxx::tree::traits< yMeanError_type, char, ::xsd::cxx::tree::schema_type::decimal > yMeanError_traits;

      const yMeanError_optional&
      yMeanError () const;

      yMeanError_optional&
      yMeanError ();

      void
      yMeanError (const yMeanError_type& x);

      void
      yMeanError (const yMeanError_optional& x);

      // zCombinedUncertainty
      //
      typedef ::xml_schema::decimal zCombinedUncertainty_type;
      typedef ::xsd::cxx::tree::optional< zCombinedUncertainty_type > zCombinedUncertainty_optional;
      typedef ::xsd::cxx::tree::traits< zCombinedUncertainty_type, char, ::xsd::cxx::tree::schema_type::decimal > zCombinedUncertainty_traits;

      const zCombinedUncertainty_optional&
      zCombinedUncertainty () const;

      zCombinedUncertainty_optional&
      zCombinedUncertainty ();

      void
      zCombinedUncertainty (const zCombinedUncertainty_type& x);

      void
      zCombinedUncertainty (const zCombinedUncertainty_optional& x);

      // zMeanError
      //
      typedef ::xml_schema::decimal zMeanError_type;
      typedef ::xsd::cxx::tree::optional< zMeanError_type > zMeanError_optional;
      typedef ::xsd::cxx::tree::traits< zMeanError_type, char, ::xsd::cxx::tree::schema_type::decimal > zMeanError_traits;

      const zMeanError_optional&
      zMeanError () const;

      zMeanError_optional&
      zMeanError ();

      void
      zMeanError (const zMeanError_type& x);

      void
      zMeanError (const zMeanError_optional& x);

      // Constructors.
      //
      ActualPointType ();

      ActualPointType (const ::xsd::qif2::ListDoubleType&);

      ActualPointType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ActualPointType (const ActualPointType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual ActualPointType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ActualPointType&
      operator= (const ActualPointType& x);

      virtual 
      ~ActualPointType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      combinedUncertainty_optional combinedUncertainty_;
      meanError_optional meanError_;
      xCombinedUncertainty_optional xCombinedUncertainty_;
      xMeanError_optional xMeanError_;
      yCombinedUncertainty_optional yCombinedUncertainty_;
      yMeanError_optional yMeanError_;
      zCombinedUncertainty_optional zCombinedUncertainty_;
      zMeanError_optional zMeanError_;
    };

    class VectorType: public ::xsd::qif2::VectorSimpleType
    {
      public:
      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, char > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::auto_ptr< linearUnit_type > p);

      // decimalPlaces
      //
      typedef ::xml_schema::non_negative_integer decimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< decimalPlaces_type > decimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< decimalPlaces_type, char > decimalPlaces_traits;

      const decimalPlaces_optional&
      decimalPlaces () const;

      decimalPlaces_optional&
      decimalPlaces ();

      void
      decimalPlaces (const decimalPlaces_type& x);

      void
      decimalPlaces (const decimalPlaces_optional& x);

      // significantFigures
      //
      typedef ::xml_schema::non_negative_integer significantFigures_type;
      typedef ::xsd::cxx::tree::optional< significantFigures_type > significantFigures_optional;
      typedef ::xsd::cxx::tree::traits< significantFigures_type, char > significantFigures_traits;

      const significantFigures_optional&
      significantFigures () const;

      significantFigures_optional&
      significantFigures ();

      void
      significantFigures (const significantFigures_type& x);

      void
      significantFigures (const significantFigures_optional& x);

      // validity
      //
      typedef ::xsd::qif2::ValidityEnumType validity_type;
      typedef ::xsd::cxx::tree::optional< validity_type > validity_optional;
      typedef ::xsd::cxx::tree::traits< validity_type, char > validity_traits;

      const validity_optional&
      validity () const;

      validity_optional&
      validity ();

      void
      validity (const validity_type& x);

      void
      validity (const validity_optional& x);

      void
      validity (::std::auto_ptr< validity_type > p);

      // xDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer xDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< xDecimalPlaces_type > xDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< xDecimalPlaces_type, char > xDecimalPlaces_traits;

      const xDecimalPlaces_optional&
      xDecimalPlaces () const;

      xDecimalPlaces_optional&
      xDecimalPlaces ();

      void
      xDecimalPlaces (const xDecimalPlaces_type& x);

      void
      xDecimalPlaces (const xDecimalPlaces_optional& x);

      // xSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer xSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< xSignificantFigures_type > xSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< xSignificantFigures_type, char > xSignificantFigures_traits;

      const xSignificantFigures_optional&
      xSignificantFigures () const;

      xSignificantFigures_optional&
      xSignificantFigures ();

      void
      xSignificantFigures (const xSignificantFigures_type& x);

      void
      xSignificantFigures (const xSignificantFigures_optional& x);

      // xValidity
      //
      typedef ::xsd::qif2::ValidityEnumType xValidity_type;
      typedef ::xsd::cxx::tree::optional< xValidity_type > xValidity_optional;
      typedef ::xsd::cxx::tree::traits< xValidity_type, char > xValidity_traits;

      const xValidity_optional&
      xValidity () const;

      xValidity_optional&
      xValidity ();

      void
      xValidity (const xValidity_type& x);

      void
      xValidity (const xValidity_optional& x);

      void
      xValidity (::std::auto_ptr< xValidity_type > p);

      // yDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer yDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< yDecimalPlaces_type > yDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< yDecimalPlaces_type, char > yDecimalPlaces_traits;

      const yDecimalPlaces_optional&
      yDecimalPlaces () const;

      yDecimalPlaces_optional&
      yDecimalPlaces ();

      void
      yDecimalPlaces (const yDecimalPlaces_type& x);

      void
      yDecimalPlaces (const yDecimalPlaces_optional& x);

      // ySignificantFigures
      //
      typedef ::xml_schema::non_negative_integer ySignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< ySignificantFigures_type > ySignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< ySignificantFigures_type, char > ySignificantFigures_traits;

      const ySignificantFigures_optional&
      ySignificantFigures () const;

      ySignificantFigures_optional&
      ySignificantFigures ();

      void
      ySignificantFigures (const ySignificantFigures_type& x);

      void
      ySignificantFigures (const ySignificantFigures_optional& x);

      // yValidity
      //
      typedef ::xsd::qif2::ValidityEnumType yValidity_type;
      typedef ::xsd::cxx::tree::optional< yValidity_type > yValidity_optional;
      typedef ::xsd::cxx::tree::traits< yValidity_type, char > yValidity_traits;

      const yValidity_optional&
      yValidity () const;

      yValidity_optional&
      yValidity ();

      void
      yValidity (const yValidity_type& x);

      void
      yValidity (const yValidity_optional& x);

      void
      yValidity (::std::auto_ptr< yValidity_type > p);

      // zDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer zDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< zDecimalPlaces_type > zDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< zDecimalPlaces_type, char > zDecimalPlaces_traits;

      const zDecimalPlaces_optional&
      zDecimalPlaces () const;

      zDecimalPlaces_optional&
      zDecimalPlaces ();

      void
      zDecimalPlaces (const zDecimalPlaces_type& x);

      void
      zDecimalPlaces (const zDecimalPlaces_optional& x);

      // zSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer zSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< zSignificantFigures_type > zSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< zSignificantFigures_type, char > zSignificantFigures_traits;

      const zSignificantFigures_optional&
      zSignificantFigures () const;

      zSignificantFigures_optional&
      zSignificantFigures ();

      void
      zSignificantFigures (const zSignificantFigures_type& x);

      void
      zSignificantFigures (const zSignificantFigures_optional& x);

      // zValidity
      //
      typedef ::xsd::qif2::ValidityEnumType zValidity_type;
      typedef ::xsd::cxx::tree::optional< zValidity_type > zValidity_optional;
      typedef ::xsd::cxx::tree::traits< zValidity_type, char > zValidity_traits;

      const zValidity_optional&
      zValidity () const;

      zValidity_optional&
      zValidity ();

      void
      zValidity (const zValidity_type& x);

      void
      zValidity (const zValidity_optional& x);

      void
      zValidity (::std::auto_ptr< zValidity_type > p);

      // Constructors.
      //
      VectorType ();

      VectorType (const ::xsd::qif2::ListDoubleType&);

      VectorType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      VectorType (const VectorType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual VectorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      VectorType&
      operator= (const VectorType& x);

      virtual 
      ~VectorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      linearUnit_optional linearUnit_;
      decimalPlaces_optional decimalPlaces_;
      significantFigures_optional significantFigures_;
      validity_optional validity_;
      xDecimalPlaces_optional xDecimalPlaces_;
      xSignificantFigures_optional xSignificantFigures_;
      xValidity_optional xValidity_;
      yDecimalPlaces_optional yDecimalPlaces_;
      ySignificantFigures_optional ySignificantFigures_;
      yValidity_optional yValidity_;
      zDecimalPlaces_optional zDecimalPlaces_;
      zSignificantFigures_optional zSignificantFigures_;
      zValidity_optional zValidity_;
    };

    class UnitVectorType: public ::xsd::qif2::UnitVectorSimpleType
    {
      public:
      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, char > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::auto_ptr< linearUnit_type > p);

      // decimalPlaces
      //
      typedef ::xml_schema::non_negative_integer decimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< decimalPlaces_type > decimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< decimalPlaces_type, char > decimalPlaces_traits;

      const decimalPlaces_optional&
      decimalPlaces () const;

      decimalPlaces_optional&
      decimalPlaces ();

      void
      decimalPlaces (const decimalPlaces_type& x);

      void
      decimalPlaces (const decimalPlaces_optional& x);

      // significantFigures
      //
      typedef ::xml_schema::non_negative_integer significantFigures_type;
      typedef ::xsd::cxx::tree::optional< significantFigures_type > significantFigures_optional;
      typedef ::xsd::cxx::tree::traits< significantFigures_type, char > significantFigures_traits;

      const significantFigures_optional&
      significantFigures () const;

      significantFigures_optional&
      significantFigures ();

      void
      significantFigures (const significantFigures_type& x);

      void
      significantFigures (const significantFigures_optional& x);

      // validity
      //
      typedef ::xsd::qif2::ValidityEnumType validity_type;
      typedef ::xsd::cxx::tree::optional< validity_type > validity_optional;
      typedef ::xsd::cxx::tree::traits< validity_type, char > validity_traits;

      const validity_optional&
      validity () const;

      validity_optional&
      validity ();

      void
      validity (const validity_type& x);

      void
      validity (const validity_optional& x);

      void
      validity (::std::auto_ptr< validity_type > p);

      // xDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer xDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< xDecimalPlaces_type > xDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< xDecimalPlaces_type, char > xDecimalPlaces_traits;

      const xDecimalPlaces_optional&
      xDecimalPlaces () const;

      xDecimalPlaces_optional&
      xDecimalPlaces ();

      void
      xDecimalPlaces (const xDecimalPlaces_type& x);

      void
      xDecimalPlaces (const xDecimalPlaces_optional& x);

      // xSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer xSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< xSignificantFigures_type > xSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< xSignificantFigures_type, char > xSignificantFigures_traits;

      const xSignificantFigures_optional&
      xSignificantFigures () const;

      xSignificantFigures_optional&
      xSignificantFigures ();

      void
      xSignificantFigures (const xSignificantFigures_type& x);

      void
      xSignificantFigures (const xSignificantFigures_optional& x);

      // xValidity
      //
      typedef ::xsd::qif2::ValidityEnumType xValidity_type;
      typedef ::xsd::cxx::tree::optional< xValidity_type > xValidity_optional;
      typedef ::xsd::cxx::tree::traits< xValidity_type, char > xValidity_traits;

      const xValidity_optional&
      xValidity () const;

      xValidity_optional&
      xValidity ();

      void
      xValidity (const xValidity_type& x);

      void
      xValidity (const xValidity_optional& x);

      void
      xValidity (::std::auto_ptr< xValidity_type > p);

      // yDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer yDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< yDecimalPlaces_type > yDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< yDecimalPlaces_type, char > yDecimalPlaces_traits;

      const yDecimalPlaces_optional&
      yDecimalPlaces () const;

      yDecimalPlaces_optional&
      yDecimalPlaces ();

      void
      yDecimalPlaces (const yDecimalPlaces_type& x);

      void
      yDecimalPlaces (const yDecimalPlaces_optional& x);

      // ySignificantFigures
      //
      typedef ::xml_schema::non_negative_integer ySignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< ySignificantFigures_type > ySignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< ySignificantFigures_type, char > ySignificantFigures_traits;

      const ySignificantFigures_optional&
      ySignificantFigures () const;

      ySignificantFigures_optional&
      ySignificantFigures ();

      void
      ySignificantFigures (const ySignificantFigures_type& x);

      void
      ySignificantFigures (const ySignificantFigures_optional& x);

      // yValidity
      //
      typedef ::xsd::qif2::ValidityEnumType yValidity_type;
      typedef ::xsd::cxx::tree::optional< yValidity_type > yValidity_optional;
      typedef ::xsd::cxx::tree::traits< yValidity_type, char > yValidity_traits;

      const yValidity_optional&
      yValidity () const;

      yValidity_optional&
      yValidity ();

      void
      yValidity (const yValidity_type& x);

      void
      yValidity (const yValidity_optional& x);

      void
      yValidity (::std::auto_ptr< yValidity_type > p);

      // zDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer zDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< zDecimalPlaces_type > zDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< zDecimalPlaces_type, char > zDecimalPlaces_traits;

      const zDecimalPlaces_optional&
      zDecimalPlaces () const;

      zDecimalPlaces_optional&
      zDecimalPlaces ();

      void
      zDecimalPlaces (const zDecimalPlaces_type& x);

      void
      zDecimalPlaces (const zDecimalPlaces_optional& x);

      // zSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer zSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< zSignificantFigures_type > zSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< zSignificantFigures_type, char > zSignificantFigures_traits;

      const zSignificantFigures_optional&
      zSignificantFigures () const;

      zSignificantFigures_optional&
      zSignificantFigures ();

      void
      zSignificantFigures (const zSignificantFigures_type& x);

      void
      zSignificantFigures (const zSignificantFigures_optional& x);

      // zValidity
      //
      typedef ::xsd::qif2::ValidityEnumType zValidity_type;
      typedef ::xsd::cxx::tree::optional< zValidity_type > zValidity_optional;
      typedef ::xsd::cxx::tree::traits< zValidity_type, char > zValidity_traits;

      const zValidity_optional&
      zValidity () const;

      zValidity_optional&
      zValidity ();

      void
      zValidity (const zValidity_type& x);

      void
      zValidity (const zValidity_optional& x);

      void
      zValidity (::std::auto_ptr< zValidity_type > p);

      // Constructors.
      //
      UnitVectorType ();

      UnitVectorType (const ::xsd::qif2::ListDoubleType&);

      UnitVectorType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      UnitVectorType (const UnitVectorType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual UnitVectorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UnitVectorType&
      operator= (const UnitVectorType& x);

      virtual 
      ~UnitVectorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      linearUnit_optional linearUnit_;
      decimalPlaces_optional decimalPlaces_;
      significantFigures_optional significantFigures_;
      validity_optional validity_;
      xDecimalPlaces_optional xDecimalPlaces_;
      xSignificantFigures_optional xSignificantFigures_;
      xValidity_optional xValidity_;
      yDecimalPlaces_optional yDecimalPlaces_;
      ySignificantFigures_optional ySignificantFigures_;
      yValidity_optional yValidity_;
      zDecimalPlaces_optional zDecimalPlaces_;
      zSignificantFigures_optional zSignificantFigures_;
      zValidity_optional zValidity_;
    };

    class ActualUnitVectorType: public ::xsd::qif2::UnitVectorType
    {
      public:
      // combinedUncertainty
      //
      typedef ::xml_schema::decimal combinedUncertainty_type;
      typedef ::xsd::cxx::tree::optional< combinedUncertainty_type > combinedUncertainty_optional;
      typedef ::xsd::cxx::tree::traits< combinedUncertainty_type, char, ::xsd::cxx::tree::schema_type::decimal > combinedUncertainty_traits;

      const combinedUncertainty_optional&
      combinedUncertainty () const;

      combinedUncertainty_optional&
      combinedUncertainty ();

      void
      combinedUncertainty (const combinedUncertainty_type& x);

      void
      combinedUncertainty (const combinedUncertainty_optional& x);

      // meanError
      //
      typedef ::xml_schema::decimal meanError_type;
      typedef ::xsd::cxx::tree::optional< meanError_type > meanError_optional;
      typedef ::xsd::cxx::tree::traits< meanError_type, char, ::xsd::cxx::tree::schema_type::decimal > meanError_traits;

      const meanError_optional&
      meanError () const;

      meanError_optional&
      meanError ();

      void
      meanError (const meanError_type& x);

      void
      meanError (const meanError_optional& x);

      // xCombinedUncertainty
      //
      typedef ::xml_schema::decimal xCombinedUncertainty_type;
      typedef ::xsd::cxx::tree::optional< xCombinedUncertainty_type > xCombinedUncertainty_optional;
      typedef ::xsd::cxx::tree::traits< xCombinedUncertainty_type, char, ::xsd::cxx::tree::schema_type::decimal > xCombinedUncertainty_traits;

      const xCombinedUncertainty_optional&
      xCombinedUncertainty () const;

      xCombinedUncertainty_optional&
      xCombinedUncertainty ();

      void
      xCombinedUncertainty (const xCombinedUncertainty_type& x);

      void
      xCombinedUncertainty (const xCombinedUncertainty_optional& x);

      // xMeanError
      //
      typedef ::xml_schema::decimal xMeanError_type;
      typedef ::xsd::cxx::tree::optional< xMeanError_type > xMeanError_optional;
      typedef ::xsd::cxx::tree::traits< xMeanError_type, char, ::xsd::cxx::tree::schema_type::decimal > xMeanError_traits;

      const xMeanError_optional&
      xMeanError () const;

      xMeanError_optional&
      xMeanError ();

      void
      xMeanError (const xMeanError_type& x);

      void
      xMeanError (const xMeanError_optional& x);

      // yCombinedUncertainty
      //
      typedef ::xml_schema::decimal yCombinedUncertainty_type;
      typedef ::xsd::cxx::tree::optional< yCombinedUncertainty_type > yCombinedUncertainty_optional;
      typedef ::xsd::cxx::tree::traits< yCombinedUncertainty_type, char, ::xsd::cxx::tree::schema_type::decimal > yCombinedUncertainty_traits;

      const yCombinedUncertainty_optional&
      yCombinedUncertainty () const;

      yCombinedUncertainty_optional&
      yCombinedUncertainty ();

      void
      yCombinedUncertainty (const yCombinedUncertainty_type& x);

      void
      yCombinedUncertainty (const yCombinedUncertainty_optional& x);

      // yMeanError
      //
      typedef ::xml_schema::decimal yMeanError_type;
      typedef ::xsd::cxx::tree::optional< yMeanError_type > yMeanError_optional;
      typedef ::xsd::cxx::tree::traits< yMeanError_type, char, ::xsd::cxx::tree::schema_type::decimal > yMeanError_traits;

      const yMeanError_optional&
      yMeanError () const;

      yMeanError_optional&
      yMeanError ();

      void
      yMeanError (const yMeanError_type& x);

      void
      yMeanError (const yMeanError_optional& x);

      // zCombinedUncertainty
      //
      typedef ::xml_schema::decimal zCombinedUncertainty_type;
      typedef ::xsd::cxx::tree::optional< zCombinedUncertainty_type > zCombinedUncertainty_optional;
      typedef ::xsd::cxx::tree::traits< zCombinedUncertainty_type, char, ::xsd::cxx::tree::schema_type::decimal > zCombinedUncertainty_traits;

      const zCombinedUncertainty_optional&
      zCombinedUncertainty () const;

      zCombinedUncertainty_optional&
      zCombinedUncertainty ();

      void
      zCombinedUncertainty (const zCombinedUncertainty_type& x);

      void
      zCombinedUncertainty (const zCombinedUncertainty_optional& x);

      // zMeanError
      //
      typedef ::xml_schema::decimal zMeanError_type;
      typedef ::xsd::cxx::tree::optional< zMeanError_type > zMeanError_optional;
      typedef ::xsd::cxx::tree::traits< zMeanError_type, char, ::xsd::cxx::tree::schema_type::decimal > zMeanError_traits;

      const zMeanError_optional&
      zMeanError () const;

      zMeanError_optional&
      zMeanError ();

      void
      zMeanError (const zMeanError_type& x);

      void
      zMeanError (const zMeanError_optional& x);

      // Constructors.
      //
      ActualUnitVectorType ();

      ActualUnitVectorType (const ::xsd::qif2::ListDoubleType&);

      ActualUnitVectorType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ActualUnitVectorType (const ActualUnitVectorType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual ActualUnitVectorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ActualUnitVectorType&
      operator= (const ActualUnitVectorType& x);

      virtual 
      ~ActualUnitVectorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      combinedUncertainty_optional combinedUncertainty_;
      meanError_optional meanError_;
      xCombinedUncertainty_optional xCombinedUncertainty_;
      xMeanError_optional xMeanError_;
      yCombinedUncertainty_optional yCombinedUncertainty_;
      yMeanError_optional yMeanError_;
      zCombinedUncertainty_optional zCombinedUncertainty_;
      zMeanError_optional zMeanError_;
    };

    class ArrayPoint2dType: public ::xsd::qif2::ListDoubleType
    {
      public:
      // N
      //
      typedef ::xml_schema::positive_integer N_type;
      typedef ::xsd::cxx::tree::traits< N_type, char > N_traits;

      const N_type&
      N () const;

      N_type&
      N ();

      void
      N (const N_type& x);

      // Constructors.
      //
      ArrayPoint2dType (const N_type&);

      ArrayPoint2dType (const ::xsd::qif2::ListDoubleType&,
                        const N_type&);

      ArrayPoint2dType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ArrayPoint2dType (const ArrayPoint2dType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual ArrayPoint2dType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayPoint2dType&
      operator= (const ArrayPoint2dType& x);

      virtual 
      ~ArrayPoint2dType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< N_type > N_;
    };

    class ArrayPointType: public ::xsd::qif2::ListDoubleType
    {
      public:
      // N
      //
      typedef ::xml_schema::positive_integer N_type;
      typedef ::xsd::cxx::tree::traits< N_type, char > N_traits;

      const N_type&
      N () const;

      N_type&
      N ();

      void
      N (const N_type& x);

      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, char > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::auto_ptr< linearUnit_type > p);

      // decimalPlaces
      //
      typedef ::xml_schema::non_negative_integer decimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< decimalPlaces_type > decimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< decimalPlaces_type, char > decimalPlaces_traits;

      const decimalPlaces_optional&
      decimalPlaces () const;

      decimalPlaces_optional&
      decimalPlaces ();

      void
      decimalPlaces (const decimalPlaces_type& x);

      void
      decimalPlaces (const decimalPlaces_optional& x);

      // significantFigures
      //
      typedef ::xml_schema::non_negative_integer significantFigures_type;
      typedef ::xsd::cxx::tree::optional< significantFigures_type > significantFigures_optional;
      typedef ::xsd::cxx::tree::traits< significantFigures_type, char > significantFigures_traits;

      const significantFigures_optional&
      significantFigures () const;

      significantFigures_optional&
      significantFigures ();

      void
      significantFigures (const significantFigures_type& x);

      void
      significantFigures (const significantFigures_optional& x);

      // validity
      //
      typedef ::xsd::qif2::ValidityEnumType validity_type;
      typedef ::xsd::cxx::tree::optional< validity_type > validity_optional;
      typedef ::xsd::cxx::tree::traits< validity_type, char > validity_traits;

      const validity_optional&
      validity () const;

      validity_optional&
      validity ();

      void
      validity (const validity_type& x);

      void
      validity (const validity_optional& x);

      void
      validity (::std::auto_ptr< validity_type > p);

      // xDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer xDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< xDecimalPlaces_type > xDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< xDecimalPlaces_type, char > xDecimalPlaces_traits;

      const xDecimalPlaces_optional&
      xDecimalPlaces () const;

      xDecimalPlaces_optional&
      xDecimalPlaces ();

      void
      xDecimalPlaces (const xDecimalPlaces_type& x);

      void
      xDecimalPlaces (const xDecimalPlaces_optional& x);

      // xSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer xSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< xSignificantFigures_type > xSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< xSignificantFigures_type, char > xSignificantFigures_traits;

      const xSignificantFigures_optional&
      xSignificantFigures () const;

      xSignificantFigures_optional&
      xSignificantFigures ();

      void
      xSignificantFigures (const xSignificantFigures_type& x);

      void
      xSignificantFigures (const xSignificantFigures_optional& x);

      // xValidity
      //
      typedef ::xsd::qif2::ValidityEnumType xValidity_type;
      typedef ::xsd::cxx::tree::optional< xValidity_type > xValidity_optional;
      typedef ::xsd::cxx::tree::traits< xValidity_type, char > xValidity_traits;

      const xValidity_optional&
      xValidity () const;

      xValidity_optional&
      xValidity ();

      void
      xValidity (const xValidity_type& x);

      void
      xValidity (const xValidity_optional& x);

      void
      xValidity (::std::auto_ptr< xValidity_type > p);

      // yDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer yDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< yDecimalPlaces_type > yDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< yDecimalPlaces_type, char > yDecimalPlaces_traits;

      const yDecimalPlaces_optional&
      yDecimalPlaces () const;

      yDecimalPlaces_optional&
      yDecimalPlaces ();

      void
      yDecimalPlaces (const yDecimalPlaces_type& x);

      void
      yDecimalPlaces (const yDecimalPlaces_optional& x);

      // ySignificantFigures
      //
      typedef ::xml_schema::non_negative_integer ySignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< ySignificantFigures_type > ySignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< ySignificantFigures_type, char > ySignificantFigures_traits;

      const ySignificantFigures_optional&
      ySignificantFigures () const;

      ySignificantFigures_optional&
      ySignificantFigures ();

      void
      ySignificantFigures (const ySignificantFigures_type& x);

      void
      ySignificantFigures (const ySignificantFigures_optional& x);

      // yValidity
      //
      typedef ::xsd::qif2::ValidityEnumType yValidity_type;
      typedef ::xsd::cxx::tree::optional< yValidity_type > yValidity_optional;
      typedef ::xsd::cxx::tree::traits< yValidity_type, char > yValidity_traits;

      const yValidity_optional&
      yValidity () const;

      yValidity_optional&
      yValidity ();

      void
      yValidity (const yValidity_type& x);

      void
      yValidity (const yValidity_optional& x);

      void
      yValidity (::std::auto_ptr< yValidity_type > p);

      // zDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer zDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< zDecimalPlaces_type > zDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< zDecimalPlaces_type, char > zDecimalPlaces_traits;

      const zDecimalPlaces_optional&
      zDecimalPlaces () const;

      zDecimalPlaces_optional&
      zDecimalPlaces ();

      void
      zDecimalPlaces (const zDecimalPlaces_type& x);

      void
      zDecimalPlaces (const zDecimalPlaces_optional& x);

      // zSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer zSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< zSignificantFigures_type > zSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< zSignificantFigures_type, char > zSignificantFigures_traits;

      const zSignificantFigures_optional&
      zSignificantFigures () const;

      zSignificantFigures_optional&
      zSignificantFigures ();

      void
      zSignificantFigures (const zSignificantFigures_type& x);

      void
      zSignificantFigures (const zSignificantFigures_optional& x);

      // zValidity
      //
      typedef ::xsd::qif2::ValidityEnumType zValidity_type;
      typedef ::xsd::cxx::tree::optional< zValidity_type > zValidity_optional;
      typedef ::xsd::cxx::tree::traits< zValidity_type, char > zValidity_traits;

      const zValidity_optional&
      zValidity () const;

      zValidity_optional&
      zValidity ();

      void
      zValidity (const zValidity_type& x);

      void
      zValidity (const zValidity_optional& x);

      void
      zValidity (::std::auto_ptr< zValidity_type > p);

      // Constructors.
      //
      ArrayPointType (const N_type&);

      ArrayPointType (const ::xsd::qif2::ListDoubleType&,
                      const N_type&);

      ArrayPointType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ArrayPointType (const ArrayPointType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual ArrayPointType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayPointType&
      operator= (const ArrayPointType& x);

      virtual 
      ~ArrayPointType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< N_type > N_;
      linearUnit_optional linearUnit_;
      decimalPlaces_optional decimalPlaces_;
      significantFigures_optional significantFigures_;
      validity_optional validity_;
      xDecimalPlaces_optional xDecimalPlaces_;
      xSignificantFigures_optional xSignificantFigures_;
      xValidity_optional xValidity_;
      yDecimalPlaces_optional yDecimalPlaces_;
      ySignificantFigures_optional ySignificantFigures_;
      yValidity_optional yValidity_;
      zDecimalPlaces_optional zDecimalPlaces_;
      zSignificantFigures_optional zSignificantFigures_;
      zValidity_optional zValidity_;
    };

    class ArrayUnitVectorType: public ::xsd::qif2::ListDoubleType
    {
      public:
      // N
      //
      typedef ::xml_schema::positive_integer N_type;
      typedef ::xsd::cxx::tree::traits< N_type, char > N_traits;

      const N_type&
      N () const;

      N_type&
      N ();

      void
      N (const N_type& x);

      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, char > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::auto_ptr< linearUnit_type > p);

      // decimalPlaces
      //
      typedef ::xml_schema::non_negative_integer decimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< decimalPlaces_type > decimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< decimalPlaces_type, char > decimalPlaces_traits;

      const decimalPlaces_optional&
      decimalPlaces () const;

      decimalPlaces_optional&
      decimalPlaces ();

      void
      decimalPlaces (const decimalPlaces_type& x);

      void
      decimalPlaces (const decimalPlaces_optional& x);

      // significantFigures
      //
      typedef ::xml_schema::non_negative_integer significantFigures_type;
      typedef ::xsd::cxx::tree::optional< significantFigures_type > significantFigures_optional;
      typedef ::xsd::cxx::tree::traits< significantFigures_type, char > significantFigures_traits;

      const significantFigures_optional&
      significantFigures () const;

      significantFigures_optional&
      significantFigures ();

      void
      significantFigures (const significantFigures_type& x);

      void
      significantFigures (const significantFigures_optional& x);

      // validity
      //
      typedef ::xsd::qif2::ValidityEnumType validity_type;
      typedef ::xsd::cxx::tree::optional< validity_type > validity_optional;
      typedef ::xsd::cxx::tree::traits< validity_type, char > validity_traits;

      const validity_optional&
      validity () const;

      validity_optional&
      validity ();

      void
      validity (const validity_type& x);

      void
      validity (const validity_optional& x);

      void
      validity (::std::auto_ptr< validity_type > p);

      // xDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer xDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< xDecimalPlaces_type > xDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< xDecimalPlaces_type, char > xDecimalPlaces_traits;

      const xDecimalPlaces_optional&
      xDecimalPlaces () const;

      xDecimalPlaces_optional&
      xDecimalPlaces ();

      void
      xDecimalPlaces (const xDecimalPlaces_type& x);

      void
      xDecimalPlaces (const xDecimalPlaces_optional& x);

      // xSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer xSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< xSignificantFigures_type > xSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< xSignificantFigures_type, char > xSignificantFigures_traits;

      const xSignificantFigures_optional&
      xSignificantFigures () const;

      xSignificantFigures_optional&
      xSignificantFigures ();

      void
      xSignificantFigures (const xSignificantFigures_type& x);

      void
      xSignificantFigures (const xSignificantFigures_optional& x);

      // xValidity
      //
      typedef ::xsd::qif2::ValidityEnumType xValidity_type;
      typedef ::xsd::cxx::tree::optional< xValidity_type > xValidity_optional;
      typedef ::xsd::cxx::tree::traits< xValidity_type, char > xValidity_traits;

      const xValidity_optional&
      xValidity () const;

      xValidity_optional&
      xValidity ();

      void
      xValidity (const xValidity_type& x);

      void
      xValidity (const xValidity_optional& x);

      void
      xValidity (::std::auto_ptr< xValidity_type > p);

      // yDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer yDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< yDecimalPlaces_type > yDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< yDecimalPlaces_type, char > yDecimalPlaces_traits;

      const yDecimalPlaces_optional&
      yDecimalPlaces () const;

      yDecimalPlaces_optional&
      yDecimalPlaces ();

      void
      yDecimalPlaces (const yDecimalPlaces_type& x);

      void
      yDecimalPlaces (const yDecimalPlaces_optional& x);

      // ySignificantFigures
      //
      typedef ::xml_schema::non_negative_integer ySignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< ySignificantFigures_type > ySignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< ySignificantFigures_type, char > ySignificantFigures_traits;

      const ySignificantFigures_optional&
      ySignificantFigures () const;

      ySignificantFigures_optional&
      ySignificantFigures ();

      void
      ySignificantFigures (const ySignificantFigures_type& x);

      void
      ySignificantFigures (const ySignificantFigures_optional& x);

      // yValidity
      //
      typedef ::xsd::qif2::ValidityEnumType yValidity_type;
      typedef ::xsd::cxx::tree::optional< yValidity_type > yValidity_optional;
      typedef ::xsd::cxx::tree::traits< yValidity_type, char > yValidity_traits;

      const yValidity_optional&
      yValidity () const;

      yValidity_optional&
      yValidity ();

      void
      yValidity (const yValidity_type& x);

      void
      yValidity (const yValidity_optional& x);

      void
      yValidity (::std::auto_ptr< yValidity_type > p);

      // zDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer zDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< zDecimalPlaces_type > zDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< zDecimalPlaces_type, char > zDecimalPlaces_traits;

      const zDecimalPlaces_optional&
      zDecimalPlaces () const;

      zDecimalPlaces_optional&
      zDecimalPlaces ();

      void
      zDecimalPlaces (const zDecimalPlaces_type& x);

      void
      zDecimalPlaces (const zDecimalPlaces_optional& x);

      // zSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer zSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< zSignificantFigures_type > zSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< zSignificantFigures_type, char > zSignificantFigures_traits;

      const zSignificantFigures_optional&
      zSignificantFigures () const;

      zSignificantFigures_optional&
      zSignificantFigures ();

      void
      zSignificantFigures (const zSignificantFigures_type& x);

      void
      zSignificantFigures (const zSignificantFigures_optional& x);

      // zValidity
      //
      typedef ::xsd::qif2::ValidityEnumType zValidity_type;
      typedef ::xsd::cxx::tree::optional< zValidity_type > zValidity_optional;
      typedef ::xsd::cxx::tree::traits< zValidity_type, char > zValidity_traits;

      const zValidity_optional&
      zValidity () const;

      zValidity_optional&
      zValidity ();

      void
      zValidity (const zValidity_type& x);

      void
      zValidity (const zValidity_optional& x);

      void
      zValidity (::std::auto_ptr< zValidity_type > p);

      // Constructors.
      //
      ArrayUnitVectorType (const N_type&);

      ArrayUnitVectorType (const ::xsd::qif2::ListDoubleType&,
                           const N_type&);

      ArrayUnitVectorType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      ArrayUnitVectorType (const ArrayUnitVectorType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual ArrayUnitVectorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayUnitVectorType&
      operator= (const ArrayUnitVectorType& x);

      virtual 
      ~ArrayUnitVectorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< N_type > N_;
      linearUnit_optional linearUnit_;
      decimalPlaces_optional decimalPlaces_;
      significantFigures_optional significantFigures_;
      validity_optional validity_;
      xDecimalPlaces_optional xDecimalPlaces_;
      xSignificantFigures_optional xSignificantFigures_;
      xValidity_optional xValidity_;
      yDecimalPlaces_optional yDecimalPlaces_;
      ySignificantFigures_optional ySignificantFigures_;
      yValidity_optional yValidity_;
      zDecimalPlaces_optional zDecimalPlaces_;
      zSignificantFigures_optional zSignificantFigures_;
      zValidity_optional zValidity_;
    };

    class PolyLineType: public ::xsd::qif2::ArrayPointType
    {
      public:
      // Constructors.
      //
      PolyLineType (const N_type&);

      PolyLineType (const ::xsd::qif2::ListDoubleType&,
                    const N_type&);

      PolyLineType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      PolyLineType (const PolyLineType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual PolyLineType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~PolyLineType ();
    };

    class PlaneType: public ::xml_schema::type
    {
      public:
      // Point
      //
      typedef ::xsd::qif2::PointType Point_type;
      typedef ::xsd::cxx::tree::traits< Point_type, char > Point_traits;

      const Point_type&
      Point () const;

      Point_type&
      Point ();

      void
      Point (const Point_type& x);

      void
      Point (::std::auto_ptr< Point_type > p);

      // Normal
      //
      typedef ::xsd::qif2::UnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::traits< Normal_type, char > Normal_traits;

      const Normal_type&
      Normal () const;

      Normal_type&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (::std::auto_ptr< Normal_type > p);

      // Constructors.
      //
      PlaneType (const Point_type&,
                 const Normal_type&);

      PlaneType (::std::auto_ptr< Point_type >,
                 ::std::auto_ptr< Normal_type >);

      PlaneType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      PlaneType (const PlaneType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual PlaneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlaneType&
      operator= (const PlaneType& x);

      virtual 
      ~PlaneType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Point_type > Point_;
      ::xsd::cxx::tree::one< Normal_type > Normal_;
    };

    class ActualPlaneType: public ::xml_schema::type
    {
      public:
      // Point
      //
      typedef ::xsd::qif2::ActualPointType Point_type;
      typedef ::xsd::cxx::tree::traits< Point_type, char > Point_traits;

      const Point_type&
      Point () const;

      Point_type&
      Point ();

      void
      Point (const Point_type& x);

      void
      Point (::std::auto_ptr< Point_type > p);

      // Normal
      //
      typedef ::xsd::qif2::ActualUnitVectorType Normal_type;
      typedef ::xsd::cxx::tree::traits< Normal_type, char > Normal_traits;

      const Normal_type&
      Normal () const;

      Normal_type&
      Normal ();

      void
      Normal (const Normal_type& x);

      void
      Normal (::std::auto_ptr< Normal_type > p);

      // Constructors.
      //
      ActualPlaneType (const Point_type&,
                       const Normal_type&);

      ActualPlaneType (::std::auto_ptr< Point_type >,
                       ::std::auto_ptr< Normal_type >);

      ActualPlaneType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ActualPlaneType (const ActualPlaneType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual ActualPlaneType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ActualPlaneType&
      operator= (const ActualPlaneType& x);

      virtual 
      ~ActualPlaneType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Point_type > Point_;
      ::xsd::cxx::tree::one< Normal_type > Normal_;
    };

    class PlaneXType: public ::xsd::qif2::PlaneType
    {
      public:
      // Direction
      //
      typedef ::xsd::qif2::UnitVectorType Direction_type;
      typedef ::xsd::cxx::tree::traits< Direction_type, char > Direction_traits;

      const Direction_type&
      Direction () const;

      Direction_type&
      Direction ();

      void
      Direction (const Direction_type& x);

      void
      Direction (::std::auto_ptr< Direction_type > p);

      // Constructors.
      //
      PlaneXType (const Point_type&,
                  const Normal_type&,
                  const Direction_type&);

      PlaneXType (::std::auto_ptr< Point_type >,
                  ::std::auto_ptr< Normal_type >,
                  ::std::auto_ptr< Direction_type >);

      PlaneXType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      PlaneXType (const PlaneXType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual PlaneXType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlaneXType&
      operator= (const PlaneXType& x);

      virtual 
      ~PlaneXType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Direction_type > Direction_;
    };

    class AxisType: public ::xml_schema::type
    {
      public:
      // AxisPoint
      //
      typedef ::xsd::qif2::PointType AxisPoint_type;
      typedef ::xsd::cxx::tree::traits< AxisPoint_type, char > AxisPoint_traits;

      const AxisPoint_type&
      AxisPoint () const;

      AxisPoint_type&
      AxisPoint ();

      void
      AxisPoint (const AxisPoint_type& x);

      void
      AxisPoint (::std::auto_ptr< AxisPoint_type > p);

      // Direction
      //
      typedef ::xsd::qif2::UnitVectorType Direction_type;
      typedef ::xsd::cxx::tree::traits< Direction_type, char > Direction_traits;

      const Direction_type&
      Direction () const;

      Direction_type&
      Direction ();

      void
      Direction (const Direction_type& x);

      void
      Direction (::std::auto_ptr< Direction_type > p);

      // Constructors.
      //
      AxisType (const AxisPoint_type&,
                const Direction_type&);

      AxisType (::std::auto_ptr< AxisPoint_type >,
                ::std::auto_ptr< Direction_type >);

      AxisType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      AxisType (const AxisType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual AxisType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AxisType&
      operator= (const AxisType& x);

      virtual 
      ~AxisType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< AxisPoint_type > AxisPoint_;
      ::xsd::cxx::tree::one< Direction_type > Direction_;
    };

    class ActualAxisType: public ::xml_schema::type
    {
      public:
      // AxisPoint
      //
      typedef ::xsd::qif2::ActualPointType AxisPoint_type;
      typedef ::xsd::cxx::tree::traits< AxisPoint_type, char > AxisPoint_traits;

      const AxisPoint_type&
      AxisPoint () const;

      AxisPoint_type&
      AxisPoint ();

      void
      AxisPoint (const AxisPoint_type& x);

      void
      AxisPoint (::std::auto_ptr< AxisPoint_type > p);

      // Direction
      //
      typedef ::xsd::qif2::ActualUnitVectorType Direction_type;
      typedef ::xsd::cxx::tree::traits< Direction_type, char > Direction_traits;

      const Direction_type&
      Direction () const;

      Direction_type&
      Direction ();

      void
      Direction (const Direction_type& x);

      void
      Direction (::std::auto_ptr< Direction_type > p);

      // Constructors.
      //
      ActualAxisType (const AxisPoint_type&,
                      const Direction_type&);

      ActualAxisType (::std::auto_ptr< AxisPoint_type >,
                      ::std::auto_ptr< Direction_type >);

      ActualAxisType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ActualAxisType (const ActualAxisType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual ActualAxisType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ActualAxisType&
      operator= (const ActualAxisType& x);

      virtual 
      ~ActualAxisType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< AxisPoint_type > AxisPoint_;
      ::xsd::cxx::tree::one< Direction_type > Direction_;
    };

    class TransformRotationType: public ::xml_schema::type
    {
      public:
      // XDirection
      //
      typedef ::xsd::qif2::UnitVectorSimpleType XDirection_type;
      typedef ::xsd::cxx::tree::traits< XDirection_type, char > XDirection_traits;

      const XDirection_type&
      XDirection () const;

      XDirection_type&
      XDirection ();

      void
      XDirection (const XDirection_type& x);

      void
      XDirection (::std::auto_ptr< XDirection_type > p);

      // YDirection
      //
      typedef ::xsd::qif2::UnitVectorSimpleType YDirection_type;
      typedef ::xsd::cxx::tree::traits< YDirection_type, char > YDirection_traits;

      const YDirection_type&
      YDirection () const;

      YDirection_type&
      YDirection ();

      void
      YDirection (const YDirection_type& x);

      void
      YDirection (::std::auto_ptr< YDirection_type > p);

      // ZDirection
      //
      typedef ::xsd::qif2::UnitVectorSimpleType ZDirection_type;
      typedef ::xsd::cxx::tree::traits< ZDirection_type, char > ZDirection_traits;

      const ZDirection_type&
      ZDirection () const;

      ZDirection_type&
      ZDirection ();

      void
      ZDirection (const ZDirection_type& x);

      void
      ZDirection (::std::auto_ptr< ZDirection_type > p);

      // Constructors.
      //
      TransformRotationType (const XDirection_type&,
                             const YDirection_type&,
                             const ZDirection_type&);

      TransformRotationType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      TransformRotationType (const TransformRotationType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual TransformRotationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TransformRotationType&
      operator= (const TransformRotationType& x);

      virtual 
      ~TransformRotationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< XDirection_type > XDirection_;
      ::xsd::cxx::tree::one< YDirection_type > YDirection_;
      ::xsd::cxx::tree::one< ZDirection_type > ZDirection_;
    };

    class CoordinateSystemCoreType: public ::xml_schema::type
    {
      public:
      // Rotation
      //
      typedef ::xsd::qif2::TransformRotationType Rotation_type;
      typedef ::xsd::cxx::tree::optional< Rotation_type > Rotation_optional;
      typedef ::xsd::cxx::tree::traits< Rotation_type, char > Rotation_traits;

      const Rotation_optional&
      Rotation () const;

      Rotation_optional&
      Rotation ();

      void
      Rotation (const Rotation_type& x);

      void
      Rotation (const Rotation_optional& x);

      void
      Rotation (::std::auto_ptr< Rotation_type > p);

      // Origin
      //
      typedef ::xsd::qif2::PointSimpleType Origin_type;
      typedef ::xsd::cxx::tree::optional< Origin_type > Origin_optional;
      typedef ::xsd::cxx::tree::traits< Origin_type, char > Origin_traits;

      const Origin_optional&
      Origin () const;

      Origin_optional&
      Origin ();

      void
      Origin (const Origin_type& x);

      void
      Origin (const Origin_optional& x);

      void
      Origin (::std::auto_ptr< Origin_type > p);

      // Constructors.
      //
      CoordinateSystemCoreType ();

      CoordinateSystemCoreType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      CoordinateSystemCoreType (const CoordinateSystemCoreType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual CoordinateSystemCoreType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CoordinateSystemCoreType&
      operator= (const CoordinateSystemCoreType& x);

      virtual 
      ~CoordinateSystemCoreType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Rotation_optional Rotation_;
      Origin_optional Origin_;
    };

    class TransformMatrixType: public ::xsd::qif2::CoordinateSystemCoreType
    {
      public:
      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, char > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::auto_ptr< linearUnit_type > p);

      // decimalPlaces
      //
      typedef ::xml_schema::non_negative_integer decimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< decimalPlaces_type > decimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< decimalPlaces_type, char > decimalPlaces_traits;

      const decimalPlaces_optional&
      decimalPlaces () const;

      decimalPlaces_optional&
      decimalPlaces ();

      void
      decimalPlaces (const decimalPlaces_type& x);

      void
      decimalPlaces (const decimalPlaces_optional& x);

      // significantFigures
      //
      typedef ::xml_schema::non_negative_integer significantFigures_type;
      typedef ::xsd::cxx::tree::optional< significantFigures_type > significantFigures_optional;
      typedef ::xsd::cxx::tree::traits< significantFigures_type, char > significantFigures_traits;

      const significantFigures_optional&
      significantFigures () const;

      significantFigures_optional&
      significantFigures ();

      void
      significantFigures (const significantFigures_type& x);

      void
      significantFigures (const significantFigures_optional& x);

      // validity
      //
      typedef ::xsd::qif2::ValidityEnumType validity_type;
      typedef ::xsd::cxx::tree::optional< validity_type > validity_optional;
      typedef ::xsd::cxx::tree::traits< validity_type, char > validity_traits;

      const validity_optional&
      validity () const;

      validity_optional&
      validity ();

      void
      validity (const validity_type& x);

      void
      validity (const validity_optional& x);

      void
      validity (::std::auto_ptr< validity_type > p);

      // xDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer xDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< xDecimalPlaces_type > xDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< xDecimalPlaces_type, char > xDecimalPlaces_traits;

      const xDecimalPlaces_optional&
      xDecimalPlaces () const;

      xDecimalPlaces_optional&
      xDecimalPlaces ();

      void
      xDecimalPlaces (const xDecimalPlaces_type& x);

      void
      xDecimalPlaces (const xDecimalPlaces_optional& x);

      // xSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer xSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< xSignificantFigures_type > xSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< xSignificantFigures_type, char > xSignificantFigures_traits;

      const xSignificantFigures_optional&
      xSignificantFigures () const;

      xSignificantFigures_optional&
      xSignificantFigures ();

      void
      xSignificantFigures (const xSignificantFigures_type& x);

      void
      xSignificantFigures (const xSignificantFigures_optional& x);

      // xValidity
      //
      typedef ::xsd::qif2::ValidityEnumType xValidity_type;
      typedef ::xsd::cxx::tree::optional< xValidity_type > xValidity_optional;
      typedef ::xsd::cxx::tree::traits< xValidity_type, char > xValidity_traits;

      const xValidity_optional&
      xValidity () const;

      xValidity_optional&
      xValidity ();

      void
      xValidity (const xValidity_type& x);

      void
      xValidity (const xValidity_optional& x);

      void
      xValidity (::std::auto_ptr< xValidity_type > p);

      // yDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer yDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< yDecimalPlaces_type > yDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< yDecimalPlaces_type, char > yDecimalPlaces_traits;

      const yDecimalPlaces_optional&
      yDecimalPlaces () const;

      yDecimalPlaces_optional&
      yDecimalPlaces ();

      void
      yDecimalPlaces (const yDecimalPlaces_type& x);

      void
      yDecimalPlaces (const yDecimalPlaces_optional& x);

      // ySignificantFigures
      //
      typedef ::xml_schema::non_negative_integer ySignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< ySignificantFigures_type > ySignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< ySignificantFigures_type, char > ySignificantFigures_traits;

      const ySignificantFigures_optional&
      ySignificantFigures () const;

      ySignificantFigures_optional&
      ySignificantFigures ();

      void
      ySignificantFigures (const ySignificantFigures_type& x);

      void
      ySignificantFigures (const ySignificantFigures_optional& x);

      // yValidity
      //
      typedef ::xsd::qif2::ValidityEnumType yValidity_type;
      typedef ::xsd::cxx::tree::optional< yValidity_type > yValidity_optional;
      typedef ::xsd::cxx::tree::traits< yValidity_type, char > yValidity_traits;

      const yValidity_optional&
      yValidity () const;

      yValidity_optional&
      yValidity ();

      void
      yValidity (const yValidity_type& x);

      void
      yValidity (const yValidity_optional& x);

      void
      yValidity (::std::auto_ptr< yValidity_type > p);

      // zDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer zDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< zDecimalPlaces_type > zDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< zDecimalPlaces_type, char > zDecimalPlaces_traits;

      const zDecimalPlaces_optional&
      zDecimalPlaces () const;

      zDecimalPlaces_optional&
      zDecimalPlaces ();

      void
      zDecimalPlaces (const zDecimalPlaces_type& x);

      void
      zDecimalPlaces (const zDecimalPlaces_optional& x);

      // zSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer zSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< zSignificantFigures_type > zSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< zSignificantFigures_type, char > zSignificantFigures_traits;

      const zSignificantFigures_optional&
      zSignificantFigures () const;

      zSignificantFigures_optional&
      zSignificantFigures ();

      void
      zSignificantFigures (const zSignificantFigures_type& x);

      void
      zSignificantFigures (const zSignificantFigures_optional& x);

      // zValidity
      //
      typedef ::xsd::qif2::ValidityEnumType zValidity_type;
      typedef ::xsd::cxx::tree::optional< zValidity_type > zValidity_optional;
      typedef ::xsd::cxx::tree::traits< zValidity_type, char > zValidity_traits;

      const zValidity_optional&
      zValidity () const;

      zValidity_optional&
      zValidity ();

      void
      zValidity (const zValidity_type& x);

      void
      zValidity (const zValidity_optional& x);

      void
      zValidity (::std::auto_ptr< zValidity_type > p);

      // Constructors.
      //
      TransformMatrixType ();

      TransformMatrixType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      TransformMatrixType (const TransformMatrixType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual TransformMatrixType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TransformMatrixType&
      operator= (const TransformMatrixType& x);

      virtual 
      ~TransformMatrixType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      linearUnit_optional linearUnit_;
      decimalPlaces_optional decimalPlaces_;
      significantFigures_optional significantFigures_;
      validity_optional validity_;
      xDecimalPlaces_optional xDecimalPlaces_;
      xSignificantFigures_optional xSignificantFigures_;
      xValidity_optional xValidity_;
      yDecimalPlaces_optional yDecimalPlaces_;
      ySignificantFigures_optional ySignificantFigures_;
      yValidity_optional yValidity_;
      zDecimalPlaces_optional zDecimalPlaces_;
      zSignificantFigures_optional zSignificantFigures_;
      zValidity_optional zValidity_;
    };

    class LineSegmentType: public ::xml_schema::type
    {
      public:
      // StartPoint
      //
      typedef ::xsd::qif2::PointSimpleType StartPoint_type;
      typedef ::xsd::cxx::tree::traits< StartPoint_type, char > StartPoint_traits;

      const StartPoint_type&
      StartPoint () const;

      StartPoint_type&
      StartPoint ();

      void
      StartPoint (const StartPoint_type& x);

      void
      StartPoint (::std::auto_ptr< StartPoint_type > p);

      // EndPoint
      //
      typedef ::xsd::qif2::PointSimpleType EndPoint_type;
      typedef ::xsd::cxx::tree::traits< EndPoint_type, char > EndPoint_traits;

      const EndPoint_type&
      EndPoint () const;

      EndPoint_type&
      EndPoint ();

      void
      EndPoint (const EndPoint_type& x);

      void
      EndPoint (::std::auto_ptr< EndPoint_type > p);

      // linearUnit
      //
      typedef ::xml_schema::token linearUnit_type;
      typedef ::xsd::cxx::tree::optional< linearUnit_type > linearUnit_optional;
      typedef ::xsd::cxx::tree::traits< linearUnit_type, char > linearUnit_traits;

      const linearUnit_optional&
      linearUnit () const;

      linearUnit_optional&
      linearUnit ();

      void
      linearUnit (const linearUnit_type& x);

      void
      linearUnit (const linearUnit_optional& x);

      void
      linearUnit (::std::auto_ptr< linearUnit_type > p);

      // decimalPlaces
      //
      typedef ::xml_schema::non_negative_integer decimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< decimalPlaces_type > decimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< decimalPlaces_type, char > decimalPlaces_traits;

      const decimalPlaces_optional&
      decimalPlaces () const;

      decimalPlaces_optional&
      decimalPlaces ();

      void
      decimalPlaces (const decimalPlaces_type& x);

      void
      decimalPlaces (const decimalPlaces_optional& x);

      // significantFigures
      //
      typedef ::xml_schema::non_negative_integer significantFigures_type;
      typedef ::xsd::cxx::tree::optional< significantFigures_type > significantFigures_optional;
      typedef ::xsd::cxx::tree::traits< significantFigures_type, char > significantFigures_traits;

      const significantFigures_optional&
      significantFigures () const;

      significantFigures_optional&
      significantFigures ();

      void
      significantFigures (const significantFigures_type& x);

      void
      significantFigures (const significantFigures_optional& x);

      // validity
      //
      typedef ::xsd::qif2::ValidityEnumType validity_type;
      typedef ::xsd::cxx::tree::optional< validity_type > validity_optional;
      typedef ::xsd::cxx::tree::traits< validity_type, char > validity_traits;

      const validity_optional&
      validity () const;

      validity_optional&
      validity ();

      void
      validity (const validity_type& x);

      void
      validity (const validity_optional& x);

      void
      validity (::std::auto_ptr< validity_type > p);

      // xDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer xDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< xDecimalPlaces_type > xDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< xDecimalPlaces_type, char > xDecimalPlaces_traits;

      const xDecimalPlaces_optional&
      xDecimalPlaces () const;

      xDecimalPlaces_optional&
      xDecimalPlaces ();

      void
      xDecimalPlaces (const xDecimalPlaces_type& x);

      void
      xDecimalPlaces (const xDecimalPlaces_optional& x);

      // xSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer xSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< xSignificantFigures_type > xSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< xSignificantFigures_type, char > xSignificantFigures_traits;

      const xSignificantFigures_optional&
      xSignificantFigures () const;

      xSignificantFigures_optional&
      xSignificantFigures ();

      void
      xSignificantFigures (const xSignificantFigures_type& x);

      void
      xSignificantFigures (const xSignificantFigures_optional& x);

      // xValidity
      //
      typedef ::xsd::qif2::ValidityEnumType xValidity_type;
      typedef ::xsd::cxx::tree::optional< xValidity_type > xValidity_optional;
      typedef ::xsd::cxx::tree::traits< xValidity_type, char > xValidity_traits;

      const xValidity_optional&
      xValidity () const;

      xValidity_optional&
      xValidity ();

      void
      xValidity (const xValidity_type& x);

      void
      xValidity (const xValidity_optional& x);

      void
      xValidity (::std::auto_ptr< xValidity_type > p);

      // yDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer yDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< yDecimalPlaces_type > yDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< yDecimalPlaces_type, char > yDecimalPlaces_traits;

      const yDecimalPlaces_optional&
      yDecimalPlaces () const;

      yDecimalPlaces_optional&
      yDecimalPlaces ();

      void
      yDecimalPlaces (const yDecimalPlaces_type& x);

      void
      yDecimalPlaces (const yDecimalPlaces_optional& x);

      // ySignificantFigures
      //
      typedef ::xml_schema::non_negative_integer ySignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< ySignificantFigures_type > ySignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< ySignificantFigures_type, char > ySignificantFigures_traits;

      const ySignificantFigures_optional&
      ySignificantFigures () const;

      ySignificantFigures_optional&
      ySignificantFigures ();

      void
      ySignificantFigures (const ySignificantFigures_type& x);

      void
      ySignificantFigures (const ySignificantFigures_optional& x);

      // yValidity
      //
      typedef ::xsd::qif2::ValidityEnumType yValidity_type;
      typedef ::xsd::cxx::tree::optional< yValidity_type > yValidity_optional;
      typedef ::xsd::cxx::tree::traits< yValidity_type, char > yValidity_traits;

      const yValidity_optional&
      yValidity () const;

      yValidity_optional&
      yValidity ();

      void
      yValidity (const yValidity_type& x);

      void
      yValidity (const yValidity_optional& x);

      void
      yValidity (::std::auto_ptr< yValidity_type > p);

      // zDecimalPlaces
      //
      typedef ::xml_schema::non_negative_integer zDecimalPlaces_type;
      typedef ::xsd::cxx::tree::optional< zDecimalPlaces_type > zDecimalPlaces_optional;
      typedef ::xsd::cxx::tree::traits< zDecimalPlaces_type, char > zDecimalPlaces_traits;

      const zDecimalPlaces_optional&
      zDecimalPlaces () const;

      zDecimalPlaces_optional&
      zDecimalPlaces ();

      void
      zDecimalPlaces (const zDecimalPlaces_type& x);

      void
      zDecimalPlaces (const zDecimalPlaces_optional& x);

      // zSignificantFigures
      //
      typedef ::xml_schema::non_negative_integer zSignificantFigures_type;
      typedef ::xsd::cxx::tree::optional< zSignificantFigures_type > zSignificantFigures_optional;
      typedef ::xsd::cxx::tree::traits< zSignificantFigures_type, char > zSignificantFigures_traits;

      const zSignificantFigures_optional&
      zSignificantFigures () const;

      zSignificantFigures_optional&
      zSignificantFigures ();

      void
      zSignificantFigures (const zSignificantFigures_type& x);

      void
      zSignificantFigures (const zSignificantFigures_optional& x);

      // zValidity
      //
      typedef ::xsd::qif2::ValidityEnumType zValidity_type;
      typedef ::xsd::cxx::tree::optional< zValidity_type > zValidity_optional;
      typedef ::xsd::cxx::tree::traits< zValidity_type, char > zValidity_traits;

      const zValidity_optional&
      zValidity () const;

      zValidity_optional&
      zValidity ();

      void
      zValidity (const zValidity_type& x);

      void
      zValidity (const zValidity_optional& x);

      void
      zValidity (::std::auto_ptr< zValidity_type > p);

      // Constructors.
      //
      LineSegmentType (const StartPoint_type&,
                       const EndPoint_type&);

      LineSegmentType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      LineSegmentType (const LineSegmentType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual LineSegmentType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineSegmentType&
      operator= (const LineSegmentType& x);

      virtual 
      ~LineSegmentType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< StartPoint_type > StartPoint_;
      ::xsd::cxx::tree::one< EndPoint_type > EndPoint_;
      linearUnit_optional linearUnit_;
      decimalPlaces_optional decimalPlaces_;
      significantFigures_optional significantFigures_;
      validity_optional validity_;
      xDecimalPlaces_optional xDecimalPlaces_;
      xSignificantFigures_optional xSignificantFigures_;
      xValidity_optional xValidity_;
      yDecimalPlaces_optional yDecimalPlaces_;
      ySignificantFigures_optional ySignificantFigures_;
      yValidity_optional yValidity_;
      zDecimalPlaces_optional zDecimalPlaces_;
      zSignificantFigures_optional zSignificantFigures_;
      zValidity_optional zValidity_;
    };

    class LineSegment2dType: public ::xml_schema::type
    {
      public:
      // StartPoint
      //
      typedef ::xsd::qif2::Point2dSimpleType StartPoint_type;
      typedef ::xsd::cxx::tree::traits< StartPoint_type, char > StartPoint_traits;

      const StartPoint_type&
      StartPoint () const;

      StartPoint_type&
      StartPoint ();

      void
      StartPoint (const StartPoint_type& x);

      void
      StartPoint (::std::auto_ptr< StartPoint_type > p);

      // EndPoint
      //
      typedef ::xsd::qif2::Point2dSimpleType EndPoint_type;
      typedef ::xsd::cxx::tree::traits< EndPoint_type, char > EndPoint_traits;

      const EndPoint_type&
      EndPoint () const;

      EndPoint_type&
      EndPoint ();

      void
      EndPoint (const EndPoint_type& x);

      void
      EndPoint (::std::auto_ptr< EndPoint_type > p);

      // Constructors.
      //
      LineSegment2dType (const StartPoint_type&,
                         const EndPoint_type&);

      LineSegment2dType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      LineSegment2dType (const LineSegment2dType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual LineSegment2dType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LineSegment2dType&
      operator= (const LineSegment2dType& x);

      virtual 
      ~LineSegment2dType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< StartPoint_type > StartPoint_;
      ::xsd::cxx::tree::one< EndPoint_type > EndPoint_;
    };

    class LatitudeLongitudeSweepType: public ::xml_schema::type
    {
      public:
      // DirMeridianPrime
      //
      typedef ::xsd::qif2::UnitVectorType DirMeridianPrime_type;
      typedef ::xsd::cxx::tree::traits< DirMeridianPrime_type, char > DirMeridianPrime_traits;

      const DirMeridianPrime_type&
      DirMeridianPrime () const;

      DirMeridianPrime_type&
      DirMeridianPrime ();

      void
      DirMeridianPrime (const DirMeridianPrime_type& x);

      void
      DirMeridianPrime (::std::auto_ptr< DirMeridianPrime_type > p);

      // DomainLatitude
      //
      typedef ::xsd::qif2::AngleRangeType DomainLatitude_type;
      typedef ::xsd::cxx::tree::traits< DomainLatitude_type, char > DomainLatitude_traits;

      const DomainLatitude_type&
      DomainLatitude () const;

      DomainLatitude_type&
      DomainLatitude ();

      void
      DomainLatitude (const DomainLatitude_type& x);

      void
      DomainLatitude (::std::auto_ptr< DomainLatitude_type > p);

      // DomainLongitude
      //
      typedef ::xsd::qif2::AngleRangeType DomainLongitude_type;
      typedef ::xsd::cxx::tree::traits< DomainLongitude_type, char > DomainLongitude_traits;

      const DomainLongitude_type&
      DomainLongitude () const;

      DomainLongitude_type&
      DomainLongitude ();

      void
      DomainLongitude (const DomainLongitude_type& x);

      void
      DomainLongitude (::std::auto_ptr< DomainLongitude_type > p);

      // Constructors.
      //
      LatitudeLongitudeSweepType (const DirMeridianPrime_type&,
                                  const DomainLatitude_type&,
                                  const DomainLongitude_type&);

      LatitudeLongitudeSweepType (::std::auto_ptr< DirMeridianPrime_type >,
                                  ::std::auto_ptr< DomainLatitude_type >,
                                  ::std::auto_ptr< DomainLongitude_type >);

      LatitudeLongitudeSweepType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      LatitudeLongitudeSweepType (const LatitudeLongitudeSweepType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual LatitudeLongitudeSweepType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LatitudeLongitudeSweepType&
      operator= (const LatitudeLongitudeSweepType& x);

      virtual 
      ~LatitudeLongitudeSweepType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DirMeridianPrime_type > DirMeridianPrime_;
      ::xsd::cxx::tree::one< DomainLatitude_type > DomainLatitude_;
      ::xsd::cxx::tree::one< DomainLongitude_type > DomainLongitude_;
    };

    class OrientedLatitudeLongitudeSweepType: public ::xsd::qif2::LatitudeLongitudeSweepType
    {
      public:
      // DirNorthPole
      //
      typedef ::xsd::qif2::UnitVectorType DirNorthPole_type;
      typedef ::xsd::cxx::tree::traits< DirNorthPole_type, char > DirNorthPole_traits;

      const DirNorthPole_type&
      DirNorthPole () const;

      DirNorthPole_type&
      DirNorthPole ();

      void
      DirNorthPole (const DirNorthPole_type& x);

      void
      DirNorthPole (::std::auto_ptr< DirNorthPole_type > p);

      // Constructors.
      //
      OrientedLatitudeLongitudeSweepType (const DirMeridianPrime_type&,
                                          const DomainLatitude_type&,
                                          const DomainLongitude_type&,
                                          const DirNorthPole_type&);

      OrientedLatitudeLongitudeSweepType (::std::auto_ptr< DirMeridianPrime_type >,
                                          ::std::auto_ptr< DomainLatitude_type >,
                                          ::std::auto_ptr< DomainLongitude_type >,
                                          ::std::auto_ptr< DirNorthPole_type >);

      OrientedLatitudeLongitudeSweepType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      OrientedLatitudeLongitudeSweepType (const OrientedLatitudeLongitudeSweepType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual OrientedLatitudeLongitudeSweepType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OrientedLatitudeLongitudeSweepType&
      operator= (const OrientedLatitudeLongitudeSweepType& x);

      virtual 
      ~OrientedLatitudeLongitudeSweepType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DirNorthPole_type > DirNorthPole_;
    };

    class SweepType: public ::xml_schema::type
    {
      public:
      // DirBeg
      //
      typedef ::xsd::qif2::UnitVectorType DirBeg_type;
      typedef ::xsd::cxx::tree::traits< DirBeg_type, char > DirBeg_traits;

      const DirBeg_type&
      DirBeg () const;

      DirBeg_type&
      DirBeg ();

      void
      DirBeg (const DirBeg_type& x);

      void
      DirBeg (::std::auto_ptr< DirBeg_type > p);

      // DomainAngle
      //
      typedef ::xsd::qif2::AngleRangeType DomainAngle_type;
      typedef ::xsd::cxx::tree::traits< DomainAngle_type, char > DomainAngle_traits;

      const DomainAngle_type&
      DomainAngle () const;

      DomainAngle_type&
      DomainAngle ();

      void
      DomainAngle (const DomainAngle_type& x);

      void
      DomainAngle (::std::auto_ptr< DomainAngle_type > p);

      // Constructors.
      //
      SweepType (const DirBeg_type&,
                 const DomainAngle_type&);

      SweepType (::std::auto_ptr< DirBeg_type >,
                 ::std::auto_ptr< DomainAngle_type >);

      SweepType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      SweepType (const SweepType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual SweepType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SweepType&
      operator= (const SweepType& x);

      virtual 
      ~SweepType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DirBeg_type > DirBeg_;
      ::xsd::cxx::tree::one< DomainAngle_type > DomainAngle_;
    };

    class AngleRangeType: public ::xsd::qif2::D2Type
    {
      public:
      // angularUnit
      //
      typedef ::xml_schema::token angularUnit_type;
      typedef ::xsd::cxx::tree::optional< angularUnit_type > angularUnit_optional;
      typedef ::xsd::cxx::tree::traits< angularUnit_type, char > angularUnit_traits;

      const angularUnit_optional&
      angularUnit () const;

      angularUnit_optional&
      angularUnit ();

      void
      angularUnit (const angularUnit_type& x);

      void
      angularUnit (const angularUnit_optional& x);

      void
      angularUnit (::std::auto_ptr< angularUnit_type > p);

      // Constructors.
      //
      AngleRangeType ();

      AngleRangeType (const ::xsd::qif2::ListDoubleType&);

      AngleRangeType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      AngleRangeType (const AngleRangeType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual AngleRangeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngleRangeType&
      operator= (const AngleRangeType& x);

      virtual 
      ~AngleRangeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      angularUnit_optional angularUnit_;
    };

    class QIFIdType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type >
    {
      public:
      // Constructors.
      //
      QIFIdType (const ::xml_schema::unsigned_int&);

      QIFIdType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      QIFIdType (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      QIFIdType (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      QIFIdType (const QIFIdType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual QIFIdType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~QIFIdType ();
    };

    class QIFReferenceType: public ::xsd::qif2::QIFIdType
    {
      public:
      // Constructors.
      //
      QIFReferenceType (const ::xml_schema::unsigned_int&);

      QIFReferenceType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      QIFReferenceType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      QIFReferenceType (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      QIFReferenceType (const QIFReferenceType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual QIFReferenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~QIFReferenceType ();
    };

    class QIFReferenceFullType: public ::xsd::qif2::QIFReferenceType
    {
      public:
      // asmPath
      //
      typedef ::xsd::qif2::QIFIdType asmPath_type;
      typedef ::xsd::cxx::tree::optional< asmPath_type > asmPath_optional;
      typedef ::xsd::cxx::tree::traits< asmPath_type, char > asmPath_traits;

      const asmPath_optional&
      asmPath () const;

      asmPath_optional&
      asmPath ();

      void
      asmPath (const asmPath_type& x);

      void
      asmPath (const asmPath_optional& x);

      void
      asmPath (::std::auto_ptr< asmPath_type > p);

      // Constructors.
      //
      QIFReferenceFullType (const ::xml_schema::unsigned_int&);

      QIFReferenceFullType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      QIFReferenceFullType (const QIFReferenceFullType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual QIFReferenceFullType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      QIFReferenceFullType&
      operator= (const QIFReferenceFullType& x);

      virtual 
      ~QIFReferenceFullType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      asmPath_optional asmPath_;
    };

    class ElementReferenceType: public ::xml_schema::type
    {
      public:
      // Id
      //
      typedef ::xsd::qif2::QIFReferenceType Id_type;
      typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

      const Id_type&
      Id () const;

      Id_type&
      Id ();

      void
      Id (const Id_type& x);

      void
      Id (::std::auto_ptr< Id_type > p);

      // Constructors.
      //
      ElementReferenceType (const Id_type&);

      ElementReferenceType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ElementReferenceType (const ElementReferenceType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual ElementReferenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElementReferenceType&
      operator= (const ElementReferenceType& x);

      virtual 
      ~ElementReferenceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Id_type > Id_;
    };

    class ElementReferenceFullType: public ::xml_schema::type
    {
      public:
      // Id
      //
      typedef ::xsd::qif2::QIFReferenceFullType Id_type;
      typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

      const Id_type&
      Id () const;

      Id_type&
      Id ();

      void
      Id (const Id_type& x);

      void
      Id (::std::auto_ptr< Id_type > p);

      // Constructors.
      //
      ElementReferenceFullType (const Id_type&);

      ElementReferenceFullType (::std::auto_ptr< Id_type >);

      ElementReferenceFullType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      ElementReferenceFullType (const ElementReferenceFullType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual ElementReferenceFullType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElementReferenceFullType&
      operator= (const ElementReferenceFullType& x);

      virtual 
      ~ElementReferenceFullType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Id_type > Id_;
    };

    class D4Type: public ::xsd::qif2::ListDoubleType
    {
      public:
      // Constructors.
      //
      D4Type ();

      D4Type (const ::xsd::qif2::ListDoubleType&);

      D4Type (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      D4Type (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      D4Type (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      D4Type (const D4Type& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      virtual D4Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~D4Type ();
    };

    class NaturalType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type >
    {
      public:
      // Constructors.
      //
      NaturalType (const ::xml_schema::unsigned_int&);

      NaturalType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      NaturalType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      NaturalType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      NaturalType (const NaturalType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual NaturalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~NaturalType ();
    };

    class ListNaturalType: public ::xml_schema::simple_type,
      public ::xsd::cxx::tree::list< ::xsd::qif2::NaturalType, char >
    {
      public:
      ListNaturalType ();

      ListNaturalType (size_type n, const ::xsd::qif2::NaturalType& x);

      template < typename I >
      ListNaturalType (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::xsd::qif2::NaturalType, char > (begin, end, this)
      {
      }

      ListNaturalType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ListNaturalType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ListNaturalType (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ListNaturalType (const ListNaturalType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual ListNaturalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ListNaturalType ();
    };

    class ArrayNaturalType: public ::xsd::qif2::ListNaturalType
    {
      public:
      // N
      //
      typedef ::xml_schema::unsigned_int N_type;
      typedef ::xsd::cxx::tree::traits< N_type, char > N_traits;

      const N_type&
      N () const;

      N_type&
      N ();

      void
      N (const N_type& x);

      // Constructors.
      //
      ArrayNaturalType (const N_type&);

      ArrayNaturalType (const ::xsd::qif2::ListNaturalType&,
                        const N_type&);

      ArrayNaturalType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ArrayNaturalType (const ArrayNaturalType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual ArrayNaturalType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayNaturalType&
      operator= (const ArrayNaturalType& x);

      virtual 
      ~ArrayNaturalType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< N_type > N_;
    };

    class ArrayReferenceType: public ::xml_schema::type
    {
      public:
      // Id
      //
      typedef ::xsd::qif2::QIFReferenceType Id_type;
      typedef ::xsd::cxx::tree::sequence< Id_type > Id_sequence;
      typedef Id_sequence::iterator Id_iterator;
      typedef Id_sequence::const_iterator Id_const_iterator;
      typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

      const Id_sequence&
      Id () const;

      Id_sequence&
      Id ();

      void
      Id (const Id_sequence& s);

      // N
      //
      typedef ::xsd::qif2::NaturalType N_type;
      typedef ::xsd::cxx::tree::traits< N_type, char > N_traits;

      const N_type&
      N () const;

      N_type&
      N ();

      void
      N (const N_type& x);

      void
      N (::std::auto_ptr< N_type > p);

      // Constructors.
      //
      ArrayReferenceType (const N_type&);

      ArrayReferenceType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ArrayReferenceType (const ArrayReferenceType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual ArrayReferenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayReferenceType&
      operator= (const ArrayReferenceType& x);

      virtual 
      ~ArrayReferenceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Id_sequence Id_;
      ::xsd::cxx::tree::one< N_type > N_;
    };

    class ArrayReferenceFullType: public ::xml_schema::type
    {
      public:
      // Id
      //
      typedef ::xsd::qif2::QIFReferenceFullType Id_type;
      typedef ::xsd::cxx::tree::sequence< Id_type > Id_sequence;
      typedef Id_sequence::iterator Id_iterator;
      typedef Id_sequence::const_iterator Id_const_iterator;
      typedef ::xsd::cxx::tree::traits< Id_type, char > Id_traits;

      const Id_sequence&
      Id () const;

      Id_sequence&
      Id ();

      void
      Id (const Id_sequence& s);

      // N
      //
      typedef ::xsd::qif2::NaturalType N_type;
      typedef ::xsd::cxx::tree::traits< N_type, char > N_traits;

      const N_type&
      N () const;

      N_type&
      N ();

      void
      N (const N_type& x);

      void
      N (::std::auto_ptr< N_type > p);

      // Constructors.
      //
      ArrayReferenceFullType (const N_type&);

      ArrayReferenceFullType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      ArrayReferenceFullType (const ArrayReferenceFullType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual ArrayReferenceFullType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayReferenceFullType&
      operator= (const ArrayReferenceFullType& x);

      virtual 
      ~ArrayReferenceFullType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Id_sequence Id_;
      ::xsd::cxx::tree::one< N_type > N_;
    };

    class ListBoolType: public ::xml_schema::simple_type,
      public ::xsd::cxx::tree::list< ::xml_schema::boolean, char >
    {
      public:
      ListBoolType ();

      ListBoolType (size_type n, const ::xml_schema::boolean& x);

      template < typename I >
      ListBoolType (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::xml_schema::boolean, char > (begin, end, this)
      {
      }

      ListBoolType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      ListBoolType (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      ListBoolType (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      ListBoolType (const ListBoolType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual ListBoolType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ListBoolType ();
    };

    class ListUnsignedByteType: public ::xml_schema::simple_type,
      public ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char >
    {
      public:
      ListUnsignedByteType ();

      ListUnsignedByteType (size_type n, const ::xml_schema::unsigned_byte& x);

      template < typename I >
      ListUnsignedByteType (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (begin, end, this)
      {
      }

      ListUnsignedByteType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ListUnsignedByteType (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ListUnsignedByteType (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ListUnsignedByteType (const ListUnsignedByteType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual ListUnsignedByteType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ListUnsignedByteType ();
    };

    class QPIdType: public ::xml_schema::token
    {
      public:
      // Constructors.
      //
      QPIdType ();

      QPIdType (const char*);

      QPIdType (const ::std::string&);

      QPIdType (const ::xml_schema::token&);

      QPIdType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      QPIdType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      QPIdType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      QPIdType (const QPIdType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual QPIdType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~QPIdType ();
    };

    class QPIdReferenceType: public ::xml_schema::token
    {
      public:
      // Constructors.
      //
      QPIdReferenceType ();

      QPIdReferenceType (const char*);

      QPIdReferenceType (const ::std::string&);

      QPIdReferenceType (const ::xml_schema::token&);

      QPIdReferenceType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      QPIdReferenceType (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      QPIdReferenceType (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      QPIdReferenceType (const QPIdReferenceType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual QPIdReferenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~QPIdReferenceType ();
    };

    class QPIdFullReferenceType: public ::xml_schema::type
    {
      public:
      // ItemQPId
      //
      typedef ::xsd::qif2::QPIdReferenceType ItemQPId_type;
      typedef ::xsd::cxx::tree::traits< ItemQPId_type, char > ItemQPId_traits;

      const ItemQPId_type&
      ItemQPId () const;

      ItemQPId_type&
      ItemQPId ();

      void
      ItemQPId (const ItemQPId_type& x);

      void
      ItemQPId (::std::auto_ptr< ItemQPId_type > p);

      // DocumentQPId
      //
      typedef ::xsd::qif2::QPIdReferenceType DocumentQPId_type;
      typedef ::xsd::cxx::tree::sequence< DocumentQPId_type > DocumentQPId_sequence;
      typedef DocumentQPId_sequence::iterator DocumentQPId_iterator;
      typedef DocumentQPId_sequence::const_iterator DocumentQPId_const_iterator;
      typedef ::xsd::cxx::tree::traits< DocumentQPId_type, char > DocumentQPId_traits;

      const DocumentQPId_sequence&
      DocumentQPId () const;

      DocumentQPId_sequence&
      DocumentQPId ();

      void
      DocumentQPId (const DocumentQPId_sequence& s);

      // Constructors.
      //
      QPIdFullReferenceType (const ItemQPId_type&);

      QPIdFullReferenceType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      QPIdFullReferenceType (const QPIdFullReferenceType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual QPIdFullReferenceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      QPIdFullReferenceType&
      operator= (const QPIdFullReferenceType& x);

      virtual 
      ~QPIdFullReferenceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ItemQPId_type > ItemQPId_;
      DocumentQPId_sequence DocumentQPId_;
    };

    class ArrayUnsignedByteType: public ::xsd::qif2::ListUnsignedByteType
    {
      public:
      // N
      //
      typedef ::xml_schema::unsigned_int N_type;
      typedef ::xsd::cxx::tree::traits< N_type, char > N_traits;

      const N_type&
      N () const;

      N_type&
      N ();

      void
      N (const N_type& x);

      // Constructors.
      //
      ArrayUnsignedByteType (const N_type&);

      ArrayUnsignedByteType (const ::xsd::qif2::ListUnsignedByteType&,
                             const N_type&);

      ArrayUnsignedByteType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      ArrayUnsignedByteType (const ArrayUnsignedByteType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual ArrayUnsignedByteType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayUnsignedByteType&
      operator= (const ArrayUnsignedByteType& x);

      virtual 
      ~ArrayUnsignedByteType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< N_type > N_;
    };

    class ArrayIntType: public ::xsd::qif2::ListIntType
    {
      public:
      // N
      //
      typedef ::xml_schema::unsigned_int N_type;
      typedef ::xsd::cxx::tree::traits< N_type, char > N_traits;

      const N_type&
      N () const;

      N_type&
      N ();

      void
      N (const N_type& x);

      // Constructors.
      //
      ArrayIntType (const N_type&);

      ArrayIntType (const ::xsd::qif2::ListIntType&,
                    const N_type&);

      ArrayIntType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      ArrayIntType (const ArrayIntType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual ArrayIntType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayIntType&
      operator= (const ArrayIntType& x);

      virtual 
      ~ArrayIntType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< N_type > N_;
    };

    class ArrayI2Type: public ::xsd::qif2::ListIntType
    {
      public:
      // N
      //
      typedef ::xml_schema::positive_integer N_type;
      typedef ::xsd::cxx::tree::traits< N_type, char > N_traits;

      const N_type&
      N () const;

      N_type&
      N ();

      void
      N (const N_type& x);

      // Constructors.
      //
      ArrayI2Type (const N_type&);

      ArrayI2Type (const ::xsd::qif2::ListIntType&,
                   const N_type&);

      ArrayI2Type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      ArrayI2Type (const ArrayI2Type& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual ArrayI2Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayI2Type&
      operator= (const ArrayI2Type& x);

      virtual 
      ~ArrayI2Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< N_type > N_;
    };

    class ArrayI3Type: public ::xsd::qif2::ListIntType
    {
      public:
      // N
      //
      typedef ::xml_schema::positive_integer N_type;
      typedef ::xsd::cxx::tree::traits< N_type, char > N_traits;

      const N_type&
      N () const;

      N_type&
      N ();

      void
      N (const N_type& x);

      // Constructors.
      //
      ArrayI3Type (const N_type&);

      ArrayI3Type (const ::xsd::qif2::ListIntType&,
                   const N_type&);

      ArrayI3Type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      ArrayI3Type (const ArrayI3Type& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual ArrayI3Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayI3Type&
      operator= (const ArrayI3Type& x);

      virtual 
      ~ArrayI3Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< N_type > N_;
    };

    class ArrayDoubleType: public ::xsd::qif2::ListDoubleType
    {
      public:
      // N
      //
      typedef ::xml_schema::unsigned_int N_type;
      typedef ::xsd::cxx::tree::traits< N_type, char > N_traits;

      const N_type&
      N () const;

      N_type&
      N ();

      void
      N (const N_type& x);

      // Constructors.
      //
      ArrayDoubleType (const N_type&);

      ArrayDoubleType (const ::xsd::qif2::ListDoubleType&,
                       const N_type&);

      ArrayDoubleType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ArrayDoubleType (const ArrayDoubleType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual ArrayDoubleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayDoubleType&
      operator= (const ArrayDoubleType& x);

      virtual 
      ~ArrayDoubleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< N_type > N_;
    };

    class ArrayBinaryType: public ::xml_schema::base64_binary
    {
      public:
      // N
      //
      typedef ::xml_schema::unsigned_int N_type;
      typedef ::xsd::cxx::tree::traits< N_type, char > N_traits;

      const N_type&
      N () const;

      N_type&
      N ();

      void
      N (const N_type& x);

      // sizeElement
      //
      typedef ::xml_schema::unsigned_int sizeElement_type;
      typedef ::xsd::cxx::tree::traits< sizeElement_type, char > sizeElement_traits;

      const sizeElement_type&
      sizeElement () const;

      sizeElement_type&
      sizeElement ();

      void
      sizeElement (const sizeElement_type& x);

      // Constructors.
      //
      ArrayBinaryType (const N_type&,
                       const sizeElement_type&);

      ArrayBinaryType (const ::xml_schema::base64_binary&,
                       const N_type&,
                       const sizeElement_type&);

      ArrayBinaryType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      ArrayBinaryType (const ArrayBinaryType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual ArrayBinaryType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArrayBinaryType&
      operator= (const ArrayBinaryType& x);

      virtual 
      ~ArrayBinaryType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< N_type > N_;
      ::xsd::cxx::tree::one< sizeElement_type > sizeElement_;
    };

    class AttributesType: public ::xml_schema::type
    {
      public:
      // Attribute
      //
      typedef ::xsd::qif2::AttributeBaseType Attribute_type;
      typedef ::xsd::cxx::tree::sequence< Attribute_type > Attribute_sequence;
      typedef Attribute_sequence::iterator Attribute_iterator;
      typedef Attribute_sequence::const_iterator Attribute_const_iterator;
      typedef ::xsd::cxx::tree::traits< Attribute_type, char > Attribute_traits;

      const Attribute_sequence&
      Attribute () const;

      Attribute_sequence&
      Attribute ();

      void
      Attribute (const Attribute_sequence& s);

      // N
      //
      typedef ::xsd::qif2::NaturalType N_type;
      typedef ::xsd::cxx::tree::traits< N_type, char > N_traits;

      const N_type&
      N () const;

      N_type&
      N ();

      void
      N (const N_type& x);

      void
      N (::std::auto_ptr< N_type > p);

      // Constructors.
      //
      AttributesType (const N_type&);

      AttributesType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      AttributesType (const AttributesType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual AttributesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AttributesType&
      operator= (const AttributesType& x);

      virtual 
      ~AttributesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Attribute_sequence Attribute_;
      ::xsd::cxx::tree::one< N_type > N_;
    };

    class AttributeBaseType: public ::xml_schema::type
    {
      public:
      // name
      //
      typedef ::xml_schema::string name_type;
      typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

      const name_type&
      name () const;

      name_type&
      name ();

      void
      name (const name_type& x);

      void
      name (::std::auto_ptr< name_type > p);

      // Constructors.
      //
      AttributeBaseType (const name_type&);

      AttributeBaseType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      AttributeBaseType (const AttributeBaseType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual AttributeBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AttributeBaseType&
      operator= (const AttributeBaseType& x);

      virtual 
      ~AttributeBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< name_type > name_;
    };

    class AttributeBoolType: public ::xsd::qif2::AttributeBaseType
    {
      public:
      // value
      //
      typedef ::xml_schema::boolean value_type;
      typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

      const value_type&
      value () const;

      value_type&
      value ();

      void
      value (const value_type& x);

      // Constructors.
      //
      AttributeBoolType (const name_type&,
                         const value_type&);

      AttributeBoolType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      AttributeBoolType (const AttributeBoolType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual AttributeBoolType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AttributeBoolType&
      operator= (const AttributeBoolType& x);

      virtual 
      ~AttributeBoolType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< value_type > value_;
    };

    class AttributeStrType: public ::xsd::qif2::AttributeBaseType
    {
      public:
      // value
      //
      typedef ::xml_schema::string value_type;
      typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

      const value_type&
      value () const;

      value_type&
      value ();

      void
      value (const value_type& x);

      void
      value (::std::auto_ptr< value_type > p);

      // Constructors.
      //
      AttributeStrType (const name_type&,
                        const value_type&);

      AttributeStrType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      AttributeStrType (const AttributeStrType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual AttributeStrType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AttributeStrType&
      operator= (const AttributeStrType& x);

      virtual 
      ~AttributeStrType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< value_type > value_;
    };

    class AttributeQPIdType: public ::xsd::qif2::AttributeBaseType
    {
      public:
      // value
      //
      typedef ::xsd::qif2::QPIdType value_type;
      typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

      const value_type&
      value () const;

      value_type&
      value ();

      void
      value (const value_type& x);

      void
      value (::std::auto_ptr< value_type > p);

      // Constructors.
      //
      AttributeQPIdType (const name_type&,
                         const value_type&);

      AttributeQPIdType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      AttributeQPIdType (const AttributeQPIdType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual AttributeQPIdType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AttributeQPIdType&
      operator= (const AttributeQPIdType& x);

      virtual 
      ~AttributeQPIdType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< value_type > value_;
    };

    class AttributeI1Type: public ::xsd::qif2::AttributeBaseType
    {
      public:
      // value
      //
      typedef ::xml_schema::integer value_type;
      typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

      const value_type&
      value () const;

      value_type&
      value ();

      void
      value (const value_type& x);

      // Constructors.
      //
      AttributeI1Type (const name_type&,
                       const value_type&);

      AttributeI1Type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      AttributeI1Type (const AttributeI1Type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual AttributeI1Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AttributeI1Type&
      operator= (const AttributeI1Type& x);

      virtual 
      ~AttributeI1Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< value_type > value_;
    };

    class AttributeI2Type: public ::xsd::qif2::AttributeBaseType
    {
      public:
      // value
      //
      typedef ::xsd::qif2::I2Type value_type;
      typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

      const value_type&
      value () const;

      value_type&
      value ();

      void
      value (const value_type& x);

      void
      value (::std::auto_ptr< value_type > p);

      // Constructors.
      //
      AttributeI2Type (const name_type&,
                       const value_type&);

      AttributeI2Type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      AttributeI2Type (const AttributeI2Type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual AttributeI2Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AttributeI2Type&
      operator= (const AttributeI2Type& x);

      virtual 
      ~AttributeI2Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< value_type > value_;
    };

    class AttributeD1Type: public ::xsd::qif2::AttributeBaseType
    {
      public:
      // value
      //
      typedef ::xml_schema::double_ value_type;
      typedef ::xsd::cxx::tree::traits< value_type, char, ::xsd::cxx::tree::schema_type::double_ > value_traits;

      const value_type&
      value () const;

      value_type&
      value ();

      void
      value (const value_type& x);

      // Constructors.
      //
      AttributeD1Type (const name_type&,
                       const value_type&);

      AttributeD1Type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      AttributeD1Type (const AttributeD1Type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual AttributeD1Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AttributeD1Type&
      operator= (const AttributeD1Type& x);

      virtual 
      ~AttributeD1Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< value_type > value_;
    };

    class AttributeD3Type: public ::xsd::qif2::AttributeBaseType
    {
      public:
      // value
      //
      typedef ::xsd::qif2::D3Type value_type;
      typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

      const value_type&
      value () const;

      value_type&
      value ();

      void
      value (const value_type& x);

      void
      value (::std::auto_ptr< value_type > p);

      // Constructors.
      //
      AttributeD3Type (const name_type&,
                       const value_type&);

      AttributeD3Type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      AttributeD3Type (const AttributeD3Type& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual AttributeD3Type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AttributeD3Type&
      operator= (const AttributeD3Type& x);

      virtual 
      ~AttributeD3Type ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< value_type > value_;
    };

    class AttributeUserType: public ::xsd::qif2::AttributeBaseType
    {
      public:
      // UserDataXML
      //
      typedef ::xsd::qif2::UserDataXMLType UserDataXML_type;
      typedef ::xsd::cxx::tree::optional< UserDataXML_type > UserDataXML_optional;
      typedef ::xsd::cxx::tree::traits< UserDataXML_type, char > UserDataXML_traits;

      const UserDataXML_optional&
      UserDataXML () const;

      UserDataXML_optional&
      UserDataXML ();

      void
      UserDataXML (const UserDataXML_type& x);

      void
      UserDataXML (const UserDataXML_optional& x);

      void
      UserDataXML (::std::auto_ptr< UserDataXML_type > p);

      // UserDataBinary
      //
      typedef ::xsd::qif2::BinaryDataType UserDataBinary_type;
      typedef ::xsd::cxx::tree::optional< UserDataBinary_type > UserDataBinary_optional;
      typedef ::xsd::cxx::tree::traits< UserDataBinary_type, char > UserDataBinary_traits;

      const UserDataBinary_optional&
      UserDataBinary () const;

      UserDataBinary_optional&
      UserDataBinary ();

      void
      UserDataBinary (const UserDataBinary_type& x);

      void
      UserDataBinary (const UserDataBinary_optional& x);

      void
      UserDataBinary (::std::auto_ptr< UserDataBinary_type > p);

      // nameUserAttribute
      //
      typedef ::xml_schema::string nameUserAttribute_type;
      typedef ::xsd::cxx::tree::traits< nameUserAttribute_type, char > nameUserAttribute_traits;

      const nameUserAttribute_type&
      nameUserAttribute () const;

      nameUserAttribute_type&
      nameUserAttribute ();

      void
      nameUserAttribute (const nameUserAttribute_type& x);

      void
      nameUserAttribute (::std::auto_ptr< nameUserAttribute_type > p);

      // Constructors.
      //
      AttributeUserType (const name_type&,
                         const nameUserAttribute_type&);

      AttributeUserType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      AttributeUserType (const AttributeUserType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual AttributeUserType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AttributeUserType&
      operator= (const AttributeUserType& x);

      virtual 
      ~AttributeUserType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      UserDataXML_optional UserDataXML_;
      UserDataBinary_optional UserDataBinary_;
      ::xsd::cxx::tree::one< nameUserAttribute_type > nameUserAttribute_;
    };

    class UserDataXMLType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      UserDataXMLType ();

      UserDataXMLType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      UserDataXMLType (const UserDataXMLType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual UserDataXMLType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~UserDataXMLType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace xsd
{
  namespace qif2
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace xsd
{
  namespace qif2
  {
    void
    operator<< (::xercesc::DOMElement&, const BinaryDataType&);

    void
    operator<< (::xercesc::DOMElement&, const ListIntType&);

    void
    operator<< (::xercesc::DOMAttr&, const ListIntType&);

    void
    operator<< (::xml_schema::list_stream&,
                const ListIntType&);

    void
    operator<< (::xercesc::DOMElement&, const I2Type&);

    void
    operator<< (::xercesc::DOMAttr&, const I2Type&);

    void
    operator<< (::xml_schema::list_stream&,
                const I2Type&);

    void
    operator<< (::xercesc::DOMElement&, const ListDoubleType&);

    void
    operator<< (::xercesc::DOMAttr&, const ListDoubleType&);

    void
    operator<< (::xml_schema::list_stream&,
                const ListDoubleType&);

    void
    operator<< (::xercesc::DOMElement&, const D3Type&);

    void
    operator<< (::xercesc::DOMAttr&, const D3Type&);

    void
    operator<< (::xml_schema::list_stream&,
                const D3Type&);

    void
    operator<< (::xercesc::DOMElement&, const D2Type&);

    void
    operator<< (::xercesc::DOMAttr&, const D2Type&);

    void
    operator<< (::xml_schema::list_stream&,
                const D2Type&);

    void
    operator<< (::xercesc::DOMElement&, const DoublePositiveType&);

    void
    operator<< (::xercesc::DOMAttr&, const DoublePositiveType&);

    void
    operator<< (::xml_schema::list_stream&,
                const DoublePositiveType&);

    void
    operator<< (::xercesc::DOMElement&, const Point2dSimpleType&);

    void
    operator<< (::xercesc::DOMAttr&, const Point2dSimpleType&);

    void
    operator<< (::xml_schema::list_stream&,
                const Point2dSimpleType&);

    void
    operator<< (::xercesc::DOMElement&, const UnitVector2dSimpleType&);

    void
    operator<< (::xercesc::DOMAttr&, const UnitVector2dSimpleType&);

    void
    operator<< (::xml_schema::list_stream&,
                const UnitVector2dSimpleType&);

    void
    operator<< (::xercesc::DOMElement&, const ParameterRangeType&);

    void
    operator<< (::xercesc::DOMAttr&, const ParameterRangeType&);

    void
    operator<< (::xml_schema::list_stream&,
                const ParameterRangeType&);

    void
    operator<< (::xercesc::DOMElement&, const PointSimpleType&);

    void
    operator<< (::xercesc::DOMAttr&, const PointSimpleType&);

    void
    operator<< (::xml_schema::list_stream&,
                const PointSimpleType&);

    void
    operator<< (::xercesc::DOMElement&, const VectorSimpleType&);

    void
    operator<< (::xercesc::DOMAttr&, const VectorSimpleType&);

    void
    operator<< (::xml_schema::list_stream&,
                const VectorSimpleType&);

    void
    operator<< (::xercesc::DOMElement&, const UnitVectorSimpleType&);

    void
    operator<< (::xercesc::DOMAttr&, const UnitVectorSimpleType&);

    void
    operator<< (::xml_schema::list_stream&,
                const UnitVectorSimpleType&);

    void
    operator<< (::xercesc::DOMElement&, const ValidityEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const ValidityEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const ValidityEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const PointType&);

    void
    operator<< (::xercesc::DOMElement&, const ActualPointType&);

    void
    operator<< (::xercesc::DOMElement&, const VectorType&);

    void
    operator<< (::xercesc::DOMElement&, const UnitVectorType&);

    void
    operator<< (::xercesc::DOMElement&, const ActualUnitVectorType&);

    void
    operator<< (::xercesc::DOMElement&, const ArrayPoint2dType&);

    void
    operator<< (::xercesc::DOMElement&, const ArrayPointType&);

    void
    operator<< (::xercesc::DOMElement&, const ArrayUnitVectorType&);

    void
    operator<< (::xercesc::DOMElement&, const PolyLineType&);

    void
    operator<< (::xercesc::DOMElement&, const PlaneType&);

    void
    operator<< (::xercesc::DOMElement&, const ActualPlaneType&);

    void
    operator<< (::xercesc::DOMElement&, const PlaneXType&);

    void
    operator<< (::xercesc::DOMElement&, const AxisType&);

    void
    operator<< (::xercesc::DOMElement&, const ActualAxisType&);

    void
    operator<< (::xercesc::DOMElement&, const TransformRotationType&);

    void
    operator<< (::xercesc::DOMElement&, const CoordinateSystemCoreType&);

    void
    operator<< (::xercesc::DOMElement&, const TransformMatrixType&);

    void
    operator<< (::xercesc::DOMElement&, const LineSegmentType&);

    void
    operator<< (::xercesc::DOMElement&, const LineSegment2dType&);

    void
    operator<< (::xercesc::DOMElement&, const LatitudeLongitudeSweepType&);

    void
    operator<< (::xercesc::DOMElement&, const OrientedLatitudeLongitudeSweepType&);

    void
    operator<< (::xercesc::DOMElement&, const SweepType&);

    void
    operator<< (::xercesc::DOMElement&, const AngleRangeType&);

    void
    operator<< (::xercesc::DOMElement&, const QIFIdType&);

    void
    operator<< (::xercesc::DOMAttr&, const QIFIdType&);

    void
    operator<< (::xml_schema::list_stream&,
                const QIFIdType&);

    void
    operator<< (::xercesc::DOMElement&, const QIFReferenceType&);

    void
    operator<< (::xercesc::DOMAttr&, const QIFReferenceType&);

    void
    operator<< (::xml_schema::list_stream&,
                const QIFReferenceType&);

    void
    operator<< (::xercesc::DOMElement&, const QIFReferenceFullType&);

    void
    operator<< (::xercesc::DOMElement&, const ElementReferenceType&);

    void
    operator<< (::xercesc::DOMElement&, const ElementReferenceFullType&);

    void
    operator<< (::xercesc::DOMElement&, const D4Type&);

    void
    operator<< (::xercesc::DOMAttr&, const D4Type&);

    void
    operator<< (::xml_schema::list_stream&,
                const D4Type&);

    void
    operator<< (::xercesc::DOMElement&, const NaturalType&);

    void
    operator<< (::xercesc::DOMAttr&, const NaturalType&);

    void
    operator<< (::xml_schema::list_stream&,
                const NaturalType&);

    void
    operator<< (::xercesc::DOMElement&, const ListNaturalType&);

    void
    operator<< (::xercesc::DOMAttr&, const ListNaturalType&);

    void
    operator<< (::xml_schema::list_stream&,
                const ListNaturalType&);

    void
    operator<< (::xercesc::DOMElement&, const ArrayNaturalType&);

    void
    operator<< (::xercesc::DOMElement&, const ArrayReferenceType&);

    void
    operator<< (::xercesc::DOMElement&, const ArrayReferenceFullType&);

    void
    operator<< (::xercesc::DOMElement&, const ListBoolType&);

    void
    operator<< (::xercesc::DOMAttr&, const ListBoolType&);

    void
    operator<< (::xml_schema::list_stream&,
                const ListBoolType&);

    void
    operator<< (::xercesc::DOMElement&, const ListUnsignedByteType&);

    void
    operator<< (::xercesc::DOMAttr&, const ListUnsignedByteType&);

    void
    operator<< (::xml_schema::list_stream&,
                const ListUnsignedByteType&);

    void
    operator<< (::xercesc::DOMElement&, const QPIdType&);

    void
    operator<< (::xercesc::DOMAttr&, const QPIdType&);

    void
    operator<< (::xml_schema::list_stream&,
                const QPIdType&);

    void
    operator<< (::xercesc::DOMElement&, const QPIdReferenceType&);

    void
    operator<< (::xercesc::DOMAttr&, const QPIdReferenceType&);

    void
    operator<< (::xml_schema::list_stream&,
                const QPIdReferenceType&);

    void
    operator<< (::xercesc::DOMElement&, const QPIdFullReferenceType&);

    void
    operator<< (::xercesc::DOMElement&, const ArrayUnsignedByteType&);

    void
    operator<< (::xercesc::DOMElement&, const ArrayIntType&);

    void
    operator<< (::xercesc::DOMElement&, const ArrayI2Type&);

    void
    operator<< (::xercesc::DOMElement&, const ArrayI3Type&);

    void
    operator<< (::xercesc::DOMElement&, const ArrayDoubleType&);

    void
    operator<< (::xercesc::DOMElement&, const ArrayBinaryType&);

    void
    operator<< (::xercesc::DOMElement&, const AttributesType&);

    void
    operator<< (::xercesc::DOMElement&, const AttributeBaseType&);

    void
    operator<< (::xercesc::DOMElement&, const AttributeBoolType&);

    void
    operator<< (::xercesc::DOMElement&, const AttributeStrType&);

    void
    operator<< (::xercesc::DOMElement&, const AttributeQPIdType&);

    void
    operator<< (::xercesc::DOMElement&, const AttributeI1Type&);

    void
    operator<< (::xercesc::DOMElement&, const AttributeI2Type&);

    void
    operator<< (::xercesc::DOMElement&, const AttributeD1Type&);

    void
    operator<< (::xercesc::DOMElement&, const AttributeD3Type&);

    void
    operator<< (::xercesc::DOMElement&, const AttributeUserType&);

    void
    operator<< (::xercesc::DOMElement&, const UserDataXMLType&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // PRIMITIVES_HXX
