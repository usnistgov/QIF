// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef QIFMEASUREMENT_RESOURCES_HXX
#define QIFMEASUREMENT_RESOURCES_HXX

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< char > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< char > not_derived;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace xsd
{
  namespace qif2
  {
    class MeasurementResourcesType;
    class CarriagesType;
    class FixturesType;
    class SensorsType;
    class ToolsType;
    class MeasurementDevicesType;
    class MeasurementResourceBaseType;
    class FixtureType;
    class MeasurementDeviceAccuracyBaseType;
    class NumericalLengthAccuracyType;
    class MeasurementDeviceType;
    class CalibrationMasterType;
    class CalibrationType;
    class CalibrationsType;
    class TemperaturesType;
    class TemperatureType;
    class QualificationsType;
    class QualificationType;
    class SensorType;
    class TouchProbeType;
    class ToolType;
    class CarriageType;
    class ProbingDeviceType;
    class CMMType;
    class CMMScalesType;
    class CMMScaleType;
    class CMMSpeedsType;
    class GageDeviceType;
    class ManualDeviceType;
    class CaliperType;
    class CMMDirectionEnumType;
    class CMMGeometryType;
    class CMMGeometryEnumType;
    class CMMAxisDirectionsType;
    class WorkingVolumeType;
    class EffectiveWorkingVolumeType;
    class RotaryTableType;
    class TableErrorsType;
    class ResolutionType;
    class XYZResolutionType;
    class CMMAccuracyTestBaseType;
    class FPSTestType;
    class FunctionDiscreteType;
    class LengthFunctionDiscreteType;
    class AngleFunctionDiscreteType;
    class B89TestType;
    class ISO10360TestType;
    class LinearErrorType;
    class LesserErrorType;
    class PointAccuracyTestType;
    class CMMAccuracyType;
    class ComparatorType;
  }
}


#include <memory>    // ::std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "../QIFLibrary/IntermediatesPMI.hxx"

namespace xsd
{
  namespace qif2
  {
    class MeasurementResourcesType: public ::xml_schema::type
    {
      public:
      // Version
      //
      typedef ::xsd::qif2::VersionType Version_type;
      typedef ::xsd::cxx::tree::optional< Version_type > Version_optional;
      typedef ::xsd::cxx::tree::traits< Version_type, char > Version_traits;

      const Version_optional&
      Version () const;

      Version_optional&
      Version ();

      void
      Version (const Version_type& x);

      void
      Version (const Version_optional& x);

      void
      Version (::std::auto_ptr< Version_type > p);

      // Carriages
      //
      typedef ::xsd::qif2::CarriagesType Carriages_type;
      typedef ::xsd::cxx::tree::optional< Carriages_type > Carriages_optional;
      typedef ::xsd::cxx::tree::traits< Carriages_type, char > Carriages_traits;

      const Carriages_optional&
      Carriages () const;

      Carriages_optional&
      Carriages ();

      void
      Carriages (const Carriages_type& x);

      void
      Carriages (const Carriages_optional& x);

      void
      Carriages (::std::auto_ptr< Carriages_type > p);

      // Fixtures
      //
      typedef ::xsd::qif2::FixturesType Fixtures_type;
      typedef ::xsd::cxx::tree::optional< Fixtures_type > Fixtures_optional;
      typedef ::xsd::cxx::tree::traits< Fixtures_type, char > Fixtures_traits;

      const Fixtures_optional&
      Fixtures () const;

      Fixtures_optional&
      Fixtures ();

      void
      Fixtures (const Fixtures_type& x);

      void
      Fixtures (const Fixtures_optional& x);

      void
      Fixtures (::std::auto_ptr< Fixtures_type > p);

      // MeasurementDevices
      //
      typedef ::xsd::qif2::MeasurementDevicesType MeasurementDevices_type;
      typedef ::xsd::cxx::tree::optional< MeasurementDevices_type > MeasurementDevices_optional;
      typedef ::xsd::cxx::tree::traits< MeasurementDevices_type, char > MeasurementDevices_traits;

      const MeasurementDevices_optional&
      MeasurementDevices () const;

      MeasurementDevices_optional&
      MeasurementDevices ();

      void
      MeasurementDevices (const MeasurementDevices_type& x);

      void
      MeasurementDevices (const MeasurementDevices_optional& x);

      void
      MeasurementDevices (::std::auto_ptr< MeasurementDevices_type > p);

      // Sensors
      //
      typedef ::xsd::qif2::SensorsType Sensors_type;
      typedef ::xsd::cxx::tree::optional< Sensors_type > Sensors_optional;
      typedef ::xsd::cxx::tree::traits< Sensors_type, char > Sensors_traits;

      const Sensors_optional&
      Sensors () const;

      Sensors_optional&
      Sensors ();

      void
      Sensors (const Sensors_type& x);

      void
      Sensors (const Sensors_optional& x);

      void
      Sensors (::std::auto_ptr< Sensors_type > p);

      // Tools
      //
      typedef ::xsd::qif2::ToolsType Tools_type;
      typedef ::xsd::cxx::tree::optional< Tools_type > Tools_optional;
      typedef ::xsd::cxx::tree::traits< Tools_type, char > Tools_traits;

      const Tools_optional&
      Tools () const;

      Tools_optional&
      Tools ();

      void
      Tools (const Tools_type& x);

      void
      Tools (const Tools_optional& x);

      void
      Tools (::std::auto_ptr< Tools_type > p);

      // Constructors.
      //
      MeasurementResourcesType ();

      MeasurementResourcesType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      MeasurementResourcesType (const MeasurementResourcesType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual MeasurementResourcesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasurementResourcesType&
      operator= (const MeasurementResourcesType& x);

      virtual 
      ~MeasurementResourcesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Version_optional Version_;
      Carriages_optional Carriages_;
      Fixtures_optional Fixtures_;
      MeasurementDevices_optional MeasurementDevices_;
      Sensors_optional Sensors_;
      Tools_optional Tools_;
    };

    class CarriagesType: public ::xml_schema::type
    {
      public:
      // Carriage
      //
      typedef ::xsd::qif2::CarriageType Carriage_type;
      typedef ::xsd::cxx::tree::sequence< Carriage_type > Carriage_sequence;
      typedef Carriage_sequence::iterator Carriage_iterator;
      typedef Carriage_sequence::const_iterator Carriage_const_iterator;
      typedef ::xsd::cxx::tree::traits< Carriage_type, char > Carriage_traits;

      const Carriage_sequence&
      Carriage () const;

      Carriage_sequence&
      Carriage ();

      void
      Carriage (const Carriage_sequence& s);

      // Constructors.
      //
      CarriagesType ();

      CarriagesType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      CarriagesType (const CarriagesType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual CarriagesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CarriagesType&
      operator= (const CarriagesType& x);

      virtual 
      ~CarriagesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Carriage_sequence Carriage_;
    };

    class FixturesType: public ::xml_schema::type
    {
      public:
      // Fixture
      //
      typedef ::xsd::qif2::FixtureType Fixture_type;
      typedef ::xsd::cxx::tree::sequence< Fixture_type > Fixture_sequence;
      typedef Fixture_sequence::iterator Fixture_iterator;
      typedef Fixture_sequence::const_iterator Fixture_const_iterator;
      typedef ::xsd::cxx::tree::traits< Fixture_type, char > Fixture_traits;

      const Fixture_sequence&
      Fixture () const;

      Fixture_sequence&
      Fixture ();

      void
      Fixture (const Fixture_sequence& s);

      // Constructors.
      //
      FixturesType ();

      FixturesType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      FixturesType (const FixturesType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual FixturesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FixturesType&
      operator= (const FixturesType& x);

      virtual 
      ~FixturesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Fixture_sequence Fixture_;
    };

    class SensorsType: public ::xml_schema::type
    {
      public:
      // Sensor
      //
      typedef ::xsd::qif2::SensorType Sensor_type;
      typedef ::xsd::cxx::tree::sequence< Sensor_type > Sensor_sequence;
      typedef Sensor_sequence::iterator Sensor_iterator;
      typedef Sensor_sequence::const_iterator Sensor_const_iterator;
      typedef ::xsd::cxx::tree::traits< Sensor_type, char > Sensor_traits;

      const Sensor_sequence&
      Sensor () const;

      Sensor_sequence&
      Sensor ();

      void
      Sensor (const Sensor_sequence& s);

      // Constructors.
      //
      SensorsType ();

      SensorsType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      SensorsType (const SensorsType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual SensorsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SensorsType&
      operator= (const SensorsType& x);

      virtual 
      ~SensorsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Sensor_sequence Sensor_;
    };

    class ToolsType: public ::xml_schema::type
    {
      public:
      // Tool
      //
      typedef ::xsd::qif2::ToolType Tool_type;
      typedef ::xsd::cxx::tree::sequence< Tool_type > Tool_sequence;
      typedef Tool_sequence::iterator Tool_iterator;
      typedef Tool_sequence::const_iterator Tool_const_iterator;
      typedef ::xsd::cxx::tree::traits< Tool_type, char > Tool_traits;

      const Tool_sequence&
      Tool () const;

      Tool_sequence&
      Tool ();

      void
      Tool (const Tool_sequence& s);

      // Constructors.
      //
      ToolsType ();

      ToolsType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      ToolsType (const ToolsType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual ToolsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToolsType&
      operator= (const ToolsType& x);

      virtual 
      ~ToolsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Tool_sequence Tool_;
    };

    class MeasurementDevicesType: public ::xml_schema::type
    {
      public:
      // MeasurementDevice
      //
      typedef ::xsd::qif2::MeasurementDeviceType MeasurementDevice_type;
      typedef ::xsd::cxx::tree::sequence< MeasurementDevice_type > MeasurementDevice_sequence;
      typedef MeasurementDevice_sequence::iterator MeasurementDevice_iterator;
      typedef MeasurementDevice_sequence::const_iterator MeasurementDevice_const_iterator;
      typedef ::xsd::cxx::tree::traits< MeasurementDevice_type, char > MeasurementDevice_traits;

      const MeasurementDevice_sequence&
      MeasurementDevice () const;

      MeasurementDevice_sequence&
      MeasurementDevice ();

      void
      MeasurementDevice (const MeasurementDevice_sequence& s);

      // Constructors.
      //
      MeasurementDevicesType ();

      MeasurementDevicesType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      MeasurementDevicesType (const MeasurementDevicesType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual MeasurementDevicesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasurementDevicesType&
      operator= (const MeasurementDevicesType& x);

      virtual 
      ~MeasurementDevicesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      MeasurementDevice_sequence MeasurementDevice_;
    };

    class MeasurementResourceBaseType: public ::xml_schema::type
    {
      public:
      // Name
      //
      typedef ::xml_schema::token Name_type;
      typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

      const Name_type&
      Name () const;

      Name_type&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (::std::auto_ptr< Name_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, char > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::auto_ptr< Description_type > p);

      // Manufacturer
      //
      typedef ::xml_schema::string Manufacturer_type;
      typedef ::xsd::cxx::tree::optional< Manufacturer_type > Manufacturer_optional;
      typedef ::xsd::cxx::tree::traits< Manufacturer_type, char > Manufacturer_traits;

      const Manufacturer_optional&
      Manufacturer () const;

      Manufacturer_optional&
      Manufacturer ();

      void
      Manufacturer (const Manufacturer_type& x);

      void
      Manufacturer (const Manufacturer_optional& x);

      void
      Manufacturer (::std::auto_ptr< Manufacturer_type > p);

      // ModelNumber
      //
      typedef ::xml_schema::string ModelNumber_type;
      typedef ::xsd::cxx::tree::optional< ModelNumber_type > ModelNumber_optional;
      typedef ::xsd::cxx::tree::traits< ModelNumber_type, char > ModelNumber_traits;

      const ModelNumber_optional&
      ModelNumber () const;

      ModelNumber_optional&
      ModelNumber ();

      void
      ModelNumber (const ModelNumber_type& x);

      void
      ModelNumber (const ModelNumber_optional& x);

      void
      ModelNumber (::std::auto_ptr< ModelNumber_type > p);

      // SerialNumber
      //
      typedef ::xml_schema::string SerialNumber_type;
      typedef ::xsd::cxx::tree::optional< SerialNumber_type > SerialNumber_optional;
      typedef ::xsd::cxx::tree::traits< SerialNumber_type, char > SerialNumber_traits;

      const SerialNumber_optional&
      SerialNumber () const;

      SerialNumber_optional&
      SerialNumber ();

      void
      SerialNumber (const SerialNumber_type& x);

      void
      SerialNumber (const SerialNumber_optional& x);

      void
      SerialNumber (::std::auto_ptr< SerialNumber_type > p);

      // LocationId
      //
      typedef ::xsd::qif2::QIFReferenceFullType LocationId_type;
      typedef ::xsd::cxx::tree::optional< LocationId_type > LocationId_optional;
      typedef ::xsd::cxx::tree::traits< LocationId_type, char > LocationId_traits;

      const LocationId_optional&
      LocationId () const;

      LocationId_optional&
      LocationId ();

      void
      LocationId (const LocationId_type& x);

      void
      LocationId (const LocationId_optional& x);

      void
      LocationId (::std::auto_ptr< LocationId_type > p);

      // Location
      //
      typedef ::xsd::qif2::LocationType Location_type;
      typedef ::xsd::cxx::tree::optional< Location_type > Location_optional;
      typedef ::xsd::cxx::tree::traits< Location_type, char > Location_traits;

      const Location_optional&
      Location () const;

      Location_optional&
      Location ();

      void
      Location (const Location_type& x);

      void
      Location (const Location_optional& x);

      void
      Location (::std::auto_ptr< Location_type > p);

      // id
      //
      typedef ::xsd::qif2::QIFIdType id_type;
      typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

      const id_type&
      id () const;

      id_type&
      id ();

      void
      id (const id_type& x);

      void
      id (::std::auto_ptr< id_type > p);

      // Constructors.
      //
      MeasurementResourceBaseType (const Name_type&,
                                   const id_type&);

      MeasurementResourceBaseType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      MeasurementResourceBaseType (const MeasurementResourceBaseType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual MeasurementResourceBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasurementResourceBaseType&
      operator= (const MeasurementResourceBaseType& x);

      virtual 
      ~MeasurementResourceBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Name_type > Name_;
      Description_optional Description_;
      Manufacturer_optional Manufacturer_;
      ModelNumber_optional ModelNumber_;
      SerialNumber_optional SerialNumber_;
      LocationId_optional LocationId_;
      Location_optional Location_;
      ::xsd::cxx::tree::one< id_type > id_;
    };

    class FixtureType: public ::xsd::qif2::MeasurementResourceBaseType
    {
      public:
      // Constructors.
      //
      FixtureType (const Name_type&,
                   const id_type&);

      FixtureType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      FixtureType (const FixtureType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual FixtureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~FixtureType ();
    };

    class MeasurementDeviceAccuracyBaseType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      MeasurementDeviceAccuracyBaseType ();

      MeasurementDeviceAccuracyBaseType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      MeasurementDeviceAccuracyBaseType (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      MeasurementDeviceAccuracyBaseType (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      MeasurementDeviceAccuracyBaseType (const MeasurementDeviceAccuracyBaseType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual MeasurementDeviceAccuracyBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~MeasurementDeviceAccuracyBaseType ();
    };

    class NumericalLengthAccuracyType: public ::xsd::qif2::MeasurementDeviceAccuracyBaseType
    {
      public:
      // AccuracyValue
      //
      typedef ::xsd::qif2::LinearValueType AccuracyValue_type;
      typedef ::xsd::cxx::tree::traits< AccuracyValue_type, char > AccuracyValue_traits;

      const AccuracyValue_type&
      AccuracyValue () const;

      AccuracyValue_type&
      AccuracyValue ();

      void
      AccuracyValue (const AccuracyValue_type& x);

      void
      AccuracyValue (::std::auto_ptr< AccuracyValue_type > p);

      // Constructors.
      //
      NumericalLengthAccuracyType (const AccuracyValue_type&);

      NumericalLengthAccuracyType (::std::auto_ptr< AccuracyValue_type >);

      NumericalLengthAccuracyType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      NumericalLengthAccuracyType (const NumericalLengthAccuracyType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual NumericalLengthAccuracyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NumericalLengthAccuracyType&
      operator= (const NumericalLengthAccuracyType& x);

      virtual 
      ~NumericalLengthAccuracyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< AccuracyValue_type > AccuracyValue_;
    };

    class MeasurementDeviceType: public ::xsd::qif2::MeasurementResourceBaseType
    {
      public:
      // Calibrations
      //
      typedef ::xsd::qif2::CalibrationsType Calibrations_type;
      typedef ::xsd::cxx::tree::optional< Calibrations_type > Calibrations_optional;
      typedef ::xsd::cxx::tree::traits< Calibrations_type, char > Calibrations_traits;

      const Calibrations_optional&
      Calibrations () const;

      Calibrations_optional&
      Calibrations ();

      void
      Calibrations (const Calibrations_type& x);

      void
      Calibrations (const Calibrations_optional& x);

      void
      Calibrations (::std::auto_ptr< Calibrations_type > p);

      // InspectionTemperatures
      //
      typedef ::xsd::qif2::TemperaturesType InspectionTemperatures_type;
      typedef ::xsd::cxx::tree::optional< InspectionTemperatures_type > InspectionTemperatures_optional;
      typedef ::xsd::cxx::tree::traits< InspectionTemperatures_type, char > InspectionTemperatures_traits;

      const InspectionTemperatures_optional&
      InspectionTemperatures () const;

      InspectionTemperatures_optional&
      InspectionTemperatures ();

      void
      InspectionTemperatures (const InspectionTemperatures_type& x);

      void
      InspectionTemperatures (const InspectionTemperatures_optional& x);

      void
      InspectionTemperatures (::std::auto_ptr< InspectionTemperatures_type > p);

      // Constructors.
      //
      MeasurementDeviceType (const Name_type&,
                             const id_type&);

      MeasurementDeviceType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      MeasurementDeviceType (const MeasurementDeviceType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual MeasurementDeviceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MeasurementDeviceType&
      operator= (const MeasurementDeviceType& x);

      virtual 
      ~MeasurementDeviceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Calibrations_optional Calibrations_;
      InspectionTemperatures_optional InspectionTemperatures_;
    };

    class CalibrationMasterType: public ::xml_schema::type
    {
      public:
      // SerialNumber
      //
      typedef ::xml_schema::string SerialNumber_type;
      typedef ::xsd::cxx::tree::traits< SerialNumber_type, char > SerialNumber_traits;

      const SerialNumber_type&
      SerialNumber () const;

      SerialNumber_type&
      SerialNumber ();

      void
      SerialNumber (const SerialNumber_type& x);

      void
      SerialNumber (::std::auto_ptr< SerialNumber_type > p);

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::optional< description_type > description_optional;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_optional&
      description () const;

      description_optional&
      description ();

      void
      description (const description_type& x);

      void
      description (const description_optional& x);

      void
      description (::std::auto_ptr< description_type > p);

      // Constructors.
      //
      CalibrationMasterType (const SerialNumber_type&);

      CalibrationMasterType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      CalibrationMasterType (const CalibrationMasterType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual CalibrationMasterType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CalibrationMasterType&
      operator= (const CalibrationMasterType& x);

      virtual 
      ~CalibrationMasterType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SerialNumber_type > SerialNumber_;
      description_optional description_;
    };

    class CalibrationType: public ::xml_schema::type
    {
      public:
      // CalibrationMaster
      //
      typedef ::xsd::qif2::CalibrationMasterType CalibrationMaster_type;
      typedef ::xsd::cxx::tree::optional< CalibrationMaster_type > CalibrationMaster_optional;
      typedef ::xsd::cxx::tree::traits< CalibrationMaster_type, char > CalibrationMaster_traits;

      const CalibrationMaster_optional&
      CalibrationMaster () const;

      CalibrationMaster_optional&
      CalibrationMaster ();

      void
      CalibrationMaster (const CalibrationMaster_type& x);

      void
      CalibrationMaster (const CalibrationMaster_optional& x);

      void
      CalibrationMaster (::std::auto_ptr< CalibrationMaster_type > p);

      // Temperatures
      //
      typedef ::xsd::qif2::TemperaturesType Temperatures_type;
      typedef ::xsd::cxx::tree::traits< Temperatures_type, char > Temperatures_traits;

      const Temperatures_type&
      Temperatures () const;

      Temperatures_type&
      Temperatures ();

      void
      Temperatures (const Temperatures_type& x);

      void
      Temperatures (::std::auto_ptr< Temperatures_type > p);

      // TimeStamp
      //
      typedef ::xml_schema::date_time TimeStamp_type;
      typedef ::xsd::cxx::tree::traits< TimeStamp_type, char > TimeStamp_traits;

      const TimeStamp_type&
      TimeStamp () const;

      TimeStamp_type&
      TimeStamp ();

      void
      TimeStamp (const TimeStamp_type& x);

      void
      TimeStamp (::std::auto_ptr< TimeStamp_type > p);

      // Constructors.
      //
      CalibrationType (const Temperatures_type&,
                       const TimeStamp_type&);

      CalibrationType (::std::auto_ptr< Temperatures_type >,
                       const TimeStamp_type&);

      CalibrationType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      CalibrationType (const CalibrationType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual CalibrationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CalibrationType&
      operator= (const CalibrationType& x);

      virtual 
      ~CalibrationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      CalibrationMaster_optional CalibrationMaster_;
      ::xsd::cxx::tree::one< Temperatures_type > Temperatures_;
      ::xsd::cxx::tree::one< TimeStamp_type > TimeStamp_;
    };

    class CalibrationsType: public ::xml_schema::type
    {
      public:
      // Calibration
      //
      typedef ::xsd::qif2::CalibrationType Calibration_type;
      typedef ::xsd::cxx::tree::sequence< Calibration_type > Calibration_sequence;
      typedef Calibration_sequence::iterator Calibration_iterator;
      typedef Calibration_sequence::const_iterator Calibration_const_iterator;
      typedef ::xsd::cxx::tree::traits< Calibration_type, char > Calibration_traits;

      const Calibration_sequence&
      Calibration () const;

      Calibration_sequence&
      Calibration ();

      void
      Calibration (const Calibration_sequence& s);

      // Constructors.
      //
      CalibrationsType ();

      CalibrationsType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      CalibrationsType (const CalibrationsType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual CalibrationsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CalibrationsType&
      operator= (const CalibrationsType& x);

      virtual 
      ~CalibrationsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Calibration_sequence Calibration_;
    };

    class TemperaturesType: public ::xml_schema::type
    {
      public:
      // Temperature
      //
      typedef ::xsd::qif2::TemperatureType Temperature_type;
      typedef ::xsd::cxx::tree::sequence< Temperature_type > Temperature_sequence;
      typedef Temperature_sequence::iterator Temperature_iterator;
      typedef Temperature_sequence::const_iterator Temperature_const_iterator;
      typedef ::xsd::cxx::tree::traits< Temperature_type, char > Temperature_traits;

      const Temperature_sequence&
      Temperature () const;

      Temperature_sequence&
      Temperature ();

      void
      Temperature (const Temperature_sequence& s);

      // Constructors.
      //
      TemperaturesType ();

      TemperaturesType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      TemperaturesType (const TemperaturesType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual TemperaturesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TemperaturesType&
      operator= (const TemperaturesType& x);

      virtual 
      ~TemperaturesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Temperature_sequence Temperature_;
    };

    class TemperatureType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif2::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, char > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::auto_ptr< Attributes_type > p);

      // Temperature
      //
      typedef ::xsd::qif2::TemperatureValueType Temperature_type;
      typedef ::xsd::cxx::tree::traits< Temperature_type, char > Temperature_traits;

      const Temperature_type&
      Temperature () const;

      Temperature_type&
      Temperature ();

      void
      Temperature (const Temperature_type& x);

      void
      Temperature (::std::auto_ptr< Temperature_type > p);

      // TimeStamp
      //
      typedef ::xml_schema::date_time TimeStamp_type;
      typedef ::xsd::cxx::tree::traits< TimeStamp_type, char > TimeStamp_traits;

      const TimeStamp_type&
      TimeStamp () const;

      TimeStamp_type&
      TimeStamp ();

      void
      TimeStamp (const TimeStamp_type& x);

      void
      TimeStamp (::std::auto_ptr< TimeStamp_type > p);

      // Constructors.
      //
      TemperatureType (const Temperature_type&,
                       const TimeStamp_type&);

      TemperatureType (::std::auto_ptr< Temperature_type >,
                       const TimeStamp_type&);

      TemperatureType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      TemperatureType (const TemperatureType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual TemperatureType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TemperatureType&
      operator= (const TemperatureType& x);

      virtual 
      ~TemperatureType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      ::xsd::cxx::tree::one< Temperature_type > Temperature_;
      ::xsd::cxx::tree::one< TimeStamp_type > TimeStamp_;
    };

    class QualificationsType: public ::xml_schema::type
    {
      public:
      // Qualification
      //
      typedef ::xsd::qif2::QualificationType Qualification_type;
      typedef ::xsd::cxx::tree::sequence< Qualification_type > Qualification_sequence;
      typedef Qualification_sequence::iterator Qualification_iterator;
      typedef Qualification_sequence::const_iterator Qualification_const_iterator;
      typedef ::xsd::cxx::tree::traits< Qualification_type, char > Qualification_traits;

      const Qualification_sequence&
      Qualification () const;

      Qualification_sequence&
      Qualification ();

      void
      Qualification (const Qualification_sequence& s);

      // Constructors.
      //
      QualificationsType ();

      QualificationsType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      QualificationsType (const QualificationsType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual QualificationsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      QualificationsType&
      operator= (const QualificationsType& x);

      virtual 
      ~QualificationsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Qualification_sequence Qualification_;
    };

    class QualificationType: public ::xml_schema::type
    {
      public:
      // Attributes
      //
      typedef ::xsd::qif2::AttributesType Attributes_type;
      typedef ::xsd::cxx::tree::optional< Attributes_type > Attributes_optional;
      typedef ::xsd::cxx::tree::traits< Attributes_type, char > Attributes_traits;

      const Attributes_optional&
      Attributes () const;

      Attributes_optional&
      Attributes ();

      void
      Attributes (const Attributes_type& x);

      void
      Attributes (const Attributes_optional& x);

      void
      Attributes (::std::auto_ptr< Attributes_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::traits< Description_type, char > Description_traits;

      const Description_type&
      Description () const;

      Description_type&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (::std::auto_ptr< Description_type > p);

      // Constructors.
      //
      QualificationType (const Description_type&);

      QualificationType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      QualificationType (const QualificationType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual QualificationType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      QualificationType&
      operator= (const QualificationType& x);

      virtual 
      ~QualificationType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Attributes_optional Attributes_;
      ::xsd::cxx::tree::one< Description_type > Description_;
    };

    class SensorType: public ::xsd::qif2::MeasurementResourceBaseType
    {
      public:
      // Qualifications
      //
      typedef ::xsd::qif2::QualificationsType Qualifications_type;
      typedef ::xsd::cxx::tree::traits< Qualifications_type, char > Qualifications_traits;

      const Qualifications_type&
      Qualifications () const;

      Qualifications_type&
      Qualifications ();

      void
      Qualifications (const Qualifications_type& x);

      void
      Qualifications (::std::auto_ptr< Qualifications_type > p);

      // AAngle
      //
      typedef ::xsd::qif2::AngularValueType AAngle_type;
      typedef ::xsd::cxx::tree::optional< AAngle_type > AAngle_optional;
      typedef ::xsd::cxx::tree::traits< AAngle_type, char > AAngle_traits;

      const AAngle_optional&
      AAngle () const;

      AAngle_optional&
      AAngle ();

      void
      AAngle (const AAngle_type& x);

      void
      AAngle (const AAngle_optional& x);

      void
      AAngle (::std::auto_ptr< AAngle_type > p);

      // BAngle
      //
      typedef ::xsd::qif2::AngularValueType BAngle_type;
      typedef ::xsd::cxx::tree::optional< BAngle_type > BAngle_optional;
      typedef ::xsd::cxx::tree::traits< BAngle_type, char > BAngle_traits;

      const BAngle_optional&
      BAngle () const;

      BAngle_optional&
      BAngle ();

      void
      BAngle (const BAngle_type& x);

      void
      BAngle (const BAngle_optional& x);

      void
      BAngle (::std::auto_ptr< BAngle_type > p);

      // Constructors.
      //
      SensorType (const Name_type&,
                  const id_type&,
                  const Qualifications_type&);

      SensorType (const Name_type&,
                  const id_type&,
                  ::std::auto_ptr< Qualifications_type >);

      SensorType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      SensorType (const SensorType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual SensorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SensorType&
      operator= (const SensorType& x);

      virtual 
      ~SensorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Qualifications_type > Qualifications_;
      AAngle_optional AAngle_;
      BAngle_optional BAngle_;
    };

    class TouchProbeType: public ::xsd::qif2::SensorType
    {
      public:
      // TipDiameter
      //
      typedef ::xsd::qif2::LinearValueType TipDiameter_type;
      typedef ::xsd::cxx::tree::traits< TipDiameter_type, char > TipDiameter_traits;

      const TipDiameter_type&
      TipDiameter () const;

      TipDiameter_type&
      TipDiameter ();

      void
      TipDiameter (const TipDiameter_type& x);

      void
      TipDiameter (::std::auto_ptr< TipDiameter_type > p);

      // Constructors.
      //
      TouchProbeType (const Name_type&,
                      const id_type&,
                      const Qualifications_type&,
                      const TipDiameter_type&);

      TouchProbeType (const Name_type&,
                      const id_type&,
                      ::std::auto_ptr< Qualifications_type >,
                      ::std::auto_ptr< TipDiameter_type >);

      TouchProbeType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      TouchProbeType (const TouchProbeType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual TouchProbeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TouchProbeType&
      operator= (const TouchProbeType& x);

      virtual 
      ~TouchProbeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< TipDiameter_type > TipDiameter_;
    };

    class ToolType: public ::xsd::qif2::MeasurementResourceBaseType
    {
      public:
      // SensorIds
      //
      typedef ::xsd::qif2::ArrayReferenceFullType SensorIds_type;
      typedef ::xsd::cxx::tree::optional< SensorIds_type > SensorIds_optional;
      typedef ::xsd::cxx::tree::traits< SensorIds_type, char > SensorIds_traits;

      const SensorIds_optional&
      SensorIds () const;

      SensorIds_optional&
      SensorIds ();

      void
      SensorIds (const SensorIds_type& x);

      void
      SensorIds (const SensorIds_optional& x);

      void
      SensorIds (::std::auto_ptr< SensorIds_type > p);

      // Constructors.
      //
      ToolType (const Name_type&,
                const id_type&);

      ToolType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      ToolType (const ToolType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual ToolType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToolType&
      operator= (const ToolType& x);

      virtual 
      ~ToolType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      SensorIds_optional SensorIds_;
    };

    class CarriageType: public ::xsd::qif2::MeasurementResourceBaseType
    {
      public:
      // ToolIds
      //
      typedef ::xsd::qif2::ArrayReferenceFullType ToolIds_type;
      typedef ::xsd::cxx::tree::optional< ToolIds_type > ToolIds_optional;
      typedef ::xsd::cxx::tree::traits< ToolIds_type, char > ToolIds_traits;

      const ToolIds_optional&
      ToolIds () const;

      ToolIds_optional&
      ToolIds ();

      void
      ToolIds (const ToolIds_type& x);

      void
      ToolIds (const ToolIds_optional& x);

      void
      ToolIds (::std::auto_ptr< ToolIds_type > p);

      // Constructors.
      //
      CarriageType (const Name_type&,
                    const id_type&);

      CarriageType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      CarriageType (const CarriageType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual CarriageType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CarriageType&
      operator= (const CarriageType& x);

      virtual 
      ~CarriageType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ToolIds_optional ToolIds_;
    };

    class ProbingDeviceType: public ::xsd::qif2::MeasurementDeviceType
    {
      public:
      // WorkingVolume
      //
      typedef ::xsd::qif2::WorkingVolumeType WorkingVolume_type;
      typedef ::xsd::cxx::tree::optional< WorkingVolume_type > WorkingVolume_optional;
      typedef ::xsd::cxx::tree::traits< WorkingVolume_type, char > WorkingVolume_traits;

      const WorkingVolume_optional&
      WorkingVolume () const;

      WorkingVolume_optional&
      WorkingVolume ();

      void
      WorkingVolume (const WorkingVolume_type& x);

      void
      WorkingVolume (const WorkingVolume_optional& x);

      void
      WorkingVolume (::std::auto_ptr< WorkingVolume_type > p);

      // EffectiveWorkingVolume
      //
      typedef ::xsd::qif2::EffectiveWorkingVolumeType EffectiveWorkingVolume_type;
      typedef ::xsd::cxx::tree::optional< EffectiveWorkingVolume_type > EffectiveWorkingVolume_optional;
      typedef ::xsd::cxx::tree::traits< EffectiveWorkingVolume_type, char > EffectiveWorkingVolume_traits;

      const EffectiveWorkingVolume_optional&
      EffectiveWorkingVolume () const;

      EffectiveWorkingVolume_optional&
      EffectiveWorkingVolume ();

      void
      EffectiveWorkingVolume (const EffectiveWorkingVolume_type& x);

      void
      EffectiveWorkingVolume (const EffectiveWorkingVolume_optional& x);

      void
      EffectiveWorkingVolume (::std::auto_ptr< EffectiveWorkingVolume_type > p);

      // Resolution
      //
      typedef ::xsd::qif2::ResolutionType Resolution_type;
      typedef ::xsd::cxx::tree::optional< Resolution_type > Resolution_optional;
      typedef ::xsd::cxx::tree::traits< Resolution_type, char > Resolution_traits;

      const Resolution_optional&
      Resolution () const;

      Resolution_optional&
      Resolution ();

      void
      Resolution (const Resolution_type& x);

      void
      Resolution (const Resolution_optional& x);

      void
      Resolution (::std::auto_ptr< Resolution_type > p);

      // Constructors.
      //
      ProbingDeviceType (const Name_type&,
                         const id_type&);

      ProbingDeviceType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      ProbingDeviceType (const ProbingDeviceType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual ProbingDeviceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ProbingDeviceType&
      operator= (const ProbingDeviceType& x);

      virtual 
      ~ProbingDeviceType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      WorkingVolume_optional WorkingVolume_;
      EffectiveWorkingVolume_optional EffectiveWorkingVolume_;
      Resolution_optional Resolution_;
    };

    class CMMType: public ::xsd::qif2::ProbingDeviceType
    {
      public:
      // HomeLocation
      //
      typedef ::xsd::qif2::PointType HomeLocation_type;
      typedef ::xsd::cxx::tree::optional< HomeLocation_type > HomeLocation_optional;
      typedef ::xsd::cxx::tree::traits< HomeLocation_type, char > HomeLocation_traits;

      const HomeLocation_optional&
      HomeLocation () const;

      HomeLocation_optional&
      HomeLocation ();

      void
      HomeLocation (const HomeLocation_type& x);

      void
      HomeLocation (const HomeLocation_optional& x);

      void
      HomeLocation (::std::auto_ptr< HomeLocation_type > p);

      // MachineGeometry
      //
      typedef ::xsd::qif2::CMMGeometryType MachineGeometry_type;
      typedef ::xsd::cxx::tree::optional< MachineGeometry_type > MachineGeometry_optional;
      typedef ::xsd::cxx::tree::traits< MachineGeometry_type, char > MachineGeometry_traits;

      const MachineGeometry_optional&
      MachineGeometry () const;

      MachineGeometry_optional&
      MachineGeometry ();

      void
      MachineGeometry (const MachineGeometry_type& x);

      void
      MachineGeometry (const MachineGeometry_optional& x);

      void
      MachineGeometry (::std::auto_ptr< MachineGeometry_type > p);

      // AxisOrientation
      //
      typedef ::xsd::qif2::CMMAxisDirectionsType AxisOrientation_type;
      typedef ::xsd::cxx::tree::optional< AxisOrientation_type > AxisOrientation_optional;
      typedef ::xsd::cxx::tree::traits< AxisOrientation_type, char > AxisOrientation_traits;

      const AxisOrientation_optional&
      AxisOrientation () const;

      AxisOrientation_optional&
      AxisOrientation ();

      void
      AxisOrientation (const AxisOrientation_type& x);

      void
      AxisOrientation (const AxisOrientation_optional& x);

      void
      AxisOrientation (::std::auto_ptr< AxisOrientation_type > p);

      // CMMScales
      //
      typedef ::xsd::qif2::CMMScalesType CMMScales_type;
      typedef ::xsd::cxx::tree::optional< CMMScales_type > CMMScales_optional;
      typedef ::xsd::cxx::tree::traits< CMMScales_type, char > CMMScales_traits;

      const CMMScales_optional&
      CMMScales () const;

      CMMScales_optional&
      CMMScales ();

      void
      CMMScales (const CMMScales_type& x);

      void
      CMMScales (const CMMScales_optional& x);

      void
      CMMScales (::std::auto_ptr< CMMScales_type > p);

      // MaxWorkpieceHeight
      //
      typedef ::xsd::qif2::LinearValueType MaxWorkpieceHeight_type;
      typedef ::xsd::cxx::tree::optional< MaxWorkpieceHeight_type > MaxWorkpieceHeight_optional;
      typedef ::xsd::cxx::tree::traits< MaxWorkpieceHeight_type, char > MaxWorkpieceHeight_traits;

      const MaxWorkpieceHeight_optional&
      MaxWorkpieceHeight () const;

      MaxWorkpieceHeight_optional&
      MaxWorkpieceHeight ();

      void
      MaxWorkpieceHeight (const MaxWorkpieceHeight_type& x);

      void
      MaxWorkpieceHeight (const MaxWorkpieceHeight_optional& x);

      void
      MaxWorkpieceHeight (::std::auto_ptr< MaxWorkpieceHeight_type > p);

      // MaxWorkpieceMass
      //
      typedef ::xsd::qif2::MassValueType MaxWorkpieceMass_type;
      typedef ::xsd::cxx::tree::optional< MaxWorkpieceMass_type > MaxWorkpieceMass_optional;
      typedef ::xsd::cxx::tree::traits< MaxWorkpieceMass_type, char > MaxWorkpieceMass_traits;

      const MaxWorkpieceMass_optional&
      MaxWorkpieceMass () const;

      MaxWorkpieceMass_optional&
      MaxWorkpieceMass ();

      void
      MaxWorkpieceMass (const MaxWorkpieceMass_type& x);

      void
      MaxWorkpieceMass (const MaxWorkpieceMass_optional& x);

      void
      MaxWorkpieceMass (::std::auto_ptr< MaxWorkpieceMass_type > p);

      // JoystickSpeeds
      //
      typedef ::xsd::qif2::CMMSpeedsType JoystickSpeeds_type;
      typedef ::xsd::cxx::tree::optional< JoystickSpeeds_type > JoystickSpeeds_optional;
      typedef ::xsd::cxx::tree::traits< JoystickSpeeds_type, char > JoystickSpeeds_traits;

      const JoystickSpeeds_optional&
      JoystickSpeeds () const;

      JoystickSpeeds_optional&
      JoystickSpeeds ();

      void
      JoystickSpeeds (const JoystickSpeeds_type& x);

      void
      JoystickSpeeds (const JoystickSpeeds_optional& x);

      void
      JoystickSpeeds (::std::auto_ptr< JoystickSpeeds_type > p);

      // CNCSpeeds
      //
      typedef ::xsd::qif2::CMMSpeedsType CNCSpeeds_type;
      typedef ::xsd::cxx::tree::optional< CNCSpeeds_type > CNCSpeeds_optional;
      typedef ::xsd::cxx::tree::traits< CNCSpeeds_type, char > CNCSpeeds_traits;

      const CNCSpeeds_optional&
      CNCSpeeds () const;

      CNCSpeeds_optional&
      CNCSpeeds ();

      void
      CNCSpeeds (const CNCSpeeds_type& x);

      void
      CNCSpeeds (const CNCSpeeds_optional& x);

      void
      CNCSpeeds (::std::auto_ptr< CNCSpeeds_type > p);

      // RotaryTable
      //
      typedef ::xsd::qif2::RotaryTableType RotaryTable_type;
      typedef ::xsd::cxx::tree::optional< RotaryTable_type > RotaryTable_optional;
      typedef ::xsd::cxx::tree::traits< RotaryTable_type, char > RotaryTable_traits;

      const RotaryTable_optional&
      RotaryTable () const;

      RotaryTable_optional&
      RotaryTable ();

      void
      RotaryTable (const RotaryTable_type& x);

      void
      RotaryTable (const RotaryTable_optional& x);

      void
      RotaryTable (::std::auto_ptr< RotaryTable_type > p);

      // NominalAccuracy
      //
      typedef ::xsd::qif2::CMMAccuracyType NominalAccuracy_type;
      typedef ::xsd::cxx::tree::optional< NominalAccuracy_type > NominalAccuracy_optional;
      typedef ::xsd::cxx::tree::traits< NominalAccuracy_type, char > NominalAccuracy_traits;

      const NominalAccuracy_optional&
      NominalAccuracy () const;

      NominalAccuracy_optional&
      NominalAccuracy ();

      void
      NominalAccuracy (const NominalAccuracy_type& x);

      void
      NominalAccuracy (const NominalAccuracy_optional& x);

      void
      NominalAccuracy (::std::auto_ptr< NominalAccuracy_type > p);

      // ActualAccuracy
      //
      typedef ::xsd::qif2::CMMAccuracyType ActualAccuracy_type;
      typedef ::xsd::cxx::tree::optional< ActualAccuracy_type > ActualAccuracy_optional;
      typedef ::xsd::cxx::tree::traits< ActualAccuracy_type, char > ActualAccuracy_traits;

      const ActualAccuracy_optional&
      ActualAccuracy () const;

      ActualAccuracy_optional&
      ActualAccuracy ();

      void
      ActualAccuracy (const ActualAccuracy_type& x);

      void
      ActualAccuracy (const ActualAccuracy_optional& x);

      void
      ActualAccuracy (::std::auto_ptr< ActualAccuracy_type > p);

      // CarriageIds
      //
      typedef ::xsd::qif2::ArrayReferenceFullType CarriageIds_type;
      typedef ::xsd::cxx::tree::optional< CarriageIds_type > CarriageIds_optional;
      typedef ::xsd::cxx::tree::traits< CarriageIds_type, char > CarriageIds_traits;

      const CarriageIds_optional&
      CarriageIds () const;

      CarriageIds_optional&
      CarriageIds ();

      void
      CarriageIds (const CarriageIds_type& x);

      void
      CarriageIds (const CarriageIds_optional& x);

      void
      CarriageIds (::std::auto_ptr< CarriageIds_type > p);

      // ToolIds
      //
      typedef ::xsd::qif2::ArrayReferenceFullType ToolIds_type;
      typedef ::xsd::cxx::tree::optional< ToolIds_type > ToolIds_optional;
      typedef ::xsd::cxx::tree::traits< ToolIds_type, char > ToolIds_traits;

      const ToolIds_optional&
      ToolIds () const;

      ToolIds_optional&
      ToolIds ();

      void
      ToolIds (const ToolIds_type& x);

      void
      ToolIds (const ToolIds_optional& x);

      void
      ToolIds (::std::auto_ptr< ToolIds_type > p);

      // Constructors.
      //
      CMMType (const Name_type&,
               const id_type&);

      CMMType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      CMMType (const CMMType& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      virtual CMMType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CMMType&
      operator= (const CMMType& x);

      virtual 
      ~CMMType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      HomeLocation_optional HomeLocation_;
      MachineGeometry_optional MachineGeometry_;
      AxisOrientation_optional AxisOrientation_;
      CMMScales_optional CMMScales_;
      MaxWorkpieceHeight_optional MaxWorkpieceHeight_;
      MaxWorkpieceMass_optional MaxWorkpieceMass_;
      JoystickSpeeds_optional JoystickSpeeds_;
      CNCSpeeds_optional CNCSpeeds_;
      RotaryTable_optional RotaryTable_;
      NominalAccuracy_optional NominalAccuracy_;
      ActualAccuracy_optional ActualAccuracy_;
      CarriageIds_optional CarriageIds_;
      ToolIds_optional ToolIds_;
    };

    class CMMScalesType: public ::xml_schema::type
    {
      public:
      // XScale
      //
      typedef ::xsd::qif2::CMMScaleType XScale_type;
      typedef ::xsd::cxx::tree::traits< XScale_type, char > XScale_traits;

      const XScale_type&
      XScale () const;

      XScale_type&
      XScale ();

      void
      XScale (const XScale_type& x);

      void
      XScale (::std::auto_ptr< XScale_type > p);

      // YScale
      //
      typedef ::xsd::qif2::CMMScaleType YScale_type;
      typedef ::xsd::cxx::tree::traits< YScale_type, char > YScale_traits;

      const YScale_type&
      YScale () const;

      YScale_type&
      YScale ();

      void
      YScale (const YScale_type& x);

      void
      YScale (::std::auto_ptr< YScale_type > p);

      // ZScale
      //
      typedef ::xsd::qif2::CMMScaleType ZScale_type;
      typedef ::xsd::cxx::tree::traits< ZScale_type, char > ZScale_traits;

      const ZScale_type&
      ZScale () const;

      ZScale_type&
      ZScale ();

      void
      ZScale (const ZScale_type& x);

      void
      ZScale (::std::auto_ptr< ZScale_type > p);

      // Constructors.
      //
      CMMScalesType (const XScale_type&,
                     const YScale_type&,
                     const ZScale_type&);

      CMMScalesType (::std::auto_ptr< XScale_type >,
                     ::std::auto_ptr< YScale_type >,
                     ::std::auto_ptr< ZScale_type >);

      CMMScalesType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      CMMScalesType (const CMMScalesType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual CMMScalesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CMMScalesType&
      operator= (const CMMScalesType& x);

      virtual 
      ~CMMScalesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< XScale_type > XScale_;
      ::xsd::cxx::tree::one< YScale_type > YScale_;
      ::xsd::cxx::tree::one< ZScale_type > ZScale_;
    };

    class CMMScaleType: public ::xml_schema::type
    {
      public:
      // ScaleMaterial
      //
      typedef ::xml_schema::string ScaleMaterial_type;
      typedef ::xsd::cxx::tree::traits< ScaleMaterial_type, char > ScaleMaterial_traits;

      const ScaleMaterial_type&
      ScaleMaterial () const;

      ScaleMaterial_type&
      ScaleMaterial ();

      void
      ScaleMaterial (const ScaleMaterial_type& x);

      void
      ScaleMaterial (::std::auto_ptr< ScaleMaterial_type > p);

      // ScaleCoefficientOfExpansion
      //
      typedef ::xml_schema::decimal ScaleCoefficientOfExpansion_type;
      typedef ::xsd::cxx::tree::traits< ScaleCoefficientOfExpansion_type, char, ::xsd::cxx::tree::schema_type::decimal > ScaleCoefficientOfExpansion_traits;

      const ScaleCoefficientOfExpansion_type&
      ScaleCoefficientOfExpansion () const;

      ScaleCoefficientOfExpansion_type&
      ScaleCoefficientOfExpansion ();

      void
      ScaleCoefficientOfExpansion (const ScaleCoefficientOfExpansion_type& x);

      // ScaleCoefficientOfExpansionUncertainty
      //
      typedef ::xml_schema::decimal ScaleCoefficientOfExpansionUncertainty_type;
      typedef ::xsd::cxx::tree::traits< ScaleCoefficientOfExpansionUncertainty_type, char, ::xsd::cxx::tree::schema_type::decimal > ScaleCoefficientOfExpansionUncertainty_traits;

      const ScaleCoefficientOfExpansionUncertainty_type&
      ScaleCoefficientOfExpansionUncertainty () const;

      ScaleCoefficientOfExpansionUncertainty_type&
      ScaleCoefficientOfExpansionUncertainty ();

      void
      ScaleCoefficientOfExpansionUncertainty (const ScaleCoefficientOfExpansionUncertainty_type& x);

      // TypeOfScale
      //
      typedef ::xml_schema::string TypeOfScale_type;
      typedef ::xsd::cxx::tree::traits< TypeOfScale_type, char > TypeOfScale_traits;

      const TypeOfScale_type&
      TypeOfScale () const;

      TypeOfScale_type&
      TypeOfScale ();

      void
      TypeOfScale (const TypeOfScale_type& x);

      void
      TypeOfScale (::std::auto_ptr< TypeOfScale_type > p);

      // ScaleResolution
      //
      typedef ::xsd::qif2::LinearValueType ScaleResolution_type;
      typedef ::xsd::cxx::tree::traits< ScaleResolution_type, char > ScaleResolution_traits;

      const ScaleResolution_type&
      ScaleResolution () const;

      ScaleResolution_type&
      ScaleResolution ();

      void
      ScaleResolution (const ScaleResolution_type& x);

      void
      ScaleResolution (::std::auto_ptr< ScaleResolution_type > p);

      // Constructors.
      //
      CMMScaleType (const ScaleMaterial_type&,
                    const ScaleCoefficientOfExpansion_type&,
                    const ScaleCoefficientOfExpansionUncertainty_type&,
                    const TypeOfScale_type&,
                    const ScaleResolution_type&);

      CMMScaleType (const ScaleMaterial_type&,
                    const ScaleCoefficientOfExpansion_type&,
                    const ScaleCoefficientOfExpansionUncertainty_type&,
                    const TypeOfScale_type&,
                    ::std::auto_ptr< ScaleResolution_type >);

      CMMScaleType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      CMMScaleType (const CMMScaleType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual CMMScaleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CMMScaleType&
      operator= (const CMMScaleType& x);

      virtual 
      ~CMMScaleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ScaleMaterial_type > ScaleMaterial_;
      ::xsd::cxx::tree::one< ScaleCoefficientOfExpansion_type > ScaleCoefficientOfExpansion_;
      ::xsd::cxx::tree::one< ScaleCoefficientOfExpansionUncertainty_type > ScaleCoefficientOfExpansionUncertainty_;
      ::xsd::cxx::tree::one< TypeOfScale_type > TypeOfScale_;
      ::xsd::cxx::tree::one< ScaleResolution_type > ScaleResolution_;
    };

    class CMMSpeedsType: public ::xml_schema::type
    {
      public:
      // MaxXTraverseSpeed
      //
      typedef ::xsd::qif2::SpeedValueType MaxXTraverseSpeed_type;
      typedef ::xsd::cxx::tree::traits< MaxXTraverseSpeed_type, char > MaxXTraverseSpeed_traits;

      const MaxXTraverseSpeed_type&
      MaxXTraverseSpeed () const;

      MaxXTraverseSpeed_type&
      MaxXTraverseSpeed ();

      void
      MaxXTraverseSpeed (const MaxXTraverseSpeed_type& x);

      void
      MaxXTraverseSpeed (::std::auto_ptr< MaxXTraverseSpeed_type > p);

      // MaxYTraverseSpeed
      //
      typedef ::xsd::qif2::SpeedValueType MaxYTraverseSpeed_type;
      typedef ::xsd::cxx::tree::traits< MaxYTraverseSpeed_type, char > MaxYTraverseSpeed_traits;

      const MaxYTraverseSpeed_type&
      MaxYTraverseSpeed () const;

      MaxYTraverseSpeed_type&
      MaxYTraverseSpeed ();

      void
      MaxYTraverseSpeed (const MaxYTraverseSpeed_type& x);

      void
      MaxYTraverseSpeed (::std::auto_ptr< MaxYTraverseSpeed_type > p);

      // MaxZTraverseSpeed
      //
      typedef ::xsd::qif2::SpeedValueType MaxZTraverseSpeed_type;
      typedef ::xsd::cxx::tree::traits< MaxZTraverseSpeed_type, char > MaxZTraverseSpeed_traits;

      const MaxZTraverseSpeed_type&
      MaxZTraverseSpeed () const;

      MaxZTraverseSpeed_type&
      MaxZTraverseSpeed ();

      void
      MaxZTraverseSpeed (const MaxZTraverseSpeed_type& x);

      void
      MaxZTraverseSpeed (::std::auto_ptr< MaxZTraverseSpeed_type > p);

      // MaxXProbingSpeed
      //
      typedef ::xsd::qif2::SpeedValueType MaxXProbingSpeed_type;
      typedef ::xsd::cxx::tree::traits< MaxXProbingSpeed_type, char > MaxXProbingSpeed_traits;

      const MaxXProbingSpeed_type&
      MaxXProbingSpeed () const;

      MaxXProbingSpeed_type&
      MaxXProbingSpeed ();

      void
      MaxXProbingSpeed (const MaxXProbingSpeed_type& x);

      void
      MaxXProbingSpeed (::std::auto_ptr< MaxXProbingSpeed_type > p);

      // MaxYProbingSpeed
      //
      typedef ::xsd::qif2::SpeedValueType MaxYProbingSpeed_type;
      typedef ::xsd::cxx::tree::traits< MaxYProbingSpeed_type, char > MaxYProbingSpeed_traits;

      const MaxYProbingSpeed_type&
      MaxYProbingSpeed () const;

      MaxYProbingSpeed_type&
      MaxYProbingSpeed ();

      void
      MaxYProbingSpeed (const MaxYProbingSpeed_type& x);

      void
      MaxYProbingSpeed (::std::auto_ptr< MaxYProbingSpeed_type > p);

      // MaxZProbingSpeed
      //
      typedef ::xsd::qif2::SpeedValueType MaxZProbingSpeed_type;
      typedef ::xsd::cxx::tree::traits< MaxZProbingSpeed_type, char > MaxZProbingSpeed_traits;

      const MaxZProbingSpeed_type&
      MaxZProbingSpeed () const;

      MaxZProbingSpeed_type&
      MaxZProbingSpeed ();

      void
      MaxZProbingSpeed (const MaxZProbingSpeed_type& x);

      void
      MaxZProbingSpeed (::std::auto_ptr< MaxZProbingSpeed_type > p);

      // Constructors.
      //
      CMMSpeedsType (const MaxXTraverseSpeed_type&,
                     const MaxYTraverseSpeed_type&,
                     const MaxZTraverseSpeed_type&,
                     const MaxXProbingSpeed_type&,
                     const MaxYProbingSpeed_type&,
                     const MaxZProbingSpeed_type&);

      CMMSpeedsType (::std::auto_ptr< MaxXTraverseSpeed_type >,
                     ::std::auto_ptr< MaxYTraverseSpeed_type >,
                     ::std::auto_ptr< MaxZTraverseSpeed_type >,
                     ::std::auto_ptr< MaxXProbingSpeed_type >,
                     ::std::auto_ptr< MaxYProbingSpeed_type >,
                     ::std::auto_ptr< MaxZProbingSpeed_type >);

      CMMSpeedsType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      CMMSpeedsType (const CMMSpeedsType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual CMMSpeedsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CMMSpeedsType&
      operator= (const CMMSpeedsType& x);

      virtual 
      ~CMMSpeedsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< MaxXTraverseSpeed_type > MaxXTraverseSpeed_;
      ::xsd::cxx::tree::one< MaxYTraverseSpeed_type > MaxYTraverseSpeed_;
      ::xsd::cxx::tree::one< MaxZTraverseSpeed_type > MaxZTraverseSpeed_;
      ::xsd::cxx::tree::one< MaxXProbingSpeed_type > MaxXProbingSpeed_;
      ::xsd::cxx::tree::one< MaxYProbingSpeed_type > MaxYProbingSpeed_;
      ::xsd::cxx::tree::one< MaxZProbingSpeed_type > MaxZProbingSpeed_;
    };

    class GageDeviceType: public ::xsd::qif2::MeasurementDeviceType
    {
      public:
      // Constructors.
      //
      GageDeviceType (const Name_type&,
                      const id_type&);

      GageDeviceType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      GageDeviceType (const GageDeviceType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual GageDeviceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~GageDeviceType ();
    };

    class ManualDeviceType: public ::xsd::qif2::MeasurementDeviceType
    {
      public:
      // Constructors.
      //
      ManualDeviceType (const Name_type&,
                        const id_type&);

      ManualDeviceType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ManualDeviceType (const ManualDeviceType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual ManualDeviceType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ManualDeviceType ();
    };

    class CaliperType: public ::xsd::qif2::ManualDeviceType
    {
      public:
      // Resolution
      //
      typedef ::xsd::qif2::LinearValueType Resolution_type;
      typedef ::xsd::cxx::tree::optional< Resolution_type > Resolution_optional;
      typedef ::xsd::cxx::tree::traits< Resolution_type, char > Resolution_traits;

      const Resolution_optional&
      Resolution () const;

      Resolution_optional&
      Resolution ();

      void
      Resolution (const Resolution_type& x);

      void
      Resolution (const Resolution_optional& x);

      void
      Resolution (::std::auto_ptr< Resolution_type > p);

      // Accuracy
      //
      typedef ::xsd::qif2::NumericalLengthAccuracyType Accuracy_type;
      typedef ::xsd::cxx::tree::optional< Accuracy_type > Accuracy_optional;
      typedef ::xsd::cxx::tree::traits< Accuracy_type, char > Accuracy_traits;

      const Accuracy_optional&
      Accuracy () const;

      Accuracy_optional&
      Accuracy ();

      void
      Accuracy (const Accuracy_type& x);

      void
      Accuracy (const Accuracy_optional& x);

      void
      Accuracy (::std::auto_ptr< Accuracy_type > p);

      // MinMeasurement
      //
      typedef ::xsd::qif2::LinearValueType MinMeasurement_type;
      typedef ::xsd::cxx::tree::optional< MinMeasurement_type > MinMeasurement_optional;
      typedef ::xsd::cxx::tree::traits< MinMeasurement_type, char > MinMeasurement_traits;

      const MinMeasurement_optional&
      MinMeasurement () const;

      MinMeasurement_optional&
      MinMeasurement ();

      void
      MinMeasurement (const MinMeasurement_type& x);

      void
      MinMeasurement (const MinMeasurement_optional& x);

      void
      MinMeasurement (::std::auto_ptr< MinMeasurement_type > p);

      // MaxMeasurement
      //
      typedef ::xsd::qif2::LinearValueType MaxMeasurement_type;
      typedef ::xsd::cxx::tree::optional< MaxMeasurement_type > MaxMeasurement_optional;
      typedef ::xsd::cxx::tree::traits< MaxMeasurement_type, char > MaxMeasurement_traits;

      const MaxMeasurement_optional&
      MaxMeasurement () const;

      MaxMeasurement_optional&
      MaxMeasurement ();

      void
      MaxMeasurement (const MaxMeasurement_type& x);

      void
      MaxMeasurement (const MaxMeasurement_optional& x);

      void
      MaxMeasurement (::std::auto_ptr< MaxMeasurement_type > p);

      // CanMeasureInnerD
      //
      typedef ::xml_schema::boolean CanMeasureInnerD_type;
      typedef ::xsd::cxx::tree::optional< CanMeasureInnerD_type > CanMeasureInnerD_optional;
      typedef ::xsd::cxx::tree::traits< CanMeasureInnerD_type, char > CanMeasureInnerD_traits;

      const CanMeasureInnerD_optional&
      CanMeasureInnerD () const;

      CanMeasureInnerD_optional&
      CanMeasureInnerD ();

      void
      CanMeasureInnerD (const CanMeasureInnerD_type& x);

      void
      CanMeasureInnerD (const CanMeasureInnerD_optional& x);

      // CanMeasureOuterD
      //
      typedef ::xml_schema::boolean CanMeasureOuterD_type;
      typedef ::xsd::cxx::tree::optional< CanMeasureOuterD_type > CanMeasureOuterD_optional;
      typedef ::xsd::cxx::tree::traits< CanMeasureOuterD_type, char > CanMeasureOuterD_traits;

      const CanMeasureOuterD_optional&
      CanMeasureOuterD () const;

      CanMeasureOuterD_optional&
      CanMeasureOuterD ();

      void
      CanMeasureOuterD (const CanMeasureOuterD_type& x);

      void
      CanMeasureOuterD (const CanMeasureOuterD_optional& x);

      // CanMeasureDepth
      //
      typedef ::xml_schema::boolean CanMeasureDepth_type;
      typedef ::xsd::cxx::tree::optional< CanMeasureDepth_type > CanMeasureDepth_optional;
      typedef ::xsd::cxx::tree::traits< CanMeasureDepth_type, char > CanMeasureDepth_traits;

      const CanMeasureDepth_optional&
      CanMeasureDepth () const;

      CanMeasureDepth_optional&
      CanMeasureDepth ();

      void
      CanMeasureDepth (const CanMeasureDepth_type& x);

      void
      CanMeasureDepth (const CanMeasureDepth_optional& x);

      // Constructors.
      //
      CaliperType (const Name_type&,
                   const id_type&);

      CaliperType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      CaliperType (const CaliperType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual CaliperType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CaliperType&
      operator= (const CaliperType& x);

      virtual 
      ~CaliperType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Resolution_optional Resolution_;
      Accuracy_optional Accuracy_;
      MinMeasurement_optional MinMeasurement_;
      MaxMeasurement_optional MaxMeasurement_;
      CanMeasureInnerD_optional CanMeasureInnerD_;
      CanMeasureOuterD_optional CanMeasureOuterD_;
      CanMeasureDepth_optional CanMeasureDepth_;
    };

    class CMMDirectionEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        RIGHT,
        LEFT,
        FRONT,
        BACK,
        UP,
        DOWN
      };

      CMMDirectionEnumType (value v);

      CMMDirectionEnumType (const char* v);

      CMMDirectionEnumType (const ::std::string& v);

      CMMDirectionEnumType (const ::xml_schema::nmtoken& v);

      CMMDirectionEnumType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      CMMDirectionEnumType (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      CMMDirectionEnumType (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      CMMDirectionEnumType (const CMMDirectionEnumType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual CMMDirectionEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CMMDirectionEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_CMMDirectionEnumType_convert ();
      }

      protected:
      value
      _xsd_CMMDirectionEnumType_convert () const;

      public:
      static const char* const _xsd_CMMDirectionEnumType_literals_[6];
      static const value _xsd_CMMDirectionEnumType_indexes_[6];
    };

    class CMMGeometryType: public ::xml_schema::type
    {
      public:
      // CMMGeometryEnum
      //
      typedef ::xsd::qif2::CMMGeometryEnumType CMMGeometryEnum_type;
      typedef ::xsd::cxx::tree::optional< CMMGeometryEnum_type > CMMGeometryEnum_optional;
      typedef ::xsd::cxx::tree::traits< CMMGeometryEnum_type, char > CMMGeometryEnum_traits;

      const CMMGeometryEnum_optional&
      CMMGeometryEnum () const;

      CMMGeometryEnum_optional&
      CMMGeometryEnum ();

      void
      CMMGeometryEnum (const CMMGeometryEnum_type& x);

      void
      CMMGeometryEnum (const CMMGeometryEnum_optional& x);

      void
      CMMGeometryEnum (::std::auto_ptr< CMMGeometryEnum_type > p);

      // OtherCMMGeometry
      //
      typedef ::xml_schema::string OtherCMMGeometry_type;
      typedef ::xsd::cxx::tree::optional< OtherCMMGeometry_type > OtherCMMGeometry_optional;
      typedef ::xsd::cxx::tree::traits< OtherCMMGeometry_type, char > OtherCMMGeometry_traits;

      const OtherCMMGeometry_optional&
      OtherCMMGeometry () const;

      OtherCMMGeometry_optional&
      OtherCMMGeometry ();

      void
      OtherCMMGeometry (const OtherCMMGeometry_type& x);

      void
      OtherCMMGeometry (const OtherCMMGeometry_optional& x);

      void
      OtherCMMGeometry (::std::auto_ptr< OtherCMMGeometry_type > p);

      // Constructors.
      //
      CMMGeometryType ();

      CMMGeometryType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      CMMGeometryType (const CMMGeometryType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual CMMGeometryType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CMMGeometryType&
      operator= (const CMMGeometryType& x);

      virtual 
      ~CMMGeometryType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      CMMGeometryEnum_optional CMMGeometryEnum_;
      OtherCMMGeometry_optional OtherCMMGeometry_;
    };

    class CMMGeometryEnumType: public ::xml_schema::nmtoken
    {
      public:
      enum value
      {
        CANTILEVER,
        BRIDGEMOVINGBRIDGE,
        BRIDGEMOVINGTABLE,
        COLUMN,
        GANTRY,
        HORIZONTALARMMOVINGARM,
        HORIZONTALARMMOVINGTABLE,
        ARTICULATEDARM
      };

      CMMGeometryEnumType (value v);

      CMMGeometryEnumType (const char* v);

      CMMGeometryEnumType (const ::std::string& v);

      CMMGeometryEnumType (const ::xml_schema::nmtoken& v);

      CMMGeometryEnumType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      CMMGeometryEnumType (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      CMMGeometryEnumType (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      CMMGeometryEnumType (const CMMGeometryEnumType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual CMMGeometryEnumType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CMMGeometryEnumType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_CMMGeometryEnumType_convert ();
      }

      protected:
      value
      _xsd_CMMGeometryEnumType_convert () const;

      public:
      static const char* const _xsd_CMMGeometryEnumType_literals_[8];
      static const value _xsd_CMMGeometryEnumType_indexes_[8];
    };

    class CMMAxisDirectionsType: public ::xml_schema::type
    {
      public:
      // XAxisDirection
      //
      typedef ::xsd::qif2::CMMDirectionEnumType XAxisDirection_type;
      typedef ::xsd::cxx::tree::traits< XAxisDirection_type, char > XAxisDirection_traits;

      const XAxisDirection_type&
      XAxisDirection () const;

      XAxisDirection_type&
      XAxisDirection ();

      void
      XAxisDirection (const XAxisDirection_type& x);

      void
      XAxisDirection (::std::auto_ptr< XAxisDirection_type > p);

      // YAxisDirection
      //
      typedef ::xsd::qif2::CMMDirectionEnumType YAxisDirection_type;
      typedef ::xsd::cxx::tree::traits< YAxisDirection_type, char > YAxisDirection_traits;

      const YAxisDirection_type&
      YAxisDirection () const;

      YAxisDirection_type&
      YAxisDirection ();

      void
      YAxisDirection (const YAxisDirection_type& x);

      void
      YAxisDirection (::std::auto_ptr< YAxisDirection_type > p);

      // ZAxisDirection
      //
      typedef ::xsd::qif2::CMMDirectionEnumType ZAxisDirection_type;
      typedef ::xsd::cxx::tree::traits< ZAxisDirection_type, char > ZAxisDirection_traits;

      const ZAxisDirection_type&
      ZAxisDirection () const;

      ZAxisDirection_type&
      ZAxisDirection ();

      void
      ZAxisDirection (const ZAxisDirection_type& x);

      void
      ZAxisDirection (::std::auto_ptr< ZAxisDirection_type > p);

      // Constructors.
      //
      CMMAxisDirectionsType (const XAxisDirection_type&,
                             const YAxisDirection_type&,
                             const ZAxisDirection_type&);

      CMMAxisDirectionsType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      CMMAxisDirectionsType (const CMMAxisDirectionsType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual CMMAxisDirectionsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CMMAxisDirectionsType&
      operator= (const CMMAxisDirectionsType& x);

      virtual 
      ~CMMAxisDirectionsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< XAxisDirection_type > XAxisDirection_;
      ::xsd::cxx::tree::one< YAxisDirection_type > YAxisDirection_;
      ::xsd::cxx::tree::one< ZAxisDirection_type > ZAxisDirection_;
    };

    class WorkingVolumeType: public ::xml_schema::type
    {
      public:
      // XAxisLength
      //
      typedef ::xsd::qif2::LinearValueType XAxisLength_type;
      typedef ::xsd::cxx::tree::traits< XAxisLength_type, char > XAxisLength_traits;

      const XAxisLength_type&
      XAxisLength () const;

      XAxisLength_type&
      XAxisLength ();

      void
      XAxisLength (const XAxisLength_type& x);

      void
      XAxisLength (::std::auto_ptr< XAxisLength_type > p);

      // YAxisLength
      //
      typedef ::xsd::qif2::LinearValueType YAxisLength_type;
      typedef ::xsd::cxx::tree::traits< YAxisLength_type, char > YAxisLength_traits;

      const YAxisLength_type&
      YAxisLength () const;

      YAxisLength_type&
      YAxisLength ();

      void
      YAxisLength (const YAxisLength_type& x);

      void
      YAxisLength (::std::auto_ptr< YAxisLength_type > p);

      // ZAxisLength
      //
      typedef ::xsd::qif2::LinearValueType ZAxisLength_type;
      typedef ::xsd::cxx::tree::traits< ZAxisLength_type, char > ZAxisLength_traits;

      const ZAxisLength_type&
      ZAxisLength () const;

      ZAxisLength_type&
      ZAxisLength ();

      void
      ZAxisLength (const ZAxisLength_type& x);

      void
      ZAxisLength (::std::auto_ptr< ZAxisLength_type > p);

      // Constructors.
      //
      WorkingVolumeType (const XAxisLength_type&,
                         const YAxisLength_type&,
                         const ZAxisLength_type&);

      WorkingVolumeType (::std::auto_ptr< XAxisLength_type >,
                         ::std::auto_ptr< YAxisLength_type >,
                         ::std::auto_ptr< ZAxisLength_type >);

      WorkingVolumeType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      WorkingVolumeType (const WorkingVolumeType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual WorkingVolumeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WorkingVolumeType&
      operator= (const WorkingVolumeType& x);

      virtual 
      ~WorkingVolumeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< XAxisLength_type > XAxisLength_;
      ::xsd::cxx::tree::one< YAxisLength_type > YAxisLength_;
      ::xsd::cxx::tree::one< ZAxisLength_type > ZAxisLength_;
    };

    class EffectiveWorkingVolumeType: public ::xml_schema::type
    {
      public:
      // MinPoint
      //
      typedef ::xsd::qif2::PointType MinPoint_type;
      typedef ::xsd::cxx::tree::traits< MinPoint_type, char > MinPoint_traits;

      const MinPoint_type&
      MinPoint () const;

      MinPoint_type&
      MinPoint ();

      void
      MinPoint (const MinPoint_type& x);

      void
      MinPoint (::std::auto_ptr< MinPoint_type > p);

      // MaxPoint
      //
      typedef ::xsd::qif2::PointType MaxPoint_type;
      typedef ::xsd::cxx::tree::traits< MaxPoint_type, char > MaxPoint_traits;

      const MaxPoint_type&
      MaxPoint () const;

      MaxPoint_type&
      MaxPoint ();

      void
      MaxPoint (const MaxPoint_type& x);

      void
      MaxPoint (::std::auto_ptr< MaxPoint_type > p);

      // Constructors.
      //
      EffectiveWorkingVolumeType (const MinPoint_type&,
                                  const MaxPoint_type&);

      EffectiveWorkingVolumeType (::std::auto_ptr< MinPoint_type >,
                                  ::std::auto_ptr< MaxPoint_type >);

      EffectiveWorkingVolumeType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      EffectiveWorkingVolumeType (const EffectiveWorkingVolumeType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual EffectiveWorkingVolumeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EffectiveWorkingVolumeType&
      operator= (const EffectiveWorkingVolumeType& x);

      virtual 
      ~EffectiveWorkingVolumeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< MinPoint_type > MinPoint_;
      ::xsd::cxx::tree::one< MaxPoint_type > MaxPoint_;
    };

    class RotaryTableType: public ::xml_schema::type
    {
      public:
      // LocationOnCMM
      //
      typedef ::xsd::qif2::PointType LocationOnCMM_type;
      typedef ::xsd::cxx::tree::traits< LocationOnCMM_type, char > LocationOnCMM_traits;

      const LocationOnCMM_type&
      LocationOnCMM () const;

      LocationOnCMM_type&
      LocationOnCMM ();

      void
      LocationOnCMM (const LocationOnCMM_type& x);

      void
      LocationOnCMM (::std::auto_ptr< LocationOnCMM_type > p);

      // AxisDirection
      //
      typedef ::xsd::qif2::UnitVectorType AxisDirection_type;
      typedef ::xsd::cxx::tree::traits< AxisDirection_type, char > AxisDirection_traits;

      const AxisDirection_type&
      AxisDirection () const;

      AxisDirection_type&
      AxisDirection ();

      void
      AxisDirection (const AxisDirection_type& x);

      void
      AxisDirection (::std::auto_ptr< AxisDirection_type > p);

      // ZeroIndexDirection
      //
      typedef ::xsd::qif2::UnitVectorType ZeroIndexDirection_type;
      typedef ::xsd::cxx::tree::traits< ZeroIndexDirection_type, char > ZeroIndexDirection_traits;

      const ZeroIndexDirection_type&
      ZeroIndexDirection () const;

      ZeroIndexDirection_type&
      ZeroIndexDirection ();

      void
      ZeroIndexDirection (const ZeroIndexDirection_type& x);

      void
      ZeroIndexDirection (::std::auto_ptr< ZeroIndexDirection_type > p);

      // TableRadius
      //
      typedef ::xsd::qif2::LinearValueType TableRadius_type;
      typedef ::xsd::cxx::tree::traits< TableRadius_type, char > TableRadius_traits;

      const TableRadius_type&
      TableRadius () const;

      TableRadius_type&
      TableRadius ();

      void
      TableRadius (const TableRadius_type& x);

      void
      TableRadius (::std::auto_ptr< TableRadius_type > p);

      // TableErrors
      //
      typedef ::xsd::qif2::TableErrorsType TableErrors_type;
      typedef ::xsd::cxx::tree::traits< TableErrors_type, char > TableErrors_traits;

      const TableErrors_type&
      TableErrors () const;

      TableErrors_type&
      TableErrors ();

      void
      TableErrors (const TableErrors_type& x);

      void
      TableErrors (::std::auto_ptr< TableErrors_type > p);

      // Constructors.
      //
      RotaryTableType (const LocationOnCMM_type&,
                       const AxisDirection_type&,
                       const ZeroIndexDirection_type&,
                       const TableRadius_type&,
                       const TableErrors_type&);

      RotaryTableType (::std::auto_ptr< LocationOnCMM_type >,
                       ::std::auto_ptr< AxisDirection_type >,
                       ::std::auto_ptr< ZeroIndexDirection_type >,
                       ::std::auto_ptr< TableRadius_type >,
                       ::std::auto_ptr< TableErrors_type >);

      RotaryTableType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      RotaryTableType (const RotaryTableType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual RotaryTableType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RotaryTableType&
      operator= (const RotaryTableType& x);

      virtual 
      ~RotaryTableType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< LocationOnCMM_type > LocationOnCMM_;
      ::xsd::cxx::tree::one< AxisDirection_type > AxisDirection_;
      ::xsd::cxx::tree::one< ZeroIndexDirection_type > ZeroIndexDirection_;
      ::xsd::cxx::tree::one< TableRadius_type > TableRadius_;
      ::xsd::cxx::tree::one< TableErrors_type > TableErrors_;
    };

    class TableErrorsType: public ::xml_schema::type
    {
      public:
      // AxialError
      //
      typedef ::xsd::qif2::LinearValueType AxialError_type;
      typedef ::xsd::cxx::tree::traits< AxialError_type, char > AxialError_traits;

      const AxialError_type&
      AxialError () const;

      AxialError_type&
      AxialError ();

      void
      AxialError (const AxialError_type& x);

      void
      AxialError (::std::auto_ptr< AxialError_type > p);

      // RadialError
      //
      typedef ::xsd::qif2::LinearValueType RadialError_type;
      typedef ::xsd::cxx::tree::traits< RadialError_type, char > RadialError_traits;

      const RadialError_type&
      RadialError () const;

      RadialError_type&
      RadialError ();

      void
      RadialError (const RadialError_type& x);

      void
      RadialError (::std::auto_ptr< RadialError_type > p);

      // TangentialError
      //
      typedef ::xsd::qif2::LinearValueType TangentialError_type;
      typedef ::xsd::cxx::tree::traits< TangentialError_type, char > TangentialError_traits;

      const TangentialError_type&
      TangentialError () const;

      TangentialError_type&
      TangentialError ();

      void
      TangentialError (const TangentialError_type& x);

      void
      TangentialError (::std::auto_ptr< TangentialError_type > p);

      // Constructors.
      //
      TableErrorsType (const AxialError_type&,
                       const RadialError_type&,
                       const TangentialError_type&);

      TableErrorsType (::std::auto_ptr< AxialError_type >,
                       ::std::auto_ptr< RadialError_type >,
                       ::std::auto_ptr< TangentialError_type >);

      TableErrorsType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      TableErrorsType (const TableErrorsType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual TableErrorsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TableErrorsType&
      operator= (const TableErrorsType& x);

      virtual 
      ~TableErrorsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< AxialError_type > AxialError_;
      ::xsd::cxx::tree::one< RadialError_type > RadialError_;
      ::xsd::cxx::tree::one< TangentialError_type > TangentialError_;
    };

    class ResolutionType: public ::xml_schema::type
    {
      public:
      // CombinedResolution
      //
      typedef ::xsd::qif2::LinearValueType CombinedResolution_type;
      typedef ::xsd::cxx::tree::optional< CombinedResolution_type > CombinedResolution_optional;
      typedef ::xsd::cxx::tree::traits< CombinedResolution_type, char > CombinedResolution_traits;

      const CombinedResolution_optional&
      CombinedResolution () const;

      CombinedResolution_optional&
      CombinedResolution ();

      void
      CombinedResolution (const CombinedResolution_type& x);

      void
      CombinedResolution (const CombinedResolution_optional& x);

      void
      CombinedResolution (::std::auto_ptr< CombinedResolution_type > p);

      // XYZResolution
      //
      typedef ::xsd::qif2::XYZResolutionType XYZResolution_type;
      typedef ::xsd::cxx::tree::optional< XYZResolution_type > XYZResolution_optional;
      typedef ::xsd::cxx::tree::traits< XYZResolution_type, char > XYZResolution_traits;

      const XYZResolution_optional&
      XYZResolution () const;

      XYZResolution_optional&
      XYZResolution ();

      void
      XYZResolution (const XYZResolution_type& x);

      void
      XYZResolution (const XYZResolution_optional& x);

      void
      XYZResolution (::std::auto_ptr< XYZResolution_type > p);

      // Constructors.
      //
      ResolutionType ();

      ResolutionType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ResolutionType (const ResolutionType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual ResolutionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ResolutionType&
      operator= (const ResolutionType& x);

      virtual 
      ~ResolutionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      CombinedResolution_optional CombinedResolution_;
      XYZResolution_optional XYZResolution_;
    };

    class XYZResolutionType: public ::xml_schema::type
    {
      public:
      // XResolution
      //
      typedef ::xsd::qif2::LinearValueType XResolution_type;
      typedef ::xsd::cxx::tree::traits< XResolution_type, char > XResolution_traits;

      const XResolution_type&
      XResolution () const;

      XResolution_type&
      XResolution ();

      void
      XResolution (const XResolution_type& x);

      void
      XResolution (::std::auto_ptr< XResolution_type > p);

      // YResolution
      //
      typedef ::xsd::qif2::LinearValueType YResolution_type;
      typedef ::xsd::cxx::tree::traits< YResolution_type, char > YResolution_traits;

      const YResolution_type&
      YResolution () const;

      YResolution_type&
      YResolution ();

      void
      YResolution (const YResolution_type& x);

      void
      YResolution (::std::auto_ptr< YResolution_type > p);

      // ZResolution
      //
      typedef ::xsd::qif2::LinearValueType ZResolution_type;
      typedef ::xsd::cxx::tree::traits< ZResolution_type, char > ZResolution_traits;

      const ZResolution_type&
      ZResolution () const;

      ZResolution_type&
      ZResolution ();

      void
      ZResolution (const ZResolution_type& x);

      void
      ZResolution (::std::auto_ptr< ZResolution_type > p);

      // Constructors.
      //
      XYZResolutionType (const XResolution_type&,
                         const YResolution_type&,
                         const ZResolution_type&);

      XYZResolutionType (::std::auto_ptr< XResolution_type >,
                         ::std::auto_ptr< YResolution_type >,
                         ::std::auto_ptr< ZResolution_type >);

      XYZResolutionType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      XYZResolutionType (const XYZResolutionType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual XYZResolutionType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      XYZResolutionType&
      operator= (const XYZResolutionType& x);

      virtual 
      ~XYZResolutionType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< XResolution_type > XResolution_;
      ::xsd::cxx::tree::one< YResolution_type > YResolution_;
      ::xsd::cxx::tree::one< ZResolution_type > ZResolution_;
    };

    class CMMAccuracyTestBaseType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      CMMAccuracyTestBaseType ();

      CMMAccuracyTestBaseType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      CMMAccuracyTestBaseType (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      CMMAccuracyTestBaseType (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      CMMAccuracyTestBaseType (const CMMAccuracyTestBaseType& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual CMMAccuracyTestBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~CMMAccuracyTestBaseType ();
    };

    class FPSTestType: public ::xsd::qif2::CMMAccuracyTestBaseType
    {
      public:
      // XLinearity
      //
      typedef ::xsd::qif2::LengthFunctionDiscreteType XLinearity_type;
      typedef ::xsd::cxx::tree::traits< XLinearity_type, char > XLinearity_traits;

      const XLinearity_type&
      XLinearity () const;

      XLinearity_type&
      XLinearity ();

      void
      XLinearity (const XLinearity_type& x);

      void
      XLinearity (::std::auto_ptr< XLinearity_type > p);

      // YLinearity
      //
      typedef ::xsd::qif2::LengthFunctionDiscreteType YLinearity_type;
      typedef ::xsd::cxx::tree::traits< YLinearity_type, char > YLinearity_traits;

      const YLinearity_type&
      YLinearity () const;

      YLinearity_type&
      YLinearity ();

      void
      YLinearity (const YLinearity_type& x);

      void
      YLinearity (::std::auto_ptr< YLinearity_type > p);

      // ZLinearity
      //
      typedef ::xsd::qif2::LengthFunctionDiscreteType ZLinearity_type;
      typedef ::xsd::cxx::tree::traits< ZLinearity_type, char > ZLinearity_traits;

      const ZLinearity_type&
      ZLinearity () const;

      ZLinearity_type&
      ZLinearity ();

      void
      ZLinearity (const ZLinearity_type& x);

      void
      ZLinearity (::std::auto_ptr< ZLinearity_type > p);

      // XAxisRoll
      //
      typedef ::xsd::qif2::AngleFunctionDiscreteType XAxisRoll_type;
      typedef ::xsd::cxx::tree::traits< XAxisRoll_type, char > XAxisRoll_traits;

      const XAxisRoll_type&
      XAxisRoll () const;

      XAxisRoll_type&
      XAxisRoll ();

      void
      XAxisRoll (const XAxisRoll_type& x);

      void
      XAxisRoll (::std::auto_ptr< XAxisRoll_type > p);

      // XAxisPitch
      //
      typedef ::xsd::qif2::AngleFunctionDiscreteType XAxisPitch_type;
      typedef ::xsd::cxx::tree::traits< XAxisPitch_type, char > XAxisPitch_traits;

      const XAxisPitch_type&
      XAxisPitch () const;

      XAxisPitch_type&
      XAxisPitch ();

      void
      XAxisPitch (const XAxisPitch_type& x);

      void
      XAxisPitch (::std::auto_ptr< XAxisPitch_type > p);

      // XAxisYaw
      //
      typedef ::xsd::qif2::AngleFunctionDiscreteType XAxisYaw_type;
      typedef ::xsd::cxx::tree::traits< XAxisYaw_type, char > XAxisYaw_traits;

      const XAxisYaw_type&
      XAxisYaw () const;

      XAxisYaw_type&
      XAxisYaw ();

      void
      XAxisYaw (const XAxisYaw_type& x);

      void
      XAxisYaw (::std::auto_ptr< XAxisYaw_type > p);

      // YAxisRoll
      //
      typedef ::xsd::qif2::AngleFunctionDiscreteType YAxisRoll_type;
      typedef ::xsd::cxx::tree::traits< YAxisRoll_type, char > YAxisRoll_traits;

      const YAxisRoll_type&
      YAxisRoll () const;

      YAxisRoll_type&
      YAxisRoll ();

      void
      YAxisRoll (const YAxisRoll_type& x);

      void
      YAxisRoll (::std::auto_ptr< YAxisRoll_type > p);

      // YAxisPitch
      //
      typedef ::xsd::qif2::AngleFunctionDiscreteType YAxisPitch_type;
      typedef ::xsd::cxx::tree::traits< YAxisPitch_type, char > YAxisPitch_traits;

      const YAxisPitch_type&
      YAxisPitch () const;

      YAxisPitch_type&
      YAxisPitch ();

      void
      YAxisPitch (const YAxisPitch_type& x);

      void
      YAxisPitch (::std::auto_ptr< YAxisPitch_type > p);

      // YAxisYaw
      //
      typedef ::xsd::qif2::AngleFunctionDiscreteType YAxisYaw_type;
      typedef ::xsd::cxx::tree::traits< YAxisYaw_type, char > YAxisYaw_traits;

      const YAxisYaw_type&
      YAxisYaw () const;

      YAxisYaw_type&
      YAxisYaw ();

      void
      YAxisYaw (const YAxisYaw_type& x);

      void
      YAxisYaw (::std::auto_ptr< YAxisYaw_type > p);

      // ZAxisRoll
      //
      typedef ::xsd::qif2::AngleFunctionDiscreteType ZAxisRoll_type;
      typedef ::xsd::cxx::tree::traits< ZAxisRoll_type, char > ZAxisRoll_traits;

      const ZAxisRoll_type&
      ZAxisRoll () const;

      ZAxisRoll_type&
      ZAxisRoll ();

      void
      ZAxisRoll (const ZAxisRoll_type& x);

      void
      ZAxisRoll (::std::auto_ptr< ZAxisRoll_type > p);

      // ZAxisPitch
      //
      typedef ::xsd::qif2::AngleFunctionDiscreteType ZAxisPitch_type;
      typedef ::xsd::cxx::tree::traits< ZAxisPitch_type, char > ZAxisPitch_traits;

      const ZAxisPitch_type&
      ZAxisPitch () const;

      ZAxisPitch_type&
      ZAxisPitch ();

      void
      ZAxisPitch (const ZAxisPitch_type& x);

      void
      ZAxisPitch (::std::auto_ptr< ZAxisPitch_type > p);

      // ZAxisYaw
      //
      typedef ::xsd::qif2::AngleFunctionDiscreteType ZAxisYaw_type;
      typedef ::xsd::cxx::tree::traits< ZAxisYaw_type, char > ZAxisYaw_traits;

      const ZAxisYaw_type&
      ZAxisYaw () const;

      ZAxisYaw_type&
      ZAxisYaw ();

      void
      ZAxisYaw (const ZAxisYaw_type& x);

      void
      ZAxisYaw (::std::auto_ptr< ZAxisYaw_type > p);

      // XAxisStraightnessY
      //
      typedef ::xsd::qif2::LengthFunctionDiscreteType XAxisStraightnessY_type;
      typedef ::xsd::cxx::tree::traits< XAxisStraightnessY_type, char > XAxisStraightnessY_traits;

      const XAxisStraightnessY_type&
      XAxisStraightnessY () const;

      XAxisStraightnessY_type&
      XAxisStraightnessY ();

      void
      XAxisStraightnessY (const XAxisStraightnessY_type& x);

      void
      XAxisStraightnessY (::std::auto_ptr< XAxisStraightnessY_type > p);

      // XAxisStraightnessZ
      //
      typedef ::xsd::qif2::LengthFunctionDiscreteType XAxisStraightnessZ_type;
      typedef ::xsd::cxx::tree::traits< XAxisStraightnessZ_type, char > XAxisStraightnessZ_traits;

      const XAxisStraightnessZ_type&
      XAxisStraightnessZ () const;

      XAxisStraightnessZ_type&
      XAxisStraightnessZ ();

      void
      XAxisStraightnessZ (const XAxisStraightnessZ_type& x);

      void
      XAxisStraightnessZ (::std::auto_ptr< XAxisStraightnessZ_type > p);

      // YAxisStraightnessX
      //
      typedef ::xsd::qif2::LengthFunctionDiscreteType YAxisStraightnessX_type;
      typedef ::xsd::cxx::tree::traits< YAxisStraightnessX_type, char > YAxisStraightnessX_traits;

      const YAxisStraightnessX_type&
      YAxisStraightnessX () const;

      YAxisStraightnessX_type&
      YAxisStraightnessX ();

      void
      YAxisStraightnessX (const YAxisStraightnessX_type& x);

      void
      YAxisStraightnessX (::std::auto_ptr< YAxisStraightnessX_type > p);

      // YAxisStraightnessZ
      //
      typedef ::xsd::qif2::LengthFunctionDiscreteType YAxisStraightnessZ_type;
      typedef ::xsd::cxx::tree::traits< YAxisStraightnessZ_type, char > YAxisStraightnessZ_traits;

      const YAxisStraightnessZ_type&
      YAxisStraightnessZ () const;

      YAxisStraightnessZ_type&
      YAxisStraightnessZ ();

      void
      YAxisStraightnessZ (const YAxisStraightnessZ_type& x);

      void
      YAxisStraightnessZ (::std::auto_ptr< YAxisStraightnessZ_type > p);

      // ZAxisStraightnessX
      //
      typedef ::xsd::qif2::LengthFunctionDiscreteType ZAxisStraightnessX_type;
      typedef ::xsd::cxx::tree::traits< ZAxisStraightnessX_type, char > ZAxisStraightnessX_traits;

      const ZAxisStraightnessX_type&
      ZAxisStraightnessX () const;

      ZAxisStraightnessX_type&
      ZAxisStraightnessX ();

      void
      ZAxisStraightnessX (const ZAxisStraightnessX_type& x);

      void
      ZAxisStraightnessX (::std::auto_ptr< ZAxisStraightnessX_type > p);

      // ZAxisStraightnessY
      //
      typedef ::xsd::qif2::LengthFunctionDiscreteType ZAxisStraightnessY_type;
      typedef ::xsd::cxx::tree::traits< ZAxisStraightnessY_type, char > ZAxisStraightnessY_traits;

      const ZAxisStraightnessY_type&
      ZAxisStraightnessY () const;

      ZAxisStraightnessY_type&
      ZAxisStraightnessY ();

      void
      ZAxisStraightnessY (const ZAxisStraightnessY_type& x);

      void
      ZAxisStraightnessY (::std::auto_ptr< ZAxisStraightnessY_type > p);

      // XYSquareness
      //
      typedef ::xml_schema::double_ XYSquareness_type;
      typedef ::xsd::cxx::tree::traits< XYSquareness_type, char, ::xsd::cxx::tree::schema_type::double_ > XYSquareness_traits;

      const XYSquareness_type&
      XYSquareness () const;

      XYSquareness_type&
      XYSquareness ();

      void
      XYSquareness (const XYSquareness_type& x);

      // XZSquareness
      //
      typedef ::xml_schema::double_ XZSquareness_type;
      typedef ::xsd::cxx::tree::traits< XZSquareness_type, char, ::xsd::cxx::tree::schema_type::double_ > XZSquareness_traits;

      const XZSquareness_type&
      XZSquareness () const;

      XZSquareness_type&
      XZSquareness ();

      void
      XZSquareness (const XZSquareness_type& x);

      // YZSquareness
      //
      typedef ::xml_schema::double_ YZSquareness_type;
      typedef ::xsd::cxx::tree::traits< YZSquareness_type, char, ::xsd::cxx::tree::schema_type::double_ > YZSquareness_traits;

      const YZSquareness_type&
      YZSquareness () const;

      YZSquareness_type&
      YZSquareness ();

      void
      YZSquareness (const YZSquareness_type& x);

      // Constructors.
      //
      FPSTestType (const XLinearity_type&,
                   const YLinearity_type&,
                   const ZLinearity_type&,
                   const XAxisRoll_type&,
                   const XAxisPitch_type&,
                   const XAxisYaw_type&,
                   const YAxisRoll_type&,
                   const YAxisPitch_type&,
                   const YAxisYaw_type&,
                   const ZAxisRoll_type&,
                   const ZAxisPitch_type&,
                   const ZAxisYaw_type&,
                   const XAxisStraightnessY_type&,
                   const XAxisStraightnessZ_type&,
                   const YAxisStraightnessX_type&,
                   const YAxisStraightnessZ_type&,
                   const ZAxisStraightnessX_type&,
                   const ZAxisStraightnessY_type&,
                   const XYSquareness_type&,
                   const XZSquareness_type&,
                   const YZSquareness_type&);

      FPSTestType (::std::auto_ptr< XLinearity_type >,
                   ::std::auto_ptr< YLinearity_type >,
                   ::std::auto_ptr< ZLinearity_type >,
                   ::std::auto_ptr< XAxisRoll_type >,
                   ::std::auto_ptr< XAxisPitch_type >,
                   ::std::auto_ptr< XAxisYaw_type >,
                   ::std::auto_ptr< YAxisRoll_type >,
                   ::std::auto_ptr< YAxisPitch_type >,
                   ::std::auto_ptr< YAxisYaw_type >,
                   ::std::auto_ptr< ZAxisRoll_type >,
                   ::std::auto_ptr< ZAxisPitch_type >,
                   ::std::auto_ptr< ZAxisYaw_type >,
                   ::std::auto_ptr< XAxisStraightnessY_type >,
                   ::std::auto_ptr< XAxisStraightnessZ_type >,
                   ::std::auto_ptr< YAxisStraightnessX_type >,
                   ::std::auto_ptr< YAxisStraightnessZ_type >,
                   ::std::auto_ptr< ZAxisStraightnessX_type >,
                   ::std::auto_ptr< ZAxisStraightnessY_type >,
                   const XYSquareness_type&,
                   const XZSquareness_type&,
                   const YZSquareness_type&);

      FPSTestType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      FPSTestType (const FPSTestType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual FPSTestType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FPSTestType&
      operator= (const FPSTestType& x);

      virtual 
      ~FPSTestType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< XLinearity_type > XLinearity_;
      ::xsd::cxx::tree::one< YLinearity_type > YLinearity_;
      ::xsd::cxx::tree::one< ZLinearity_type > ZLinearity_;
      ::xsd::cxx::tree::one< XAxisRoll_type > XAxisRoll_;
      ::xsd::cxx::tree::one< XAxisPitch_type > XAxisPitch_;
      ::xsd::cxx::tree::one< XAxisYaw_type > XAxisYaw_;
      ::xsd::cxx::tree::one< YAxisRoll_type > YAxisRoll_;
      ::xsd::cxx::tree::one< YAxisPitch_type > YAxisPitch_;
      ::xsd::cxx::tree::one< YAxisYaw_type > YAxisYaw_;
      ::xsd::cxx::tree::one< ZAxisRoll_type > ZAxisRoll_;
      ::xsd::cxx::tree::one< ZAxisPitch_type > ZAxisPitch_;
      ::xsd::cxx::tree::one< ZAxisYaw_type > ZAxisYaw_;
      ::xsd::cxx::tree::one< XAxisStraightnessY_type > XAxisStraightnessY_;
      ::xsd::cxx::tree::one< XAxisStraightnessZ_type > XAxisStraightnessZ_;
      ::xsd::cxx::tree::one< YAxisStraightnessX_type > YAxisStraightnessX_;
      ::xsd::cxx::tree::one< YAxisStraightnessZ_type > YAxisStraightnessZ_;
      ::xsd::cxx::tree::one< ZAxisStraightnessX_type > ZAxisStraightnessX_;
      ::xsd::cxx::tree::one< ZAxisStraightnessY_type > ZAxisStraightnessY_;
      ::xsd::cxx::tree::one< XYSquareness_type > XYSquareness_;
      ::xsd::cxx::tree::one< XZSquareness_type > XZSquareness_;
      ::xsd::cxx::tree::one< YZSquareness_type > YZSquareness_;
    };

    class FunctionDiscreteType: public ::xml_schema::type
    {
      public:
      // DomainValues
      //
      typedef ::xsd::qif2::ListDoubleType DomainValues_type;
      typedef ::xsd::cxx::tree::traits< DomainValues_type, char > DomainValues_traits;

      const DomainValues_type&
      DomainValues () const;

      DomainValues_type&
      DomainValues ();

      void
      DomainValues (const DomainValues_type& x);

      void
      DomainValues (::std::auto_ptr< DomainValues_type > p);

      // RangeValues
      //
      typedef ::xsd::qif2::ListDoubleType RangeValues_type;
      typedef ::xsd::cxx::tree::traits< RangeValues_type, char > RangeValues_traits;

      const RangeValues_type&
      RangeValues () const;

      RangeValues_type&
      RangeValues ();

      void
      RangeValues (const RangeValues_type& x);

      void
      RangeValues (::std::auto_ptr< RangeValues_type > p);

      // N
      //
      typedef ::xsd::qif2::NaturalType N_type;
      typedef ::xsd::cxx::tree::traits< N_type, char > N_traits;

      const N_type&
      N () const;

      N_type&
      N ();

      void
      N (const N_type& x);

      void
      N (::std::auto_ptr< N_type > p);

      // Constructors.
      //
      FunctionDiscreteType (const DomainValues_type&,
                            const RangeValues_type&,
                            const N_type&);

      FunctionDiscreteType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      FunctionDiscreteType (const FunctionDiscreteType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual FunctionDiscreteType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FunctionDiscreteType&
      operator= (const FunctionDiscreteType& x);

      virtual 
      ~FunctionDiscreteType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DomainValues_type > DomainValues_;
      ::xsd::cxx::tree::one< RangeValues_type > RangeValues_;
      ::xsd::cxx::tree::one< N_type > N_;
    };

    class LengthFunctionDiscreteType: public ::xsd::qif2::FunctionDiscreteType
    {
      public:
      // DomainLinearUnit
      //
      typedef ::xml_schema::token DomainLinearUnit_type;
      typedef ::xsd::cxx::tree::traits< DomainLinearUnit_type, char > DomainLinearUnit_traits;

      const DomainLinearUnit_type&
      DomainLinearUnit () const;

      DomainLinearUnit_type&
      DomainLinearUnit ();

      void
      DomainLinearUnit (const DomainLinearUnit_type& x);

      void
      DomainLinearUnit (::std::auto_ptr< DomainLinearUnit_type > p);

      // RangeLinearUnit
      //
      typedef ::xml_schema::token RangeLinearUnit_type;
      typedef ::xsd::cxx::tree::traits< RangeLinearUnit_type, char > RangeLinearUnit_traits;

      const RangeLinearUnit_type&
      RangeLinearUnit () const;

      RangeLinearUnit_type&
      RangeLinearUnit ();

      void
      RangeLinearUnit (const RangeLinearUnit_type& x);

      void
      RangeLinearUnit (::std::auto_ptr< RangeLinearUnit_type > p);

      // Constructors.
      //
      LengthFunctionDiscreteType (const DomainValues_type&,
                                  const RangeValues_type&,
                                  const N_type&,
                                  const DomainLinearUnit_type&,
                                  const RangeLinearUnit_type&);

      LengthFunctionDiscreteType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      LengthFunctionDiscreteType (const LengthFunctionDiscreteType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual LengthFunctionDiscreteType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LengthFunctionDiscreteType&
      operator= (const LengthFunctionDiscreteType& x);

      virtual 
      ~LengthFunctionDiscreteType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DomainLinearUnit_type > DomainLinearUnit_;
      ::xsd::cxx::tree::one< RangeLinearUnit_type > RangeLinearUnit_;
    };

    class AngleFunctionDiscreteType: public ::xsd::qif2::FunctionDiscreteType
    {
      public:
      // DomainLinearUnit
      //
      typedef ::xml_schema::token DomainLinearUnit_type;
      typedef ::xsd::cxx::tree::traits< DomainLinearUnit_type, char > DomainLinearUnit_traits;

      const DomainLinearUnit_type&
      DomainLinearUnit () const;

      DomainLinearUnit_type&
      DomainLinearUnit ();

      void
      DomainLinearUnit (const DomainLinearUnit_type& x);

      void
      DomainLinearUnit (::std::auto_ptr< DomainLinearUnit_type > p);

      // RangeAngularUnit
      //
      typedef ::xml_schema::token RangeAngularUnit_type;
      typedef ::xsd::cxx::tree::traits< RangeAngularUnit_type, char > RangeAngularUnit_traits;

      const RangeAngularUnit_type&
      RangeAngularUnit () const;

      RangeAngularUnit_type&
      RangeAngularUnit ();

      void
      RangeAngularUnit (const RangeAngularUnit_type& x);

      void
      RangeAngularUnit (::std::auto_ptr< RangeAngularUnit_type > p);

      // Constructors.
      //
      AngleFunctionDiscreteType (const DomainValues_type&,
                                 const RangeValues_type&,
                                 const N_type&,
                                 const DomainLinearUnit_type&,
                                 const RangeAngularUnit_type&);

      AngleFunctionDiscreteType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      AngleFunctionDiscreteType (const AngleFunctionDiscreteType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual AngleFunctionDiscreteType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AngleFunctionDiscreteType&
      operator= (const AngleFunctionDiscreteType& x);

      virtual 
      ~AngleFunctionDiscreteType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< DomainLinearUnit_type > DomainLinearUnit_;
      ::xsd::cxx::tree::one< RangeAngularUnit_type > RangeAngularUnit_;
    };

    class B89TestType: public ::xsd::qif2::CMMAccuracyTestBaseType
    {
      public:
      // XLinearAccuracy
      //
      typedef ::xsd::qif2::LinearValueType XLinearAccuracy_type;
      typedef ::xsd::cxx::tree::traits< XLinearAccuracy_type, char > XLinearAccuracy_traits;

      const XLinearAccuracy_type&
      XLinearAccuracy () const;

      XLinearAccuracy_type&
      XLinearAccuracy ();

      void
      XLinearAccuracy (const XLinearAccuracy_type& x);

      void
      XLinearAccuracy (::std::auto_ptr< XLinearAccuracy_type > p);

      // YLinearAccuracy
      //
      typedef ::xsd::qif2::LinearValueType YLinearAccuracy_type;
      typedef ::xsd::cxx::tree::traits< YLinearAccuracy_type, char > YLinearAccuracy_traits;

      const YLinearAccuracy_type&
      YLinearAccuracy () const;

      YLinearAccuracy_type&
      YLinearAccuracy ();

      void
      YLinearAccuracy (const YLinearAccuracy_type& x);

      void
      YLinearAccuracy (::std::auto_ptr< YLinearAccuracy_type > p);

      // ZLinearAccuracy
      //
      typedef ::xsd::qif2::LinearValueType ZLinearAccuracy_type;
      typedef ::xsd::cxx::tree::traits< ZLinearAccuracy_type, char > ZLinearAccuracy_traits;

      const ZLinearAccuracy_type&
      ZLinearAccuracy () const;

      ZLinearAccuracy_type&
      ZLinearAccuracy ();

      void
      ZLinearAccuracy (const ZLinearAccuracy_type& x);

      void
      ZLinearAccuracy (::std::auto_ptr< ZLinearAccuracy_type > p);

      // OffsetVolumetricPerformance
      //
      typedef ::xsd::qif2::LinearValueType OffsetVolumetricPerformance_type;
      typedef ::xsd::cxx::tree::traits< OffsetVolumetricPerformance_type, char > OffsetVolumetricPerformance_traits;

      const OffsetVolumetricPerformance_type&
      OffsetVolumetricPerformance () const;

      OffsetVolumetricPerformance_type&
      OffsetVolumetricPerformance ();

      void
      OffsetVolumetricPerformance (const OffsetVolumetricPerformance_type& x);

      void
      OffsetVolumetricPerformance (::std::auto_ptr< OffsetVolumetricPerformance_type > p);

      // VolumetricPerformance
      //
      typedef ::xsd::qif2::LinearValueType VolumetricPerformance_type;
      typedef ::xsd::cxx::tree::traits< VolumetricPerformance_type, char > VolumetricPerformance_traits;

      const VolumetricPerformance_type&
      VolumetricPerformance () const;

      VolumetricPerformance_type&
      VolumetricPerformance ();

      void
      VolumetricPerformance (const VolumetricPerformance_type& x);

      void
      VolumetricPerformance (::std::auto_ptr< VolumetricPerformance_type > p);

      // Repeatability
      //
      typedef ::xsd::qif2::LinearValueType Repeatability_type;
      typedef ::xsd::cxx::tree::traits< Repeatability_type, char > Repeatability_traits;

      const Repeatability_type&
      Repeatability () const;

      Repeatability_type&
      Repeatability ();

      void
      Repeatability (const Repeatability_type& x);

      void
      Repeatability (::std::auto_ptr< Repeatability_type > p);

      // Constructors.
      //
      B89TestType (const XLinearAccuracy_type&,
                   const YLinearAccuracy_type&,
                   const ZLinearAccuracy_type&,
                   const OffsetVolumetricPerformance_type&,
                   const VolumetricPerformance_type&,
                   const Repeatability_type&);

      B89TestType (::std::auto_ptr< XLinearAccuracy_type >,
                   ::std::auto_ptr< YLinearAccuracy_type >,
                   ::std::auto_ptr< ZLinearAccuracy_type >,
                   ::std::auto_ptr< OffsetVolumetricPerformance_type >,
                   ::std::auto_ptr< VolumetricPerformance_type >,
                   ::std::auto_ptr< Repeatability_type >);

      B89TestType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      B89TestType (const B89TestType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual B89TestType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      B89TestType&
      operator= (const B89TestType& x);

      virtual 
      ~B89TestType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< XLinearAccuracy_type > XLinearAccuracy_;
      ::xsd::cxx::tree::one< YLinearAccuracy_type > YLinearAccuracy_;
      ::xsd::cxx::tree::one< ZLinearAccuracy_type > ZLinearAccuracy_;
      ::xsd::cxx::tree::one< OffsetVolumetricPerformance_type > OffsetVolumetricPerformance_;
      ::xsd::cxx::tree::one< VolumetricPerformance_type > VolumetricPerformance_;
      ::xsd::cxx::tree::one< Repeatability_type > Repeatability_;
    };

    class ISO10360TestType: public ::xsd::qif2::CMMAccuracyTestBaseType
    {
      public:
      // MaxErrorConstant
      //
      typedef ::xsd::qif2::LinearValueType MaxErrorConstant_type;
      typedef ::xsd::cxx::tree::optional< MaxErrorConstant_type > MaxErrorConstant_optional;
      typedef ::xsd::cxx::tree::traits< MaxErrorConstant_type, char > MaxErrorConstant_traits;

      const MaxErrorConstant_optional&
      MaxErrorConstant () const;

      MaxErrorConstant_optional&
      MaxErrorConstant ();

      void
      MaxErrorConstant (const MaxErrorConstant_type& x);

      void
      MaxErrorConstant (const MaxErrorConstant_optional& x);

      void
      MaxErrorConstant (::std::auto_ptr< MaxErrorConstant_type > p);

      // LinearError
      //
      typedef ::xsd::qif2::LinearErrorType LinearError_type;
      typedef ::xsd::cxx::tree::optional< LinearError_type > LinearError_optional;
      typedef ::xsd::cxx::tree::traits< LinearError_type, char > LinearError_traits;

      const LinearError_optional&
      LinearError () const;

      LinearError_optional&
      LinearError ();

      void
      LinearError (const LinearError_type& x);

      void
      LinearError (const LinearError_optional& x);

      void
      LinearError (::std::auto_ptr< LinearError_type > p);

      // LesserError
      //
      typedef ::xsd::qif2::LesserErrorType LesserError_type;
      typedef ::xsd::cxx::tree::optional< LesserError_type > LesserError_optional;
      typedef ::xsd::cxx::tree::traits< LesserError_type, char > LesserError_traits;

      const LesserError_optional&
      LesserError () const;

      LesserError_optional&
      LesserError ();

      void
      LesserError (const LesserError_type& x);

      void
      LesserError (const LesserError_optional& x);

      void
      LesserError (::std::auto_ptr< LesserError_type > p);

      // Constructors.
      //
      ISO10360TestType ();

      ISO10360TestType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      ISO10360TestType (const ISO10360TestType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual ISO10360TestType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ISO10360TestType&
      operator= (const ISO10360TestType& x);

      virtual 
      ~ISO10360TestType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      MaxErrorConstant_optional MaxErrorConstant_;
      LinearError_optional LinearError_;
      LesserError_optional LesserError_;
    };

    class LinearErrorType: public ::xml_schema::type
    {
      public:
      // BaseError
      //
      typedef ::xsd::qif2::LinearValueType BaseError_type;
      typedef ::xsd::cxx::tree::traits< BaseError_type, char > BaseError_traits;

      const BaseError_type&
      BaseError () const;

      BaseError_type&
      BaseError ();

      void
      BaseError (const BaseError_type& x);

      void
      BaseError (::std::auto_ptr< BaseError_type > p);

      // ErrorRate
      //
      typedef ::xml_schema::decimal ErrorRate_type;
      typedef ::xsd::cxx::tree::traits< ErrorRate_type, char, ::xsd::cxx::tree::schema_type::decimal > ErrorRate_traits;

      const ErrorRate_type&
      ErrorRate () const;

      ErrorRate_type&
      ErrorRate ();

      void
      ErrorRate (const ErrorRate_type& x);

      // Constructors.
      //
      LinearErrorType (const BaseError_type&,
                       const ErrorRate_type&);

      LinearErrorType (::std::auto_ptr< BaseError_type >,
                       const ErrorRate_type&);

      LinearErrorType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      LinearErrorType (const LinearErrorType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual LinearErrorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinearErrorType&
      operator= (const LinearErrorType& x);

      virtual 
      ~LinearErrorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< BaseError_type > BaseError_;
      ::xsd::cxx::tree::one< ErrorRate_type > ErrorRate_;
    };

    class LesserErrorType: public ::xml_schema::type
    {
      public:
      // MaxErrorConstant
      //
      typedef ::xsd::qif2::LinearValueType MaxErrorConstant_type;
      typedef ::xsd::cxx::tree::traits< MaxErrorConstant_type, char > MaxErrorConstant_traits;

      const MaxErrorConstant_type&
      MaxErrorConstant () const;

      MaxErrorConstant_type&
      MaxErrorConstant ();

      void
      MaxErrorConstant (const MaxErrorConstant_type& x);

      void
      MaxErrorConstant (::std::auto_ptr< MaxErrorConstant_type > p);

      // LinearError
      //
      typedef ::xsd::qif2::LinearErrorType LinearError_type;
      typedef ::xsd::cxx::tree::traits< LinearError_type, char > LinearError_traits;

      const LinearError_type&
      LinearError () const;

      LinearError_type&
      LinearError ();

      void
      LinearError (const LinearError_type& x);

      void
      LinearError (::std::auto_ptr< LinearError_type > p);

      // Constructors.
      //
      LesserErrorType (const MaxErrorConstant_type&,
                       const LinearError_type&);

      LesserErrorType (::std::auto_ptr< MaxErrorConstant_type >,
                       ::std::auto_ptr< LinearError_type >);

      LesserErrorType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      LesserErrorType (const LesserErrorType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual LesserErrorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LesserErrorType&
      operator= (const LesserErrorType& x);

      virtual 
      ~LesserErrorType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< MaxErrorConstant_type > MaxErrorConstant_;
      ::xsd::cxx::tree::one< LinearError_type > LinearError_;
    };

    class PointAccuracyTestType: public ::xsd::qif2::CMMAccuracyTestBaseType
    {
      public:
      // Accuracy
      //
      typedef ::xsd::qif2::LinearValueType Accuracy_type;
      typedef ::xsd::cxx::tree::traits< Accuracy_type, char > Accuracy_traits;

      const Accuracy_type&
      Accuracy () const;

      Accuracy_type&
      Accuracy ();

      void
      Accuracy (const Accuracy_type& x);

      void
      Accuracy (::std::auto_ptr< Accuracy_type > p);

      // Constructors.
      //
      PointAccuracyTestType (const Accuracy_type&);

      PointAccuracyTestType (::std::auto_ptr< Accuracy_type >);

      PointAccuracyTestType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      PointAccuracyTestType (const PointAccuracyTestType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual PointAccuracyTestType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointAccuracyTestType&
      operator= (const PointAccuracyTestType& x);

      virtual 
      ~PointAccuracyTestType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Accuracy_type > Accuracy_;
    };

    class CMMAccuracyType: public ::xsd::qif2::MeasurementDeviceAccuracyBaseType
    {
      public:
      // MinTemperature
      //
      typedef ::xsd::qif2::TemperatureValueType MinTemperature_type;
      typedef ::xsd::cxx::tree::traits< MinTemperature_type, char > MinTemperature_traits;

      const MinTemperature_type&
      MinTemperature () const;

      MinTemperature_type&
      MinTemperature ();

      void
      MinTemperature (const MinTemperature_type& x);

      void
      MinTemperature (::std::auto_ptr< MinTemperature_type > p);

      // MaxTemperature
      //
      typedef ::xsd::qif2::TemperatureValueType MaxTemperature_type;
      typedef ::xsd::cxx::tree::traits< MaxTemperature_type, char > MaxTemperature_traits;

      const MaxTemperature_type&
      MaxTemperature () const;

      MaxTemperature_type&
      MaxTemperature ();

      void
      MaxTemperature (const MaxTemperature_type& x);

      void
      MaxTemperature (::std::auto_ptr< MaxTemperature_type > p);

      // CMMAccuracyTest
      //
      typedef ::xsd::qif2::CMMAccuracyTestBaseType CMMAccuracyTest_type;
      typedef ::xsd::cxx::tree::traits< CMMAccuracyTest_type, char > CMMAccuracyTest_traits;

      const CMMAccuracyTest_type&
      CMMAccuracyTest () const;

      CMMAccuracyTest_type&
      CMMAccuracyTest ();

      void
      CMMAccuracyTest (const CMMAccuracyTest_type& x);

      void
      CMMAccuracyTest (::std::auto_ptr< CMMAccuracyTest_type > p);

      // Constructors.
      //
      CMMAccuracyType (const MinTemperature_type&,
                       const MaxTemperature_type&,
                       const CMMAccuracyTest_type&);

      CMMAccuracyType (::std::auto_ptr< MinTemperature_type >,
                       ::std::auto_ptr< MaxTemperature_type >,
                       const CMMAccuracyTest_type&);

      CMMAccuracyType (const MinTemperature_type&,
                       const MaxTemperature_type&,
                       ::std::auto_ptr< CMMAccuracyTest_type >);

      CMMAccuracyType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      CMMAccuracyType (const CMMAccuracyType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual CMMAccuracyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CMMAccuracyType&
      operator= (const CMMAccuracyType& x);

      virtual 
      ~CMMAccuracyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< MinTemperature_type > MinTemperature_;
      ::xsd::cxx::tree::one< MaxTemperature_type > MaxTemperature_;
      ::xsd::cxx::tree::one< CMMAccuracyTest_type > CMMAccuracyTest_;
    };

    class ComparatorType: public ::xsd::qif2::ProbingDeviceType
    {
      public:
      // Constructors.
      //
      ComparatorType (const Name_type&,
                      const id_type&);

      ComparatorType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ComparatorType (const ComparatorType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual ComparatorType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ComparatorType ();
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace xsd
{
  namespace qif2
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace xsd
{
  namespace qif2
  {
    void
    operator<< (::xercesc::DOMElement&, const MeasurementResourcesType&);

    void
    operator<< (::xercesc::DOMElement&, const CarriagesType&);

    void
    operator<< (::xercesc::DOMElement&, const FixturesType&);

    void
    operator<< (::xercesc::DOMElement&, const SensorsType&);

    void
    operator<< (::xercesc::DOMElement&, const ToolsType&);

    void
    operator<< (::xercesc::DOMElement&, const MeasurementDevicesType&);

    void
    operator<< (::xercesc::DOMElement&, const MeasurementResourceBaseType&);

    void
    operator<< (::xercesc::DOMElement&, const FixtureType&);

    void
    operator<< (::xercesc::DOMElement&, const MeasurementDeviceAccuracyBaseType&);

    void
    operator<< (::xercesc::DOMAttr&, const MeasurementDeviceAccuracyBaseType&);

    void
    operator<< (::xml_schema::list_stream&,
                const MeasurementDeviceAccuracyBaseType&);

    void
    operator<< (::xercesc::DOMElement&, const NumericalLengthAccuracyType&);

    void
    operator<< (::xercesc::DOMElement&, const MeasurementDeviceType&);

    void
    operator<< (::xercesc::DOMElement&, const CalibrationMasterType&);

    void
    operator<< (::xercesc::DOMElement&, const CalibrationType&);

    void
    operator<< (::xercesc::DOMElement&, const CalibrationsType&);

    void
    operator<< (::xercesc::DOMElement&, const TemperaturesType&);

    void
    operator<< (::xercesc::DOMElement&, const TemperatureType&);

    void
    operator<< (::xercesc::DOMElement&, const QualificationsType&);

    void
    operator<< (::xercesc::DOMElement&, const QualificationType&);

    void
    operator<< (::xercesc::DOMElement&, const SensorType&);

    void
    operator<< (::xercesc::DOMElement&, const TouchProbeType&);

    void
    operator<< (::xercesc::DOMElement&, const ToolType&);

    void
    operator<< (::xercesc::DOMElement&, const CarriageType&);

    void
    operator<< (::xercesc::DOMElement&, const ProbingDeviceType&);

    void
    operator<< (::xercesc::DOMElement&, const CMMType&);

    void
    operator<< (::xercesc::DOMElement&, const CMMScalesType&);

    void
    operator<< (::xercesc::DOMElement&, const CMMScaleType&);

    void
    operator<< (::xercesc::DOMElement&, const CMMSpeedsType&);

    void
    operator<< (::xercesc::DOMElement&, const GageDeviceType&);

    void
    operator<< (::xercesc::DOMElement&, const ManualDeviceType&);

    void
    operator<< (::xercesc::DOMElement&, const CaliperType&);

    void
    operator<< (::xercesc::DOMElement&, const CMMDirectionEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const CMMDirectionEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const CMMDirectionEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const CMMGeometryType&);

    void
    operator<< (::xercesc::DOMElement&, const CMMGeometryEnumType&);

    void
    operator<< (::xercesc::DOMAttr&, const CMMGeometryEnumType&);

    void
    operator<< (::xml_schema::list_stream&,
                const CMMGeometryEnumType&);

    void
    operator<< (::xercesc::DOMElement&, const CMMAxisDirectionsType&);

    void
    operator<< (::xercesc::DOMElement&, const WorkingVolumeType&);

    void
    operator<< (::xercesc::DOMElement&, const EffectiveWorkingVolumeType&);

    void
    operator<< (::xercesc::DOMElement&, const RotaryTableType&);

    void
    operator<< (::xercesc::DOMElement&, const TableErrorsType&);

    void
    operator<< (::xercesc::DOMElement&, const ResolutionType&);

    void
    operator<< (::xercesc::DOMElement&, const XYZResolutionType&);

    void
    operator<< (::xercesc::DOMElement&, const CMMAccuracyTestBaseType&);

    void
    operator<< (::xercesc::DOMAttr&, const CMMAccuracyTestBaseType&);

    void
    operator<< (::xml_schema::list_stream&,
                const CMMAccuracyTestBaseType&);

    void
    operator<< (::xercesc::DOMElement&, const FPSTestType&);

    void
    operator<< (::xercesc::DOMElement&, const FunctionDiscreteType&);

    void
    operator<< (::xercesc::DOMElement&, const LengthFunctionDiscreteType&);

    void
    operator<< (::xercesc::DOMElement&, const AngleFunctionDiscreteType&);

    void
    operator<< (::xercesc::DOMElement&, const B89TestType&);

    void
    operator<< (::xercesc::DOMElement&, const ISO10360TestType&);

    void
    operator<< (::xercesc::DOMElement&, const LinearErrorType&);

    void
    operator<< (::xercesc::DOMElement&, const LesserErrorType&);

    void
    operator<< (::xercesc::DOMElement&, const PointAccuracyTestType&);

    void
    operator<< (::xercesc::DOMElement&, const CMMAccuracyType&);

    void
    operator<< (::xercesc::DOMElement&, const ComparatorType&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // QIFMEASUREMENT_RESOURCES_HXX
