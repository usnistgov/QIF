// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef QIFRULES_HXX
#define QIFRULES_HXX

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< char > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< char > not_derived;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace xsd
{
  namespace qif2
  {
    class QIFRulesType;
    class FeatureRulesType;
    class QIFRuleBaseType;
    class IfThenElseFeatureRulesType;
    class MaxFeatureRulesType;
    class DMESelectionRulesType;
    class PointRuleBaseType;
    class IfThenFeatureRuleType;
    class ElseRuleType;
    class ThenPointsType;
    class IfThenArcRuleType;
    class ArcPointSamplingStrategyType;
    class IfThenCircleRuleType;
    class CirclePointSamplingStrategyType;
    class IfThenConeRuleType;
    class ConePointSamplingStrategyType;
    class IfThenConicalSegmentRuleType;
    class ConicalSegmentPointSamplingStrategyType;
    class IfThenCuboidRuleType;
    class CuboidPointSamplingStrategyType;
    class IfThenCylinderRuleType;
    class CylinderPointSamplingStrategyType;
    class IfThenCylindricalSegmentRuleType;
    class CylindricalSegmentPointSamplingStrategyType;
    class IfThenEllipseRuleType;
    class EllipsePointSamplingStrategyType;
    class IfThenElongatedCylinderRuleType;
    class ElongatedCylinderPointSamplingStrategyType;
    class IfThenExtrudedCrossSectionRuleType;
    class ExtrudedCrossSectionPointSamplingStrategyType;
    class IfThenLineRuleType;
    class LinePointSamplingStrategyType;
    class IfThenOppositeLinesRuleType;
    class OppositeLinesPointSamplingStrategyType;
    class IfThenOppositePlanesRuleType;
    class OppositePlanesPointSamplingStrategyType;
    class IfThenPlaneRuleType;
    class PlanePointSamplingStrategyType;
    class IfThenPointDefinedCurveRuleType;
    class PointDefinedCurvePointSamplingStrategyType;
    class IfThenPointDefinedSurfaceRuleType;
    class PointDefinedSurfacePointSamplingStrategyType;
    class IfThenPointRuleType;
    class PointPointSamplingStrategyType;
    class IfThenSphereRuleType;
    class SpherePointSamplingStrategyType;
    class IfThenSphericalSegmentRuleType;
    class SphericalSegmentPointSamplingStrategyType;
    class IfThenSurfaceOfRevolutionRuleType;
    class SurfaceOfRevolutionPointSamplingStrategyType;
    class IfThenToroidalSegmentRuleType;
    class ToroidalSegmentPointSamplingStrategyType;
    class IfThenTorusRuleType;
    class TorusPointSamplingStrategyType;
    class IfThenSurfaceRuleType;
    class IfThenCurveRuleType;
    class DMESelectionRuleType;
  }
}


#include <memory>    // ::std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "../QIFLibrary/Expressions.hxx"

#include "../QIFLibrary/IntermediatesPMI.hxx"

namespace xsd
{
  namespace qif2
  {
    class QIFRulesType: public ::xml_schema::type
    {
      public:
      // Version
      //
      typedef ::xsd::qif2::VersionType Version_type;
      typedef ::xsd::cxx::tree::optional< Version_type > Version_optional;
      typedef ::xsd::cxx::tree::traits< Version_type, char > Version_traits;

      const Version_optional&
      Version () const;

      Version_optional&
      Version ();

      void
      Version (const Version_type& x);

      void
      Version (const Version_optional& x);

      void
      Version (::std::auto_ptr< Version_type > p);

      // RulesUnits
      //
      typedef ::xsd::qif2::OtherUnitsType RulesUnits_type;
      typedef ::xsd::cxx::tree::optional< RulesUnits_type > RulesUnits_optional;
      typedef ::xsd::cxx::tree::traits< RulesUnits_type, char > RulesUnits_traits;

      const RulesUnits_optional&
      RulesUnits () const;

      RulesUnits_optional&
      RulesUnits ();

      void
      RulesUnits (const RulesUnits_type& x);

      void
      RulesUnits (const RulesUnits_optional& x);

      void
      RulesUnits (::std::auto_ptr< RulesUnits_type > p);

      // FeatureRules
      //
      typedef ::xsd::qif2::FeatureRulesType FeatureRules_type;
      typedef ::xsd::cxx::tree::optional< FeatureRules_type > FeatureRules_optional;
      typedef ::xsd::cxx::tree::traits< FeatureRules_type, char > FeatureRules_traits;

      const FeatureRules_optional&
      FeatureRules () const;

      FeatureRules_optional&
      FeatureRules ();

      void
      FeatureRules (const FeatureRules_type& x);

      void
      FeatureRules (const FeatureRules_optional& x);

      void
      FeatureRules (::std::auto_ptr< FeatureRules_type > p);

      // DMESelectionRules
      //
      typedef ::xsd::qif2::DMESelectionRulesType DMESelectionRules_type;
      typedef ::xsd::cxx::tree::optional< DMESelectionRules_type > DMESelectionRules_optional;
      typedef ::xsd::cxx::tree::traits< DMESelectionRules_type, char > DMESelectionRules_traits;

      const DMESelectionRules_optional&
      DMESelectionRules () const;

      DMESelectionRules_optional&
      DMESelectionRules ();

      void
      DMESelectionRules (const DMESelectionRules_type& x);

      void
      DMESelectionRules (const DMESelectionRules_optional& x);

      void
      DMESelectionRules (::std::auto_ptr< DMESelectionRules_type > p);

      // Constructors.
      //
      QIFRulesType ();

      QIFRulesType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      QIFRulesType (const QIFRulesType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual QIFRulesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      QIFRulesType&
      operator= (const QIFRulesType& x);

      virtual 
      ~QIFRulesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Version_optional Version_;
      RulesUnits_optional RulesUnits_;
      FeatureRules_optional FeatureRules_;
      DMESelectionRules_optional DMESelectionRules_;
    };

    class FeatureRulesType: public ::xml_schema::type
    {
      public:
      // SamplingRigorMax
      //
      typedef ::xml_schema::unsigned_int SamplingRigorMax_type;
      typedef ::xsd::cxx::tree::traits< SamplingRigorMax_type, char > SamplingRigorMax_traits;

      const SamplingRigorMax_type&
      SamplingRigorMax () const;

      SamplingRigorMax_type&
      SamplingRigorMax ();

      void
      SamplingRigorMax (const SamplingRigorMax_type& x);

      // IfThenElseFeatureRules
      //
      typedef ::xsd::qif2::IfThenElseFeatureRulesType IfThenElseFeatureRules_type;
      typedef ::xsd::cxx::tree::optional< IfThenElseFeatureRules_type > IfThenElseFeatureRules_optional;
      typedef ::xsd::cxx::tree::traits< IfThenElseFeatureRules_type, char > IfThenElseFeatureRules_traits;

      const IfThenElseFeatureRules_optional&
      IfThenElseFeatureRules () const;

      IfThenElseFeatureRules_optional&
      IfThenElseFeatureRules ();

      void
      IfThenElseFeatureRules (const IfThenElseFeatureRules_type& x);

      void
      IfThenElseFeatureRules (const IfThenElseFeatureRules_optional& x);

      void
      IfThenElseFeatureRules (::std::auto_ptr< IfThenElseFeatureRules_type > p);

      // MaxFeatureRules
      //
      typedef ::xsd::qif2::MaxFeatureRulesType MaxFeatureRules_type;
      typedef ::xsd::cxx::tree::optional< MaxFeatureRules_type > MaxFeatureRules_optional;
      typedef ::xsd::cxx::tree::traits< MaxFeatureRules_type, char > MaxFeatureRules_traits;

      const MaxFeatureRules_optional&
      MaxFeatureRules () const;

      MaxFeatureRules_optional&
      MaxFeatureRules ();

      void
      MaxFeatureRules (const MaxFeatureRules_type& x);

      void
      MaxFeatureRules (const MaxFeatureRules_optional& x);

      void
      MaxFeatureRules (::std::auto_ptr< MaxFeatureRules_type > p);

      // Constructors.
      //
      FeatureRulesType (const SamplingRigorMax_type&);

      FeatureRulesType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      FeatureRulesType (const FeatureRulesType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual FeatureRulesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FeatureRulesType&
      operator= (const FeatureRulesType& x);

      virtual 
      ~FeatureRulesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< SamplingRigorMax_type > SamplingRigorMax_;
      IfThenElseFeatureRules_optional IfThenElseFeatureRules_;
      MaxFeatureRules_optional MaxFeatureRules_;
    };

    class QIFRuleBaseType: public ::xml_schema::type
    {
      public:
      // name
      //
      typedef ::xml_schema::token name_type;
      typedef ::xsd::cxx::tree::optional< name_type > name_optional;
      typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

      const name_optional&
      name () const;

      name_optional&
      name ();

      void
      name (const name_type& x);

      void
      name (const name_optional& x);

      void
      name (::std::auto_ptr< name_type > p);

      // Constructors.
      //
      QIFRuleBaseType ();

      QIFRuleBaseType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      QIFRuleBaseType (const QIFRuleBaseType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual QIFRuleBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      QIFRuleBaseType&
      operator= (const QIFRuleBaseType& x);

      virtual 
      ~QIFRuleBaseType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      name_optional name_;
    };

    class IfThenElseFeatureRulesType: public ::xml_schema::type
    {
      public:
      // IfThenFeatureRule
      //
      typedef ::xsd::qif2::IfThenFeatureRuleType IfThenFeatureRule_type;
      typedef ::xsd::cxx::tree::sequence< IfThenFeatureRule_type > IfThenFeatureRule_sequence;
      typedef IfThenFeatureRule_sequence::iterator IfThenFeatureRule_iterator;
      typedef IfThenFeatureRule_sequence::const_iterator IfThenFeatureRule_const_iterator;
      typedef ::xsd::cxx::tree::traits< IfThenFeatureRule_type, char > IfThenFeatureRule_traits;

      const IfThenFeatureRule_sequence&
      IfThenFeatureRule () const;

      IfThenFeatureRule_sequence&
      IfThenFeatureRule ();

      void
      IfThenFeatureRule (const IfThenFeatureRule_sequence& s);

      // Else
      //
      typedef ::xsd::qif2::ElseRuleType Else_type;
      typedef ::xsd::cxx::tree::optional< Else_type > Else_optional;
      typedef ::xsd::cxx::tree::traits< Else_type, char > Else_traits;

      const Else_optional&
      Else () const;

      Else_optional&
      Else ();

      void
      Else (const Else_type& x);

      void
      Else (const Else_optional& x);

      void
      Else (::std::auto_ptr< Else_type > p);

      // Constructors.
      //
      IfThenElseFeatureRulesType ();

      IfThenElseFeatureRulesType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      IfThenElseFeatureRulesType (const IfThenElseFeatureRulesType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual IfThenElseFeatureRulesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenElseFeatureRulesType&
      operator= (const IfThenElseFeatureRulesType& x);

      virtual 
      ~IfThenElseFeatureRulesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      IfThenFeatureRule_sequence IfThenFeatureRule_;
      Else_optional Else_;
    };

    class MaxFeatureRulesType: public ::xml_schema::type
    {
      public:
      // IfThenFeatureRule
      //
      typedef ::xsd::qif2::IfThenFeatureRuleType IfThenFeatureRule_type;
      typedef ::xsd::cxx::tree::sequence< IfThenFeatureRule_type > IfThenFeatureRule_sequence;
      typedef IfThenFeatureRule_sequence::iterator IfThenFeatureRule_iterator;
      typedef IfThenFeatureRule_sequence::const_iterator IfThenFeatureRule_const_iterator;
      typedef ::xsd::cxx::tree::traits< IfThenFeatureRule_type, char > IfThenFeatureRule_traits;

      const IfThenFeatureRule_sequence&
      IfThenFeatureRule () const;

      IfThenFeatureRule_sequence&
      IfThenFeatureRule ();

      void
      IfThenFeatureRule (const IfThenFeatureRule_sequence& s);

      // Else
      //
      typedef ::xsd::qif2::ElseRuleType Else_type;
      typedef ::xsd::cxx::tree::optional< Else_type > Else_optional;
      typedef ::xsd::cxx::tree::traits< Else_type, char > Else_traits;

      const Else_optional&
      Else () const;

      Else_optional&
      Else ();

      void
      Else (const Else_type& x);

      void
      Else (const Else_optional& x);

      void
      Else (::std::auto_ptr< Else_type > p);

      // Constructors.
      //
      MaxFeatureRulesType ();

      MaxFeatureRulesType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      MaxFeatureRulesType (const MaxFeatureRulesType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual MaxFeatureRulesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MaxFeatureRulesType&
      operator= (const MaxFeatureRulesType& x);

      virtual 
      ~MaxFeatureRulesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      IfThenFeatureRule_sequence IfThenFeatureRule_;
      Else_optional Else_;
    };

    class DMESelectionRulesType: public ::xml_schema::type
    {
      public:
      // DMESelectionRule
      //
      typedef ::xsd::qif2::DMESelectionRuleType DMESelectionRule_type;
      typedef ::xsd::cxx::tree::sequence< DMESelectionRule_type > DMESelectionRule_sequence;
      typedef DMESelectionRule_sequence::iterator DMESelectionRule_iterator;
      typedef DMESelectionRule_sequence::const_iterator DMESelectionRule_const_iterator;
      typedef ::xsd::cxx::tree::traits< DMESelectionRule_type, char > DMESelectionRule_traits;

      const DMESelectionRule_sequence&
      DMESelectionRule () const;

      DMESelectionRule_sequence&
      DMESelectionRule ();

      void
      DMESelectionRule (const DMESelectionRule_sequence& s);

      // Constructors.
      //
      DMESelectionRulesType ();

      DMESelectionRulesType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      DMESelectionRulesType (const DMESelectionRulesType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual DMESelectionRulesType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DMESelectionRulesType&
      operator= (const DMESelectionRulesType& x);

      virtual 
      ~DMESelectionRulesType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      DMESelectionRule_sequence DMESelectionRule_;
    };

    class PointRuleBaseType: public ::xsd::qif2::QIFRuleBaseType
    {
      public:
      // Constructors.
      //
      PointRuleBaseType ();

      PointRuleBaseType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      PointRuleBaseType (const PointRuleBaseType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual PointRuleBaseType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~PointRuleBaseType ();
    };

    class IfThenFeatureRuleType: public ::xsd::qif2::PointRuleBaseType
    {
      public:
      // BooleanExpression
      //
      typedef ::xsd::qif2::BooleanExpressionBaseType BooleanExpression_type;
      typedef ::xsd::cxx::tree::optional< BooleanExpression_type > BooleanExpression_optional;
      typedef ::xsd::cxx::tree::traits< BooleanExpression_type, char > BooleanExpression_traits;

      const BooleanExpression_optional&
      BooleanExpression () const;

      BooleanExpression_optional&
      BooleanExpression ();

      void
      BooleanExpression (const BooleanExpression_type& x);

      void
      BooleanExpression (const BooleanExpression_optional& x);

      void
      BooleanExpression (::std::auto_ptr< BooleanExpression_type > p);

      // ThenPoints
      //
      typedef ::xsd::qif2::ThenPointsType ThenPoints_type;
      typedef ::xsd::cxx::tree::optional< ThenPoints_type > ThenPoints_optional;
      typedef ::xsd::cxx::tree::traits< ThenPoints_type, char > ThenPoints_traits;

      const ThenPoints_optional&
      ThenPoints () const;

      ThenPoints_optional&
      ThenPoints ();

      void
      ThenPoints (const ThenPoints_type& x);

      void
      ThenPoints (const ThenPoints_optional& x);

      void
      ThenPoints (::std::auto_ptr< ThenPoints_type > p);

      // Constructors.
      //
      IfThenFeatureRuleType ();

      IfThenFeatureRuleType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      IfThenFeatureRuleType (const IfThenFeatureRuleType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual IfThenFeatureRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenFeatureRuleType&
      operator= (const IfThenFeatureRuleType& x);

      virtual 
      ~IfThenFeatureRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      BooleanExpression_optional BooleanExpression_;
      ThenPoints_optional ThenPoints_;
    };

    class ElseRuleType: public ::xsd::qif2::PointRuleBaseType
    {
      public:
      // ThenPoints
      //
      typedef ::xsd::qif2::ThenPointsType ThenPoints_type;
      typedef ::xsd::cxx::tree::traits< ThenPoints_type, char > ThenPoints_traits;

      const ThenPoints_type&
      ThenPoints () const;

      ThenPoints_type&
      ThenPoints ();

      void
      ThenPoints (const ThenPoints_type& x);

      void
      ThenPoints (::std::auto_ptr< ThenPoints_type > p);

      // Constructors.
      //
      ElseRuleType (const ThenPoints_type&);

      ElseRuleType (::std::auto_ptr< ThenPoints_type >);

      ElseRuleType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      ElseRuleType (const ElseRuleType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual ElseRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElseRuleType&
      operator= (const ElseRuleType& x);

      virtual 
      ~ElseRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ThenPoints_type > ThenPoints_;
    };

    class ThenPointsType: public ::xml_schema::type
    {
      public:
      // NumberOfPoints
      //
      typedef ::xml_schema::unsigned_int NumberOfPoints_type;
      typedef ::xsd::cxx::tree::optional< NumberOfPoints_type > NumberOfPoints_optional;
      typedef ::xsd::cxx::tree::traits< NumberOfPoints_type, char > NumberOfPoints_traits;

      const NumberOfPoints_optional&
      NumberOfPoints () const;

      NumberOfPoints_optional&
      NumberOfPoints ();

      void
      NumberOfPoints (const NumberOfPoints_type& x);

      void
      NumberOfPoints (const NumberOfPoints_optional& x);

      // MinPoints
      //
      typedef ::xml_schema::unsigned_int MinPoints_type;
      typedef ::xsd::cxx::tree::optional< MinPoints_type > MinPoints_optional;
      typedef ::xsd::cxx::tree::traits< MinPoints_type, char > MinPoints_traits;

      const MinPoints_optional&
      MinPoints () const;

      MinPoints_optional&
      MinPoints ();

      void
      MinPoints (const MinPoints_type& x);

      void
      MinPoints (const MinPoints_optional& x);

      // PointDensity
      //
      typedef ::xsd::qif2::PositiveDecimalType PointDensity_type;
      typedef ::xsd::cxx::tree::optional< PointDensity_type > PointDensity_optional;
      typedef ::xsd::cxx::tree::traits< PointDensity_type, char > PointDensity_traits;

      const PointDensity_optional&
      PointDensity () const;

      PointDensity_optional&
      PointDensity ();

      void
      PointDensity (const PointDensity_type& x);

      void
      PointDensity (const PointDensity_optional& x);

      void
      PointDensity (::std::auto_ptr< PointDensity_type > p);

      // MinPointDensity
      //
      typedef ::xsd::qif2::PositiveDecimalType MinPointDensity_type;
      typedef ::xsd::cxx::tree::optional< MinPointDensity_type > MinPointDensity_optional;
      typedef ::xsd::cxx::tree::traits< MinPointDensity_type, char > MinPointDensity_traits;

      const MinPointDensity_optional&
      MinPointDensity () const;

      MinPointDensity_optional&
      MinPointDensity ();

      void
      MinPointDensity (const MinPointDensity_type& x);

      void
      MinPointDensity (const MinPointDensity_optional& x);

      void
      MinPointDensity (::std::auto_ptr< MinPointDensity_type > p);

      // Constructors.
      //
      ThenPointsType ();

      ThenPointsType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ThenPointsType (const ThenPointsType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual ThenPointsType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ThenPointsType&
      operator= (const ThenPointsType& x);

      virtual 
      ~ThenPointsType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      NumberOfPoints_optional NumberOfPoints_;
      MinPoints_optional MinPoints_;
      PointDensity_optional PointDensity_;
      MinPointDensity_optional MinPointDensity_;
    };

    class IfThenArcRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif2::ArcPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, char > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif2::NonFeatureOfSizeSubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, char > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenArcRuleType ();

      IfThenArcRuleType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      IfThenArcRuleType (const IfThenArcRuleType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual IfThenArcRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenArcRuleType&
      operator= (const IfThenArcRuleType& x);

      virtual 
      ~IfThenArcRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class ArcPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif2::OpenCurvePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, char > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, char > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      ArcPointSamplingStrategyType ();

      ArcPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      ArcPointSamplingStrategyType (const ArcPointSamplingStrategyType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual ArcPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ArcPointSamplingStrategyType&
      operator= (const ArcPointSamplingStrategyType& x);

      virtual 
      ~ArcPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class IfThenCircleRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif2::CirclePointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, char > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif2::FeatureOfSizeSubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, char > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenCircleRuleType ();

      IfThenCircleRuleType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      IfThenCircleRuleType (const IfThenCircleRuleType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual IfThenCircleRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenCircleRuleType&
      operator= (const IfThenCircleRuleType& x);

      virtual 
      ~IfThenCircleRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class CirclePointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif2::ClosedCurvePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, char > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, char > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      CirclePointSamplingStrategyType ();

      CirclePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      CirclePointSamplingStrategyType (const CirclePointSamplingStrategyType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual CirclePointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CirclePointSamplingStrategyType&
      operator= (const CirclePointSamplingStrategyType& x);

      virtual 
      ~CirclePointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class IfThenConeRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif2::ConePointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, char > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif2::FeatureOfSizeSubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, char > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenConeRuleType ();

      IfThenConeRuleType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      IfThenConeRuleType (const IfThenConeRuleType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual IfThenConeRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenConeRuleType&
      operator= (const IfThenConeRuleType& x);

      virtual 
      ~IfThenConeRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class ConePointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif2::ConePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, char > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, char > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      ConePointSamplingStrategyType ();

      ConePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      ConePointSamplingStrategyType (const ConePointSamplingStrategyType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual ConePointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConePointSamplingStrategyType&
      operator= (const ConePointSamplingStrategyType& x);

      virtual 
      ~ConePointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class IfThenConicalSegmentRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif2::ConicalSegmentPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, char > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif2::NonFeatureOfSizeSubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, char > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenConicalSegmentRuleType ();

      IfThenConicalSegmentRuleType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      IfThenConicalSegmentRuleType (const IfThenConicalSegmentRuleType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual IfThenConicalSegmentRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenConicalSegmentRuleType&
      operator= (const IfThenConicalSegmentRuleType& x);

      virtual 
      ~IfThenConicalSegmentRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class ConicalSegmentPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif2::ConePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, char > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, char > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      ConicalSegmentPointSamplingStrategyType ();

      ConicalSegmentPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      ConicalSegmentPointSamplingStrategyType (const ConicalSegmentPointSamplingStrategyType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual ConicalSegmentPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ConicalSegmentPointSamplingStrategyType&
      operator= (const ConicalSegmentPointSamplingStrategyType& x);

      virtual 
      ~ConicalSegmentPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class IfThenCuboidRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif2::CuboidPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, char > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif2::FeatureOfSizeSubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, char > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenCuboidRuleType ();

      IfThenCuboidRuleType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      IfThenCuboidRuleType (const IfThenCuboidRuleType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual IfThenCuboidRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenCuboidRuleType&
      operator= (const IfThenCuboidRuleType& x);

      virtual 
      ~IfThenCuboidRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class CuboidPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif2::PrismPointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, char > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, char > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      CuboidPointSamplingStrategyType ();

      CuboidPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      CuboidPointSamplingStrategyType (const CuboidPointSamplingStrategyType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual CuboidPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CuboidPointSamplingStrategyType&
      operator= (const CuboidPointSamplingStrategyType& x);

      virtual 
      ~CuboidPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class IfThenCylinderRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif2::CylinderPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, char > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif2::FeatureOfSizeSubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, char > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenCylinderRuleType ();

      IfThenCylinderRuleType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      IfThenCylinderRuleType (const IfThenCylinderRuleType& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

      virtual IfThenCylinderRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenCylinderRuleType&
      operator= (const IfThenCylinderRuleType& x);

      virtual 
      ~IfThenCylinderRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class CylinderPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif2::SurfaceOfRevolutionPointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, char > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, char > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      CylinderPointSamplingStrategyType ();

      CylinderPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      CylinderPointSamplingStrategyType (const CylinderPointSamplingStrategyType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual CylinderPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylinderPointSamplingStrategyType&
      operator= (const CylinderPointSamplingStrategyType& x);

      virtual 
      ~CylinderPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class IfThenCylindricalSegmentRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif2::CylindricalSegmentPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, char > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif2::NonFeatureOfSizeSubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, char > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenCylindricalSegmentRuleType ();

      IfThenCylindricalSegmentRuleType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      IfThenCylindricalSegmentRuleType (const IfThenCylindricalSegmentRuleType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual IfThenCylindricalSegmentRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenCylindricalSegmentRuleType&
      operator= (const IfThenCylindricalSegmentRuleType& x);

      virtual 
      ~IfThenCylindricalSegmentRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class CylindricalSegmentPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif2::SurfaceOfRevolutionPointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, char > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, char > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      CylindricalSegmentPointSamplingStrategyType ();

      CylindricalSegmentPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      CylindricalSegmentPointSamplingStrategyType (const CylindricalSegmentPointSamplingStrategyType& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

      virtual CylindricalSegmentPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CylindricalSegmentPointSamplingStrategyType&
      operator= (const CylindricalSegmentPointSamplingStrategyType& x);

      virtual 
      ~CylindricalSegmentPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class IfThenEllipseRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif2::EllipsePointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, char > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif2::FeatureOfSizeSubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, char > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenEllipseRuleType ();

      IfThenEllipseRuleType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      IfThenEllipseRuleType (const IfThenEllipseRuleType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual IfThenEllipseRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenEllipseRuleType&
      operator= (const IfThenEllipseRuleType& x);

      virtual 
      ~IfThenEllipseRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class EllipsePointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif2::ClosedCurvePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, char > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, char > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      EllipsePointSamplingStrategyType ();

      EllipsePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      EllipsePointSamplingStrategyType (const EllipsePointSamplingStrategyType& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual EllipsePointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EllipsePointSamplingStrategyType&
      operator= (const EllipsePointSamplingStrategyType& x);

      virtual 
      ~EllipsePointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class IfThenElongatedCylinderRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif2::ElongatedCylinderPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, char > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif2::FeatureOfSizeSubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, char > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenElongatedCylinderRuleType ();

      IfThenElongatedCylinderRuleType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      IfThenElongatedCylinderRuleType (const IfThenElongatedCylinderRuleType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual IfThenElongatedCylinderRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenElongatedCylinderRuleType&
      operator= (const IfThenElongatedCylinderRuleType& x);

      virtual 
      ~IfThenElongatedCylinderRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class ElongatedCylinderPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif2::ElongatedCylinderPointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, char > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, char > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      ElongatedCylinderPointSamplingStrategyType ();

      ElongatedCylinderPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      ElongatedCylinderPointSamplingStrategyType (const ElongatedCylinderPointSamplingStrategyType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual ElongatedCylinderPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ElongatedCylinderPointSamplingStrategyType&
      operator= (const ElongatedCylinderPointSamplingStrategyType& x);

      virtual 
      ~ElongatedCylinderPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class IfThenExtrudedCrossSectionRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif2::ExtrudedCrossSectionPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, char > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif2::CurveSubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, char > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenExtrudedCrossSectionRuleType ();

      IfThenExtrudedCrossSectionRuleType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      IfThenExtrudedCrossSectionRuleType (const IfThenExtrudedCrossSectionRuleType& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual IfThenExtrudedCrossSectionRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenExtrudedCrossSectionRuleType&
      operator= (const IfThenExtrudedCrossSectionRuleType& x);

      virtual 
      ~IfThenExtrudedCrossSectionRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class ExtrudedCrossSectionPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif2::ExtrudedCrossSectionPointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, char > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, char > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      ExtrudedCrossSectionPointSamplingStrategyType ();

      ExtrudedCrossSectionPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      ExtrudedCrossSectionPointSamplingStrategyType (const ExtrudedCrossSectionPointSamplingStrategyType& x,
                                                     ::xml_schema::flags f = 0,
                                                     ::xml_schema::container* c = 0);

      virtual ExtrudedCrossSectionPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ExtrudedCrossSectionPointSamplingStrategyType&
      operator= (const ExtrudedCrossSectionPointSamplingStrategyType& x);

      virtual 
      ~ExtrudedCrossSectionPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class IfThenLineRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif2::LinePointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, char > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif2::NonFeatureOfSizeSubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, char > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenLineRuleType ();

      IfThenLineRuleType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      IfThenLineRuleType (const IfThenLineRuleType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual IfThenLineRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenLineRuleType&
      operator= (const IfThenLineRuleType& x);

      virtual 
      ~IfThenLineRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class LinePointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif2::OpenCurvePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, char > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, char > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      LinePointSamplingStrategyType ();

      LinePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      LinePointSamplingStrategyType (const LinePointSamplingStrategyType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual LinePointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LinePointSamplingStrategyType&
      operator= (const LinePointSamplingStrategyType& x);

      virtual 
      ~LinePointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class IfThenOppositeLinesRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif2::OppositeLinesPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, char > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif2::FeatureOfSizeSubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, char > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenOppositeLinesRuleType ();

      IfThenOppositeLinesRuleType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      IfThenOppositeLinesRuleType (const IfThenOppositeLinesRuleType& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual IfThenOppositeLinesRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenOppositeLinesRuleType&
      operator= (const IfThenOppositeLinesRuleType& x);

      virtual 
      ~IfThenOppositeLinesRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class OppositeLinesPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif2::OpenCurvePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, char > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, char > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      OppositeLinesPointSamplingStrategyType ();

      OppositeLinesPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      OppositeLinesPointSamplingStrategyType (const OppositeLinesPointSamplingStrategyType& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

      virtual OppositeLinesPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositeLinesPointSamplingStrategyType&
      operator= (const OppositeLinesPointSamplingStrategyType& x);

      virtual 
      ~OppositeLinesPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class IfThenOppositePlanesRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif2::OppositePlanesPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, char > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif2::FeatureOfSizeSubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, char > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenOppositePlanesRuleType ();

      IfThenOppositePlanesRuleType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      IfThenOppositePlanesRuleType (const IfThenOppositePlanesRuleType& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual IfThenOppositePlanesRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenOppositePlanesRuleType&
      operator= (const IfThenOppositePlanesRuleType& x);

      virtual 
      ~IfThenOppositePlanesRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class OppositePlanesPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif2::PlanePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, char > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, char > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      OppositePlanesPointSamplingStrategyType ();

      OppositePlanesPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      OppositePlanesPointSamplingStrategyType (const OppositePlanesPointSamplingStrategyType& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

      virtual OppositePlanesPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      OppositePlanesPointSamplingStrategyType&
      operator= (const OppositePlanesPointSamplingStrategyType& x);

      virtual 
      ~OppositePlanesPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class IfThenPlaneRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif2::PlanePointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, char > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif2::NonFeatureOfSizeSubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, char > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenPlaneRuleType ();

      IfThenPlaneRuleType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      IfThenPlaneRuleType (const IfThenPlaneRuleType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual IfThenPlaneRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenPlaneRuleType&
      operator= (const IfThenPlaneRuleType& x);

      virtual 
      ~IfThenPlaneRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class PlanePointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif2::PlanePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, char > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, char > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      PlanePointSamplingStrategyType ();

      PlanePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      PlanePointSamplingStrategyType (const PlanePointSamplingStrategyType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual PlanePointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PlanePointSamplingStrategyType&
      operator= (const PlanePointSamplingStrategyType& x);

      virtual 
      ~PlanePointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class IfThenPointDefinedCurveRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif2::PointDefinedCurvePointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, char > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif2::CurveSubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, char > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenPointDefinedCurveRuleType ();

      IfThenPointDefinedCurveRuleType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      IfThenPointDefinedCurveRuleType (const IfThenPointDefinedCurveRuleType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual IfThenPointDefinedCurveRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenPointDefinedCurveRuleType&
      operator= (const IfThenPointDefinedCurveRuleType& x);

      virtual 
      ~IfThenPointDefinedCurveRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class PointDefinedCurvePointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif2::PointDefinedPointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, char > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, char > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      PointDefinedCurvePointSamplingStrategyType ();

      PointDefinedCurvePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      PointDefinedCurvePointSamplingStrategyType (const PointDefinedCurvePointSamplingStrategyType& x,
                                                  ::xml_schema::flags f = 0,
                                                  ::xml_schema::container* c = 0);

      virtual PointDefinedCurvePointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedCurvePointSamplingStrategyType&
      operator= (const PointDefinedCurvePointSamplingStrategyType& x);

      virtual 
      ~PointDefinedCurvePointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class IfThenPointDefinedSurfaceRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif2::PointDefinedSurfacePointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, char > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif2::SurfaceSubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, char > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenPointDefinedSurfaceRuleType ();

      IfThenPointDefinedSurfaceRuleType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      IfThenPointDefinedSurfaceRuleType (const IfThenPointDefinedSurfaceRuleType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual IfThenPointDefinedSurfaceRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenPointDefinedSurfaceRuleType&
      operator= (const IfThenPointDefinedSurfaceRuleType& x);

      virtual 
      ~IfThenPointDefinedSurfaceRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class PointDefinedSurfacePointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif2::PointDefinedPointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, char > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, char > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      PointDefinedSurfacePointSamplingStrategyType ();

      PointDefinedSurfacePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      PointDefinedSurfacePointSamplingStrategyType (const PointDefinedSurfacePointSamplingStrategyType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual PointDefinedSurfacePointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointDefinedSurfacePointSamplingStrategyType&
      operator= (const PointDefinedSurfacePointSamplingStrategyType& x);

      virtual 
      ~PointDefinedSurfacePointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class IfThenPointRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif2::PointPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, char > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > p);

      // Constructors.
      //
      IfThenPointRuleType ();

      IfThenPointRuleType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      IfThenPointRuleType (const IfThenPointRuleType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual IfThenPointRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenPointRuleType&
      operator= (const IfThenPointRuleType& x);

      virtual 
      ~IfThenPointRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
    };

    class PointPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif2::PointPointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, char > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, char > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      PointPointSamplingStrategyType ();

      PointPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      PointPointSamplingStrategyType (const PointPointSamplingStrategyType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual PointPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointPointSamplingStrategyType&
      operator= (const PointPointSamplingStrategyType& x);

      virtual 
      ~PointPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class IfThenSphereRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif2::SpherePointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, char > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif2::FeatureOfSizeSubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, char > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenSphereRuleType ();

      IfThenSphereRuleType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      IfThenSphereRuleType (const IfThenSphereRuleType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual IfThenSphereRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenSphereRuleType&
      operator= (const IfThenSphereRuleType& x);

      virtual 
      ~IfThenSphereRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class SpherePointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif2::SpherePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, char > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, char > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      SpherePointSamplingStrategyType ();

      SpherePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      SpherePointSamplingStrategyType (const SpherePointSamplingStrategyType& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual SpherePointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SpherePointSamplingStrategyType&
      operator= (const SpherePointSamplingStrategyType& x);

      virtual 
      ~SpherePointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class IfThenSphericalSegmentRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif2::SphericalSegmentPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, char > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif2::NonFeatureOfSizeSubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, char > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenSphericalSegmentRuleType ();

      IfThenSphericalSegmentRuleType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      IfThenSphericalSegmentRuleType (const IfThenSphericalSegmentRuleType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual IfThenSphericalSegmentRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenSphericalSegmentRuleType&
      operator= (const IfThenSphericalSegmentRuleType& x);

      virtual 
      ~IfThenSphericalSegmentRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class SphericalSegmentPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif2::SpherePointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, char > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, char > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      SphericalSegmentPointSamplingStrategyType ();

      SphericalSegmentPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      SphericalSegmentPointSamplingStrategyType (const SphericalSegmentPointSamplingStrategyType& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

      virtual SphericalSegmentPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SphericalSegmentPointSamplingStrategyType&
      operator= (const SphericalSegmentPointSamplingStrategyType& x);

      virtual 
      ~SphericalSegmentPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class IfThenSurfaceOfRevolutionRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif2::SurfaceOfRevolutionPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, char > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif2::CurveSubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, char > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenSurfaceOfRevolutionRuleType ();

      IfThenSurfaceOfRevolutionRuleType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      IfThenSurfaceOfRevolutionRuleType (const IfThenSurfaceOfRevolutionRuleType& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual IfThenSurfaceOfRevolutionRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenSurfaceOfRevolutionRuleType&
      operator= (const IfThenSurfaceOfRevolutionRuleType& x);

      virtual 
      ~IfThenSurfaceOfRevolutionRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class SurfaceOfRevolutionPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif2::SurfaceOfRevolutionPointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, char > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, char > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      SurfaceOfRevolutionPointSamplingStrategyType ();

      SurfaceOfRevolutionPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      SurfaceOfRevolutionPointSamplingStrategyType (const SurfaceOfRevolutionPointSamplingStrategyType& x,
                                                    ::xml_schema::flags f = 0,
                                                    ::xml_schema::container* c = 0);

      virtual SurfaceOfRevolutionPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SurfaceOfRevolutionPointSamplingStrategyType&
      operator= (const SurfaceOfRevolutionPointSamplingStrategyType& x);

      virtual 
      ~SurfaceOfRevolutionPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class IfThenToroidalSegmentRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif2::ToroidalSegmentPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, char > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif2::NonFeatureOfSizeSubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, char > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenToroidalSegmentRuleType ();

      IfThenToroidalSegmentRuleType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      IfThenToroidalSegmentRuleType (const IfThenToroidalSegmentRuleType& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual IfThenToroidalSegmentRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenToroidalSegmentRuleType&
      operator= (const IfThenToroidalSegmentRuleType& x);

      virtual 
      ~IfThenToroidalSegmentRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class ToroidalSegmentPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif2::SurfaceOfRevolutionPointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, char > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, char > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      ToroidalSegmentPointSamplingStrategyType ();

      ToroidalSegmentPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      ToroidalSegmentPointSamplingStrategyType (const ToroidalSegmentPointSamplingStrategyType& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

      virtual ToroidalSegmentPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ToroidalSegmentPointSamplingStrategyType&
      operator= (const ToroidalSegmentPointSamplingStrategyType& x);

      virtual 
      ~ToroidalSegmentPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class IfThenTorusRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // ThenPointStrategy
      //
      typedef ::xsd::qif2::TorusPointSamplingStrategyType ThenPointStrategy_type;
      typedef ::xsd::cxx::tree::optional< ThenPointStrategy_type > ThenPointStrategy_optional;
      typedef ::xsd::cxx::tree::traits< ThenPointStrategy_type, char > ThenPointStrategy_traits;

      const ThenPointStrategy_optional&
      ThenPointStrategy () const;

      ThenPointStrategy_optional&
      ThenPointStrategy ();

      void
      ThenPointStrategy (const ThenPointStrategy_type& x);

      void
      ThenPointStrategy (const ThenPointStrategy_optional& x);

      void
      ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > p);

      // ThenFittingAlgorithm
      //
      typedef ::xsd::qif2::FeatureOfSizeSubstituteFeatureAlgorithmType ThenFittingAlgorithm_type;
      typedef ::xsd::cxx::tree::optional< ThenFittingAlgorithm_type > ThenFittingAlgorithm_optional;
      typedef ::xsd::cxx::tree::traits< ThenFittingAlgorithm_type, char > ThenFittingAlgorithm_traits;

      const ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm () const;

      ThenFittingAlgorithm_optional&
      ThenFittingAlgorithm ();

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x);

      void
      ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x);

      void
      ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > p);

      // Constructors.
      //
      IfThenTorusRuleType ();

      IfThenTorusRuleType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      IfThenTorusRuleType (const IfThenTorusRuleType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual IfThenTorusRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      IfThenTorusRuleType&
      operator= (const IfThenTorusRuleType& x);

      virtual 
      ~IfThenTorusRuleType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ThenPointStrategy_optional ThenPointStrategy_;
      ThenFittingAlgorithm_optional ThenFittingAlgorithm_;
    };

    class TorusPointSamplingStrategyType: public ::xml_schema::type
    {
      public:
      // PointSamplingStrategyEnum
      //
      typedef ::xsd::qif2::SurfaceOfRevolutionPointSamplingStrategyEnumType PointSamplingStrategyEnum_type;
      typedef ::xsd::cxx::tree::optional< PointSamplingStrategyEnum_type > PointSamplingStrategyEnum_optional;
      typedef ::xsd::cxx::tree::traits< PointSamplingStrategyEnum_type, char > PointSamplingStrategyEnum_traits;

      const PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum () const;

      PointSamplingStrategyEnum_optional&
      PointSamplingStrategyEnum ();

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x);

      void
      PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x);

      void
      PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > p);

      // UserDefinedStrategy
      //
      typedef ::xml_schema::token UserDefinedStrategy_type;
      typedef ::xsd::cxx::tree::optional< UserDefinedStrategy_type > UserDefinedStrategy_optional;
      typedef ::xsd::cxx::tree::traits< UserDefinedStrategy_type, char > UserDefinedStrategy_traits;

      const UserDefinedStrategy_optional&
      UserDefinedStrategy () const;

      UserDefinedStrategy_optional&
      UserDefinedStrategy ();

      void
      UserDefinedStrategy (const UserDefinedStrategy_type& x);

      void
      UserDefinedStrategy (const UserDefinedStrategy_optional& x);

      void
      UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > p);

      // Constructors.
      //
      TorusPointSamplingStrategyType ();

      TorusPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      TorusPointSamplingStrategyType (const TorusPointSamplingStrategyType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual TorusPointSamplingStrategyType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TorusPointSamplingStrategyType&
      operator= (const TorusPointSamplingStrategyType& x);

      virtual 
      ~TorusPointSamplingStrategyType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      PointSamplingStrategyEnum_optional PointSamplingStrategyEnum_;
      UserDefinedStrategy_optional UserDefinedStrategy_;
    };

    class IfThenSurfaceRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // Constructors.
      //
      IfThenSurfaceRuleType ();

      IfThenSurfaceRuleType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      IfThenSurfaceRuleType (const IfThenSurfaceRuleType& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual IfThenSurfaceRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~IfThenSurfaceRuleType ();
    };

    class IfThenCurveRuleType: public ::xsd::qif2::IfThenFeatureRuleType
    {
      public:
      // Constructors.
      //
      IfThenCurveRuleType ();

      IfThenCurveRuleType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      IfThenCurveRuleType (const IfThenCurveRuleType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual IfThenCurveRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~IfThenCurveRuleType ();
    };

    class DMESelectionRuleType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      DMESelectionRuleType ();

      DMESelectionRuleType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      DMESelectionRuleType (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      DMESelectionRuleType (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      DMESelectionRuleType (const DMESelectionRuleType& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual DMESelectionRuleType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~DMESelectionRuleType ();
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace xsd
{
  namespace qif2
  {
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // QIFRULES_HXX
