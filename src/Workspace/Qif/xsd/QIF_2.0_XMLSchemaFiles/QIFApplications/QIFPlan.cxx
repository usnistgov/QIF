// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "QIFPlan.hxx"

namespace xsd
{
  namespace qif2
  {
    // MeasurementPlanType
    // 

    const MeasurementPlanType::Version_optional& MeasurementPlanType::
    Version () const
    {
      return this->Version_;
    }

    MeasurementPlanType::Version_optional& MeasurementPlanType::
    Version ()
    {
      return this->Version_;
    }

    void MeasurementPlanType::
    Version (const Version_type& x)
    {
      this->Version_.set (x);
    }

    void MeasurementPlanType::
    Version (const Version_optional& x)
    {
      this->Version_ = x;
    }

    void MeasurementPlanType::
    Version (::std::auto_ptr< Version_type > x)
    {
      this->Version_.set (x);
    }

    const MeasurementPlanType::RulesUsedQPId_optional& MeasurementPlanType::
    RulesUsedQPId () const
    {
      return this->RulesUsedQPId_;
    }

    MeasurementPlanType::RulesUsedQPId_optional& MeasurementPlanType::
    RulesUsedQPId ()
    {
      return this->RulesUsedQPId_;
    }

    void MeasurementPlanType::
    RulesUsedQPId (const RulesUsedQPId_type& x)
    {
      this->RulesUsedQPId_.set (x);
    }

    void MeasurementPlanType::
    RulesUsedQPId (const RulesUsedQPId_optional& x)
    {
      this->RulesUsedQPId_ = x;
    }

    void MeasurementPlanType::
    RulesUsedQPId (::std::auto_ptr< RulesUsedQPId_type > x)
    {
      this->RulesUsedQPId_.set (x);
    }

    const MeasurementPlanType::RulesToUseQPId_optional& MeasurementPlanType::
    RulesToUseQPId () const
    {
      return this->RulesToUseQPId_;
    }

    MeasurementPlanType::RulesToUseQPId_optional& MeasurementPlanType::
    RulesToUseQPId ()
    {
      return this->RulesToUseQPId_;
    }

    void MeasurementPlanType::
    RulesToUseQPId (const RulesToUseQPId_type& x)
    {
      this->RulesToUseQPId_.set (x);
    }

    void MeasurementPlanType::
    RulesToUseQPId (const RulesToUseQPId_optional& x)
    {
      this->RulesToUseQPId_ = x;
    }

    void MeasurementPlanType::
    RulesToUseQPId (::std::auto_ptr< RulesToUseQPId_type > x)
    {
      this->RulesToUseQPId_.set (x);
    }

    const MeasurementPlanType::WorkInstructions_optional& MeasurementPlanType::
    WorkInstructions () const
    {
      return this->WorkInstructions_;
    }

    MeasurementPlanType::WorkInstructions_optional& MeasurementPlanType::
    WorkInstructions ()
    {
      return this->WorkInstructions_;
    }

    void MeasurementPlanType::
    WorkInstructions (const WorkInstructions_type& x)
    {
      this->WorkInstructions_.set (x);
    }

    void MeasurementPlanType::
    WorkInstructions (const WorkInstructions_optional& x)
    {
      this->WorkInstructions_ = x;
    }

    void MeasurementPlanType::
    WorkInstructions (::std::auto_ptr< WorkInstructions_type > x)
    {
      this->WorkInstructions_.set (x);
    }

    const MeasurementPlanType::ActionMethods_optional& MeasurementPlanType::
    ActionMethods () const
    {
      return this->ActionMethods_;
    }

    MeasurementPlanType::ActionMethods_optional& MeasurementPlanType::
    ActionMethods ()
    {
      return this->ActionMethods_;
    }

    void MeasurementPlanType::
    ActionMethods (const ActionMethods_type& x)
    {
      this->ActionMethods_.set (x);
    }

    void MeasurementPlanType::
    ActionMethods (const ActionMethods_optional& x)
    {
      this->ActionMethods_ = x;
    }

    void MeasurementPlanType::
    ActionMethods (::std::auto_ptr< ActionMethods_type > x)
    {
      this->ActionMethods_.set (x);
    }

    const MeasurementPlanType::Measurands_optional& MeasurementPlanType::
    Measurands () const
    {
      return this->Measurands_;
    }

    MeasurementPlanType::Measurands_optional& MeasurementPlanType::
    Measurands ()
    {
      return this->Measurands_;
    }

    void MeasurementPlanType::
    Measurands (const Measurands_type& x)
    {
      this->Measurands_.set (x);
    }

    void MeasurementPlanType::
    Measurands (const Measurands_optional& x)
    {
      this->Measurands_ = x;
    }

    void MeasurementPlanType::
    Measurands (::std::auto_ptr< Measurands_type > x)
    {
      this->Measurands_.set (x);
    }

    const MeasurementPlanType::PlanRoot_type& MeasurementPlanType::
    PlanRoot () const
    {
      return this->PlanRoot_.get ();
    }

    MeasurementPlanType::PlanRoot_type& MeasurementPlanType::
    PlanRoot ()
    {
      return this->PlanRoot_.get ();
    }

    void MeasurementPlanType::
    PlanRoot (const PlanRoot_type& x)
    {
      this->PlanRoot_.set (x);
    }

    void MeasurementPlanType::
    PlanRoot (::std::auto_ptr< PlanRoot_type > x)
    {
      this->PlanRoot_.set (x);
    }


    // PlanElementBaseType
    // 

    const PlanElementBaseType::WorkInstructionIds_optional& PlanElementBaseType::
    WorkInstructionIds () const
    {
      return this->WorkInstructionIds_;
    }

    PlanElementBaseType::WorkInstructionIds_optional& PlanElementBaseType::
    WorkInstructionIds ()
    {
      return this->WorkInstructionIds_;
    }

    void PlanElementBaseType::
    WorkInstructionIds (const WorkInstructionIds_type& x)
    {
      this->WorkInstructionIds_.set (x);
    }

    void PlanElementBaseType::
    WorkInstructionIds (const WorkInstructionIds_optional& x)
    {
      this->WorkInstructionIds_ = x;
    }

    void PlanElementBaseType::
    WorkInstructionIds (::std::auto_ptr< WorkInstructionIds_type > x)
    {
      this->WorkInstructionIds_.set (x);
    }


    // UnnumberedPlanElementsType
    // 

    const UnnumberedPlanElementsType::PlanElement_sequence& UnnumberedPlanElementsType::
    PlanElement () const
    {
      return this->PlanElement_;
    }

    UnnumberedPlanElementsType::PlanElement_sequence& UnnumberedPlanElementsType::
    PlanElement ()
    {
      return this->PlanElement_;
    }

    void UnnumberedPlanElementsType::
    PlanElement (const PlanElement_sequence& s)
    {
      this->PlanElement_ = s;
    }


    // NumberedPlanElementType
    // 

    const NumberedPlanElementType::SequenceNumber_type& NumberedPlanElementType::
    SequenceNumber () const
    {
      return this->SequenceNumber_.get ();
    }

    NumberedPlanElementType::SequenceNumber_type& NumberedPlanElementType::
    SequenceNumber ()
    {
      return this->SequenceNumber_.get ();
    }

    void NumberedPlanElementType::
    SequenceNumber (const SequenceNumber_type& x)
    {
      this->SequenceNumber_.set (x);
    }

    const NumberedPlanElementType::PlanElement_type& NumberedPlanElementType::
    PlanElement () const
    {
      return this->PlanElement_.get ();
    }

    NumberedPlanElementType::PlanElement_type& NumberedPlanElementType::
    PlanElement ()
    {
      return this->PlanElement_.get ();
    }

    void NumberedPlanElementType::
    PlanElement (const PlanElement_type& x)
    {
      this->PlanElement_.set (x);
    }

    void NumberedPlanElementType::
    PlanElement (::std::auto_ptr< PlanElement_type > x)
    {
      this->PlanElement_.set (x);
    }


    // NumberedPlanElementsType
    // 

    const NumberedPlanElementsType::NumberedPlanElement_sequence& NumberedPlanElementsType::
    NumberedPlanElement () const
    {
      return this->NumberedPlanElement_;
    }

    NumberedPlanElementsType::NumberedPlanElement_sequence& NumberedPlanElementsType::
    NumberedPlanElement ()
    {
      return this->NumberedPlanElement_;
    }

    void NumberedPlanElementsType::
    NumberedPlanElement (const NumberedPlanElement_sequence& s)
    {
      this->NumberedPlanElement_ = s;
    }


    // ActionBaseType
    // 

    const ActionBaseType::PreferredActionMethodId_optional& ActionBaseType::
    PreferredActionMethodId () const
    {
      return this->PreferredActionMethodId_;
    }

    ActionBaseType::PreferredActionMethodId_optional& ActionBaseType::
    PreferredActionMethodId ()
    {
      return this->PreferredActionMethodId_;
    }

    void ActionBaseType::
    PreferredActionMethodId (const PreferredActionMethodId_type& x)
    {
      this->PreferredActionMethodId_.set (x);
    }

    void ActionBaseType::
    PreferredActionMethodId (const PreferredActionMethodId_optional& x)
    {
      this->PreferredActionMethodId_ = x;
    }

    void ActionBaseType::
    PreferredActionMethodId (::std::auto_ptr< PreferredActionMethodId_type > x)
    {
      this->PreferredActionMethodId_.set (x);
    }

    const ActionBaseType::AlternativeActionMethodIds_optional& ActionBaseType::
    AlternativeActionMethodIds () const
    {
      return this->AlternativeActionMethodIds_;
    }

    ActionBaseType::AlternativeActionMethodIds_optional& ActionBaseType::
    AlternativeActionMethodIds ()
    {
      return this->AlternativeActionMethodIds_;
    }

    void ActionBaseType::
    AlternativeActionMethodIds (const AlternativeActionMethodIds_type& x)
    {
      this->AlternativeActionMethodIds_.set (x);
    }

    void ActionBaseType::
    AlternativeActionMethodIds (const AlternativeActionMethodIds_optional& x)
    {
      this->AlternativeActionMethodIds_ = x;
    }

    void ActionBaseType::
    AlternativeActionMethodIds (::std::auto_ptr< AlternativeActionMethodIds_type > x)
    {
      this->AlternativeActionMethodIds_.set (x);
    }

    const ActionBaseType::PreferredResourceIds_optional& ActionBaseType::
    PreferredResourceIds () const
    {
      return this->PreferredResourceIds_;
    }

    ActionBaseType::PreferredResourceIds_optional& ActionBaseType::
    PreferredResourceIds ()
    {
      return this->PreferredResourceIds_;
    }

    void ActionBaseType::
    PreferredResourceIds (const PreferredResourceIds_type& x)
    {
      this->PreferredResourceIds_.set (x);
    }

    void ActionBaseType::
    PreferredResourceIds (const PreferredResourceIds_optional& x)
    {
      this->PreferredResourceIds_ = x;
    }

    void ActionBaseType::
    PreferredResourceIds (::std::auto_ptr< PreferredResourceIds_type > x)
    {
      this->PreferredResourceIds_.set (x);
    }


    // MeasureEvaluateAllActionType
    // 


    // MeasureEvaluateSpecifiedActionType
    // 

    const MeasureEvaluateSpecifiedActionType::CharacteristicItemIds_type& MeasureEvaluateSpecifiedActionType::
    CharacteristicItemIds () const
    {
      return this->CharacteristicItemIds_.get ();
    }

    MeasureEvaluateSpecifiedActionType::CharacteristicItemIds_type& MeasureEvaluateSpecifiedActionType::
    CharacteristicItemIds ()
    {
      return this->CharacteristicItemIds_.get ();
    }

    void MeasureEvaluateSpecifiedActionType::
    CharacteristicItemIds (const CharacteristicItemIds_type& x)
    {
      this->CharacteristicItemIds_.set (x);
    }

    void MeasureEvaluateSpecifiedActionType::
    CharacteristicItemIds (::std::auto_ptr< CharacteristicItemIds_type > x)
    {
      this->CharacteristicItemIds_.set (x);
    }


    // EvaluateSpecifiedCharacteristicsActionType
    // 

    const EvaluateSpecifiedCharacteristicsActionType::CharacteristicItemIds_type& EvaluateSpecifiedCharacteristicsActionType::
    CharacteristicItemIds () const
    {
      return this->CharacteristicItemIds_.get ();
    }

    EvaluateSpecifiedCharacteristicsActionType::CharacteristicItemIds_type& EvaluateSpecifiedCharacteristicsActionType::
    CharacteristicItemIds ()
    {
      return this->CharacteristicItemIds_.get ();
    }

    void EvaluateSpecifiedCharacteristicsActionType::
    CharacteristicItemIds (const CharacteristicItemIds_type& x)
    {
      this->CharacteristicItemIds_.set (x);
    }

    void EvaluateSpecifiedCharacteristicsActionType::
    CharacteristicItemIds (::std::auto_ptr< CharacteristicItemIds_type > x)
    {
      this->CharacteristicItemIds_.set (x);
    }


    // MeasureSpecifiedFeaturesActionType
    // 

    const MeasureSpecifiedFeaturesActionType::FeatureItemIds_type& MeasureSpecifiedFeaturesActionType::
    FeatureItemIds () const
    {
      return this->FeatureItemIds_.get ();
    }

    MeasureSpecifiedFeaturesActionType::FeatureItemIds_type& MeasureSpecifiedFeaturesActionType::
    FeatureItemIds ()
    {
      return this->FeatureItemIds_.get ();
    }

    void MeasureSpecifiedFeaturesActionType::
    FeatureItemIds (const FeatureItemIds_type& x)
    {
      this->FeatureItemIds_.set (x);
    }

    void MeasureSpecifiedFeaturesActionType::
    FeatureItemIds (::std::auto_ptr< FeatureItemIds_type > x)
    {
      this->FeatureItemIds_.set (x);
    }


    // MeasurandBaseType
    // 

    const MeasurandBaseType::id_type& MeasurandBaseType::
    id () const
    {
      return this->id_.get ();
    }

    MeasurandBaseType::id_type& MeasurandBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void MeasurandBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void MeasurandBaseType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // EvaluateCharacteristicMeasurandType
    // 

    const EvaluateCharacteristicMeasurandType::CharacteristicItemId_type& EvaluateCharacteristicMeasurandType::
    CharacteristicItemId () const
    {
      return this->CharacteristicItemId_.get ();
    }

    EvaluateCharacteristicMeasurandType::CharacteristicItemId_type& EvaluateCharacteristicMeasurandType::
    CharacteristicItemId ()
    {
      return this->CharacteristicItemId_.get ();
    }

    void EvaluateCharacteristicMeasurandType::
    CharacteristicItemId (const CharacteristicItemId_type& x)
    {
      this->CharacteristicItemId_.set (x);
    }

    void EvaluateCharacteristicMeasurandType::
    CharacteristicItemId (::std::auto_ptr< CharacteristicItemId_type > x)
    {
      this->CharacteristicItemId_.set (x);
    }


    // EstablishDatumMeasurandType
    // 

    const EstablishDatumMeasurandType::DatumDefinitionId_type& EstablishDatumMeasurandType::
    DatumDefinitionId () const
    {
      return this->DatumDefinitionId_.get ();
    }

    EstablishDatumMeasurandType::DatumDefinitionId_type& EstablishDatumMeasurandType::
    DatumDefinitionId ()
    {
      return this->DatumDefinitionId_.get ();
    }

    void EstablishDatumMeasurandType::
    DatumDefinitionId (const DatumDefinitionId_type& x)
    {
      this->DatumDefinitionId_.set (x);
    }

    void EstablishDatumMeasurandType::
    DatumDefinitionId (::std::auto_ptr< DatumDefinitionId_type > x)
    {
      this->DatumDefinitionId_.set (x);
    }

    const EstablishDatumMeasurandType::DatumReferenceFrameId_type& EstablishDatumMeasurandType::
    DatumReferenceFrameId () const
    {
      return this->DatumReferenceFrameId_.get ();
    }

    EstablishDatumMeasurandType::DatumReferenceFrameId_type& EstablishDatumMeasurandType::
    DatumReferenceFrameId ()
    {
      return this->DatumReferenceFrameId_.get ();
    }

    void EstablishDatumMeasurandType::
    DatumReferenceFrameId (const DatumReferenceFrameId_type& x)
    {
      this->DatumReferenceFrameId_.set (x);
    }

    void EstablishDatumMeasurandType::
    DatumReferenceFrameId (::std::auto_ptr< DatumReferenceFrameId_type > x)
    {
      this->DatumReferenceFrameId_.set (x);
    }


    // MeasureSpecifiedMeasurandsActionType
    // 

    const MeasureSpecifiedMeasurandsActionType::MeasurandIds_type& MeasureSpecifiedMeasurandsActionType::
    MeasurandIds () const
    {
      return this->MeasurandIds_.get ();
    }

    MeasureSpecifiedMeasurandsActionType::MeasurandIds_type& MeasureSpecifiedMeasurandsActionType::
    MeasurandIds ()
    {
      return this->MeasurandIds_.get ();
    }

    void MeasureSpecifiedMeasurandsActionType::
    MeasurandIds (const MeasurandIds_type& x)
    {
      this->MeasurandIds_.set (x);
    }

    void MeasureSpecifiedMeasurandsActionType::
    MeasurandIds (::std::auto_ptr< MeasurandIds_type > x)
    {
      this->MeasurandIds_.set (x);
    }


    // MeasurandsType
    // 

    const MeasurandsType::Measurand_sequence& MeasurandsType::
    Measurand () const
    {
      return this->Measurand_;
    }

    MeasurandsType::Measurand_sequence& MeasurandsType::
    Measurand ()
    {
      return this->Measurand_;
    }

    void MeasurandsType::
    Measurand (const Measurand_sequence& s)
    {
      this->Measurand_ = s;
    }


    // ActionMethodBaseType
    // 

    const ActionMethodBaseType::ChosenResourceIds_optional& ActionMethodBaseType::
    ChosenResourceIds () const
    {
      return this->ChosenResourceIds_;
    }

    ActionMethodBaseType::ChosenResourceIds_optional& ActionMethodBaseType::
    ChosenResourceIds ()
    {
      return this->ChosenResourceIds_;
    }

    void ActionMethodBaseType::
    ChosenResourceIds (const ChosenResourceIds_type& x)
    {
      this->ChosenResourceIds_.set (x);
    }

    void ActionMethodBaseType::
    ChosenResourceIds (const ChosenResourceIds_optional& x)
    {
      this->ChosenResourceIds_ = x;
    }

    void ActionMethodBaseType::
    ChosenResourceIds (::std::auto_ptr< ChosenResourceIds_type > x)
    {
      this->ChosenResourceIds_.set (x);
    }

    const ActionMethodBaseType::WorkInstructionIds_optional& ActionMethodBaseType::
    WorkInstructionIds () const
    {
      return this->WorkInstructionIds_;
    }

    ActionMethodBaseType::WorkInstructionIds_optional& ActionMethodBaseType::
    WorkInstructionIds ()
    {
      return this->WorkInstructionIds_;
    }

    void ActionMethodBaseType::
    WorkInstructionIds (const WorkInstructionIds_type& x)
    {
      this->WorkInstructionIds_.set (x);
    }

    void ActionMethodBaseType::
    WorkInstructionIds (const WorkInstructionIds_optional& x)
    {
      this->WorkInstructionIds_ = x;
    }

    void ActionMethodBaseType::
    WorkInstructionIds (::std::auto_ptr< WorkInstructionIds_type > x)
    {
      this->WorkInstructionIds_.set (x);
    }

    const ActionMethodBaseType::id_type& ActionMethodBaseType::
    id () const
    {
      return this->id_.get ();
    }

    ActionMethodBaseType::id_type& ActionMethodBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void ActionMethodBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void ActionMethodBaseType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // MeasureFeatureMethodBaseType
    // 


    // CoordinateMeasureFeatureMethodType
    // 

    const CoordinateMeasureFeatureMethodType::NumberOfMeasurementPoints_optional& CoordinateMeasureFeatureMethodType::
    NumberOfMeasurementPoints () const
    {
      return this->NumberOfMeasurementPoints_;
    }

    CoordinateMeasureFeatureMethodType::NumberOfMeasurementPoints_optional& CoordinateMeasureFeatureMethodType::
    NumberOfMeasurementPoints ()
    {
      return this->NumberOfMeasurementPoints_;
    }

    void CoordinateMeasureFeatureMethodType::
    NumberOfMeasurementPoints (const NumberOfMeasurementPoints_type& x)
    {
      this->NumberOfMeasurementPoints_.set (x);
    }

    void CoordinateMeasureFeatureMethodType::
    NumberOfMeasurementPoints (const NumberOfMeasurementPoints_optional& x)
    {
      this->NumberOfMeasurementPoints_ = x;
    }


    // GageMeasureFeatureMethodType
    // 


    // ManualMeasureFeatureMethodType
    // 


    // OtherMeasureFeatureMethodType
    // 


    // ActionMethodsType
    // 

    const ActionMethodsType::ActionMethod_sequence& ActionMethodsType::
    ActionMethod () const
    {
      return this->ActionMethod_;
    }

    ActionMethodsType::ActionMethod_sequence& ActionMethodsType::
    ActionMethod ()
    {
      return this->ActionMethod_;
    }

    void ActionMethodsType::
    ActionMethod (const ActionMethod_sequence& s)
    {
      this->ActionMethod_ = s;
    }


    // MeasureActionGroupFunctionEnumType
    // 

    MeasureActionGroupFunctionEnumType::
    MeasureActionGroupFunctionEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_MeasureActionGroupFunctionEnumType_literals_[v])
    {
    }

    MeasureActionGroupFunctionEnumType::
    MeasureActionGroupFunctionEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MeasureActionGroupFunctionEnumType::
    MeasureActionGroupFunctionEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MeasureActionGroupFunctionEnumType::
    MeasureActionGroupFunctionEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    MeasureActionGroupFunctionEnumType::
    MeasureActionGroupFunctionEnumType (const MeasureActionGroupFunctionEnumType& v,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    MeasureActionGroupFunctionEnumType& MeasureActionGroupFunctionEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_MeasureActionGroupFunctionEnumType_literals_[v]);

      return *this;
    }


    // MeasureActionGroupFunctionType
    // 

    const MeasureActionGroupFunctionType::MeasureActionGroupFunctionEnum_optional& MeasureActionGroupFunctionType::
    MeasureActionGroupFunctionEnum () const
    {
      return this->MeasureActionGroupFunctionEnum_;
    }

    MeasureActionGroupFunctionType::MeasureActionGroupFunctionEnum_optional& MeasureActionGroupFunctionType::
    MeasureActionGroupFunctionEnum ()
    {
      return this->MeasureActionGroupFunctionEnum_;
    }

    void MeasureActionGroupFunctionType::
    MeasureActionGroupFunctionEnum (const MeasureActionGroupFunctionEnum_type& x)
    {
      this->MeasureActionGroupFunctionEnum_.set (x);
    }

    void MeasureActionGroupFunctionType::
    MeasureActionGroupFunctionEnum (const MeasureActionGroupFunctionEnum_optional& x)
    {
      this->MeasureActionGroupFunctionEnum_ = x;
    }

    void MeasureActionGroupFunctionType::
    MeasureActionGroupFunctionEnum (::std::auto_ptr< MeasureActionGroupFunctionEnum_type > x)
    {
      this->MeasureActionGroupFunctionEnum_.set (x);
    }

    const MeasureActionGroupFunctionType::OtherMeasureActionGroupFunction_optional& MeasureActionGroupFunctionType::
    OtherMeasureActionGroupFunction () const
    {
      return this->OtherMeasureActionGroupFunction_;
    }

    MeasureActionGroupFunctionType::OtherMeasureActionGroupFunction_optional& MeasureActionGroupFunctionType::
    OtherMeasureActionGroupFunction ()
    {
      return this->OtherMeasureActionGroupFunction_;
    }

    void MeasureActionGroupFunctionType::
    OtherMeasureActionGroupFunction (const OtherMeasureActionGroupFunction_type& x)
    {
      this->OtherMeasureActionGroupFunction_.set (x);
    }

    void MeasureActionGroupFunctionType::
    OtherMeasureActionGroupFunction (const OtherMeasureActionGroupFunction_optional& x)
    {
      this->OtherMeasureActionGroupFunction_ = x;
    }

    void MeasureActionGroupFunctionType::
    OtherMeasureActionGroupFunction (::std::auto_ptr< OtherMeasureActionGroupFunction_type > x)
    {
      this->OtherMeasureActionGroupFunction_.set (x);
    }


    // ActionGroupBaseType
    // 

    const ActionGroupBaseType::MeasureActionGroupFunction_optional& ActionGroupBaseType::
    MeasureActionGroupFunction () const
    {
      return this->MeasureActionGroupFunction_;
    }

    ActionGroupBaseType::MeasureActionGroupFunction_optional& ActionGroupBaseType::
    MeasureActionGroupFunction ()
    {
      return this->MeasureActionGroupFunction_;
    }

    void ActionGroupBaseType::
    MeasureActionGroupFunction (const MeasureActionGroupFunction_type& x)
    {
      this->MeasureActionGroupFunction_.set (x);
    }

    void ActionGroupBaseType::
    MeasureActionGroupFunction (const MeasureActionGroupFunction_optional& x)
    {
      this->MeasureActionGroupFunction_ = x;
    }

    void ActionGroupBaseType::
    MeasureActionGroupFunction (::std::auto_ptr< MeasureActionGroupFunction_type > x)
    {
      this->MeasureActionGroupFunction_.set (x);
    }


    // OrderedActionGroupType
    // 

    const OrderedActionGroupType::Steps_type& OrderedActionGroupType::
    Steps () const
    {
      return this->Steps_.get ();
    }

    OrderedActionGroupType::Steps_type& OrderedActionGroupType::
    Steps ()
    {
      return this->Steps_.get ();
    }

    void OrderedActionGroupType::
    Steps (const Steps_type& x)
    {
      this->Steps_.set (x);
    }

    void OrderedActionGroupType::
    Steps (::std::auto_ptr< Steps_type > x)
    {
      this->Steps_.set (x);
    }


    // UnorderedActionGroupType
    // 

    const UnorderedActionGroupType::Steps_type& UnorderedActionGroupType::
    Steps () const
    {
      return this->Steps_.get ();
    }

    UnorderedActionGroupType::Steps_type& UnorderedActionGroupType::
    Steps ()
    {
      return this->Steps_.get ();
    }

    void UnorderedActionGroupType::
    Steps (const Steps_type& x)
    {
      this->Steps_.set (x);
    }

    void UnorderedActionGroupType::
    Steps (::std::auto_ptr< Steps_type > x)
    {
      this->Steps_.set (x);
    }


    // PartiallyOrderedActionGroupType
    // 

    const PartiallyOrderedActionGroupType::StepsWithPredecessors_type& PartiallyOrderedActionGroupType::
    StepsWithPredecessors () const
    {
      return this->StepsWithPredecessors_.get ();
    }

    PartiallyOrderedActionGroupType::StepsWithPredecessors_type& PartiallyOrderedActionGroupType::
    StepsWithPredecessors ()
    {
      return this->StepsWithPredecessors_.get ();
    }

    void PartiallyOrderedActionGroupType::
    StepsWithPredecessors (const StepsWithPredecessors_type& x)
    {
      this->StepsWithPredecessors_.set (x);
    }

    void PartiallyOrderedActionGroupType::
    StepsWithPredecessors (::std::auto_ptr< StepsWithPredecessors_type > x)
    {
      this->StepsWithPredecessors_.set (x);
    }


    // StepWithPredecessorsType
    // 

    const StepWithPredecessorsType::Predecessors_optional& StepWithPredecessorsType::
    Predecessors () const
    {
      return this->Predecessors_;
    }

    StepWithPredecessorsType::Predecessors_optional& StepWithPredecessorsType::
    Predecessors ()
    {
      return this->Predecessors_;
    }

    void StepWithPredecessorsType::
    Predecessors (const Predecessors_type& x)
    {
      this->Predecessors_.set (x);
    }

    void StepWithPredecessorsType::
    Predecessors (const Predecessors_optional& x)
    {
      this->Predecessors_ = x;
    }

    void StepWithPredecessorsType::
    Predecessors (::std::auto_ptr< Predecessors_type > x)
    {
      this->Predecessors_.set (x);
    }

    const StepWithPredecessorsType::Step_type& StepWithPredecessorsType::
    Step () const
    {
      return this->Step_.get ();
    }

    StepWithPredecessorsType::Step_type& StepWithPredecessorsType::
    Step ()
    {
      return this->Step_.get ();
    }

    void StepWithPredecessorsType::
    Step (const Step_type& x)
    {
      this->Step_.set (x);
    }

    void StepWithPredecessorsType::
    Step (::std::auto_ptr< Step_type > x)
    {
      this->Step_.set (x);
    }


    // StepsWithPredecessorsType
    // 

    const StepsWithPredecessorsType::StepWithPredecessors_sequence& StepsWithPredecessorsType::
    StepWithPredecessors () const
    {
      return this->StepWithPredecessors_;
    }

    StepsWithPredecessorsType::StepWithPredecessors_sequence& StepsWithPredecessorsType::
    StepWithPredecessors ()
    {
      return this->StepWithPredecessors_;
    }

    void StepsWithPredecessorsType::
    StepWithPredecessors (const StepWithPredecessors_sequence& s)
    {
      this->StepWithPredecessors_ = s;
    }


    // PredecessorsType
    // 

    const PredecessorsType::Predecessor_sequence& PredecessorsType::
    Predecessor () const
    {
      return this->Predecessor_;
    }

    PredecessorsType::Predecessor_sequence& PredecessorsType::
    Predecessor ()
    {
      return this->Predecessor_;
    }

    void PredecessorsType::
    Predecessor (const Predecessor_sequence& s)
    {
      this->Predecessor_ = s;
    }


    // OneOfActionGroupType
    // 

    const OneOfActionGroupType::Steps_type& OneOfActionGroupType::
    Steps () const
    {
      return this->Steps_.get ();
    }

    OneOfActionGroupType::Steps_type& OneOfActionGroupType::
    Steps ()
    {
      return this->Steps_.get ();
    }

    void OneOfActionGroupType::
    Steps (const Steps_type& x)
    {
      this->Steps_.set (x);
    }

    void OneOfActionGroupType::
    Steps (::std::auto_ptr< Steps_type > x)
    {
      this->Steps_.set (x);
    }


    // PickSomeActionGroupType
    // 

    const PickSomeActionGroupType::Steps_type& PickSomeActionGroupType::
    Steps () const
    {
      return this->Steps_.get ();
    }

    PickSomeActionGroupType::Steps_type& PickSomeActionGroupType::
    Steps ()
    {
      return this->Steps_.get ();
    }

    void PickSomeActionGroupType::
    Steps (const Steps_type& x)
    {
      this->Steps_.set (x);
    }

    void PickSomeActionGroupType::
    Steps (::std::auto_ptr< Steps_type > x)
    {
      this->Steps_.set (x);
    }

    const PickSomeActionGroupType::NumberOfSteps_type& PickSomeActionGroupType::
    NumberOfSteps () const
    {
      return this->NumberOfSteps_.get ();
    }

    PickSomeActionGroupType::NumberOfSteps_type& PickSomeActionGroupType::
    NumberOfSteps ()
    {
      return this->NumberOfSteps_.get ();
    }

    void PickSomeActionGroupType::
    NumberOfSteps (const NumberOfSteps_type& x)
    {
      this->NumberOfSteps_.set (x);
    }


    // WorkInstructionBaseType
    // 

    const WorkInstructionBaseType::id_type& WorkInstructionBaseType::
    id () const
    {
      return this->id_.get ();
    }

    WorkInstructionBaseType::id_type& WorkInstructionBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void WorkInstructionBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void WorkInstructionBaseType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // TextInstructionType
    // 

    const TextInstructionType::TextInstruction_type& TextInstructionType::
    TextInstruction () const
    {
      return this->TextInstruction_.get ();
    }

    TextInstructionType::TextInstruction_type& TextInstructionType::
    TextInstruction ()
    {
      return this->TextInstruction_.get ();
    }

    void TextInstructionType::
    TextInstruction (const TextInstruction_type& x)
    {
      this->TextInstruction_.set (x);
    }

    void TextInstructionType::
    TextInstruction (::std::auto_ptr< TextInstruction_type > x)
    {
      this->TextInstruction_.set (x);
    }


    // DocumentFileInstructionType
    // 

    const DocumentFileInstructionType::ExternalFile_type& DocumentFileInstructionType::
    ExternalFile () const
    {
      return this->ExternalFile_.get ();
    }

    DocumentFileInstructionType::ExternalFile_type& DocumentFileInstructionType::
    ExternalFile ()
    {
      return this->ExternalFile_.get ();
    }

    void DocumentFileInstructionType::
    ExternalFile (const ExternalFile_type& x)
    {
      this->ExternalFile_.set (x);
    }

    void DocumentFileInstructionType::
    ExternalFile (::std::auto_ptr< ExternalFile_type > x)
    {
      this->ExternalFile_.set (x);
    }


    // ImageInstructionType
    // 

    const ImageInstructionType::ExternalFile_type& ImageInstructionType::
    ExternalFile () const
    {
      return this->ExternalFile_.get ();
    }

    ImageInstructionType::ExternalFile_type& ImageInstructionType::
    ExternalFile ()
    {
      return this->ExternalFile_.get ();
    }

    void ImageInstructionType::
    ExternalFile (const ExternalFile_type& x)
    {
      this->ExternalFile_.set (x);
    }

    void ImageInstructionType::
    ExternalFile (::std::auto_ptr< ExternalFile_type > x)
    {
      this->ExternalFile_.set (x);
    }


    // VideoInstructionType
    // 

    const VideoInstructionType::ExternalFile_type& VideoInstructionType::
    ExternalFile () const
    {
      return this->ExternalFile_.get ();
    }

    VideoInstructionType::ExternalFile_type& VideoInstructionType::
    ExternalFile ()
    {
      return this->ExternalFile_.get ();
    }

    void VideoInstructionType::
    ExternalFile (const ExternalFile_type& x)
    {
      this->ExternalFile_.set (x);
    }

    void VideoInstructionType::
    ExternalFile (::std::auto_ptr< ExternalFile_type > x)
    {
      this->ExternalFile_.set (x);
    }


    // WorkInstructionsType
    // 

    const WorkInstructionsType::WorkInstruction_sequence& WorkInstructionsType::
    WorkInstruction () const
    {
      return this->WorkInstruction_;
    }

    WorkInstructionsType::WorkInstruction_sequence& WorkInstructionsType::
    WorkInstruction ()
    {
      return this->WorkInstruction_;
    }

    void WorkInstructionsType::
    WorkInstruction (const WorkInstruction_sequence& s)
    {
      this->WorkInstruction_ = s;
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif2
  {
    // MeasurementPlanType
    //

    MeasurementPlanType::
    MeasurementPlanType (const PlanRoot_type& PlanRoot)
    : ::xml_schema::type (),
      Version_ (this),
      RulesUsedQPId_ (this),
      RulesToUseQPId_ (this),
      WorkInstructions_ (this),
      ActionMethods_ (this),
      Measurands_ (this),
      PlanRoot_ (PlanRoot, this)
    {
    }

    MeasurementPlanType::
    MeasurementPlanType (::std::auto_ptr< PlanRoot_type > PlanRoot)
    : ::xml_schema::type (),
      Version_ (this),
      RulesUsedQPId_ (this),
      RulesToUseQPId_ (this),
      WorkInstructions_ (this),
      ActionMethods_ (this),
      Measurands_ (this),
      PlanRoot_ (PlanRoot, this)
    {
    }

    MeasurementPlanType::
    MeasurementPlanType (const MeasurementPlanType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Version_ (x.Version_, f, this),
      RulesUsedQPId_ (x.RulesUsedQPId_, f, this),
      RulesToUseQPId_ (x.RulesToUseQPId_, f, this),
      WorkInstructions_ (x.WorkInstructions_, f, this),
      ActionMethods_ (x.ActionMethods_, f, this),
      Measurands_ (x.Measurands_, f, this),
      PlanRoot_ (x.PlanRoot_, f, this)
    {
    }

    MeasurementPlanType::
    MeasurementPlanType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Version_ (this),
      RulesUsedQPId_ (this),
      RulesToUseQPId_ (this),
      WorkInstructions_ (this),
      ActionMethods_ (this),
      Measurands_ (this),
      PlanRoot_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasurementPlanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Version
        //
        if (n.name () == "Version" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          if (!this->Version_)
          {
            this->Version_.set (r);
            continue;
          }
        }

        // RulesUsedQPId
        //
        if (n.name () == "RulesUsedQPId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RulesUsedQPId_type > r (
            RulesUsedQPId_traits::create (i, f, this));

          if (!this->RulesUsedQPId_)
          {
            this->RulesUsedQPId_.set (r);
            continue;
          }
        }

        // RulesToUseQPId
        //
        if (n.name () == "RulesToUseQPId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RulesToUseQPId_type > r (
            RulesToUseQPId_traits::create (i, f, this));

          if (!this->RulesToUseQPId_)
          {
            this->RulesToUseQPId_.set (r);
            continue;
          }
        }

        // WorkInstructions
        //
        if (n.name () == "WorkInstructions" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WorkInstructions_type > r (
            WorkInstructions_traits::create (i, f, this));

          if (!this->WorkInstructions_)
          {
            this->WorkInstructions_.set (r);
            continue;
          }
        }

        // ActionMethods
        //
        if (n.name () == "ActionMethods" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ActionMethods_type > r (
            ActionMethods_traits::create (i, f, this));

          if (!this->ActionMethods_)
          {
            this->ActionMethods_.set (r);
            continue;
          }
        }

        // Measurands
        //
        if (n.name () == "Measurands" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measurands_type > r (
            Measurands_traits::create (i, f, this));

          if (!this->Measurands_)
          {
            this->Measurands_.set (r);
            continue;
          }
        }

        // PlanRoot
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "PlanRoot",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< PlanRoot_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!PlanRoot_.present ())
            {
              ::std::auto_ptr< PlanRoot_type > r (
                dynamic_cast< PlanRoot_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->PlanRoot_.set (r);
              continue;
            }
          }
        }

        break;
      }

      if (!PlanRoot_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PlanRoot",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    MeasurementPlanType* MeasurementPlanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementPlanType (*this, f, c);
    }

    MeasurementPlanType& MeasurementPlanType::
    operator= (const MeasurementPlanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Version_ = x.Version_;
        this->RulesUsedQPId_ = x.RulesUsedQPId_;
        this->RulesToUseQPId_ = x.RulesToUseQPId_;
        this->WorkInstructions_ = x.WorkInstructions_;
        this->ActionMethods_ = x.ActionMethods_;
        this->Measurands_ = x.Measurands_;
        this->PlanRoot_ = x.PlanRoot_;
      }

      return *this;
    }

    MeasurementPlanType::
    ~MeasurementPlanType ()
    {
    }

    // PlanElementBaseType
    //

    PlanElementBaseType::
    PlanElementBaseType ()
    : ::xml_schema::type (),
      WorkInstructionIds_ (this)
    {
    }

    PlanElementBaseType::
    PlanElementBaseType (const PlanElementBaseType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      WorkInstructionIds_ (x.WorkInstructionIds_, f, this)
    {
    }

    PlanElementBaseType::
    PlanElementBaseType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      WorkInstructionIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlanElementBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // WorkInstructionIds
        //
        if (n.name () == "WorkInstructionIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WorkInstructionIds_type > r (
            WorkInstructionIds_traits::create (i, f, this));

          if (!this->WorkInstructionIds_)
          {
            this->WorkInstructionIds_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PlanElementBaseType* PlanElementBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlanElementBaseType (*this, f, c);
    }

    PlanElementBaseType& PlanElementBaseType::
    operator= (const PlanElementBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->WorkInstructionIds_ = x.WorkInstructionIds_;
      }

      return *this;
    }

    PlanElementBaseType::
    ~PlanElementBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PlanElementBaseType >
    _xsd_PlanElementBaseType_type_factory_init (
      "PlanElementBaseType",
      "http://qifstandards.org/xsd/qif2");

    // UnnumberedPlanElementsType
    //

    UnnumberedPlanElementsType::
    UnnumberedPlanElementsType ()
    : ::xml_schema::type (),
      PlanElement_ (this)
    {
    }

    UnnumberedPlanElementsType::
    UnnumberedPlanElementsType (const UnnumberedPlanElementsType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PlanElement_ (x.PlanElement_, f, this)
    {
    }

    UnnumberedPlanElementsType::
    UnnumberedPlanElementsType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PlanElement_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UnnumberedPlanElementsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PlanElement
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "PlanElement",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< PlanElement_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< PlanElement_type > r (
              dynamic_cast< PlanElement_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->PlanElement_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    UnnumberedPlanElementsType* UnnumberedPlanElementsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UnnumberedPlanElementsType (*this, f, c);
    }

    UnnumberedPlanElementsType& UnnumberedPlanElementsType::
    operator= (const UnnumberedPlanElementsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PlanElement_ = x.PlanElement_;
      }

      return *this;
    }

    UnnumberedPlanElementsType::
    ~UnnumberedPlanElementsType ()
    {
    }

    // NumberedPlanElementType
    //

    NumberedPlanElementType::
    NumberedPlanElementType (const SequenceNumber_type& SequenceNumber,
                             const PlanElement_type& PlanElement)
    : ::xml_schema::type (),
      SequenceNumber_ (SequenceNumber, this),
      PlanElement_ (PlanElement, this)
    {
    }

    NumberedPlanElementType::
    NumberedPlanElementType (const SequenceNumber_type& SequenceNumber,
                             ::std::auto_ptr< PlanElement_type > PlanElement)
    : ::xml_schema::type (),
      SequenceNumber_ (SequenceNumber, this),
      PlanElement_ (PlanElement, this)
    {
    }

    NumberedPlanElementType::
    NumberedPlanElementType (const NumberedPlanElementType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SequenceNumber_ (x.SequenceNumber_, f, this),
      PlanElement_ (x.PlanElement_, f, this)
    {
    }

    NumberedPlanElementType::
    NumberedPlanElementType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SequenceNumber_ (this),
      PlanElement_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void NumberedPlanElementType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SequenceNumber
        //
        if (n.name () == "SequenceNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!SequenceNumber_.present ())
          {
            this->SequenceNumber_.set (SequenceNumber_traits::create (i, f, this));
            continue;
          }
        }

        // PlanElement
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "PlanElement",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< PlanElement_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!PlanElement_.present ())
            {
              ::std::auto_ptr< PlanElement_type > r (
                dynamic_cast< PlanElement_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->PlanElement_.set (r);
              continue;
            }
          }
        }

        break;
      }

      if (!SequenceNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SequenceNumber",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!PlanElement_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PlanElement",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    NumberedPlanElementType* NumberedPlanElementType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NumberedPlanElementType (*this, f, c);
    }

    NumberedPlanElementType& NumberedPlanElementType::
    operator= (const NumberedPlanElementType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->SequenceNumber_ = x.SequenceNumber_;
        this->PlanElement_ = x.PlanElement_;
      }

      return *this;
    }

    NumberedPlanElementType::
    ~NumberedPlanElementType ()
    {
    }

    // NumberedPlanElementsType
    //

    NumberedPlanElementsType::
    NumberedPlanElementsType ()
    : ::xml_schema::type (),
      NumberedPlanElement_ (this)
    {
    }

    NumberedPlanElementsType::
    NumberedPlanElementsType (const NumberedPlanElementsType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      NumberedPlanElement_ (x.NumberedPlanElement_, f, this)
    {
    }

    NumberedPlanElementsType::
    NumberedPlanElementsType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      NumberedPlanElement_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void NumberedPlanElementsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // NumberedPlanElement
        //
        if (n.name () == "NumberedPlanElement" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< NumberedPlanElement_type > r (
            NumberedPlanElement_traits::create (i, f, this));

          this->NumberedPlanElement_.push_back (r);
          continue;
        }

        break;
      }
    }

    NumberedPlanElementsType* NumberedPlanElementsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NumberedPlanElementsType (*this, f, c);
    }

    NumberedPlanElementsType& NumberedPlanElementsType::
    operator= (const NumberedPlanElementsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->NumberedPlanElement_ = x.NumberedPlanElement_;
      }

      return *this;
    }

    NumberedPlanElementsType::
    ~NumberedPlanElementsType ()
    {
    }

    // ActionBaseType
    //

    ActionBaseType::
    ActionBaseType ()
    : ::xsd::qif2::PlanElementBaseType (),
      PreferredActionMethodId_ (this),
      AlternativeActionMethodIds_ (this),
      PreferredResourceIds_ (this)
    {
    }

    ActionBaseType::
    ActionBaseType (const ActionBaseType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::PlanElementBaseType (x, f, c),
      PreferredActionMethodId_ (x.PreferredActionMethodId_, f, this),
      AlternativeActionMethodIds_ (x.AlternativeActionMethodIds_, f, this),
      PreferredResourceIds_ (x.PreferredResourceIds_, f, this)
    {
    }

    ActionBaseType::
    ActionBaseType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::PlanElementBaseType (e, f | ::xml_schema::flags::base, c),
      PreferredActionMethodId_ (this),
      AlternativeActionMethodIds_ (this),
      PreferredResourceIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ActionBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::PlanElementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PreferredActionMethodId
        //
        if (n.name () == "PreferredActionMethodId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PreferredActionMethodId_type > r (
            PreferredActionMethodId_traits::create (i, f, this));

          if (!this->PreferredActionMethodId_)
          {
            this->PreferredActionMethodId_.set (r);
            continue;
          }
        }

        // AlternativeActionMethodIds
        //
        if (n.name () == "AlternativeActionMethodIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AlternativeActionMethodIds_type > r (
            AlternativeActionMethodIds_traits::create (i, f, this));

          if (!this->AlternativeActionMethodIds_)
          {
            this->AlternativeActionMethodIds_.set (r);
            continue;
          }
        }

        // PreferredResourceIds
        //
        if (n.name () == "PreferredResourceIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PreferredResourceIds_type > r (
            PreferredResourceIds_traits::create (i, f, this));

          if (!this->PreferredResourceIds_)
          {
            this->PreferredResourceIds_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ActionBaseType* ActionBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActionBaseType (*this, f, c);
    }

    ActionBaseType& ActionBaseType::
    operator= (const ActionBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::PlanElementBaseType& > (*this) = x;
        this->PreferredActionMethodId_ = x.PreferredActionMethodId_;
        this->AlternativeActionMethodIds_ = x.AlternativeActionMethodIds_;
        this->PreferredResourceIds_ = x.PreferredResourceIds_;
      }

      return *this;
    }

    ActionBaseType::
    ~ActionBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ActionBaseType >
    _xsd_ActionBaseType_type_factory_init (
      "ActionBaseType",
      "http://qifstandards.org/xsd/qif2");

    // MeasureEvaluateAllActionType
    //

    MeasureEvaluateAllActionType::
    MeasureEvaluateAllActionType ()
    : ::xsd::qif2::ActionBaseType ()
    {
    }

    MeasureEvaluateAllActionType::
    MeasureEvaluateAllActionType (const MeasureEvaluateAllActionType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ActionBaseType (x, f, c)
    {
    }

    MeasureEvaluateAllActionType::
    MeasureEvaluateAllActionType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ActionBaseType (e, f, c)
    {
    }

    MeasureEvaluateAllActionType* MeasureEvaluateAllActionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasureEvaluateAllActionType (*this, f, c);
    }

    MeasureEvaluateAllActionType::
    ~MeasureEvaluateAllActionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, MeasureEvaluateAllActionType >
    _xsd_MeasureEvaluateAllActionType_type_factory_init (
      "MeasureEvaluateAllActionType",
      "http://qifstandards.org/xsd/qif2");

    // MeasureEvaluateSpecifiedActionType
    //

    MeasureEvaluateSpecifiedActionType::
    MeasureEvaluateSpecifiedActionType (const CharacteristicItemIds_type& CharacteristicItemIds)
    : ::xsd::qif2::ActionBaseType (),
      CharacteristicItemIds_ (CharacteristicItemIds, this)
    {
    }

    MeasureEvaluateSpecifiedActionType::
    MeasureEvaluateSpecifiedActionType (::std::auto_ptr< CharacteristicItemIds_type > CharacteristicItemIds)
    : ::xsd::qif2::ActionBaseType (),
      CharacteristicItemIds_ (CharacteristicItemIds, this)
    {
    }

    MeasureEvaluateSpecifiedActionType::
    MeasureEvaluateSpecifiedActionType (const MeasureEvaluateSpecifiedActionType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::ActionBaseType (x, f, c),
      CharacteristicItemIds_ (x.CharacteristicItemIds_, f, this)
    {
    }

    MeasureEvaluateSpecifiedActionType::
    MeasureEvaluateSpecifiedActionType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::ActionBaseType (e, f | ::xml_schema::flags::base, c),
      CharacteristicItemIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasureEvaluateSpecifiedActionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CharacteristicItemIds
        //
        if (n.name () == "CharacteristicItemIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CharacteristicItemIds_type > r (
            CharacteristicItemIds_traits::create (i, f, this));

          if (!CharacteristicItemIds_.present ())
          {
            this->CharacteristicItemIds_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CharacteristicItemIds_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CharacteristicItemIds",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    MeasureEvaluateSpecifiedActionType* MeasureEvaluateSpecifiedActionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasureEvaluateSpecifiedActionType (*this, f, c);
    }

    MeasureEvaluateSpecifiedActionType& MeasureEvaluateSpecifiedActionType::
    operator= (const MeasureEvaluateSpecifiedActionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ActionBaseType& > (*this) = x;
        this->CharacteristicItemIds_ = x.CharacteristicItemIds_;
      }

      return *this;
    }

    MeasureEvaluateSpecifiedActionType::
    ~MeasureEvaluateSpecifiedActionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, MeasureEvaluateSpecifiedActionType >
    _xsd_MeasureEvaluateSpecifiedActionType_type_factory_init (
      "MeasureEvaluateSpecifiedActionType",
      "http://qifstandards.org/xsd/qif2");

    // EvaluateSpecifiedCharacteristicsActionType
    //

    EvaluateSpecifiedCharacteristicsActionType::
    EvaluateSpecifiedCharacteristicsActionType (const CharacteristicItemIds_type& CharacteristicItemIds)
    : ::xsd::qif2::ActionBaseType (),
      CharacteristicItemIds_ (CharacteristicItemIds, this)
    {
    }

    EvaluateSpecifiedCharacteristicsActionType::
    EvaluateSpecifiedCharacteristicsActionType (::std::auto_ptr< CharacteristicItemIds_type > CharacteristicItemIds)
    : ::xsd::qif2::ActionBaseType (),
      CharacteristicItemIds_ (CharacteristicItemIds, this)
    {
    }

    EvaluateSpecifiedCharacteristicsActionType::
    EvaluateSpecifiedCharacteristicsActionType (const EvaluateSpecifiedCharacteristicsActionType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif2::ActionBaseType (x, f, c),
      CharacteristicItemIds_ (x.CharacteristicItemIds_, f, this)
    {
    }

    EvaluateSpecifiedCharacteristicsActionType::
    EvaluateSpecifiedCharacteristicsActionType (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xsd::qif2::ActionBaseType (e, f | ::xml_schema::flags::base, c),
      CharacteristicItemIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EvaluateSpecifiedCharacteristicsActionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CharacteristicItemIds
        //
        if (n.name () == "CharacteristicItemIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CharacteristicItemIds_type > r (
            CharacteristicItemIds_traits::create (i, f, this));

          if (!CharacteristicItemIds_.present ())
          {
            this->CharacteristicItemIds_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CharacteristicItemIds_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CharacteristicItemIds",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EvaluateSpecifiedCharacteristicsActionType* EvaluateSpecifiedCharacteristicsActionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EvaluateSpecifiedCharacteristicsActionType (*this, f, c);
    }

    EvaluateSpecifiedCharacteristicsActionType& EvaluateSpecifiedCharacteristicsActionType::
    operator= (const EvaluateSpecifiedCharacteristicsActionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ActionBaseType& > (*this) = x;
        this->CharacteristicItemIds_ = x.CharacteristicItemIds_;
      }

      return *this;
    }

    EvaluateSpecifiedCharacteristicsActionType::
    ~EvaluateSpecifiedCharacteristicsActionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, EvaluateSpecifiedCharacteristicsActionType >
    _xsd_EvaluateSpecifiedCharacteristicsActionType_type_factory_init (
      "EvaluateSpecifiedCharacteristicsActionType",
      "http://qifstandards.org/xsd/qif2");

    // MeasureSpecifiedFeaturesActionType
    //

    MeasureSpecifiedFeaturesActionType::
    MeasureSpecifiedFeaturesActionType (const FeatureItemIds_type& FeatureItemIds)
    : ::xsd::qif2::ActionBaseType (),
      FeatureItemIds_ (FeatureItemIds, this)
    {
    }

    MeasureSpecifiedFeaturesActionType::
    MeasureSpecifiedFeaturesActionType (::std::auto_ptr< FeatureItemIds_type > FeatureItemIds)
    : ::xsd::qif2::ActionBaseType (),
      FeatureItemIds_ (FeatureItemIds, this)
    {
    }

    MeasureSpecifiedFeaturesActionType::
    MeasureSpecifiedFeaturesActionType (const MeasureSpecifiedFeaturesActionType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::ActionBaseType (x, f, c),
      FeatureItemIds_ (x.FeatureItemIds_, f, this)
    {
    }

    MeasureSpecifiedFeaturesActionType::
    MeasureSpecifiedFeaturesActionType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::ActionBaseType (e, f | ::xml_schema::flags::base, c),
      FeatureItemIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasureSpecifiedFeaturesActionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FeatureItemIds
        //
        if (n.name () == "FeatureItemIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureItemIds_type > r (
            FeatureItemIds_traits::create (i, f, this));

          if (!FeatureItemIds_.present ())
          {
            this->FeatureItemIds_.set (r);
            continue;
          }
        }

        break;
      }

      if (!FeatureItemIds_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "FeatureItemIds",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    MeasureSpecifiedFeaturesActionType* MeasureSpecifiedFeaturesActionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasureSpecifiedFeaturesActionType (*this, f, c);
    }

    MeasureSpecifiedFeaturesActionType& MeasureSpecifiedFeaturesActionType::
    operator= (const MeasureSpecifiedFeaturesActionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ActionBaseType& > (*this) = x;
        this->FeatureItemIds_ = x.FeatureItemIds_;
      }

      return *this;
    }

    MeasureSpecifiedFeaturesActionType::
    ~MeasureSpecifiedFeaturesActionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, MeasureSpecifiedFeaturesActionType >
    _xsd_MeasureSpecifiedFeaturesActionType_type_factory_init (
      "MeasureSpecifiedFeaturesActionType",
      "http://qifstandards.org/xsd/qif2");

    // MeasurandBaseType
    //

    MeasurandBaseType::
    MeasurandBaseType (const id_type& id)
    : ::xml_schema::type (),
      id_ (id, this)
    {
    }

    MeasurandBaseType::
    MeasurandBaseType (const MeasurandBaseType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this)
    {
    }

    MeasurandBaseType::
    MeasurandBaseType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void MeasurandBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    MeasurandBaseType* MeasurandBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurandBaseType (*this, f, c);
    }

    MeasurandBaseType& MeasurandBaseType::
    operator= (const MeasurandBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
      }

      return *this;
    }

    MeasurandBaseType::
    ~MeasurandBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, MeasurandBaseType >
    _xsd_MeasurandBaseType_type_factory_init (
      "MeasurandBaseType",
      "http://qifstandards.org/xsd/qif2");

    // EvaluateCharacteristicMeasurandType
    //

    EvaluateCharacteristicMeasurandType::
    EvaluateCharacteristicMeasurandType (const id_type& id,
                                         const CharacteristicItemId_type& CharacteristicItemId)
    : ::xsd::qif2::MeasurandBaseType (id),
      CharacteristicItemId_ (CharacteristicItemId, this)
    {
    }

    EvaluateCharacteristicMeasurandType::
    EvaluateCharacteristicMeasurandType (const id_type& id,
                                         ::std::auto_ptr< CharacteristicItemId_type > CharacteristicItemId)
    : ::xsd::qif2::MeasurandBaseType (id),
      CharacteristicItemId_ (CharacteristicItemId, this)
    {
    }

    EvaluateCharacteristicMeasurandType::
    EvaluateCharacteristicMeasurandType (const EvaluateCharacteristicMeasurandType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::MeasurandBaseType (x, f, c),
      CharacteristicItemId_ (x.CharacteristicItemId_, f, this)
    {
    }

    EvaluateCharacteristicMeasurandType::
    EvaluateCharacteristicMeasurandType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::MeasurandBaseType (e, f | ::xml_schema::flags::base, c),
      CharacteristicItemId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EvaluateCharacteristicMeasurandType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::MeasurandBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CharacteristicItemId
        //
        if (n.name () == "CharacteristicItemId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CharacteristicItemId_type > r (
            CharacteristicItemId_traits::create (i, f, this));

          if (!CharacteristicItemId_.present ())
          {
            this->CharacteristicItemId_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CharacteristicItemId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CharacteristicItemId",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EvaluateCharacteristicMeasurandType* EvaluateCharacteristicMeasurandType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EvaluateCharacteristicMeasurandType (*this, f, c);
    }

    EvaluateCharacteristicMeasurandType& EvaluateCharacteristicMeasurandType::
    operator= (const EvaluateCharacteristicMeasurandType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::MeasurandBaseType& > (*this) = x;
        this->CharacteristicItemId_ = x.CharacteristicItemId_;
      }

      return *this;
    }

    EvaluateCharacteristicMeasurandType::
    ~EvaluateCharacteristicMeasurandType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, EvaluateCharacteristicMeasurandType >
    _xsd_EvaluateCharacteristicMeasurandType_type_factory_init (
      "EvaluateCharacteristicMeasurandType",
      "http://qifstandards.org/xsd/qif2");

    // EstablishDatumMeasurandType
    //

    EstablishDatumMeasurandType::
    EstablishDatumMeasurandType (const id_type& id,
                                 const DatumDefinitionId_type& DatumDefinitionId,
                                 const DatumReferenceFrameId_type& DatumReferenceFrameId)
    : ::xsd::qif2::MeasurandBaseType (id),
      DatumDefinitionId_ (DatumDefinitionId, this),
      DatumReferenceFrameId_ (DatumReferenceFrameId, this)
    {
    }

    EstablishDatumMeasurandType::
    EstablishDatumMeasurandType (const id_type& id,
                                 ::std::auto_ptr< DatumDefinitionId_type > DatumDefinitionId,
                                 ::std::auto_ptr< DatumReferenceFrameId_type > DatumReferenceFrameId)
    : ::xsd::qif2::MeasurandBaseType (id),
      DatumDefinitionId_ (DatumDefinitionId, this),
      DatumReferenceFrameId_ (DatumReferenceFrameId, this)
    {
    }

    EstablishDatumMeasurandType::
    EstablishDatumMeasurandType (const EstablishDatumMeasurandType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::MeasurandBaseType (x, f, c),
      DatumDefinitionId_ (x.DatumDefinitionId_, f, this),
      DatumReferenceFrameId_ (x.DatumReferenceFrameId_, f, this)
    {
    }

    EstablishDatumMeasurandType::
    EstablishDatumMeasurandType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::MeasurandBaseType (e, f | ::xml_schema::flags::base, c),
      DatumDefinitionId_ (this),
      DatumReferenceFrameId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EstablishDatumMeasurandType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::MeasurandBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DatumDefinitionId
        //
        if (n.name () == "DatumDefinitionId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DatumDefinitionId_type > r (
            DatumDefinitionId_traits::create (i, f, this));

          if (!DatumDefinitionId_.present ())
          {
            this->DatumDefinitionId_.set (r);
            continue;
          }
        }

        // DatumReferenceFrameId
        //
        if (n.name () == "DatumReferenceFrameId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DatumReferenceFrameId_type > r (
            DatumReferenceFrameId_traits::create (i, f, this));

          if (!DatumReferenceFrameId_.present ())
          {
            this->DatumReferenceFrameId_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DatumDefinitionId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DatumDefinitionId",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!DatumReferenceFrameId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DatumReferenceFrameId",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EstablishDatumMeasurandType* EstablishDatumMeasurandType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EstablishDatumMeasurandType (*this, f, c);
    }

    EstablishDatumMeasurandType& EstablishDatumMeasurandType::
    operator= (const EstablishDatumMeasurandType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::MeasurandBaseType& > (*this) = x;
        this->DatumDefinitionId_ = x.DatumDefinitionId_;
        this->DatumReferenceFrameId_ = x.DatumReferenceFrameId_;
      }

      return *this;
    }

    EstablishDatumMeasurandType::
    ~EstablishDatumMeasurandType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, EstablishDatumMeasurandType >
    _xsd_EstablishDatumMeasurandType_type_factory_init (
      "EstablishDatumMeasurandType",
      "http://qifstandards.org/xsd/qif2");

    // MeasureSpecifiedMeasurandsActionType
    //

    MeasureSpecifiedMeasurandsActionType::
    MeasureSpecifiedMeasurandsActionType (const MeasurandIds_type& MeasurandIds)
    : ::xsd::qif2::ActionBaseType (),
      MeasurandIds_ (MeasurandIds, this)
    {
    }

    MeasureSpecifiedMeasurandsActionType::
    MeasureSpecifiedMeasurandsActionType (::std::auto_ptr< MeasurandIds_type > MeasurandIds)
    : ::xsd::qif2::ActionBaseType (),
      MeasurandIds_ (MeasurandIds, this)
    {
    }

    MeasureSpecifiedMeasurandsActionType::
    MeasureSpecifiedMeasurandsActionType (const MeasureSpecifiedMeasurandsActionType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif2::ActionBaseType (x, f, c),
      MeasurandIds_ (x.MeasurandIds_, f, this)
    {
    }

    MeasureSpecifiedMeasurandsActionType::
    MeasureSpecifiedMeasurandsActionType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif2::ActionBaseType (e, f | ::xml_schema::flags::base, c),
      MeasurandIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasureSpecifiedMeasurandsActionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MeasurandIds
        //
        if (n.name () == "MeasurandIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MeasurandIds_type > r (
            MeasurandIds_traits::create (i, f, this));

          if (!MeasurandIds_.present ())
          {
            this->MeasurandIds_.set (r);
            continue;
          }
        }

        break;
      }

      if (!MeasurandIds_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MeasurandIds",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    MeasureSpecifiedMeasurandsActionType* MeasureSpecifiedMeasurandsActionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasureSpecifiedMeasurandsActionType (*this, f, c);
    }

    MeasureSpecifiedMeasurandsActionType& MeasureSpecifiedMeasurandsActionType::
    operator= (const MeasureSpecifiedMeasurandsActionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ActionBaseType& > (*this) = x;
        this->MeasurandIds_ = x.MeasurandIds_;
      }

      return *this;
    }

    MeasureSpecifiedMeasurandsActionType::
    ~MeasureSpecifiedMeasurandsActionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, MeasureSpecifiedMeasurandsActionType >
    _xsd_MeasureSpecifiedMeasurandsActionType_type_factory_init (
      "MeasureSpecifiedMeasurandsActionType",
      "http://qifstandards.org/xsd/qif2");

    // MeasurandsType
    //

    MeasurandsType::
    MeasurandsType ()
    : ::xml_schema::type (),
      Measurand_ (this)
    {
    }

    MeasurandsType::
    MeasurandsType (const MeasurandsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measurand_ (x.Measurand_, f, this)
    {
    }

    MeasurandsType::
    MeasurandsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measurand_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasurandsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measurand
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "Measurand",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< Measurand_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< Measurand_type > r (
              dynamic_cast< Measurand_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->Measurand_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    MeasurandsType* MeasurandsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurandsType (*this, f, c);
    }

    MeasurandsType& MeasurandsType::
    operator= (const MeasurandsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measurand_ = x.Measurand_;
      }

      return *this;
    }

    MeasurandsType::
    ~MeasurandsType ()
    {
    }

    // ActionMethodBaseType
    //

    ActionMethodBaseType::
    ActionMethodBaseType (const id_type& id)
    : ::xml_schema::type (),
      ChosenResourceIds_ (this),
      WorkInstructionIds_ (this),
      id_ (id, this)
    {
    }

    ActionMethodBaseType::
    ActionMethodBaseType (const ActionMethodBaseType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ChosenResourceIds_ (x.ChosenResourceIds_, f, this),
      WorkInstructionIds_ (x.WorkInstructionIds_, f, this),
      id_ (x.id_, f, this)
    {
    }

    ActionMethodBaseType::
    ActionMethodBaseType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ChosenResourceIds_ (this),
      WorkInstructionIds_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ActionMethodBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ChosenResourceIds
        //
        if (n.name () == "ChosenResourceIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ChosenResourceIds_type > r (
            ChosenResourceIds_traits::create (i, f, this));

          if (!this->ChosenResourceIds_)
          {
            this->ChosenResourceIds_.set (r);
            continue;
          }
        }

        // WorkInstructionIds
        //
        if (n.name () == "WorkInstructionIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WorkInstructionIds_type > r (
            WorkInstructionIds_traits::create (i, f, this));

          if (!this->WorkInstructionIds_)
          {
            this->WorkInstructionIds_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    ActionMethodBaseType* ActionMethodBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActionMethodBaseType (*this, f, c);
    }

    ActionMethodBaseType& ActionMethodBaseType::
    operator= (const ActionMethodBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ChosenResourceIds_ = x.ChosenResourceIds_;
        this->WorkInstructionIds_ = x.WorkInstructionIds_;
        this->id_ = x.id_;
      }

      return *this;
    }

    ActionMethodBaseType::
    ~ActionMethodBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ActionMethodBaseType >
    _xsd_ActionMethodBaseType_type_factory_init (
      "ActionMethodBaseType",
      "http://qifstandards.org/xsd/qif2");

    // MeasureFeatureMethodBaseType
    //

    MeasureFeatureMethodBaseType::
    MeasureFeatureMethodBaseType (const id_type& id)
    : ::xsd::qif2::ActionMethodBaseType (id)
    {
    }

    MeasureFeatureMethodBaseType::
    MeasureFeatureMethodBaseType (const MeasureFeatureMethodBaseType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ActionMethodBaseType (x, f, c)
    {
    }

    MeasureFeatureMethodBaseType::
    MeasureFeatureMethodBaseType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ActionMethodBaseType (e, f, c)
    {
    }

    MeasureFeatureMethodBaseType* MeasureFeatureMethodBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasureFeatureMethodBaseType (*this, f, c);
    }

    MeasureFeatureMethodBaseType::
    ~MeasureFeatureMethodBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, MeasureFeatureMethodBaseType >
    _xsd_MeasureFeatureMethodBaseType_type_factory_init (
      "MeasureFeatureMethodBaseType",
      "http://qifstandards.org/xsd/qif2");

    // CoordinateMeasureFeatureMethodType
    //

    CoordinateMeasureFeatureMethodType::
    CoordinateMeasureFeatureMethodType (const id_type& id)
    : ::xsd::qif2::MeasureFeatureMethodBaseType (id),
      NumberOfMeasurementPoints_ (this)
    {
    }

    CoordinateMeasureFeatureMethodType::
    CoordinateMeasureFeatureMethodType (const CoordinateMeasureFeatureMethodType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::MeasureFeatureMethodBaseType (x, f, c),
      NumberOfMeasurementPoints_ (x.NumberOfMeasurementPoints_, f, this)
    {
    }

    CoordinateMeasureFeatureMethodType::
    CoordinateMeasureFeatureMethodType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::MeasureFeatureMethodBaseType (e, f | ::xml_schema::flags::base, c),
      NumberOfMeasurementPoints_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CoordinateMeasureFeatureMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::MeasureFeatureMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // NumberOfMeasurementPoints
        //
        if (n.name () == "NumberOfMeasurementPoints" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->NumberOfMeasurementPoints_)
          {
            this->NumberOfMeasurementPoints_.set (NumberOfMeasurementPoints_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }
    }

    CoordinateMeasureFeatureMethodType* CoordinateMeasureFeatureMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoordinateMeasureFeatureMethodType (*this, f, c);
    }

    CoordinateMeasureFeatureMethodType& CoordinateMeasureFeatureMethodType::
    operator= (const CoordinateMeasureFeatureMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::MeasureFeatureMethodBaseType& > (*this) = x;
        this->NumberOfMeasurementPoints_ = x.NumberOfMeasurementPoints_;
      }

      return *this;
    }

    CoordinateMeasureFeatureMethodType::
    ~CoordinateMeasureFeatureMethodType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CoordinateMeasureFeatureMethodType >
    _xsd_CoordinateMeasureFeatureMethodType_type_factory_init (
      "CoordinateMeasureFeatureMethodType",
      "http://qifstandards.org/xsd/qif2");

    // GageMeasureFeatureMethodType
    //

    GageMeasureFeatureMethodType::
    GageMeasureFeatureMethodType (const id_type& id)
    : ::xsd::qif2::MeasureFeatureMethodBaseType (id)
    {
    }

    GageMeasureFeatureMethodType::
    GageMeasureFeatureMethodType (const GageMeasureFeatureMethodType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::MeasureFeatureMethodBaseType (x, f, c)
    {
    }

    GageMeasureFeatureMethodType::
    GageMeasureFeatureMethodType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::MeasureFeatureMethodBaseType (e, f, c)
    {
    }

    GageMeasureFeatureMethodType* GageMeasureFeatureMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GageMeasureFeatureMethodType (*this, f, c);
    }

    GageMeasureFeatureMethodType::
    ~GageMeasureFeatureMethodType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, GageMeasureFeatureMethodType >
    _xsd_GageMeasureFeatureMethodType_type_factory_init (
      "GageMeasureFeatureMethodType",
      "http://qifstandards.org/xsd/qif2");

    // ManualMeasureFeatureMethodType
    //

    ManualMeasureFeatureMethodType::
    ManualMeasureFeatureMethodType (const id_type& id)
    : ::xsd::qif2::MeasureFeatureMethodBaseType (id)
    {
    }

    ManualMeasureFeatureMethodType::
    ManualMeasureFeatureMethodType (const ManualMeasureFeatureMethodType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::MeasureFeatureMethodBaseType (x, f, c)
    {
    }

    ManualMeasureFeatureMethodType::
    ManualMeasureFeatureMethodType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::MeasureFeatureMethodBaseType (e, f, c)
    {
    }

    ManualMeasureFeatureMethodType* ManualMeasureFeatureMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ManualMeasureFeatureMethodType (*this, f, c);
    }

    ManualMeasureFeatureMethodType::
    ~ManualMeasureFeatureMethodType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ManualMeasureFeatureMethodType >
    _xsd_ManualMeasureFeatureMethodType_type_factory_init (
      "ManualMeasureFeatureMethodType",
      "http://qifstandards.org/xsd/qif2");

    // OtherMeasureFeatureMethodType
    //

    OtherMeasureFeatureMethodType::
    OtherMeasureFeatureMethodType (const id_type& id)
    : ::xsd::qif2::MeasureFeatureMethodBaseType (id)
    {
    }

    OtherMeasureFeatureMethodType::
    OtherMeasureFeatureMethodType (const OtherMeasureFeatureMethodType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::MeasureFeatureMethodBaseType (x, f, c)
    {
    }

    OtherMeasureFeatureMethodType::
    OtherMeasureFeatureMethodType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::MeasureFeatureMethodBaseType (e, f, c)
    {
    }

    OtherMeasureFeatureMethodType* OtherMeasureFeatureMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherMeasureFeatureMethodType (*this, f, c);
    }

    OtherMeasureFeatureMethodType::
    ~OtherMeasureFeatureMethodType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, OtherMeasureFeatureMethodType >
    _xsd_OtherMeasureFeatureMethodType_type_factory_init (
      "OtherMeasureFeatureMethodType",
      "http://qifstandards.org/xsd/qif2");

    // ActionMethodsType
    //

    ActionMethodsType::
    ActionMethodsType ()
    : ::xml_schema::type (),
      ActionMethod_ (this)
    {
    }

    ActionMethodsType::
    ActionMethodsType (const ActionMethodsType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ActionMethod_ (x.ActionMethod_, f, this)
    {
    }

    ActionMethodsType::
    ActionMethodsType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ActionMethod_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ActionMethodsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ActionMethod
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "ActionMethod",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< ActionMethod_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< ActionMethod_type > r (
              dynamic_cast< ActionMethod_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ActionMethod_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    ActionMethodsType* ActionMethodsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActionMethodsType (*this, f, c);
    }

    ActionMethodsType& ActionMethodsType::
    operator= (const ActionMethodsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ActionMethod_ = x.ActionMethod_;
      }

      return *this;
    }

    ActionMethodsType::
    ~ActionMethodsType ()
    {
    }

    // MeasureActionGroupFunctionEnumType
    //

    MeasureActionGroupFunctionEnumType::
    MeasureActionGroupFunctionEnumType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_MeasureActionGroupFunctionEnumType_convert ();
    }

    MeasureActionGroupFunctionEnumType::
    MeasureActionGroupFunctionEnumType (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_MeasureActionGroupFunctionEnumType_convert ();
    }

    MeasureActionGroupFunctionEnumType::
    MeasureActionGroupFunctionEnumType (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_MeasureActionGroupFunctionEnumType_convert ();
    }

    MeasureActionGroupFunctionEnumType* MeasureActionGroupFunctionEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasureActionGroupFunctionEnumType (*this, f, c);
    }

    MeasureActionGroupFunctionEnumType::value MeasureActionGroupFunctionEnumType::
    _xsd_MeasureActionGroupFunctionEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MeasureActionGroupFunctionEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_MeasureActionGroupFunctionEnumType_indexes_,
                        _xsd_MeasureActionGroupFunctionEnumType_indexes_ + 9,
                        *this,
                        c));

      if (i == _xsd_MeasureActionGroupFunctionEnumType_indexes_ + 9 || _xsd_MeasureActionGroupFunctionEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const MeasureActionGroupFunctionEnumType::
    _xsd_MeasureActionGroupFunctionEnumType_literals_[9] =
    {
      "ROUTING_PLAN",
      "OPERATION_SEQUENCE",
      "SETUP_USAGE_GROUP",
      "SENSOR_USAGE_GROUP",
      "CARRIAGE_USAGE_GROUP",
      "PCS_USAGE_GROUP",
      "EVALUATE_CHAR_ACTIONS",
      "ESTABLISH_DATUM_ACTIONS",
      "UNDEFINED"
    };

    const MeasureActionGroupFunctionEnumType::value MeasureActionGroupFunctionEnumType::
    _xsd_MeasureActionGroupFunctionEnumType_indexes_[9] =
    {
      ::xsd::qif2::MeasureActionGroupFunctionEnumType::CARRIAGE_USAGE_GROUP,
      ::xsd::qif2::MeasureActionGroupFunctionEnumType::ESTABLISH_DATUM_ACTIONS,
      ::xsd::qif2::MeasureActionGroupFunctionEnumType::EVALUATE_CHAR_ACTIONS,
      ::xsd::qif2::MeasureActionGroupFunctionEnumType::OPERATION_SEQUENCE,
      ::xsd::qif2::MeasureActionGroupFunctionEnumType::PCS_USAGE_GROUP,
      ::xsd::qif2::MeasureActionGroupFunctionEnumType::ROUTING_PLAN,
      ::xsd::qif2::MeasureActionGroupFunctionEnumType::SENSOR_USAGE_GROUP,
      ::xsd::qif2::MeasureActionGroupFunctionEnumType::SETUP_USAGE_GROUP,
      ::xsd::qif2::MeasureActionGroupFunctionEnumType::UNDEFINED
    };

    // MeasureActionGroupFunctionType
    //

    MeasureActionGroupFunctionType::
    MeasureActionGroupFunctionType ()
    : ::xml_schema::type (),
      MeasureActionGroupFunctionEnum_ (this),
      OtherMeasureActionGroupFunction_ (this)
    {
    }

    MeasureActionGroupFunctionType::
    MeasureActionGroupFunctionType (const MeasureActionGroupFunctionType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MeasureActionGroupFunctionEnum_ (x.MeasureActionGroupFunctionEnum_, f, this),
      OtherMeasureActionGroupFunction_ (x.OtherMeasureActionGroupFunction_, f, this)
    {
    }

    MeasureActionGroupFunctionType::
    MeasureActionGroupFunctionType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MeasureActionGroupFunctionEnum_ (this),
      OtherMeasureActionGroupFunction_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasureActionGroupFunctionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MeasureActionGroupFunctionEnum
        //
        if (n.name () == "MeasureActionGroupFunctionEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MeasureActionGroupFunctionEnum_type > r (
            MeasureActionGroupFunctionEnum_traits::create (i, f, this));

          if (!this->MeasureActionGroupFunctionEnum_)
          {
            this->MeasureActionGroupFunctionEnum_.set (r);
            continue;
          }
        }

        // OtherMeasureActionGroupFunction
        //
        if (n.name () == "OtherMeasureActionGroupFunction" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherMeasureActionGroupFunction_type > r (
            OtherMeasureActionGroupFunction_traits::create (i, f, this));

          if (!this->OtherMeasureActionGroupFunction_)
          {
            this->OtherMeasureActionGroupFunction_.set (r);
            continue;
          }
        }

        break;
      }
    }

    MeasureActionGroupFunctionType* MeasureActionGroupFunctionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasureActionGroupFunctionType (*this, f, c);
    }

    MeasureActionGroupFunctionType& MeasureActionGroupFunctionType::
    operator= (const MeasureActionGroupFunctionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MeasureActionGroupFunctionEnum_ = x.MeasureActionGroupFunctionEnum_;
        this->OtherMeasureActionGroupFunction_ = x.OtherMeasureActionGroupFunction_;
      }

      return *this;
    }

    MeasureActionGroupFunctionType::
    ~MeasureActionGroupFunctionType ()
    {
    }

    // ActionGroupBaseType
    //

    ActionGroupBaseType::
    ActionGroupBaseType ()
    : ::xsd::qif2::PlanElementBaseType (),
      MeasureActionGroupFunction_ (this)
    {
    }

    ActionGroupBaseType::
    ActionGroupBaseType (const ActionGroupBaseType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::PlanElementBaseType (x, f, c),
      MeasureActionGroupFunction_ (x.MeasureActionGroupFunction_, f, this)
    {
    }

    ActionGroupBaseType::
    ActionGroupBaseType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::PlanElementBaseType (e, f | ::xml_schema::flags::base, c),
      MeasureActionGroupFunction_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ActionGroupBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::PlanElementBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MeasureActionGroupFunction
        //
        if (n.name () == "MeasureActionGroupFunction" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MeasureActionGroupFunction_type > r (
            MeasureActionGroupFunction_traits::create (i, f, this));

          if (!this->MeasureActionGroupFunction_)
          {
            this->MeasureActionGroupFunction_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ActionGroupBaseType* ActionGroupBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActionGroupBaseType (*this, f, c);
    }

    ActionGroupBaseType& ActionGroupBaseType::
    operator= (const ActionGroupBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::PlanElementBaseType& > (*this) = x;
        this->MeasureActionGroupFunction_ = x.MeasureActionGroupFunction_;
      }

      return *this;
    }

    ActionGroupBaseType::
    ~ActionGroupBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ActionGroupBaseType >
    _xsd_ActionGroupBaseType_type_factory_init (
      "ActionGroupBaseType",
      "http://qifstandards.org/xsd/qif2");

    // OrderedActionGroupType
    //

    OrderedActionGroupType::
    OrderedActionGroupType (const Steps_type& Steps)
    : ::xsd::qif2::ActionGroupBaseType (),
      Steps_ (Steps, this)
    {
    }

    OrderedActionGroupType::
    OrderedActionGroupType (::std::auto_ptr< Steps_type > Steps)
    : ::xsd::qif2::ActionGroupBaseType (),
      Steps_ (Steps, this)
    {
    }

    OrderedActionGroupType::
    OrderedActionGroupType (const OrderedActionGroupType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ActionGroupBaseType (x, f, c),
      Steps_ (x.Steps_, f, this)
    {
    }

    OrderedActionGroupType::
    OrderedActionGroupType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ActionGroupBaseType (e, f | ::xml_schema::flags::base, c),
      Steps_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OrderedActionGroupType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActionGroupBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Steps
        //
        if (n.name () == "Steps" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Steps_type > r (
            Steps_traits::create (i, f, this));

          if (!Steps_.present ())
          {
            this->Steps_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Steps_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Steps",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OrderedActionGroupType* OrderedActionGroupType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OrderedActionGroupType (*this, f, c);
    }

    OrderedActionGroupType& OrderedActionGroupType::
    operator= (const OrderedActionGroupType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ActionGroupBaseType& > (*this) = x;
        this->Steps_ = x.Steps_;
      }

      return *this;
    }

    OrderedActionGroupType::
    ~OrderedActionGroupType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, OrderedActionGroupType >
    _xsd_OrderedActionGroupType_type_factory_init (
      "OrderedActionGroupType",
      "http://qifstandards.org/xsd/qif2");

    // UnorderedActionGroupType
    //

    UnorderedActionGroupType::
    UnorderedActionGroupType (const Steps_type& Steps)
    : ::xsd::qif2::ActionGroupBaseType (),
      Steps_ (Steps, this)
    {
    }

    UnorderedActionGroupType::
    UnorderedActionGroupType (::std::auto_ptr< Steps_type > Steps)
    : ::xsd::qif2::ActionGroupBaseType (),
      Steps_ (Steps, this)
    {
    }

    UnorderedActionGroupType::
    UnorderedActionGroupType (const UnorderedActionGroupType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ActionGroupBaseType (x, f, c),
      Steps_ (x.Steps_, f, this)
    {
    }

    UnorderedActionGroupType::
    UnorderedActionGroupType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ActionGroupBaseType (e, f | ::xml_schema::flags::base, c),
      Steps_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void UnorderedActionGroupType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActionGroupBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Steps
        //
        if (n.name () == "Steps" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Steps_type > r (
            Steps_traits::create (i, f, this));

          if (!Steps_.present ())
          {
            this->Steps_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Steps_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Steps",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    UnorderedActionGroupType* UnorderedActionGroupType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UnorderedActionGroupType (*this, f, c);
    }

    UnorderedActionGroupType& UnorderedActionGroupType::
    operator= (const UnorderedActionGroupType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ActionGroupBaseType& > (*this) = x;
        this->Steps_ = x.Steps_;
      }

      return *this;
    }

    UnorderedActionGroupType::
    ~UnorderedActionGroupType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, UnorderedActionGroupType >
    _xsd_UnorderedActionGroupType_type_factory_init (
      "UnorderedActionGroupType",
      "http://qifstandards.org/xsd/qif2");

    // PartiallyOrderedActionGroupType
    //

    PartiallyOrderedActionGroupType::
    PartiallyOrderedActionGroupType (const StepsWithPredecessors_type& StepsWithPredecessors)
    : ::xsd::qif2::ActionGroupBaseType (),
      StepsWithPredecessors_ (StepsWithPredecessors, this)
    {
    }

    PartiallyOrderedActionGroupType::
    PartiallyOrderedActionGroupType (::std::auto_ptr< StepsWithPredecessors_type > StepsWithPredecessors)
    : ::xsd::qif2::ActionGroupBaseType (),
      StepsWithPredecessors_ (StepsWithPredecessors, this)
    {
    }

    PartiallyOrderedActionGroupType::
    PartiallyOrderedActionGroupType (const PartiallyOrderedActionGroupType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::ActionGroupBaseType (x, f, c),
      StepsWithPredecessors_ (x.StepsWithPredecessors_, f, this)
    {
    }

    PartiallyOrderedActionGroupType::
    PartiallyOrderedActionGroupType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::ActionGroupBaseType (e, f | ::xml_schema::flags::base, c),
      StepsWithPredecessors_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PartiallyOrderedActionGroupType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActionGroupBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // StepsWithPredecessors
        //
        if (n.name () == "StepsWithPredecessors" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< StepsWithPredecessors_type > r (
            StepsWithPredecessors_traits::create (i, f, this));

          if (!StepsWithPredecessors_.present ())
          {
            this->StepsWithPredecessors_.set (r);
            continue;
          }
        }

        break;
      }

      if (!StepsWithPredecessors_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "StepsWithPredecessors",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PartiallyOrderedActionGroupType* PartiallyOrderedActionGroupType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PartiallyOrderedActionGroupType (*this, f, c);
    }

    PartiallyOrderedActionGroupType& PartiallyOrderedActionGroupType::
    operator= (const PartiallyOrderedActionGroupType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ActionGroupBaseType& > (*this) = x;
        this->StepsWithPredecessors_ = x.StepsWithPredecessors_;
      }

      return *this;
    }

    PartiallyOrderedActionGroupType::
    ~PartiallyOrderedActionGroupType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PartiallyOrderedActionGroupType >
    _xsd_PartiallyOrderedActionGroupType_type_factory_init (
      "PartiallyOrderedActionGroupType",
      "http://qifstandards.org/xsd/qif2");

    // StepWithPredecessorsType
    //

    StepWithPredecessorsType::
    StepWithPredecessorsType (const Step_type& Step)
    : ::xml_schema::type (),
      Predecessors_ (this),
      Step_ (Step, this)
    {
    }

    StepWithPredecessorsType::
    StepWithPredecessorsType (::std::auto_ptr< Step_type > Step)
    : ::xml_schema::type (),
      Predecessors_ (this),
      Step_ (Step, this)
    {
    }

    StepWithPredecessorsType::
    StepWithPredecessorsType (const StepWithPredecessorsType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Predecessors_ (x.Predecessors_, f, this),
      Step_ (x.Step_, f, this)
    {
    }

    StepWithPredecessorsType::
    StepWithPredecessorsType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Predecessors_ (this),
      Step_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void StepWithPredecessorsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Predecessors
        //
        if (n.name () == "Predecessors" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Predecessors_type > r (
            Predecessors_traits::create (i, f, this));

          if (!this->Predecessors_)
          {
            this->Predecessors_.set (r);
            continue;
          }
        }

        // Step
        //
        if (n.name () == "Step" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Step_type > r (
            Step_traits::create (i, f, this));

          if (!Step_.present ())
          {
            this->Step_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Step_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Step",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    StepWithPredecessorsType* StepWithPredecessorsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StepWithPredecessorsType (*this, f, c);
    }

    StepWithPredecessorsType& StepWithPredecessorsType::
    operator= (const StepWithPredecessorsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Predecessors_ = x.Predecessors_;
        this->Step_ = x.Step_;
      }

      return *this;
    }

    StepWithPredecessorsType::
    ~StepWithPredecessorsType ()
    {
    }

    // StepsWithPredecessorsType
    //

    StepsWithPredecessorsType::
    StepsWithPredecessorsType ()
    : ::xml_schema::type (),
      StepWithPredecessors_ (this)
    {
    }

    StepsWithPredecessorsType::
    StepsWithPredecessorsType (const StepsWithPredecessorsType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      StepWithPredecessors_ (x.StepWithPredecessors_, f, this)
    {
    }

    StepsWithPredecessorsType::
    StepsWithPredecessorsType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      StepWithPredecessors_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void StepsWithPredecessorsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // StepWithPredecessors
        //
        if (n.name () == "StepWithPredecessors" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< StepWithPredecessors_type > r (
            StepWithPredecessors_traits::create (i, f, this));

          this->StepWithPredecessors_.push_back (r);
          continue;
        }

        break;
      }
    }

    StepsWithPredecessorsType* StepsWithPredecessorsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class StepsWithPredecessorsType (*this, f, c);
    }

    StepsWithPredecessorsType& StepsWithPredecessorsType::
    operator= (const StepsWithPredecessorsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->StepWithPredecessors_ = x.StepWithPredecessors_;
      }

      return *this;
    }

    StepsWithPredecessorsType::
    ~StepsWithPredecessorsType ()
    {
    }

    // PredecessorsType
    //

    PredecessorsType::
    PredecessorsType ()
    : ::xml_schema::type (),
      Predecessor_ (this)
    {
    }

    PredecessorsType::
    PredecessorsType (const PredecessorsType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Predecessor_ (x.Predecessor_, f, this)
    {
    }

    PredecessorsType::
    PredecessorsType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Predecessor_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PredecessorsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Predecessor
        //
        if (n.name () == "Predecessor" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          this->Predecessor_.push_back (Predecessor_traits::create (i, f, this));
          continue;
        }

        break;
      }
    }

    PredecessorsType* PredecessorsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PredecessorsType (*this, f, c);
    }

    PredecessorsType& PredecessorsType::
    operator= (const PredecessorsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Predecessor_ = x.Predecessor_;
      }

      return *this;
    }

    PredecessorsType::
    ~PredecessorsType ()
    {
    }

    // OneOfActionGroupType
    //

    OneOfActionGroupType::
    OneOfActionGroupType (const Steps_type& Steps)
    : ::xsd::qif2::ActionGroupBaseType (),
      Steps_ (Steps, this)
    {
    }

    OneOfActionGroupType::
    OneOfActionGroupType (::std::auto_ptr< Steps_type > Steps)
    : ::xsd::qif2::ActionGroupBaseType (),
      Steps_ (Steps, this)
    {
    }

    OneOfActionGroupType::
    OneOfActionGroupType (const OneOfActionGroupType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ActionGroupBaseType (x, f, c),
      Steps_ (x.Steps_, f, this)
    {
    }

    OneOfActionGroupType::
    OneOfActionGroupType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ActionGroupBaseType (e, f | ::xml_schema::flags::base, c),
      Steps_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OneOfActionGroupType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActionGroupBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Steps
        //
        if (n.name () == "Steps" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Steps_type > r (
            Steps_traits::create (i, f, this));

          if (!Steps_.present ())
          {
            this->Steps_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Steps_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Steps",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OneOfActionGroupType* OneOfActionGroupType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OneOfActionGroupType (*this, f, c);
    }

    OneOfActionGroupType& OneOfActionGroupType::
    operator= (const OneOfActionGroupType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ActionGroupBaseType& > (*this) = x;
        this->Steps_ = x.Steps_;
      }

      return *this;
    }

    OneOfActionGroupType::
    ~OneOfActionGroupType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, OneOfActionGroupType >
    _xsd_OneOfActionGroupType_type_factory_init (
      "OneOfActionGroupType",
      "http://qifstandards.org/xsd/qif2");

    // PickSomeActionGroupType
    //

    PickSomeActionGroupType::
    PickSomeActionGroupType (const Steps_type& Steps,
                             const NumberOfSteps_type& NumberOfSteps)
    : ::xsd::qif2::ActionGroupBaseType (),
      Steps_ (Steps, this),
      NumberOfSteps_ (NumberOfSteps, this)
    {
    }

    PickSomeActionGroupType::
    PickSomeActionGroupType (::std::auto_ptr< Steps_type > Steps,
                             const NumberOfSteps_type& NumberOfSteps)
    : ::xsd::qif2::ActionGroupBaseType (),
      Steps_ (Steps, this),
      NumberOfSteps_ (NumberOfSteps, this)
    {
    }

    PickSomeActionGroupType::
    PickSomeActionGroupType (const PickSomeActionGroupType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ActionGroupBaseType (x, f, c),
      Steps_ (x.Steps_, f, this),
      NumberOfSteps_ (x.NumberOfSteps_, f, this)
    {
    }

    PickSomeActionGroupType::
    PickSomeActionGroupType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ActionGroupBaseType (e, f | ::xml_schema::flags::base, c),
      Steps_ (this),
      NumberOfSteps_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PickSomeActionGroupType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActionGroupBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Steps
        //
        if (n.name () == "Steps" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Steps_type > r (
            Steps_traits::create (i, f, this));

          if (!Steps_.present ())
          {
            this->Steps_.set (r);
            continue;
          }
        }

        // NumberOfSteps
        //
        if (n.name () == "NumberOfSteps" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!NumberOfSteps_.present ())
          {
            this->NumberOfSteps_.set (NumberOfSteps_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!Steps_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Steps",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!NumberOfSteps_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "NumberOfSteps",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PickSomeActionGroupType* PickSomeActionGroupType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PickSomeActionGroupType (*this, f, c);
    }

    PickSomeActionGroupType& PickSomeActionGroupType::
    operator= (const PickSomeActionGroupType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ActionGroupBaseType& > (*this) = x;
        this->Steps_ = x.Steps_;
        this->NumberOfSteps_ = x.NumberOfSteps_;
      }

      return *this;
    }

    PickSomeActionGroupType::
    ~PickSomeActionGroupType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PickSomeActionGroupType >
    _xsd_PickSomeActionGroupType_type_factory_init (
      "PickSomeActionGroupType",
      "http://qifstandards.org/xsd/qif2");

    // WorkInstructionBaseType
    //

    WorkInstructionBaseType::
    WorkInstructionBaseType (const id_type& id)
    : ::xml_schema::type (),
      id_ (id, this)
    {
    }

    WorkInstructionBaseType::
    WorkInstructionBaseType (const WorkInstructionBaseType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this)
    {
    }

    WorkInstructionBaseType::
    WorkInstructionBaseType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void WorkInstructionBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    WorkInstructionBaseType* WorkInstructionBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WorkInstructionBaseType (*this, f, c);
    }

    WorkInstructionBaseType& WorkInstructionBaseType::
    operator= (const WorkInstructionBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
      }

      return *this;
    }

    WorkInstructionBaseType::
    ~WorkInstructionBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, WorkInstructionBaseType >
    _xsd_WorkInstructionBaseType_type_factory_init (
      "WorkInstructionBaseType",
      "http://qifstandards.org/xsd/qif2");

    // TextInstructionType
    //

    TextInstructionType::
    TextInstructionType (const id_type& id,
                         const TextInstruction_type& TextInstruction)
    : ::xsd::qif2::WorkInstructionBaseType (id),
      TextInstruction_ (TextInstruction, this)
    {
    }

    TextInstructionType::
    TextInstructionType (const TextInstructionType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::WorkInstructionBaseType (x, f, c),
      TextInstruction_ (x.TextInstruction_, f, this)
    {
    }

    TextInstructionType::
    TextInstructionType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::WorkInstructionBaseType (e, f | ::xml_schema::flags::base, c),
      TextInstruction_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TextInstructionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::WorkInstructionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // TextInstruction
        //
        if (n.name () == "TextInstruction" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TextInstruction_type > r (
            TextInstruction_traits::create (i, f, this));

          if (!TextInstruction_.present ())
          {
            this->TextInstruction_.set (r);
            continue;
          }
        }

        break;
      }

      if (!TextInstruction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "TextInstruction",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TextInstructionType* TextInstructionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TextInstructionType (*this, f, c);
    }

    TextInstructionType& TextInstructionType::
    operator= (const TextInstructionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::WorkInstructionBaseType& > (*this) = x;
        this->TextInstruction_ = x.TextInstruction_;
      }

      return *this;
    }

    TextInstructionType::
    ~TextInstructionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TextInstructionType >
    _xsd_TextInstructionType_type_factory_init (
      "TextInstructionType",
      "http://qifstandards.org/xsd/qif2");

    // DocumentFileInstructionType
    //

    DocumentFileInstructionType::
    DocumentFileInstructionType (const id_type& id,
                                 const ExternalFile_type& ExternalFile)
    : ::xsd::qif2::WorkInstructionBaseType (id),
      ExternalFile_ (ExternalFile, this)
    {
    }

    DocumentFileInstructionType::
    DocumentFileInstructionType (const id_type& id,
                                 ::std::auto_ptr< ExternalFile_type > ExternalFile)
    : ::xsd::qif2::WorkInstructionBaseType (id),
      ExternalFile_ (ExternalFile, this)
    {
    }

    DocumentFileInstructionType::
    DocumentFileInstructionType (const DocumentFileInstructionType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::WorkInstructionBaseType (x, f, c),
      ExternalFile_ (x.ExternalFile_, f, this)
    {
    }

    DocumentFileInstructionType::
    DocumentFileInstructionType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::WorkInstructionBaseType (e, f | ::xml_schema::flags::base, c),
      ExternalFile_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DocumentFileInstructionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::WorkInstructionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ExternalFile
        //
        if (n.name () == "ExternalFile" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ExternalFile_type > r (
            ExternalFile_traits::create (i, f, this));

          if (!ExternalFile_.present ())
          {
            this->ExternalFile_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ExternalFile_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ExternalFile",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    DocumentFileInstructionType* DocumentFileInstructionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DocumentFileInstructionType (*this, f, c);
    }

    DocumentFileInstructionType& DocumentFileInstructionType::
    operator= (const DocumentFileInstructionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::WorkInstructionBaseType& > (*this) = x;
        this->ExternalFile_ = x.ExternalFile_;
      }

      return *this;
    }

    DocumentFileInstructionType::
    ~DocumentFileInstructionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DocumentFileInstructionType >
    _xsd_DocumentFileInstructionType_type_factory_init (
      "DocumentFileInstructionType",
      "http://qifstandards.org/xsd/qif2");

    // ImageInstructionType
    //

    ImageInstructionType::
    ImageInstructionType (const id_type& id,
                          const ExternalFile_type& ExternalFile)
    : ::xsd::qif2::WorkInstructionBaseType (id),
      ExternalFile_ (ExternalFile, this)
    {
    }

    ImageInstructionType::
    ImageInstructionType (const id_type& id,
                          ::std::auto_ptr< ExternalFile_type > ExternalFile)
    : ::xsd::qif2::WorkInstructionBaseType (id),
      ExternalFile_ (ExternalFile, this)
    {
    }

    ImageInstructionType::
    ImageInstructionType (const ImageInstructionType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::WorkInstructionBaseType (x, f, c),
      ExternalFile_ (x.ExternalFile_, f, this)
    {
    }

    ImageInstructionType::
    ImageInstructionType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::WorkInstructionBaseType (e, f | ::xml_schema::flags::base, c),
      ExternalFile_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ImageInstructionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::WorkInstructionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ExternalFile
        //
        if (n.name () == "ExternalFile" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ExternalFile_type > r (
            ExternalFile_traits::create (i, f, this));

          if (!ExternalFile_.present ())
          {
            this->ExternalFile_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ExternalFile_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ExternalFile",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ImageInstructionType* ImageInstructionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ImageInstructionType (*this, f, c);
    }

    ImageInstructionType& ImageInstructionType::
    operator= (const ImageInstructionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::WorkInstructionBaseType& > (*this) = x;
        this->ExternalFile_ = x.ExternalFile_;
      }

      return *this;
    }

    ImageInstructionType::
    ~ImageInstructionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ImageInstructionType >
    _xsd_ImageInstructionType_type_factory_init (
      "ImageInstructionType",
      "http://qifstandards.org/xsd/qif2");

    // VideoInstructionType
    //

    VideoInstructionType::
    VideoInstructionType (const id_type& id,
                          const ExternalFile_type& ExternalFile)
    : ::xsd::qif2::WorkInstructionBaseType (id),
      ExternalFile_ (ExternalFile, this)
    {
    }

    VideoInstructionType::
    VideoInstructionType (const id_type& id,
                          ::std::auto_ptr< ExternalFile_type > ExternalFile)
    : ::xsd::qif2::WorkInstructionBaseType (id),
      ExternalFile_ (ExternalFile, this)
    {
    }

    VideoInstructionType::
    VideoInstructionType (const VideoInstructionType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::WorkInstructionBaseType (x, f, c),
      ExternalFile_ (x.ExternalFile_, f, this)
    {
    }

    VideoInstructionType::
    VideoInstructionType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::WorkInstructionBaseType (e, f | ::xml_schema::flags::base, c),
      ExternalFile_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void VideoInstructionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::WorkInstructionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ExternalFile
        //
        if (n.name () == "ExternalFile" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ExternalFile_type > r (
            ExternalFile_traits::create (i, f, this));

          if (!ExternalFile_.present ())
          {
            this->ExternalFile_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ExternalFile_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ExternalFile",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    VideoInstructionType* VideoInstructionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VideoInstructionType (*this, f, c);
    }

    VideoInstructionType& VideoInstructionType::
    operator= (const VideoInstructionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::WorkInstructionBaseType& > (*this) = x;
        this->ExternalFile_ = x.ExternalFile_;
      }

      return *this;
    }

    VideoInstructionType::
    ~VideoInstructionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, VideoInstructionType >
    _xsd_VideoInstructionType_type_factory_init (
      "VideoInstructionType",
      "http://qifstandards.org/xsd/qif2");

    // WorkInstructionsType
    //

    WorkInstructionsType::
    WorkInstructionsType ()
    : ::xml_schema::type (),
      WorkInstruction_ (this)
    {
    }

    WorkInstructionsType::
    WorkInstructionsType (const WorkInstructionsType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      WorkInstruction_ (x.WorkInstruction_, f, this)
    {
    }

    WorkInstructionsType::
    WorkInstructionsType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      WorkInstruction_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void WorkInstructionsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // WorkInstruction
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "WorkInstruction",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< WorkInstruction_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< WorkInstruction_type > r (
              dynamic_cast< WorkInstruction_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->WorkInstruction_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    WorkInstructionsType* WorkInstructionsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WorkInstructionsType (*this, f, c);
    }

    WorkInstructionsType& WorkInstructionsType::
    operator= (const WorkInstructionsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->WorkInstruction_ = x.WorkInstruction_;
      }

      return *this;
    }

    WorkInstructionsType::
    ~WorkInstructionsType ()
    {
    }

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::OrderedActionGroupType >
    _xsd_OrderedPlanRoot_element_factory_init (
      "PlanRoot",
      "http://qifstandards.org/xsd/qif2",
      "OrderedPlanRoot",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::UnorderedActionGroupType >
    _xsd_UnorderedPlanRoot_element_factory_init (
      "PlanRoot",
      "http://qifstandards.org/xsd/qif2",
      "UnorderedPlanRoot",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PartiallyOrderedActionGroupType >
    _xsd_PartiallyOrderedPlanRoot_element_factory_init (
      "PlanRoot",
      "http://qifstandards.org/xsd/qif2",
      "PartiallyOrderedPlanRoot",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::OneOfActionGroupType >
    _xsd_OneOfPlanRoot_element_factory_init (
      "PlanRoot",
      "http://qifstandards.org/xsd/qif2",
      "OneOfPlanRoot",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PickSomeActionGroupType >
    _xsd_PickSomePlanRoot_element_factory_init (
      "PlanRoot",
      "http://qifstandards.org/xsd/qif2",
      "PickSomePlanRoot",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::OrderedActionGroupType >
    _xsd_OrderedActionGroup_element_factory_init (
      "PlanElement",
      "http://qifstandards.org/xsd/qif2",
      "OrderedActionGroup",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::UnorderedActionGroupType >
    _xsd_UnorderedActionGroup_element_factory_init (
      "PlanElement",
      "http://qifstandards.org/xsd/qif2",
      "UnorderedActionGroup",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PartiallyOrderedActionGroupType >
    _xsd_PartiallyOrderedActionGroup_element_factory_init (
      "PlanElement",
      "http://qifstandards.org/xsd/qif2",
      "PartiallyOrderedActionGroup",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::OneOfActionGroupType >
    _xsd_OneOfActionGroup_element_factory_init (
      "PlanElement",
      "http://qifstandards.org/xsd/qif2",
      "OneOfActionGroup",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PickSomeActionGroupType >
    _xsd_PickSomeActionGroup_element_factory_init (
      "PlanElement",
      "http://qifstandards.org/xsd/qif2",
      "PickSomeActionGroup",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::MeasureEvaluateAllActionType >
    _xsd_MeasureEvaluateAll_element_factory_init (
      "PlanElement",
      "http://qifstandards.org/xsd/qif2",
      "MeasureEvaluateAll",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::MeasureEvaluateSpecifiedActionType >
    _xsd_MeasureEvaluateSpecified_element_factory_init (
      "PlanElement",
      "http://qifstandards.org/xsd/qif2",
      "MeasureEvaluateSpecified",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::EvaluateSpecifiedCharacteristicsActionType >
    _xsd_EvaluateSpecifiedCharacteristics_element_factory_init (
      "PlanElement",
      "http://qifstandards.org/xsd/qif2",
      "EvaluateSpecifiedCharacteristics",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::MeasureSpecifiedFeaturesActionType >
    _xsd_MeasureSpecifiedFeatures_element_factory_init (
      "PlanElement",
      "http://qifstandards.org/xsd/qif2",
      "MeasureSpecifiedFeatures",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::MeasureSpecifiedMeasurandsActionType >
    _xsd_MeasureSpecifiedMeasurands_element_factory_init (
      "PlanElement",
      "http://qifstandards.org/xsd/qif2",
      "MeasureSpecifiedMeasurands",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::TextInstructionType >
    _xsd_TextInstruction_element_factory_init (
      "WorkInstruction",
      "http://qifstandards.org/xsd/qif2",
      "TextInstruction",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::DocumentFileInstructionType >
    _xsd_DocumentFileInstruction_element_factory_init (
      "WorkInstruction",
      "http://qifstandards.org/xsd/qif2",
      "DocumentFileInstruction",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ImageInstructionType >
    _xsd_ImageInstruction_element_factory_init (
      "WorkInstruction",
      "http://qifstandards.org/xsd/qif2",
      "ImageInstruction",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::VideoInstructionType >
    _xsd_VideoInstruction_element_factory_init (
      "WorkInstruction",
      "http://qifstandards.org/xsd/qif2",
      "VideoInstruction",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::CoordinateMeasureFeatureMethodType >
    _xsd_CoordinateMeasureFeatureMethod_element_factory_init (
      "ActionMethod",
      "http://qifstandards.org/xsd/qif2",
      "CoordinateMeasureFeatureMethod",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::GageMeasureFeatureMethodType >
    _xsd_GageMeasureFeatureMethod_element_factory_init (
      "ActionMethod",
      "http://qifstandards.org/xsd/qif2",
      "GageMeasureFeatureMethod",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ManualMeasureFeatureMethodType >
    _xsd_ManualMeasureFeatureMethod_element_factory_init (
      "ActionMethod",
      "http://qifstandards.org/xsd/qif2",
      "ManualMeasureFeatureMethod",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::OtherMeasureFeatureMethodType >
    _xsd_OtherMeasureFeatureMethod_element_factory_init (
      "ActionMethod",
      "http://qifstandards.org/xsd/qif2",
      "OtherMeasureFeatureMethod",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::EvaluateCharacteristicMeasurandType >
    _xsd_EvaluateCharacteristicMeasurand_element_factory_init (
      "Measurand",
      "http://qifstandards.org/xsd/qif2",
      "EvaluateCharacteristicMeasurand",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::EstablishDatumMeasurandType >
    _xsd_EstablishDatumMeasurand_element_factory_init (
      "Measurand",
      "http://qifstandards.org/xsd/qif2",
      "EstablishDatumMeasurand",
      "http://qifstandards.org/xsd/qif2");
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif2
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif2
  {
    void
    operator<< (::xercesc::DOMElement& e, const MeasurementPlanType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Version
      //
      if (i.Version ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Version",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Version ();
      }

      // RulesUsedQPId
      //
      if (i.RulesUsedQPId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RulesUsedQPId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.RulesUsedQPId ();
      }

      // RulesToUseQPId
      //
      if (i.RulesToUseQPId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RulesToUseQPId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.RulesToUseQPId ();
      }

      // WorkInstructions
      //
      if (i.WorkInstructions ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "WorkInstructions",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.WorkInstructions ();
      }

      // ActionMethods
      //
      if (i.ActionMethods ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ActionMethods",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ActionMethods ();
      }

      // Measurands
      //
      if (i.Measurands ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measurands",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measurands ();
      }

      // PlanRoot
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const MeasurementPlanType::PlanRoot_type& x (i.PlanRoot ());
        if (typeid (MeasurementPlanType::PlanRoot_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "PlanRoot",
              "http://qifstandards.org/xsd/qif2",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "PlanRoot",
            "http://qifstandards.org/xsd/qif2",
            true, true, e, x);
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PlanElementBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // WorkInstructionIds
      //
      if (i.WorkInstructionIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "WorkInstructionIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.WorkInstructionIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PlanElementBaseType >
    _xsd_PlanElementBaseType_type_serializer_init (
      "PlanElementBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const UnnumberedPlanElementsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PlanElement
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (UnnumberedPlanElementsType::PlanElement_const_iterator
             b (i.PlanElement ().begin ()), n (i.PlanElement ().end ());
             b != n; ++b)
        {
          if (typeid (UnnumberedPlanElementsType::PlanElement_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "PlanElement",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "PlanElement",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const NumberedPlanElementType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SequenceNumber
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SequenceNumber",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SequenceNumber ();
      }

      // PlanElement
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const NumberedPlanElementType::PlanElement_type& x (i.PlanElement ());
        if (typeid (NumberedPlanElementType::PlanElement_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "PlanElement",
              "http://qifstandards.org/xsd/qif2",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "PlanElement",
            "http://qifstandards.org/xsd/qif2",
            true, true, e, x);
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const NumberedPlanElementsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // NumberedPlanElement
      //
      for (NumberedPlanElementsType::NumberedPlanElement_const_iterator
           b (i.NumberedPlanElement ().begin ()), n (i.NumberedPlanElement ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "NumberedPlanElement",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ActionBaseType& i)
    {
      e << static_cast< const ::xsd::qif2::PlanElementBaseType& > (i);

      // PreferredActionMethodId
      //
      if (i.PreferredActionMethodId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PreferredActionMethodId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PreferredActionMethodId ();
      }

      // AlternativeActionMethodIds
      //
      if (i.AlternativeActionMethodIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AlternativeActionMethodIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.AlternativeActionMethodIds ();
      }

      // PreferredResourceIds
      //
      if (i.PreferredResourceIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PreferredResourceIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PreferredResourceIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ActionBaseType >
    _xsd_ActionBaseType_type_serializer_init (
      "ActionBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const MeasureEvaluateAllActionType& i)
    {
      e << static_cast< const ::xsd::qif2::ActionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MeasureEvaluateAllActionType >
    _xsd_MeasureEvaluateAllActionType_type_serializer_init (
      "MeasureEvaluateAllActionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const MeasureEvaluateSpecifiedActionType& i)
    {
      e << static_cast< const ::xsd::qif2::ActionBaseType& > (i);

      // CharacteristicItemIds
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CharacteristicItemIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.CharacteristicItemIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MeasureEvaluateSpecifiedActionType >
    _xsd_MeasureEvaluateSpecifiedActionType_type_serializer_init (
      "MeasureEvaluateSpecifiedActionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const EvaluateSpecifiedCharacteristicsActionType& i)
    {
      e << static_cast< const ::xsd::qif2::ActionBaseType& > (i);

      // CharacteristicItemIds
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CharacteristicItemIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.CharacteristicItemIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EvaluateSpecifiedCharacteristicsActionType >
    _xsd_EvaluateSpecifiedCharacteristicsActionType_type_serializer_init (
      "EvaluateSpecifiedCharacteristicsActionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const MeasureSpecifiedFeaturesActionType& i)
    {
      e << static_cast< const ::xsd::qif2::ActionBaseType& > (i);

      // FeatureItemIds
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FeatureItemIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.FeatureItemIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MeasureSpecifiedFeaturesActionType >
    _xsd_MeasureSpecifiedFeaturesActionType_type_serializer_init (
      "MeasureSpecifiedFeaturesActionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const MeasurandBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MeasurandBaseType >
    _xsd_MeasurandBaseType_type_serializer_init (
      "MeasurandBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const EvaluateCharacteristicMeasurandType& i)
    {
      e << static_cast< const ::xsd::qif2::MeasurandBaseType& > (i);

      // CharacteristicItemId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CharacteristicItemId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.CharacteristicItemId ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EvaluateCharacteristicMeasurandType >
    _xsd_EvaluateCharacteristicMeasurandType_type_serializer_init (
      "EvaluateCharacteristicMeasurandType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const EstablishDatumMeasurandType& i)
    {
      e << static_cast< const ::xsd::qif2::MeasurandBaseType& > (i);

      // DatumDefinitionId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DatumDefinitionId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DatumDefinitionId ();
      }

      // DatumReferenceFrameId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DatumReferenceFrameId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DatumReferenceFrameId ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EstablishDatumMeasurandType >
    _xsd_EstablishDatumMeasurandType_type_serializer_init (
      "EstablishDatumMeasurandType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const MeasureSpecifiedMeasurandsActionType& i)
    {
      e << static_cast< const ::xsd::qif2::ActionBaseType& > (i);

      // MeasurandIds
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MeasurandIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.MeasurandIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MeasureSpecifiedMeasurandsActionType >
    _xsd_MeasureSpecifiedMeasurandsActionType_type_serializer_init (
      "MeasureSpecifiedMeasurandsActionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const MeasurandsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measurand
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (MeasurandsType::Measurand_const_iterator
             b (i.Measurand ().begin ()), n (i.Measurand ().end ());
             b != n; ++b)
        {
          if (typeid (MeasurandsType::Measurand_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "Measurand",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "Measurand",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ActionMethodBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ChosenResourceIds
      //
      if (i.ChosenResourceIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ChosenResourceIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ChosenResourceIds ();
      }

      // WorkInstructionIds
      //
      if (i.WorkInstructionIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "WorkInstructionIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.WorkInstructionIds ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ActionMethodBaseType >
    _xsd_ActionMethodBaseType_type_serializer_init (
      "ActionMethodBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const MeasureFeatureMethodBaseType& i)
    {
      e << static_cast< const ::xsd::qif2::ActionMethodBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MeasureFeatureMethodBaseType >
    _xsd_MeasureFeatureMethodBaseType_type_serializer_init (
      "MeasureFeatureMethodBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CoordinateMeasureFeatureMethodType& i)
    {
      e << static_cast< const ::xsd::qif2::MeasureFeatureMethodBaseType& > (i);

      // NumberOfMeasurementPoints
      //
      if (i.NumberOfMeasurementPoints ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "NumberOfMeasurementPoints",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.NumberOfMeasurementPoints ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CoordinateMeasureFeatureMethodType >
    _xsd_CoordinateMeasureFeatureMethodType_type_serializer_init (
      "CoordinateMeasureFeatureMethodType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const GageMeasureFeatureMethodType& i)
    {
      e << static_cast< const ::xsd::qif2::MeasureFeatureMethodBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GageMeasureFeatureMethodType >
    _xsd_GageMeasureFeatureMethodType_type_serializer_init (
      "GageMeasureFeatureMethodType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ManualMeasureFeatureMethodType& i)
    {
      e << static_cast< const ::xsd::qif2::MeasureFeatureMethodBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ManualMeasureFeatureMethodType >
    _xsd_ManualMeasureFeatureMethodType_type_serializer_init (
      "ManualMeasureFeatureMethodType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const OtherMeasureFeatureMethodType& i)
    {
      e << static_cast< const ::xsd::qif2::MeasureFeatureMethodBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OtherMeasureFeatureMethodType >
    _xsd_OtherMeasureFeatureMethodType_type_serializer_init (
      "OtherMeasureFeatureMethodType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ActionMethodsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ActionMethod
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (ActionMethodsType::ActionMethod_const_iterator
             b (i.ActionMethod ().begin ()), n (i.ActionMethod ().end ());
             b != n; ++b)
        {
          if (typeid (ActionMethodsType::ActionMethod_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "ActionMethod",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "ActionMethod",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const MeasureActionGroupFunctionEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const MeasureActionGroupFunctionEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const MeasureActionGroupFunctionEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const MeasureActionGroupFunctionType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MeasureActionGroupFunctionEnum
      //
      if (i.MeasureActionGroupFunctionEnum ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MeasureActionGroupFunctionEnum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MeasureActionGroupFunctionEnum ();
      }

      // OtherMeasureActionGroupFunction
      //
      if (i.OtherMeasureActionGroupFunction ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "OtherMeasureActionGroupFunction",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.OtherMeasureActionGroupFunction ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ActionGroupBaseType& i)
    {
      e << static_cast< const ::xsd::qif2::PlanElementBaseType& > (i);

      // MeasureActionGroupFunction
      //
      if (i.MeasureActionGroupFunction ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MeasureActionGroupFunction",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MeasureActionGroupFunction ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ActionGroupBaseType >
    _xsd_ActionGroupBaseType_type_serializer_init (
      "ActionGroupBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const OrderedActionGroupType& i)
    {
      e << static_cast< const ::xsd::qif2::ActionGroupBaseType& > (i);

      // Steps
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Steps",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Steps ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OrderedActionGroupType >
    _xsd_OrderedActionGroupType_type_serializer_init (
      "OrderedActionGroupType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const UnorderedActionGroupType& i)
    {
      e << static_cast< const ::xsd::qif2::ActionGroupBaseType& > (i);

      // Steps
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Steps",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Steps ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, UnorderedActionGroupType >
    _xsd_UnorderedActionGroupType_type_serializer_init (
      "UnorderedActionGroupType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PartiallyOrderedActionGroupType& i)
    {
      e << static_cast< const ::xsd::qif2::ActionGroupBaseType& > (i);

      // StepsWithPredecessors
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "StepsWithPredecessors",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.StepsWithPredecessors ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PartiallyOrderedActionGroupType >
    _xsd_PartiallyOrderedActionGroupType_type_serializer_init (
      "PartiallyOrderedActionGroupType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const StepWithPredecessorsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Predecessors
      //
      if (i.Predecessors ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Predecessors",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Predecessors ();
      }

      // Step
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Step",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Step ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const StepsWithPredecessorsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // StepWithPredecessors
      //
      for (StepsWithPredecessorsType::StepWithPredecessors_const_iterator
           b (i.StepWithPredecessors ().begin ()), n (i.StepWithPredecessors ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "StepWithPredecessors",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PredecessorsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Predecessor
      //
      for (PredecessorsType::Predecessor_const_iterator
           b (i.Predecessor ().begin ()), n (i.Predecessor ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Predecessor",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OneOfActionGroupType& i)
    {
      e << static_cast< const ::xsd::qif2::ActionGroupBaseType& > (i);

      // Steps
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Steps",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Steps ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OneOfActionGroupType >
    _xsd_OneOfActionGroupType_type_serializer_init (
      "OneOfActionGroupType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PickSomeActionGroupType& i)
    {
      e << static_cast< const ::xsd::qif2::ActionGroupBaseType& > (i);

      // Steps
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Steps",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Steps ();
      }

      // NumberOfSteps
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "NumberOfSteps",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.NumberOfSteps ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PickSomeActionGroupType >
    _xsd_PickSomeActionGroupType_type_serializer_init (
      "PickSomeActionGroupType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const WorkInstructionBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, WorkInstructionBaseType >
    _xsd_WorkInstructionBaseType_type_serializer_init (
      "WorkInstructionBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const TextInstructionType& i)
    {
      e << static_cast< const ::xsd::qif2::WorkInstructionBaseType& > (i);

      // TextInstruction
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TextInstruction",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.TextInstruction ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TextInstructionType >
    _xsd_TextInstructionType_type_serializer_init (
      "TextInstructionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const DocumentFileInstructionType& i)
    {
      e << static_cast< const ::xsd::qif2::WorkInstructionBaseType& > (i);

      // ExternalFile
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ExternalFile",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ExternalFile ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DocumentFileInstructionType >
    _xsd_DocumentFileInstructionType_type_serializer_init (
      "DocumentFileInstructionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ImageInstructionType& i)
    {
      e << static_cast< const ::xsd::qif2::WorkInstructionBaseType& > (i);

      // ExternalFile
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ExternalFile",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ExternalFile ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ImageInstructionType >
    _xsd_ImageInstructionType_type_serializer_init (
      "ImageInstructionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const VideoInstructionType& i)
    {
      e << static_cast< const ::xsd::qif2::WorkInstructionBaseType& > (i);

      // ExternalFile
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ExternalFile",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ExternalFile ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, VideoInstructionType >
    _xsd_VideoInstructionType_type_serializer_init (
      "VideoInstructionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const WorkInstructionsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // WorkInstruction
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (WorkInstructionsType::WorkInstruction_const_iterator
             b (i.WorkInstruction ().begin ()), n (i.WorkInstruction ().end ());
             b != n; ++b)
        {
          if (typeid (WorkInstructionsType::WorkInstruction_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "WorkInstruction",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "WorkInstruction",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::OrderedActionGroupType >
    _xsd_OrderedPlanRoot_element_serializer_init (
      "PlanRoot",
      "http://qifstandards.org/xsd/qif2",
      "OrderedPlanRoot",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::UnorderedActionGroupType >
    _xsd_UnorderedPlanRoot_element_serializer_init (
      "PlanRoot",
      "http://qifstandards.org/xsd/qif2",
      "UnorderedPlanRoot",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PartiallyOrderedActionGroupType >
    _xsd_PartiallyOrderedPlanRoot_element_serializer_init (
      "PlanRoot",
      "http://qifstandards.org/xsd/qif2",
      "PartiallyOrderedPlanRoot",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::OneOfActionGroupType >
    _xsd_OneOfPlanRoot_element_serializer_init (
      "PlanRoot",
      "http://qifstandards.org/xsd/qif2",
      "OneOfPlanRoot",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PickSomeActionGroupType >
    _xsd_PickSomePlanRoot_element_serializer_init (
      "PlanRoot",
      "http://qifstandards.org/xsd/qif2",
      "PickSomePlanRoot",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::OrderedActionGroupType >
    _xsd_OrderedActionGroup_element_serializer_init (
      "PlanElement",
      "http://qifstandards.org/xsd/qif2",
      "OrderedActionGroup",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::UnorderedActionGroupType >
    _xsd_UnorderedActionGroup_element_serializer_init (
      "PlanElement",
      "http://qifstandards.org/xsd/qif2",
      "UnorderedActionGroup",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PartiallyOrderedActionGroupType >
    _xsd_PartiallyOrderedActionGroup_element_serializer_init (
      "PlanElement",
      "http://qifstandards.org/xsd/qif2",
      "PartiallyOrderedActionGroup",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::OneOfActionGroupType >
    _xsd_OneOfActionGroup_element_serializer_init (
      "PlanElement",
      "http://qifstandards.org/xsd/qif2",
      "OneOfActionGroup",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PickSomeActionGroupType >
    _xsd_PickSomeActionGroup_element_serializer_init (
      "PlanElement",
      "http://qifstandards.org/xsd/qif2",
      "PickSomeActionGroup",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::MeasureEvaluateAllActionType >
    _xsd_MeasureEvaluateAll_element_serializer_init (
      "PlanElement",
      "http://qifstandards.org/xsd/qif2",
      "MeasureEvaluateAll",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::MeasureEvaluateSpecifiedActionType >
    _xsd_MeasureEvaluateSpecified_element_serializer_init (
      "PlanElement",
      "http://qifstandards.org/xsd/qif2",
      "MeasureEvaluateSpecified",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::EvaluateSpecifiedCharacteristicsActionType >
    _xsd_EvaluateSpecifiedCharacteristics_element_serializer_init (
      "PlanElement",
      "http://qifstandards.org/xsd/qif2",
      "EvaluateSpecifiedCharacteristics",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::MeasureSpecifiedFeaturesActionType >
    _xsd_MeasureSpecifiedFeatures_element_serializer_init (
      "PlanElement",
      "http://qifstandards.org/xsd/qif2",
      "MeasureSpecifiedFeatures",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::MeasureSpecifiedMeasurandsActionType >
    _xsd_MeasureSpecifiedMeasurands_element_serializer_init (
      "PlanElement",
      "http://qifstandards.org/xsd/qif2",
      "MeasureSpecifiedMeasurands",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::TextInstructionType >
    _xsd_TextInstruction_element_serializer_init (
      "WorkInstruction",
      "http://qifstandards.org/xsd/qif2",
      "TextInstruction",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::DocumentFileInstructionType >
    _xsd_DocumentFileInstruction_element_serializer_init (
      "WorkInstruction",
      "http://qifstandards.org/xsd/qif2",
      "DocumentFileInstruction",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ImageInstructionType >
    _xsd_ImageInstruction_element_serializer_init (
      "WorkInstruction",
      "http://qifstandards.org/xsd/qif2",
      "ImageInstruction",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::VideoInstructionType >
    _xsd_VideoInstruction_element_serializer_init (
      "WorkInstruction",
      "http://qifstandards.org/xsd/qif2",
      "VideoInstruction",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::CoordinateMeasureFeatureMethodType >
    _xsd_CoordinateMeasureFeatureMethod_element_serializer_init (
      "ActionMethod",
      "http://qifstandards.org/xsd/qif2",
      "CoordinateMeasureFeatureMethod",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::GageMeasureFeatureMethodType >
    _xsd_GageMeasureFeatureMethod_element_serializer_init (
      "ActionMethod",
      "http://qifstandards.org/xsd/qif2",
      "GageMeasureFeatureMethod",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ManualMeasureFeatureMethodType >
    _xsd_ManualMeasureFeatureMethod_element_serializer_init (
      "ActionMethod",
      "http://qifstandards.org/xsd/qif2",
      "ManualMeasureFeatureMethod",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::OtherMeasureFeatureMethodType >
    _xsd_OtherMeasureFeatureMethod_element_serializer_init (
      "ActionMethod",
      "http://qifstandards.org/xsd/qif2",
      "OtherMeasureFeatureMethod",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::EvaluateCharacteristicMeasurandType >
    _xsd_EvaluateCharacteristicMeasurand_element_serializer_init (
      "Measurand",
      "http://qifstandards.org/xsd/qif2",
      "EvaluateCharacteristicMeasurand",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::EstablishDatumMeasurandType >
    _xsd_EstablishDatumMeasurand_element_serializer_init (
      "Measurand",
      "http://qifstandards.org/xsd/qif2",
      "EstablishDatumMeasurand",
      "http://qifstandards.org/xsd/qif2");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

